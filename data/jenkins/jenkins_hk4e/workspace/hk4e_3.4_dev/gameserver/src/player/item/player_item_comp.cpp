// File: /data/jenkins/jenkins_hk4e/workspace/hk4e_3.4_dev/gameserver/src/player/item/player_item_comp.cpp

// Line 86: range 0000000017CB9F04-0000000017CB9F7E
void __cdecl AddItemContextHolder::AddItemContextHolder(AddItemContextHolder *const this, PlayerPtr *p_player_ptr)
{
  Player *v2; // rax
  PlayerItemComp *ItemComp; // rax

  std::weak_ptr<Player>::weak_ptr<Player,void>(&this->player_wtr_, p_player_ptr);
  if ( std::operator!=<Player>(p_player_ptr, 0LL) )
  {
    v2 = std::__shared_ptr_access<Player,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Player,(__gnu_cxx::_Lock_policy)2,false,false> *const)p_player_ptr);
    ItemComp = Player::getItemComp(v2);
    PlayerItemComp::clearTransferItems(ItemComp);
  }
};

// Line 95: range 0000000017CB9F80-0000000017CBA1AB
std::vector<TransferItemParam> *__cdecl AddItemContextHolder::getTransferItems(
        std::vector<TransferItemParam> *retstr,
        AddItemContextHolder *const this)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  _DWORD *v4; // r13
  Player *v5; // rax
  PlayerItemComp *ItemComp; // rsi
  char v8[160]; // [rsp+10h] [rbp-A0h] BYREF

  v2 = (unsigned __int64)v8;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(128LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "2 32 16 13 player_ptr:98 64 24 9 result:96";
  *(_QWORD *)(v2 + 16) = AddItemContextHolder::getTransferItems;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -219021312;
  v4[536862722] = -218103808;
  v4[536862723] = -202116109;
  std::vector<TransferItemParam>::vector((std::vector<TransferItemParam> *const)(v2 + 64));
  std::weak_ptr<Player>::lock((const std::weak_ptr<Player> *const)(v2 + 32));
  if ( std::operator!=<Player>((const std::shared_ptr<Player> *)(v2 + 32), 0LL) )
  {
    v5 = std::__shared_ptr_access<Player,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Player,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 32));
    ItemComp = Player::getItemComp(v5);
    if ( *(char *)(((unsigned __int64)retstr >> 3) + 0x7FFF8000) < 0
      || *(_BYTE *)((((unsigned __int64)&retstr->_M_impl._M_end_of_storage + 7) >> 3) + 0x7FFF8000) != 0
      && (((unsigned __int8)retstr + 23) & 7) >= *(_BYTE *)((((unsigned __int64)&retstr->_M_impl._M_end_of_storage + 7) >> 3)
                                                          + 0x7FFF8000) )
    {
      ItemComp = (PlayerItemComp *)24;
      __asan_report_store_n(retstr, 24LL);
    }
    PlayerItemComp::getTransferItems(retstr, ItemComp);
  }
  else
  {
    std::vector<TransferItemParam>::vector(retstr, (std::vector<TransferItemParam> *)(v2 + 64));
  }
  std::shared_ptr<Player>::~shared_ptr((std::shared_ptr<Player> *const)(v2 + 32));
  std::vector<TransferItemParam>::~vector((std::vector<TransferItemParam> *const)(v2 + 64));
  if ( v8 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return retstr;
};

// Line 107: range 0000000017CBA1AC-0000000017CBA2BC
void __cdecl AddItemContextHolder::~AddItemContextHolder(AddItemContextHolder *const this)
{
  unsigned __int64 v1; // rbx
  __int64 v2; // rax
  unsigned __int64 v3; // r12
  Player *v4; // rax
  PlayerItemComp *ItemComp; // rax
  char v6[96]; // [rsp+10h] [rbp-60h] BYREF

  v1 = (unsigned __int64)v6;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v2 = __asan_stack_malloc_0(64LL);
    if ( v2 )
      v1 = v2;
  }
  *(_QWORD *)v1 = 1102416563LL;
  *(_QWORD *)(v1 + 8) = "1 32 16 14 player_ptr:109";
  *(_QWORD *)(v1 + 16) = AddItemContextHolder::~AddItemContextHolder;
  v3 = v1 >> 3;
  *(_DWORD *)(v3 + 2147450880) = -235802127;
  *(_DWORD *)(v3 + 2147450884) = -202178560;
  std::weak_ptr<Player>::lock((const std::weak_ptr<Player> *const)(v1 + 32));
  if ( std::operator!=<Player>((const std::shared_ptr<Player> *)(v1 + 32), 0LL) )
  {
    v4 = std::__shared_ptr_access<Player,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Player,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v1 + 32));
    ItemComp = Player::getItemComp(v4);
    PlayerItemComp::clearTransferItems(ItemComp);
  }
  std::shared_ptr<Player>::~shared_ptr((std::shared_ptr<Player> *const)(v1 + 32));
  std::weak_ptr<Player>::~weak_ptr(&this->player_wtr_);
  if ( v6 == (char *)v1 )
  {
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v1 = 1172321806LL;
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 117: range 0000000017CBA2BE-0000000017CBA4E4
int32_t __cdecl MaterialDeleteReturnRecord::fromBin(
        MaterialDeleteReturnRecord *const this,
        const proto::MaterialDeleteReturnRecordBin *record_bin)
{
  unsigned int *p_second; // rax
  unsigned int second; // ebx
  google::protobuf::Map<unsigned int,unsigned int>::const_reference v4; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v5; // rax
  unsigned int *v6; // rdx
  char v7; // cl
  unsigned int *v8; // rax
  unsigned int v9; // ebx
  google::protobuf::Map<unsigned int,unsigned int>::const_reference v10; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v11; // rax
  unsigned int *v12; // rdx
  char v13; // cl
  const google::protobuf::Map<unsigned int,unsigned int> *__for_range; // [rsp+10h] [rbp-70h]
  const google::protobuf::Map<unsigned int,unsigned int> *__for_range_0; // [rsp+18h] [rbp-68h]
  google::protobuf::Map<unsigned int,unsigned int>::const_reference p_item_id; // [rsp+20h] [rbp-60h]
  google::protobuf::Map<unsigned int,unsigned int>::const_reference p_material_id; // [rsp+28h] [rbp-58h]
  google::protobuf::Map<unsigned int,unsigned int>::const_iterator __for_begin; // [rsp+30h] [rbp-50h] BYREF
  google::protobuf::Map<unsigned int,unsigned int>::const_iterator __for_end; // [rsp+50h] [rbp-30h] BYREF

  __for_range = proto::MaterialDeleteReturnRecordBin::delete_material_map(record_bin);
  google::protobuf::Map<unsigned int,unsigned int>::begin(&__for_begin, __for_range);
  google::protobuf::Map<unsigned int,unsigned int>::end(&__for_end, __for_range);
  while ( google::protobuf::operator!=(&__for_begin, &__for_end) )
  {
    p_material_id = google::protobuf::Map<unsigned int,unsigned int>::const_iterator::operator*(&__for_begin);
    p_second = &p_material_id->second;
    if ( *(_BYTE *)(((unsigned __int64)p_second >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)p_second & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_second >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(p_second);
    }
    second = p_material_id->second;
    v4 = p_material_id;
    v5 = std::unordered_map<unsigned int,unsigned int>::operator[](
           &this->delete_material_map,
           (const std::unordered_map<unsigned int,unsigned int>::key_type *)p_material_id);
    v6 = v5;
    v7 = *(_BYTE *)(((unsigned __int64)v5 >> 3) + 0x7FFF8000);
    if ( v7 != 0 && (char)(((unsigned __int8)v5 & 7) + 3) >= v7 )
    {
      LOBYTE(v4) = v7 != 0;
      __asan_report_store4(v5, v4, v5);
    }
    *v6 = second;
    google::protobuf::Map<unsigned int,unsigned int>::const_iterator::operator++(&__for_begin);
  }
  __for_range_0 = proto::MaterialDeleteReturnRecordBin::return_item_map(record_bin);
  google::protobuf::Map<unsigned int,unsigned int>::begin(&__for_begin, __for_range_0);
  google::protobuf::Map<unsigned int,unsigned int>::end(&__for_end, __for_range_0);
  while ( google::protobuf::operator!=(&__for_begin, &__for_end) )
  {
    p_item_id = google::protobuf::Map<unsigned int,unsigned int>::const_iterator::operator*(&__for_begin);
    v8 = &p_item_id->second;
    if ( *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v8 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v8);
    }
    v9 = p_item_id->second;
    v10 = p_item_id;
    v11 = std::unordered_map<unsigned int,unsigned int>::operator[](
            &this->return_item_map,
            (const std::unordered_map<unsigned int,unsigned int>::key_type *)p_item_id);
    v12 = v11;
    v13 = *(_BYTE *)(((unsigned __int64)v11 >> 3) + 0x7FFF8000);
    if ( v13 != 0 && (char)(((unsigned __int8)v11 & 7) + 3) >= v13 )
    {
      LOBYTE(v10) = v13 != 0;
      __asan_report_store4(v11, v10, v11);
    }
    *v12 = v9;
    google::protobuf::Map<unsigned int,unsigned int>::const_iterator::operator++(&__for_begin);
  }
  return 0;
};

// Line 130: range 0000000017CBA4E6-0000000017CBA746
int32_t __cdecl MaterialDeleteReturnRecord::toBin(
        MaterialDeleteReturnRecord *const this,
        proto::MaterialDeleteReturnRecordBin *record_bin)
{
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *v2; // rax
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type v3; // ebx
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *v4; // rsi
  unsigned int *v5; // rax
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *v6; // rdx
  char v7; // cl
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *v8; // rax
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type v9; // ebx
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *v10; // rsi
  unsigned int *v11; // rax
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *v12; // rdx
  char v13; // cl
  std::unordered_map<unsigned int,unsigned int>::iterator __for_begin; // [rsp+10h] [rbp-70h] BYREF
  std::unordered_map<unsigned int,unsigned int>::iterator __for_end; // [rsp+18h] [rbp-68h] BYREF
  google::protobuf::Map<unsigned int,unsigned int> *bin_delete_material_map; // [rsp+20h] [rbp-60h]
  std::unordered_map<unsigned int,unsigned int> *__for_range; // [rsp+28h] [rbp-58h]
  google::protobuf::Map<unsigned int,unsigned int> *bin_return_item_map; // [rsp+30h] [rbp-50h]
  std::unordered_map<unsigned int,unsigned int> *__for_range_0; // [rsp+38h] [rbp-48h]
  std::pair<unsigned int const,unsigned int> *v22; // [rsp+40h] [rbp-40h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *item_id; // [rsp+48h] [rbp-38h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *num; // [rsp+50h] [rbp-30h]
  std::pair<unsigned int const,unsigned int> *__in; // [rsp+58h] [rbp-28h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *material_id; // [rsp+60h] [rbp-20h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *delete_num; // [rsp+68h] [rbp-18h]

  bin_delete_material_map = proto::MaterialDeleteReturnRecordBin::mutable_delete_material_map(record_bin);
  __for_range = &this->delete_material_map;
  __for_begin._M_cur = std::unordered_map<unsigned int,unsigned int>::begin(&this->delete_material_map)._M_cur;
  __for_end._M_cur = std::unordered_map<unsigned int,unsigned int>::end(&this->delete_material_map)._M_cur;
  while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(&__for_begin, &__for_end) )
  {
    __in = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*(&__for_begin);
    material_id = std::get<0ul,unsigned int const,unsigned int>(__in);
    v2 = std::get<1ul,unsigned int const,unsigned int>(__in);
    delete_num = v2;
    if ( *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v2 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v2);
    }
    v3 = *delete_num;
    v4 = material_id;
    v5 = google::protobuf::Map<unsigned int,unsigned int>::operator[](bin_delete_material_map, material_id);
    v6 = v5;
    v7 = *(_BYTE *)(((unsigned __int64)v5 >> 3) + 0x7FFF8000);
    if ( v7 != 0 && (char)(((unsigned __int8)v5 & 7) + 3) >= v7 )
    {
      LOBYTE(v4) = v7 != 0;
      __asan_report_store4(v5, v4, v5);
    }
    *v6 = v3;
    std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++(&__for_begin);
  }
  bin_return_item_map = proto::MaterialDeleteReturnRecordBin::mutable_return_item_map(record_bin);
  __for_range_0 = &this->return_item_map;
  __for_begin._M_cur = std::unordered_map<unsigned int,unsigned int>::begin(&this->return_item_map)._M_cur;
  __for_end._M_cur = std::unordered_map<unsigned int,unsigned int>::end(__for_range_0)._M_cur;
  while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(&__for_begin, &__for_end) )
  {
    v22 = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*(&__for_begin);
    item_id = std::get<0ul,unsigned int const,unsigned int>(v22);
    v8 = std::get<1ul,unsigned int const,unsigned int>(v22);
    num = v8;
    if ( *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v8 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v8);
    }
    v9 = *num;
    v10 = item_id;
    v11 = google::protobuf::Map<unsigned int,unsigned int>::operator[](bin_return_item_map, item_id);
    v12 = v11;
    v13 = *(_BYTE *)(((unsigned __int64)v11 >> 3) + 0x7FFF8000);
    if ( v13 != 0 && (char)(((unsigned __int8)v11 & 7) + 3) >= v13 )
    {
      LOBYTE(v10) = v13 != 0;
      __asan_report_store4(v11, v10, v11);
    }
    *v12 = v9;
    std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++(&__for_begin);
  }
  return 0;
};

// Line 145: range 0000000017CBA748-0000000017CBA857
void __fastcall MaterialDeleteReturnRecord::recordDeleteMaterial(
        MaterialDeleteReturnRecord *const this,
        uint32_t material_id,
        uint32_t item_num)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  unsigned __int64 v5; // r12
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v6; // rax
  char v8[96]; // [rsp+10h] [rbp-60h] BYREF

  v3 = (unsigned __int64)v8;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_0(64LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 4 15 material_id:144";
  *(_QWORD *)(v3 + 16) = MaterialDeleteReturnRecord::recordDeleteMaterial;
  v5 = v3 >> 3;
  *(_DWORD *)(v5 + 2147450880) = -235802127;
  *(_DWORD *)(v5 + 2147450884) = -202116348;
  *(_DWORD *)(v3 + 32) = material_id;
  v6 = std::unordered_map<unsigned int,unsigned int>::operator[](
         &this->delete_material_map,
         (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v3 + 32));
  if ( *(_BYTE *)(((unsigned __int64)v6 >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)v6 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v6 >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(v6);
  }
  *v6 += item_num;
  if ( v8 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 150: range 0000000017CBA858-0000000017CBA982
void __cdecl MaterialDeleteReturnRecord::recordReturnItem(
        MaterialDeleteReturnRecord *const this,
        const std::unordered_map<unsigned int,unsigned int> *return_item_map)
{
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v2; // rax
  std::unordered_map<unsigned int,unsigned int>::mapped_type v3; // esi
  std::unordered_map<unsigned int,unsigned int>::const_iterator __for_begin; // [rsp+10h] [rbp-30h] BYREF
  std::unordered_map<unsigned int,unsigned int>::const_iterator __for_end; // [rsp+18h] [rbp-28h] BYREF
  const std::unordered_map<unsigned int,unsigned int> *__for_range; // [rsp+20h] [rbp-20h]
  const std::pair<unsigned int const,unsigned int> *v7; // [rsp+28h] [rbp-18h]
  std::tuple_element<0,const std::pair<unsigned int const,unsigned int> >::type *item_id; // [rsp+30h] [rbp-10h]
  std::tuple_element<1,const std::pair<unsigned int const,unsigned int> >::type *num; // [rsp+38h] [rbp-8h]

  __for_range = return_item_map;
  __for_begin._M_cur = std::unordered_map<unsigned int,unsigned int>::begin(return_item_map)._M_cur;
  __for_end._M_cur = std::unordered_map<unsigned int,unsigned int>::end(return_item_map)._M_cur;
  while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(&__for_begin, &__for_end) )
  {
    v7 = std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*(&__for_begin);
    item_id = std::get<0ul,unsigned int const,unsigned int>(v7);
    num = (std::tuple_element<1,const std::pair<unsigned int const,unsigned int> >::type *)std::get<1ul,unsigned int const,unsigned int>(v7);
    v2 = std::unordered_map<unsigned int,unsigned int>::operator[](&this->return_item_map, item_id);
    if ( *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v2 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v2);
    }
    v3 = *v2;
    if ( *(_BYTE *)(((unsigned __int64)num >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)num & 7) + 3) >= *(_BYTE *)(((unsigned __int64)num >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(num);
    }
    *v2 = v3 + *num;
    std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++(&__for_begin);
  }
};

// Line 158: range 0000000017CBA984-0000000017CBA9C1
bool __cdecl MaterialDeleteReturnRecord::empty(MaterialDeleteReturnRecord *const this)
{
  return std::unordered_map<unsigned int,unsigned int>::empty(&this->delete_material_map)
      && std::unordered_map<unsigned int,unsigned int>::empty(&this->return_item_map);
};

// Line 163: range 0000000017CBA9C2-0000000017CBA9EC
void __cdecl MaterialDeleteReturnRecord::clear(MaterialDeleteReturnRecord *const this)
{
  std::unordered_map<unsigned int,unsigned int>::clear(&this->delete_material_map);
  std::unordered_map<unsigned int,unsigned int>::clear(&this->return_item_map);
};

// Line 169: range 0000000017DABFC2-0000000017DAC1E9
void __cdecl ItemLimitRecord::fromBin<proto::ItemLimitRecordBin>(
        ItemLimitRecord *const this,
        const proto::ItemLimitRecordBin *bin)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r13
  __int64 refresh_time; // rdx
  char v6; // al
  google::protobuf::uint32 v7; // r14d
  char *v8; // rsi
  std::unordered_map<ItemIndexKey,unsigned int>::mapped_type *v9; // rax
  google::protobuf::uint32 *v10; // rdx
  char v11; // cl
  const proto::ItemLimitRecordBin *bina; // [rsp+0h] [rbp-A0h]
  google::protobuf::RepeatedPtrField<proto::ItemLimitCountRecordBin>::const_iterator __for_begin; // [rsp+10h] [rbp-90h] BYREF
  google::protobuf::RepeatedPtrField<proto::ItemLimitCountRecordBin>::const_iterator __for_end; // [rsp+18h] [rbp-88h] BYREF
  const google::protobuf::RepeatedPtrField<proto::ItemLimitCountRecordBin> *__for_range; // [rsp+20h] [rbp-80h]
  const proto::ItemLimitCountRecordBin *record_bin; // [rsp+28h] [rbp-78h]
  char v17[112]; // [rsp+30h] [rbp-70h] BYREF

  bina = bin;
  v2 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 8 18 item_index_key:174";
  *(_QWORD *)(v2 + 16) = ItemLimitRecord::fromBin<proto::ItemLimitRecordBin>;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116352;
  refresh_time = proto::ItemLimitRecordBin::last_refresh_time(bin);
  v6 = *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000);
  if ( v6 != 0 && v6 <= 3 )
  {
    LOBYTE(bin) = v6 != 0;
    __asan_report_store4(this, bin, refresh_time);
  }
  this->last_refresh_time = refresh_time;
  __for_range = proto::ItemLimitRecordBin::item_limit_count_record_list(bina);
  __for_begin.it_ = google::protobuf::RepeatedPtrField<proto::ItemLimitCountRecordBin>::begin(__for_range).it_;
  __for_end.it_ = google::protobuf::RepeatedPtrField<proto::ItemLimitCountRecordBin>::end(__for_range).it_;
  while ( google::protobuf::internal::RepeatedPtrIterator<proto::ItemLimitCountRecordBin const>::operator!=(
            &__for_begin,
            &__for_end) )
  {
    record_bin = google::protobuf::internal::RepeatedPtrIterator<proto::ItemLimitCountRecordBin const>::operator*(&__for_begin);
    *(_DWORD *)(v2 + 32) = 0;
    *(_DWORD *)(v2 + 36) = 0;
    *(_DWORD *)(v2 + 32) = proto::ItemLimitCountRecordBin::item_type(record_bin);
    *(_DWORD *)(v2 + 36) = proto::ItemLimitCountRecordBin::index_value(record_bin);
    v7 = proto::ItemLimitCountRecordBin::item_count(record_bin);
    v8 = (char *)(v2 + 32);
    v9 = std::unordered_map<ItemIndexKey,unsigned int>::operator[](
           &this->item_count_map,
           (const std::unordered_map<ItemIndexKey,unsigned int>::key_type *)(v2 + 32));
    v10 = v9;
    v11 = *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000);
    if ( v11 != 0 && (char)(((unsigned __int8)v9 & 7) + 3) >= v11 )
    {
      LOBYTE(v8) = v11 != 0;
      __asan_report_store4(v9, v8, v9);
    }
    *v10 = v7;
    google::protobuf::internal::RepeatedPtrIterator<proto::ItemLimitCountRecordBin const>::operator++(&__for_begin);
  }
  if ( v17 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 195: range 0000000017CBA9EE-0000000017CBAC06
void __cdecl OutputControlRecord::fromBin(
        OutputControlRecord *const this,
        const proto::OutputControlRecordBin *output_control_record_bin)
{
  __int64 refresh_time; // rdx
  char v3; // al
  google::protobuf::uint32 v4; // ebx
  std::unordered_map<unsigned int,unsigned int>::key_type *p_k; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v6; // rax
  google::protobuf::uint32 *v7; // rdx
  char v8; // cl
  google::protobuf::uint32 v9; // ebx
  std::unordered_map<unsigned int,unsigned int>::key_type *v10; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v11; // rax
  google::protobuf::uint32 *v12; // rdx
  char v13; // cl
  const proto::OutputControlRecordBin *output_control_record_bina; // [rsp+0h] [rbp-60h]
  std::unordered_map<unsigned int,unsigned int>::key_type __k; // [rsp+1Ch] [rbp-44h] BYREF
  google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::const_iterator __for_begin; // [rsp+20h] [rbp-40h] BYREF
  google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::const_iterator __for_end; // [rsp+28h] [rbp-38h] BYREF
  const google::protobuf::RepeatedPtrField<proto::Uint32PairBin> *__for_range; // [rsp+30h] [rbp-30h]
  const google::protobuf::RepeatedPtrField<proto::Uint32PairBin> *__for_range_0; // [rsp+38h] [rbp-28h]
  const proto::Uint32PairBin *pair_bin_0; // [rsp+40h] [rbp-20h]
  const proto::Uint32PairBin *pair_bin; // [rsp+48h] [rbp-18h]

  output_control_record_bina = output_control_record_bin;
  refresh_time = proto::OutputControlRecordBin::last_refresh_time(output_control_record_bin);
  v3 = *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000);
  if ( v3 != 0 && v3 <= 3 )
  {
    LOBYTE(output_control_record_bin) = v3 != 0;
    __asan_report_store4(this, output_control_record_bin, refresh_time);
  }
  this->last_refresh_time = refresh_time;
  __for_range = proto::OutputControlRecordBin::daily_count_list(output_control_record_bina);
  __for_begin.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::begin(__for_range).it_;
  __for_end.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::end(__for_range).it_;
  while ( google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator!=(
            &__for_begin,
            &__for_end) )
  {
    pair_bin = google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator*(&__for_begin);
    v4 = proto::Uint32PairBin::value(pair_bin);
    __k = proto::Uint32PairBin::key(pair_bin);
    p_k = &__k;
    v6 = std::unordered_map<unsigned int,unsigned int>::operator[](&this->daily_count_map, &__k);
    v7 = v6;
    v8 = *(_BYTE *)(((unsigned __int64)v6 >> 3) + 0x7FFF8000);
    if ( v8 != 0 && (char)(((unsigned __int8)v6 & 7) + 3) >= v8 )
    {
      LOBYTE(p_k) = v8 != 0;
      __asan_report_store4(v6, p_k, v6);
    }
    *v7 = v4;
    google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator++(&__for_begin);
  }
  __for_range_0 = proto::OutputControlRecordBin::total_count_list(output_control_record_bina);
  __for_begin.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::begin(__for_range_0).it_;
  __for_end.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::end(__for_range_0).it_;
  while ( google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator!=(
            &__for_begin,
            &__for_end) )
  {
    pair_bin_0 = google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator*(&__for_begin);
    v9 = proto::Uint32PairBin::value(pair_bin_0);
    __k = proto::Uint32PairBin::key(pair_bin_0);
    v10 = &__k;
    v11 = std::unordered_map<unsigned int,unsigned int>::operator[](&this->total_count_map, &__k);
    v12 = v11;
    v13 = *(_BYTE *)(((unsigned __int64)v11 >> 3) + 0x7FFF8000);
    if ( v13 != 0 && (char)(((unsigned __int8)v11 & 7) + 3) >= v13 )
    {
      LOBYTE(v10) = v13 != 0;
      __asan_report_store4(v11, v10, v11);
    }
    *v12 = v9;
    google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator++(&__for_begin);
  }
};

// Line 210: range 0000000017CBAC08-0000000017CBAFA1
void __cdecl OutputControlRecord::toBin(
        const OutputControlRecord *const this,
        proto::OutputControlRecordBin *output_control_record_bin)
{
  std::pair<unsigned int const,unsigned int> *v2; // rax
  std::pair<unsigned int const,unsigned int> *v3; // rdx
  std::pair<unsigned int const,unsigned int> *v4; // rax
  std::pair<unsigned int const,unsigned int> *v5; // rdx
  std::unordered_map<unsigned int,unsigned int>::const_iterator __for_begin; // [rsp+18h] [rbp-58h] BYREF
  std::unordered_map<unsigned int,unsigned int>::const_iterator __for_end; // [rsp+20h] [rbp-50h] BYREF
  const std::unordered_map<unsigned int,unsigned int> *__for_range; // [rsp+28h] [rbp-48h]
  const std::unordered_map<unsigned int,unsigned int> *__for_range_0; // [rsp+30h] [rbp-40h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *id_0; // [rsp+38h] [rbp-38h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *count_0; // [rsp+40h] [rbp-30h]
  proto::Uint32PairBin *pair_bin_0; // [rsp+48h] [rbp-28h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *id; // [rsp+50h] [rbp-20h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *count; // [rsp+58h] [rbp-18h]
  proto::Uint32PairBin *pair_bin; // [rsp+60h] [rbp-10h]
  std::pair<unsigned int const,unsigned int> __in; // [rsp+68h] [rbp-8h] BYREF

  if ( *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(this);
  }
  proto::OutputControlRecordBin::set_last_refresh_time(output_control_record_bin, this->last_refresh_time);
  __for_range = &this->daily_count_map;
  __for_begin._M_cur = std::unordered_map<unsigned int,unsigned int>::begin(&this->daily_count_map)._M_cur;
  __for_end._M_cur = std::unordered_map<unsigned int,unsigned int>::end(&this->daily_count_map)._M_cur;
  while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(&__for_begin, &__for_end) )
  {
    v2 = (std::pair<unsigned int const,unsigned int> *)std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*(&__for_begin);
    v3 = v2;
    if ( ((unsigned __int8)v2 & 7) >= *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000)
      && *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000) != 0
      || *(_BYTE *)((((unsigned __int64)&v2->second + 3) >> 3) + 0x7FFF8000) != 0
      && (((unsigned __int8)v2 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v2->second + 3) >> 3) + 0x7FFF8000) )
    {
      __asan_report_load_n(v2, 8LL);
    }
    __in = *v3;
    id = std::get<0ul,unsigned int const,unsigned int>(&__in);
    count = std::get<1ul,unsigned int const,unsigned int>(&__in);
    pair_bin = proto::OutputControlRecordBin::add_daily_count_list(output_control_record_bin);
    if ( *(_BYTE *)(((unsigned __int64)id >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)id >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(id);
    }
    proto::Uint32PairBin::set_key(pair_bin, *id);
    if ( *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(count);
    }
    proto::Uint32PairBin::set_value(pair_bin, *count);
    std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++(&__for_begin);
  }
  __for_range_0 = &this->total_count_map;
  __for_begin._M_cur = std::unordered_map<unsigned int,unsigned int>::begin(&this->total_count_map)._M_cur;
  __for_end._M_cur = std::unordered_map<unsigned int,unsigned int>::end(__for_range_0)._M_cur;
  while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(&__for_begin, &__for_end) )
  {
    v4 = (std::pair<unsigned int const,unsigned int> *)std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*(&__for_begin);
    v5 = v4;
    if ( ((unsigned __int8)v4 & 7) >= *(_BYTE *)(((unsigned __int64)v4 >> 3) + 0x7FFF8000)
      && *(_BYTE *)(((unsigned __int64)v4 >> 3) + 0x7FFF8000) != 0
      || *(_BYTE *)((((unsigned __int64)&v4->second + 3) >> 3) + 0x7FFF8000) != 0
      && (((unsigned __int8)v4 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v4->second + 3) >> 3) + 0x7FFF8000) )
    {
      __asan_report_load_n(v4, 8LL);
    }
    __in = *v5;
    id_0 = std::get<0ul,unsigned int const,unsigned int>(&__in);
    count_0 = std::get<1ul,unsigned int const,unsigned int>(&__in);
    pair_bin_0 = proto::OutputControlRecordBin::add_total_count_list(output_control_record_bin);
    if ( *(_BYTE *)(((unsigned __int64)id_0 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)id_0 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)id_0 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(id_0);
    }
    proto::Uint32PairBin::set_key(pair_bin_0, *id_0);
    if ( *(_BYTE *)(((unsigned __int64)count_0 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)count_0 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)count_0 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(count_0);
    }
    proto::Uint32PairBin::set_value(pair_bin_0, *count_0);
    std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++(&__for_begin);
  }
};

// Line 230: range 0000000017CBAFA2-0000000017CBB278
void __cdecl ActivityOutputControlRecord::fromBin(
        ActivityOutputControlRecord *const this,
        const proto::ActivityOutputControlRecordBin *bin)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  __int64 refresh_time; // rdx
  char v6; // al
  google::protobuf::uint32 v7; // r14d
  ActivityOutputIndexRecord *v8; // r15
  std::unordered_map<unsigned int,unsigned int>::key_type *p_k; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v10; // rax
  google::protobuf::uint32 *v11; // rdx
  char v12; // cl
  const proto::ActivityOutputControlRecordBin *bina; // [rsp+10h] [rbp-D0h]
  std::unordered_map<unsigned int,unsigned int>::key_type __k; // [rsp+24h] [rbp-BCh] BYREF
  google::protobuf::RepeatedPtrField<proto::ActivityOutputIndexRecordBin>::const_iterator __for_begin; // [rsp+28h] [rbp-B8h] BYREF
  google::protobuf::RepeatedPtrField<proto::ActivityOutputIndexRecordBin>::const_iterator __for_end; // [rsp+30h] [rbp-B0h] BYREF
  google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::const_iterator __for_begin_0; // [rsp+38h] [rbp-A8h] BYREF
  google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::const_iterator __for_end_0; // [rsp+40h] [rbp-A0h] BYREF
  const google::protobuf::RepeatedPtrField<proto::ActivityOutputIndexRecordBin> *__for_range; // [rsp+48h] [rbp-98h]
  const proto::ActivityOutputIndexRecordBin *index_record_bin; // [rsp+50h] [rbp-90h]
  ActivityOutputIndexRecord *index_record; // [rsp+58h] [rbp-88h]
  const google::protobuf::RepeatedPtrField<proto::Uint32PairBin> *__for_range_0; // [rsp+60h] [rbp-80h]
  const proto::Uint32PairBin *pair_bin; // [rsp+68h] [rbp-78h]
  char v24[112]; // [rsp+70h] [rbp-70h] BYREF

  bina = bin;
  v2 = (unsigned __int64)v24;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 23 output_control_type:234";
  *(_QWORD *)(v2 + 16) = ActivityOutputControlRecord::fromBin;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  refresh_time = proto::ActivityOutputControlRecordBin::last_refresh_time(bin);
  v6 = *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000);
  if ( v6 != 0 && v6 <= 3 )
  {
    LOBYTE(bin) = v6 != 0;
    __asan_report_store4(this, bin, refresh_time);
  }
  this->last_refresh_time = refresh_time;
  __for_range = proto::ActivityOutputControlRecordBin::activity_output_index_record_list(bina);
  __for_begin.it_ = google::protobuf::RepeatedPtrField<proto::ActivityOutputIndexRecordBin>::begin(__for_range).it_;
  __for_end.it_ = google::protobuf::RepeatedPtrField<proto::ActivityOutputIndexRecordBin>::end(__for_range).it_;
  while ( google::protobuf::internal::RepeatedPtrIterator<proto::ActivityOutputIndexRecordBin const>::operator!=(
            &__for_begin,
            &__for_end) )
  {
    index_record_bin = google::protobuf::internal::RepeatedPtrIterator<proto::ActivityOutputIndexRecordBin const>::operator*(&__for_begin);
    *(_DWORD *)(v2 + 32) = proto::ActivityOutputIndexRecordBin::output_control_type(index_record_bin);
    index_record = std::map<data::OutputControlType,ActivityOutputIndexRecord>::operator[](
                     &this->activity_output_index_record_map,
                     (const std::map<data::OutputControlType,ActivityOutputIndexRecord>::key_type *)(v2 + 32));
    __for_range_0 = proto::ActivityOutputIndexRecordBin::activity_count_list(index_record_bin);
    __for_begin_0.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::begin(__for_range_0).it_;
    __for_end_0.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::end(__for_range_0).it_;
    while ( google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator!=(
              &__for_begin_0,
              &__for_end_0) )
    {
      pair_bin = google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator*(&__for_begin_0);
      v7 = proto::Uint32PairBin::value(pair_bin);
      v8 = index_record;
      __k = proto::Uint32PairBin::key(pair_bin);
      p_k = &__k;
      v10 = std::unordered_map<unsigned int,unsigned int>::operator[](&v8->activity_count_map, &__k);
      v11 = v10;
      v12 = *(_BYTE *)(((unsigned __int64)v10 >> 3) + 0x7FFF8000);
      if ( v12 != 0 && (char)(((unsigned __int8)v10 & 7) + 3) >= v12 )
      {
        LOBYTE(p_k) = v12 != 0;
        __asan_report_store4(v10, p_k, v10);
      }
      *v11 = v7;
      google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator++(&__for_begin_0);
    }
    google::protobuf::internal::RepeatedPtrIterator<proto::ActivityOutputIndexRecordBin const>::operator++(&__for_begin);
  }
  if ( v24 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 230: range 0000000017DADE8E-0000000017DAE061
void __cdecl ItemLimitRecord::toBin<proto::ItemLimitRecordBin>(
        const ItemLimitRecord *const this,
        proto::ItemLimitRecordBin *bin)
{
  std::unordered_map<ItemIndexKey,unsigned int>::const_iterator __for_begin; // [rsp+18h] [rbp-38h] BYREF
  std::unordered_map<ItemIndexKey,unsigned int>::const_iterator __for_end; // [rsp+20h] [rbp-30h] BYREF
  const std::unordered_map<ItemIndexKey,unsigned int> *__for_range; // [rsp+28h] [rbp-28h]
  const std::pair<const ItemIndexKey,unsigned int> *v5; // [rsp+30h] [rbp-20h]
  std::tuple_element<0,const std::pair<const ItemIndexKey,unsigned int> >::type *item_index_key; // [rsp+38h] [rbp-18h]
  std::tuple_element<1,const std::pair<const ItemIndexKey,unsigned int> >::type *item_count; // [rsp+40h] [rbp-10h]
  proto::ItemLimitCountRecordBin *item_limit_count_record_bin; // [rsp+48h] [rbp-8h]

  if ( *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(this);
  }
  proto::ItemLimitRecordBin::set_last_refresh_time(bin, this->last_refresh_time);
  __for_range = &this->item_count_map;
  __for_begin._M_cur = std::unordered_map<ItemIndexKey,unsigned int>::begin(&this->item_count_map)._M_cur;
  __for_end._M_cur = std::unordered_map<ItemIndexKey,unsigned int>::end(&this->item_count_map)._M_cur;
  while ( std::__detail::operator!=<std::pair<ItemIndexKey const,unsigned int>,false>(&__for_begin, &__for_end) )
  {
    v5 = std::__detail::_Node_const_iterator<std::pair<ItemIndexKey const,unsigned int>,false,false>::operator*(&__for_begin);
    item_index_key = std::get<0ul,ItemIndexKey const,unsigned int>(v5);
    item_count = (std::tuple_element<1,const std::pair<const ItemIndexKey,unsigned int> >::type *)std::get<1ul,ItemIndexKey const,unsigned int>(v5);
    item_limit_count_record_bin = proto::ItemLimitRecordBin::add_item_limit_count_record_list(bin);
    if ( *(_BYTE *)(((unsigned __int64)item_index_key >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_index_key & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_index_key >> 3)
                                                                       + 0x7FFF8000) )
    {
      __asan_report_load4(item_index_key);
    }
    proto::ItemLimitCountRecordBin::set_item_type(item_limit_count_record_bin, item_index_key->item_type);
    if ( *(_BYTE *)(((unsigned __int64)&item_index_key->index_value >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_index_key + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_index_key->index_value >> 3)
                                                                   + 0x7FFF8000) )
    {
      __asan_report_load4(&item_index_key->index_value);
    }
    proto::ItemLimitCountRecordBin::set_index_value(item_limit_count_record_bin, item_index_key->index_value);
    if ( *(_BYTE *)(((unsigned __int64)item_count >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_count);
    }
    proto::ItemLimitCountRecordBin::set_item_count(item_limit_count_record_bin, *item_count);
    std::__detail::_Node_const_iterator<std::pair<ItemIndexKey const,unsigned int>,false,false>::operator++(&__for_begin);
  }
};

// Line 244: range 0000000017CBB27A-0000000017CBB550
void __cdecl ActivityOutputControlRecord::toBin(
        const ActivityOutputControlRecord *const this,
        proto::ActivityOutputControlRecordBin *bin)
{
  std::pair<unsigned int const,unsigned int> *v2; // rax
  std::pair<unsigned int const,unsigned int> *v3; // rdx
  std::map<data::OutputControlType,ActivityOutputIndexRecord>::const_iterator __for_begin; // [rsp+10h] [rbp-70h] BYREF
  std::map<data::OutputControlType,ActivityOutputIndexRecord>::const_iterator __for_end; // [rsp+18h] [rbp-68h] BYREF
  std::unordered_map<unsigned int,unsigned int>::const_iterator __for_begin_0; // [rsp+20h] [rbp-60h] BYREF
  std::unordered_map<unsigned int,unsigned int>::const_iterator __for_end_0; // [rsp+28h] [rbp-58h] BYREF
  const std::map<data::OutputControlType,ActivityOutputIndexRecord> *__for_range; // [rsp+30h] [rbp-50h]
  const std::pair<const data::OutputControlType,ActivityOutputIndexRecord> *v9; // [rsp+38h] [rbp-48h]
  std::tuple_element<0,const std::pair<const data::OutputControlType,ActivityOutputIndexRecord> >::type *output_control_type; // [rsp+40h] [rbp-40h]
  std::tuple_element<1,const std::pair<const data::OutputControlType,ActivityOutputIndexRecord> >::type *index_record; // [rsp+48h] [rbp-38h]
  proto::ActivityOutputIndexRecordBin *index_record_bin; // [rsp+50h] [rbp-30h]
  const std::unordered_map<unsigned int,unsigned int> *__for_range_0; // [rsp+58h] [rbp-28h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *output_index; // [rsp+60h] [rbp-20h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *output_count; // [rsp+68h] [rbp-18h]
  proto::Uint32PairBin *pair_bin; // [rsp+70h] [rbp-10h]
  std::pair<unsigned int const,unsigned int> __in; // [rsp+78h] [rbp-8h] BYREF

  if ( *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(this);
  }
  proto::ActivityOutputControlRecordBin::set_last_refresh_time(bin, this->last_refresh_time);
  __for_range = &this->activity_output_index_record_map;
  __for_begin._M_node = std::map<data::OutputControlType,ActivityOutputIndexRecord>::begin(&this->activity_output_index_record_map)._M_node;
  __for_end._M_node = std::map<data::OutputControlType,ActivityOutputIndexRecord>::end(&this->activity_output_index_record_map)._M_node;
  while ( std::operator!=(&__for_begin, &__for_end) )
  {
    v9 = std::_Rb_tree_const_iterator<std::pair<data::OutputControlType const,ActivityOutputIndexRecord>>::operator*(&__for_begin);
    output_control_type = std::get<0ul,data::OutputControlType const,ActivityOutputIndexRecord>(v9);
    index_record = (std::tuple_element<1,const std::pair<const data::OutputControlType,ActivityOutputIndexRecord> >::type *)std::get<1ul,data::OutputControlType const,ActivityOutputIndexRecord>(v9);
    index_record_bin = proto::ActivityOutputControlRecordBin::add_activity_output_index_record_list(bin);
    if ( *(_BYTE *)(((unsigned __int64)output_control_type >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)output_control_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)output_control_type >> 3)
                                                                            + 0x7FFF8000) )
    {
      __asan_report_load4(output_control_type);
    }
    proto::ActivityOutputIndexRecordBin::set_output_control_type(index_record_bin, *output_control_type);
    __for_range_0 = &index_record->activity_count_map;
    __for_begin_0._M_cur = std::unordered_map<unsigned int,unsigned int>::begin(&index_record->activity_count_map)._M_cur;
    __for_end_0._M_cur = std::unordered_map<unsigned int,unsigned int>::end(__for_range_0)._M_cur;
    while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(&__for_begin_0, &__for_end_0) )
    {
      v2 = (std::pair<unsigned int const,unsigned int> *)std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*(&__for_begin_0);
      v3 = v2;
      if ( ((unsigned __int8)v2 & 7) >= *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000)
        && *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000) != 0
        || *(_BYTE *)((((unsigned __int64)&v2->second + 3) >> 3) + 0x7FFF8000) != 0
        && (((unsigned __int8)v2 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v2->second + 3) >> 3) + 0x7FFF8000) )
      {
        __asan_report_load_n(v2, 8LL);
      }
      __in = *v3;
      output_index = std::get<0ul,unsigned int const,unsigned int>(&__in);
      output_count = std::get<1ul,unsigned int const,unsigned int>(&__in);
      pair_bin = proto::ActivityOutputIndexRecordBin::add_activity_count_list(index_record_bin);
      if ( *(_BYTE *)(((unsigned __int64)output_index >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)output_index & 7) + 3) >= *(_BYTE *)(((unsigned __int64)output_index >> 3)
                                                                       + 0x7FFF8000) )
      {
        __asan_report_load4(output_index);
      }
      proto::Uint32PairBin::set_key(pair_bin, *output_index);
      if ( *(_BYTE *)(((unsigned __int64)output_count >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)output_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)output_count >> 3)
                                                                       + 0x7FFF8000) )
      {
        __asan_report_load4(output_count);
      }
      proto::Uint32PairBin::set_value(pair_bin, *output_count);
      std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++(&__for_begin_0);
    }
    std::_Rb_tree_const_iterator<std::pair<data::OutputControlType const,ActivityOutputIndexRecord>>::operator++(&__for_begin);
  }
};

// Line 260: range 0000000017CBB552-0000000017CBB652
void __cdecl ShopGoodsOutputRecord::fromBin(
        ShopGoodsOutputRecord *const this,
        const proto::ShopGoodsOutputRecordBin *shop_goods_output_record_bin)
{
  uint32_t v2; // ecx
  char v3; // dl
  __int64 v4; // rdx
  uint32_t record_time; // ecx
  char v6; // dl
  __int64 v7; // rdx
  uint32_t v8; // ecx
  char v9; // dl
  __int64 v10; // rdx
  const proto::ShopGoodsOutputRecordBin *shop_goods_output_record_bina; // [rsp+0h] [rbp-10h]

  shop_goods_output_record_bina = shop_goods_output_record_bin;
  v2 = proto::ShopGoodsOutputRecordBin::goods_id(shop_goods_output_record_bin);
  v3 = *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000);
  LOBYTE(shop_goods_output_record_bin) = v3 != 0;
  v4 = (v3 != 0) & (unsigned __int8)((char)(((unsigned __int8)this & 7) + 3) >= v3);
  if ( (_BYTE)v4 )
    __asan_report_store4(this, shop_goods_output_record_bin, v4);
  this->goods_id = v2;
  record_time = proto::ShopGoodsOutputRecordBin::last_record_time(shop_goods_output_record_bina);
  v6 = *(_BYTE *)(((unsigned __int64)&this->last_record_time >> 3) + 0x7FFF8000);
  LOBYTE(shop_goods_output_record_bin) = v6 != 0;
  v7 = (v6 != 0) & (unsigned __int8)((char)((((_BYTE)this + 4) & 7) + 3) >= v6);
  if ( (_BYTE)v7 )
    __asan_report_store4(&this->last_record_time, shop_goods_output_record_bin, v7);
  this->last_record_time = record_time;
  v8 = proto::ShopGoodsOutputRecordBin::buy_count(shop_goods_output_record_bina);
  v9 = *(_BYTE *)(((unsigned __int64)&this->buy_count >> 3) + 0x7FFF8000);
  LOBYTE(shop_goods_output_record_bin) = v9 != 0;
  v10 = (v9 != 0) & (unsigned __int8)((char)((((_BYTE)this + 8) & 7) + 3) >= v9);
  if ( (_BYTE)v10 )
    __asan_report_store4(&this->buy_count, shop_goods_output_record_bin, v10);
  this->buy_count = v8;
};

// Line 267: range 0000000017CBB654-0000000017CBB751
void __cdecl ShopGoodsOutputRecord::toBin(
        const ShopGoodsOutputRecord *const this,
        proto::ShopGoodsOutputRecordBin *shop_goods_output_record_bin)
{
  if ( *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)this & 7) + 3) >= *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(this);
  }
  proto::ShopGoodsOutputRecordBin::set_goods_id(shop_goods_output_record_bin, this->goods_id);
  if ( *(_BYTE *)(((unsigned __int64)&this->last_record_time >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->last_record_time >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->last_record_time);
  }
  proto::ShopGoodsOutputRecordBin::set_last_record_time(shop_goods_output_record_bin, this->last_record_time);
  if ( *(_BYTE *)(((unsigned __int64)&this->buy_count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->buy_count >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->buy_count);
  }
  proto::ShopGoodsOutputRecordBin::set_buy_count(shop_goods_output_record_bin, this->buy_count);
};

// Line 274: range 0000000017CBB752-0000000017CBB801
void __cdecl SingleBonusRecord::fromBin(
        SingleBonusRecord *const this,
        const proto::SingleBonusRecordBin *single_bonus_record_bin)
{
  uint32_t refresh_time; // ecx
  char v3; // dl
  __int64 v4; // rdx
  uint32_t v5; // ecx
  char v6; // dl
  __int64 v7; // rdx
  const proto::SingleBonusRecordBin *single_bonus_record_bina; // [rsp+0h] [rbp-10h]

  single_bonus_record_bina = single_bonus_record_bin;
  refresh_time = proto::SingleBonusRecordBin::last_refresh_time(single_bonus_record_bin);
  v3 = *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000);
  LOBYTE(single_bonus_record_bin) = v3 != 0;
  v4 = (v3 != 0) & (unsigned __int8)((char)(((unsigned __int8)this & 7) + 3) >= v3);
  if ( (_BYTE)v4 )
    __asan_report_store4(this, single_bonus_record_bin, v4);
  this->last_refresh_time = refresh_time;
  v5 = proto::SingleBonusRecordBin::bonus_count(single_bonus_record_bina);
  v6 = *(_BYTE *)(((unsigned __int64)&this->bonus_count >> 3) + 0x7FFF8000);
  LOBYTE(single_bonus_record_bin) = v6 != 0;
  v7 = (v6 != 0) & (unsigned __int8)((char)((((_BYTE)this + 4) & 7) + 3) >= v6);
  if ( (_BYTE)v7 )
    __asan_report_store4(&this->bonus_count, single_bonus_record_bin, v7);
  this->bonus_count = v5;
};

// Line 280: range 0000000017CBB802-0000000017CBB8AF
void __cdecl SingleBonusRecord::toBin(
        const SingleBonusRecord *const this,
        proto::SingleBonusRecordBin *single_bonus_record_bin)
{
  if ( *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)this & 7) + 3) >= *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(this);
  }
  proto::SingleBonusRecordBin::set_last_refresh_time(single_bonus_record_bin, this->last_refresh_time);
  if ( *(_BYTE *)(((unsigned __int64)&this->bonus_count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->bonus_count >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->bonus_count);
  }
  proto::SingleBonusRecordBin::set_bonus_count(single_bonus_record_bin, this->bonus_count);
};

// Line 287: range 0000000017CBB8B0-0000000017CBD84D
int32_t __cdecl PlayerItemComp::fromBin(PlayerItemComp *const this, const proto::PlayerDataBin *player_data_bin)
{
  unsigned __int64 v2; // r12
  __int64 v3; // rax
  _DWORD *v4; // r13
  int32_t result; // eax
  uint32_t v7; // ecx
  char v8; // dl
  __int64 v9; // rdx
  __int64 v10; // rdx
  char v11; // al
  uint32_t v12; // ecx
  char v13; // dl
  __int64 v14; // rdx
  __int64 v15; // rdx
  char v16; // al
  uint32_t v17; // ecx
  char v18; // dl
  __int64 v19; // rdx
  uint32_t v20; // ecx
  char v21; // dl
  __int64 v22; // rdx
  __int64 v23; // rdx
  char v24; // al
  uint32_t v25; // ecx
  char v26; // dl
  __int64 v27; // rdx
  __int64 v28; // rdx
  char v29; // al
  uint32_t v30; // ecx
  char v31; // dl
  __int64 v32; // rdx
  unsigned int v33; // eax
  __int64 v34; // rdx
  char v35; // al
  __int64 v36; // rsi
  __int64 v37; // rdx
  char v38; // al
  const google::protobuf::MapPair<unsigned int,long unsigned int> *v39; // rax
  __int64 v40; // r14
  unsigned __int64 v41; // rax
  AutoRecoverItemProxy *v42; // r14
  const proto::AutoRecoverItemBin *v43; // rax
  uint32_t v44; // eax
  common::milog::MiLogStream *v45; // r14
  common::milog::MiLogStream *v46; // rax
  common::milog::MiLogStream *v47; // rcx
  ItemLimitRecord *v48; // rax
  google::protobuf::uint32 v49; // r14d
  char *v50; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v51; // rax
  google::protobuf::uint32 *v52; // rdx
  char v53; // cl
  const proto::MaterialDeleteReturnRecordBin *v54; // rax
  common::milog::MiLogStream *v55; // rcx
  std::map<data::OutputControlType,OutputControlRecord> *p_output_control_record_map; // rcx
  OutputControlRecord *v57; // rax
  const proto::ShopOutputRecordBin *v58; // rax
  ShopGoodsOutputRecord *v59; // rax
  std::unordered_map<unsigned int,SingleBonusRecord> *v60; // r14
  SingleBonusRecord *v61; // rax
  const proto::EquipLevelupRecordBin *v62; // rax
  google::protobuf::uint32 v63; // r14d
  char *v64; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v65; // rax
  google::protobuf::uint32 *v66; // rdx
  char v67; // cl
  const proto::EquipLevelupRecordBin *v68; // rax
  google::protobuf::uint32 v69; // r14d
  char *v70; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v71; // rax
  google::protobuf::uint32 *v72; // rdx
  char v73; // cl
  const proto::EquipLevelupRecordBin *v74; // rax
  google::protobuf::uint32 v75; // r14d
  char *v76; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v77; // rax
  google::protobuf::uint32 *v78; // rdx
  char v79; // cl
  std::set<data::EquipType> *v80; // rcx
  ActivityOutputControlRecord *v81; // rax
  char *v82; // rsi
  __int64 v83; // rdx
  char v84; // al
  std::map<unsigned int,ReliquaryMainPropGuaranteeData> *p_main_prop_guarantee_data_map; // r14
  uint32_t v86; // ecx
  char v87; // dl
  char *v88; // rsi
  __int64 v89; // rdx
  uint32_t v90; // ecx
  char v91; // dl
  __int64 v92; // rdx
  google::protobuf::uint32 v93; // r14d
  char *v94; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v95; // rax
  google::protobuf::uint32 *v96; // rdx
  char v97; // cl
  unsigned int __x; // [rsp+2Ch] [rbp-274h] BYREF
  google::protobuf::RepeatedPtrField<proto::BonusRecordBin>::const_iterator __for_begin_2; // [rsp+30h] [rbp-270h] BYREF
  google::protobuf::RepeatedPtrField<proto::ReliquaryGuaranteeDepotBin>::const_iterator __for_end_2; // [rsp+38h] [rbp-268h] BYREF
  google::protobuf::RepeatedPtrField<proto::ReliquaryMainPropGuaranteeDataBin>::const_iterator __for_begin_3; // [rsp+40h] [rbp-260h] BYREF
  google::protobuf::RepeatedField<unsigned int>::const_iterator __for_begin; // [rsp+48h] [rbp-258h]
  google::protobuf::RepeatedField<unsigned int>::const_iterator __for_begin_1; // [rsp+50h] [rbp-250h]
  const proto::PlayerItemCompBin *proto_comp; // [rsp+58h] [rbp-248h]
  const google::protobuf::RepeatedField<unsigned int> *__for_range; // [rsp+60h] [rbp-240h]
  google::protobuf::RepeatedField<unsigned int>::const_iterator __for_end; // [rsp+68h] [rbp-238h]
  const google::protobuf::Map<unsigned int,long unsigned int> *__for_range_0; // [rsp+70h] [rbp-230h]
  const google::protobuf::RepeatedPtrField<proto::ItemLimitRecordBin> *__for_range_1; // [rsp+78h] [rbp-228h]
  const google::protobuf::RepeatedPtrField<proto::Uint32PairBin> *__for_range_2; // [rsp+80h] [rbp-220h]
  const google::protobuf::Map<unsigned int,proto::OutputControlRecordBin> *__for_range_3; // [rsp+88h] [rbp-218h]
  const google::protobuf::RepeatedPtrField<proto::ShopGoodsOutputRecordBin> *__for_range_4; // [rsp+90h] [rbp-210h]
  const google::protobuf::RepeatedPtrField<proto::BonusRecordBin> *__for_range_5; // [rsp+98h] [rbp-208h]
  const google::protobuf::RepeatedPtrField<proto::Uint32PairBin> *__for_range_7; // [rsp+A0h] [rbp-200h]
  const google::protobuf::RepeatedPtrField<proto::Uint32PairBin> *__for_range_8; // [rsp+A8h] [rbp-1F8h]
  const google::protobuf::RepeatedPtrField<proto::ReliquaryLevelupNumRecordBin> *__for_range_9; // [rsp+B0h] [rbp-1F0h]
  const google::protobuf::RepeatedPtrField<proto::ReliquarySuitBin> *__for_range_11; // [rsp+B8h] [rbp-1E8h]
  const google::protobuf::RepeatedPtrField<proto::ActivityOutputControlRecordBin> *__for_range_13; // [rsp+C0h] [rbp-1E0h]
  const google::protobuf::RepeatedPtrField<proto::ReliquaryGuaranteeDepotBin> *__for_range_14; // [rsp+C8h] [rbp-1D8h]
  const google::protobuf::RepeatedPtrField<proto::Uint32PairBin> *__for_range_16; // [rsp+D0h] [rbp-1D0h]
  const proto::Uint32PairBin *pair_bin_3; // [rsp+D8h] [rbp-1C8h]
  const proto::ReliquaryGuaranteeDepotBin *reliquary_guarantee_depot_bin; // [rsp+E0h] [rbp-1C0h]
  ReliquaryGuaranteeDepot *depot; // [rsp+E8h] [rbp-1B8h]
  const google::protobuf::RepeatedPtrField<proto::ReliquaryMainPropGuaranteeDataBin> *__for_range_15; // [rsp+F0h] [rbp-1B0h]
  const proto::ReliquaryMainPropGuaranteeDataBin *main_prop_guarantee_data_bin; // [rsp+F8h] [rbp-1A8h]
  ReliquaryMainPropGuaranteeData *main_prop_guarantee_data; // [rsp+100h] [rbp-1A0h]
  const proto::ActivityOutputControlRecordBin *activity_output_control_record_bin; // [rsp+108h] [rbp-198h]
  const proto::ReliquarySuitBin *reliquary_suit_bin; // [rsp+110h] [rbp-190h]
  const google::protobuf::RepeatedField<unsigned int> *__for_range_12; // [rsp+118h] [rbp-188h]
  google::protobuf::RepeatedField<unsigned int>::const_iterator __for_end_3; // [rsp+120h] [rbp-180h]
  const unsigned int *reliquary_type; // [rsp+128h] [rbp-178h]
  const proto::ReliquaryLevelupNumRecordBin *levelup_num_record_bin; // [rsp+130h] [rbp-170h]
  std::unordered_map<unsigned int,unsigned int> *levelup_num_map; // [rsp+138h] [rbp-168h]
  const google::protobuf::RepeatedPtrField<proto::Uint32PairBin> *__for_range_10; // [rsp+140h] [rbp-160h]
  const proto::Uint32PairBin *pair_bin_2; // [rsp+148h] [rbp-158h]
  const proto::Uint32PairBin *pair_bin_1; // [rsp+150h] [rbp-150h]
  const proto::Uint32PairBin *pair_bin_0; // [rsp+158h] [rbp-148h]
  const proto::BonusRecordBin *bonus_record_bin; // [rsp+160h] [rbp-140h]
  const google::protobuf::RepeatedPtrField<proto::SingleBonusRecordBin> *__for_range_6; // [rsp+168h] [rbp-138h]
  const proto::SingleBonusRecordBin *single_record_bin; // [rsp+170h] [rbp-130h]
  const proto::ShopGoodsOutputRecordBin *shop_goods_output_record_bin; // [rsp+178h] [rbp-128h]
  const unsigned int *p_output_control_type; // [rsp+180h] [rbp-120h]
  const proto::Uint32PairBin *pair_bin; // [rsp+188h] [rbp-118h]
  const proto::ItemLimitRecordBin *item_limit_record_bin; // [rsp+190h] [rbp-110h]
  google::protobuf::RepeatedPtrField<proto::ItemLimitRecordBin>::const_iterator __for_end_1; // [rsp+198h] [rbp-108h] BYREF
  unsigned int cd_group_id; // [rsp+1A0h] [rbp-100h] BYREF
  __int64 v146; // [rsp+1A8h] [rbp-F8h]
  google::protobuf::Map<unsigned int,long unsigned int>::const_iterator __for_begin_0; // [rsp+1B0h] [rbp-F0h] BYREF
  google::protobuf::Map<unsigned int,long unsigned int>::const_iterator __for_end_0; // [rsp+1D0h] [rbp-D0h] BYREF
  common::milog::MiLogStream v149; // [rsp+1F0h] [rbp-B0h] BYREF
  char v150[144]; // [rsp+210h] [rbp-90h] BYREF

  v2 = (unsigned __int64)v150;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(96LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "2 48 4 15 source_type:389 64 4 19 history_item_id:298";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::fromBin;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234556943;
  v4[536862722] = -202116348;
  proto_comp = proto::PlayerDataBin::item_bin(player_data_bin);
  if ( proto::PlayerItemCompBin::has_pack_store(proto_comp)
    && (player_data_bin = (const proto::PlayerDataBin *)proto::PlayerItemCompBin::pack_store(proto_comp),
        PackItemStore::fromBin(&this->pack_store_, (const proto::ItemStoreBin *)player_data_bin)) )
  {
    common::milog::MiLogStream::create(
      &v149,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "fromBin",
      294);
    common::milog::MiLogStream::operator()(&v149, "fromBin for pack failed");
    common::milog::MiLogStream::~MiLogStream(&v149);
    result = -1;
  }
  else
  {
    __for_range = proto::PlayerItemCompBin::history_item_list(proto_comp);
    __for_begin = google::protobuf::RepeatedField<unsigned int>::begin(__for_range);
    __for_end = google::protobuf::RepeatedField<unsigned int>::end(__for_range);
    while ( __for_begin != __for_end )
    {
      if ( *(_BYTE *)(((unsigned __int64)__for_begin >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)__for_begin & 7) + 3) >= *(_BYTE *)(((unsigned __int64)__for_begin >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(__for_begin);
      }
      *(_DWORD *)(v2 + 64) = *__for_begin;
      player_data_bin = (const proto::PlayerDataBin *)(v2 + 64);
      std::set<unsigned int>::insert(&this->history_item_set_, (const std::set<unsigned int>::value_type *)(v2 + 64));
      ++__for_begin;
    }
    v7 = proto::PlayerItemCompBin::hcoin(proto_comp);
    v8 = *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000);
    LOBYTE(player_data_bin) = v8 != 0;
    v9 = (v8 != 0) & (unsigned __int8)((char)((((_BYTE)this - 28) & 7) + 3) >= v8);
    if ( (_BYTE)v9 )
      __asan_report_store4(&this->hcoin_, player_data_bin, v9);
    this->hcoin_ = v7;
    v10 = proto::PlayerItemCompBin::scoin(proto_comp);
    v11 = *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000);
    if ( v11 != 0 && v11 <= 3 )
    {
      LOBYTE(player_data_bin) = v11 != 0;
      __asan_report_store4(&this->scoin_, player_data_bin, v10);
    }
    this->scoin_ = v10;
    v12 = proto::PlayerItemCompBin::mcoin(proto_comp);
    v13 = *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000);
    LOBYTE(player_data_bin) = v13 != 0;
    v14 = (v13 != 0) & (unsigned __int8)((char)((((_BYTE)this - 36) & 7) + 3) >= v13);
    if ( (_BYTE)v14 )
      __asan_report_store4(&this->mcoin_, player_data_bin, v14);
    this->mcoin_ = v12;
    v15 = proto::PlayerItemCompBin::psn_mcoin(proto_comp);
    v16 = *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000);
    if ( v16 != 0 && v16 <= 3 )
    {
      LOBYTE(player_data_bin) = v16 != 0;
      __asan_report_store4(&this->psn_mcoin_, player_data_bin, v15);
    }
    this->psn_mcoin_ = v15;
    v17 = proto::PlayerItemCompBin::home_coin(proto_comp);
    v18 = *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000);
    LOBYTE(player_data_bin) = v18 != 0;
    v19 = (v18 != 0) & (unsigned __int8)((char)((((_BYTE)this - 20) & 7) + 3) >= v18);
    if ( (_BYTE)v19 )
      __asan_report_store4(&this->home_coin_, player_data_bin, v19);
    this->home_coin_ = v17;
    v20 = proto::PlayerItemCompBin::wait_sub_mcoin(proto_comp);
    v21 = *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000);
    LOBYTE(player_data_bin) = v21 != 0;
    v22 = (v21 != 0) & (unsigned __int8)((char)((((_BYTE)this - 4) & 7) + 3) >= v21);
    if ( (_BYTE)v22 )
      __asan_report_store4(&this->wait_sub_mcoin_, player_data_bin, v22);
    this->wait_sub_mcoin_ = v20;
    v23 = proto::PlayerItemCompBin::wait_sub_psn_mcoin(proto_comp);
    v24 = *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000);
    if ( v24 != 0 && v24 <= 3 )
    {
      LOBYTE(player_data_bin) = v24 != 0;
      __asan_report_store4(&this->wait_sub_psn_mcoin_, player_data_bin, v23);
    }
    this->wait_sub_psn_mcoin_ = v23;
    v25 = proto::PlayerItemCompBin::wait_sub_hcoin(proto_comp);
    v26 = *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000);
    LOBYTE(player_data_bin) = v26 != 0;
    v27 = (v26 != 0) & (unsigned __int8)((char)((((_BYTE)this - 12) & 7) + 3) >= v26);
    if ( (_BYTE)v27 )
      __asan_report_store4(&this->wait_sub_hcoin_, player_data_bin, v27);
    this->wait_sub_hcoin_ = v25;
    v28 = proto::PlayerItemCompBin::wait_sub_scoin(proto_comp);
    v29 = *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000);
    if ( v29 != 0 && v29 <= 3 )
    {
      LOBYTE(player_data_bin) = v29 != 0;
      __asan_report_store4(&this->wait_sub_scoin_, player_data_bin, v28);
    }
    this->wait_sub_scoin_ = v28;
    v30 = proto::PlayerItemCompBin::wait_sub_home_coin(proto_comp);
    v31 = *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000);
    LOBYTE(player_data_bin) = v31 != 0;
    v32 = (v31 != 0) & (unsigned __int8)((char)((((_BYTE)this + 4) & 7) + 3) >= v31);
    if ( (_BYTE)v32 )
      __asan_report_store4(&this->wait_sub_home_coin_, player_data_bin, v32);
    this->wait_sub_home_coin_ = v30;
    LOBYTE(v33) = proto::PlayerItemCompBin::is_psn_version_modify(proto_comp);
    v34 = v33;
    v35 = *(_BYTE *)(((unsigned __int64)&this->is_psn_version_modify_ >> 3) + 0x7FFF8000);
    if ( v35 < 0 )
    {
      LOBYTE(player_data_bin) = v35 != 0;
      __asan_report_store1(&this->is_psn_version_modify_, player_data_bin, v34);
    }
    this->is_psn_version_modify_ = v34;
    if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->hcoin_);
    }
    if ( !this->hcoin_ )
      goto LABEL_44;
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->wait_sub_hcoin_);
    }
    if ( this->wait_sub_hcoin_ )
    {
      common::milog::MiLogStream::create(
        &v149,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "fromBin",
        318);
      common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
        &v149,
        (const char (*)[34])"hcoin_ > 0 && wait_sub_hcoin_ > 0");
      common::milog::MiLogStream::~MiLogStream(&v149);
      result = -1;
    }
    else
    {
LABEL_44:
      if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&this->scoin_);
      }
      if ( !this->scoin_ )
        goto LABEL_51;
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&this->wait_sub_scoin_);
      }
      if ( this->wait_sub_scoin_ )
      {
        common::milog::MiLogStream::create(
          &v149,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "fromBin",
          323);
        common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
          &v149,
          (const char (*)[34])"scoin_ > 0 && wait_sub_scoin_ > 0");
        common::milog::MiLogStream::~MiLogStream(&v149);
        result = -1;
      }
      else
      {
LABEL_51:
        if ( *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)this - 36) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(&this->mcoin_);
        }
        if ( !this->mcoin_ )
          goto LABEL_58;
        if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)this - 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3)
                                                             + 0x7FFF8000) )
        {
          __asan_report_load4(&this->wait_sub_mcoin_);
        }
        if ( this->wait_sub_mcoin_ )
        {
          common::milog::MiLogStream::create(
            &v149,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "fromBin",
            328);
          common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
            &v149,
            (const char (*)[34])"mcoin_ > 0 && wait_sub_mcoin_ > 0");
          common::milog::MiLogStream::~MiLogStream(&v149);
          result = -1;
        }
        else
        {
LABEL_58:
          if ( *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(&this->psn_mcoin_);
          }
          if ( !this->psn_mcoin_ )
            goto LABEL_65;
          if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(&this->wait_sub_psn_mcoin_);
          }
          if ( this->wait_sub_psn_mcoin_ )
          {
            common::milog::MiLogStream::create(
              &v149,
              &common::milog::MiLogDefault::default_log_obj_,
              4u,
              "./src/player/item/player_item_comp.cpp",
              "fromBin",
              333);
            common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
              &v149,
              (const char (*)[42])"psn_mcoin_ > 0 && wait_sub_psn_mcoin_ > 0");
            common::milog::MiLogStream::~MiLogStream(&v149);
            result = -1;
          }
          else
          {
LABEL_65:
            v36 = (((_BYTE)this - 20) & 7u) + 3;
            if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3)
                                                                  + 0x7FFF8000) )
            {
              __asan_report_load4(&this->home_coin_);
            }
            if ( !this->home_coin_ )
              goto LABEL_72;
            v36 = (((_BYTE)this + 4) & 7u) + 3;
            if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3)
                                                                 + 0x7FFF8000) )
            {
              __asan_report_load4(&this->wait_sub_home_coin_);
            }
            if ( this->wait_sub_home_coin_ )
            {
              common::milog::MiLogStream::create(
                &v149,
                &common::milog::MiLogDefault::default_log_obj_,
                4u,
                "./src/player/item/player_item_comp.cpp",
                "fromBin",
                338);
              common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                &v149,
                (const char (*)[42])"home_coin_ > 0 && wait_sub_home_coin_ > 0");
              common::milog::MiLogStream::~MiLogStream(&v149);
              result = -1;
            }
            else
            {
LABEL_72:
              v37 = proto::PlayerItemCompBin::legendary_key(proto_comp);
              v38 = *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000);
              if ( v38 != 0 && v38 <= 3 )
              {
                LOBYTE(v36) = v38 != 0;
                __asan_report_store4(&this->legendary_key_, v36, v37);
              }
              this->legendary_key_ = v37;
              __for_range_0 = proto::PlayerItemCompBin::item_cd_map(proto_comp);
              google::protobuf::Map<unsigned int,unsigned long>::begin(&__for_begin_0, __for_range_0);
              google::protobuf::Map<unsigned int,unsigned long>::end(&__for_end_0, __for_range_0);
              while ( google::protobuf::operator!=(&__for_begin_0, &__for_end_0) )
              {
                v39 = google::protobuf::Map<unsigned int,unsigned long>::const_iterator::operator*(&__for_begin_0);
                google::protobuf::MapPair<unsigned int,unsigned long>::MapPair(
                  (google::protobuf::MapPair<unsigned int,long unsigned int> *const)&cd_group_id,
                  v39);
                v40 = v146;
                v41 = (unsigned __int64)std::map<unsigned int,unsigned long>::operator[](
                                          &this->item_cd_map_,
                                          &cd_group_id);
                if ( *(_BYTE *)((v41 >> 3) + 0x7FFF8000) )
                  v41 = __asan_report_store8(v41, &cd_group_id);
                *(_QWORD *)v41 = v40;
                google::protobuf::MapPair<unsigned int,unsigned long>::~MapPair((google::protobuf::MapPair<unsigned int,long unsigned int> *const)&cd_group_id);
                google::protobuf::Map<unsigned int,unsigned long>::const_iterator::operator++(&__for_begin_0);
              }
              if ( std::operator==<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
              {
                common::milog::MiLogStream::create(
                  &v149,
                  &common::milog::MiLogDefault::default_log_obj_,
                  4u,
                  "./src/player/item/player_item_comp.cpp",
                  "fromBin",
                  351);
                common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(
                  &v149,
                  (const char (*)[18])"resin ptr is null");
                common::milog::MiLogStream::~MiLogStream(&v149);
                result = -1;
              }
              else
              {
                v42 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
                v43 = proto::PlayerItemCompBin::resin_record(proto_comp);
                AutoRecoverItemProxy::fromBin(v42, v43);
                __for_range_1 = proto::PlayerItemCompBin::item_limit_record_list(proto_comp);
                __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::ItemLimitRecordBin>::begin(__for_range_1).it_;
                __for_end_1.it_ = google::protobuf::RepeatedPtrField<proto::ItemLimitRecordBin>::end(__for_range_1).it_;
                while ( google::protobuf::internal::RepeatedPtrIterator<proto::ItemLimitRecordBin const>::operator!=(
                          (const google::protobuf::internal::RepeatedPtrIterator<const proto::ItemLimitRecordBin> *const)&__for_begin_3,
                          &__for_end_1) )
                {
                  item_limit_record_bin = google::protobuf::internal::RepeatedPtrIterator<proto::ItemLimitRecordBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::ItemLimitRecordBin> *const)&__for_begin_3);
                  v44 = proto::ItemLimitRecordBin::item_limit_type(item_limit_record_bin);
                  if ( !data::isValidItemLimitType(v44) )
                  {
                    common::milog::MiLogStream::create(
                      &v149,
                      &common::milog::MiLogDefault::default_log_obj_,
                      3u,
                      "./src/player/item/player_item_comp.cpp",
                      "fromBin",
                      360);
                    v45 = common::milog::MiLogStream::operator<<<char [23],(char *[23])0>(
                            &v149,
                            (const char (*)[23])"invalid ItemLimitType:");
                    *(_DWORD *)(v2 + 64) = proto::ItemLimitRecordBin::item_limit_type(item_limit_record_bin);
                    v46 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                            v45,
                            (const unsigned int *)(v2 + 64));
                    v47 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(
                            v46,
                            (const char (*)[9])" player:");
                    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                      __asan_report_load8();
                    operator<<(v47, this->player_);
                    common::milog::MiLogStream::~MiLogStream(&v149);
                  }
                  else
                  {
                    *(_DWORD *)(v2 + 64) = proto::ItemLimitRecordBin::item_limit_type(item_limit_record_bin);
                    v48 = std::unordered_map<data::ItemLimitType,ItemLimitRecord>::operator[](
                            &this->item_limit_record_map_,
                            (std::unordered_map<data::ItemLimitType,ItemLimitRecord>::key_type *)(v2 + 64));
                    ItemLimitRecord::fromBin<proto::ItemLimitRecordBin>(v48, item_limit_record_bin);
                  }
                  google::protobuf::internal::RepeatedPtrIterator<proto::ItemLimitRecordBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::ItemLimitRecordBin> *const)&__for_begin_3);
                }
                __for_range_2 = proto::PlayerItemCompBin::item_total_obtain_count_list(proto_comp);
                __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::begin(__for_range_2).it_;
                __for_end_1.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::end(__for_range_2).it_;
                while ( google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator!=(
                          (const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3,
                          (const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin>::iterator *)&__for_end_1) )
                {
                  pair_bin = google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3);
                  v49 = proto::Uint32PairBin::value(pair_bin);
                  *(_DWORD *)(v2 + 64) = proto::Uint32PairBin::key(pair_bin);
                  v50 = (char *)(v2 + 64);
                  v51 = std::unordered_map<unsigned int,unsigned int>::operator[](
                          &this->item_total_obtain_count_map_,
                          (std::unordered_map<unsigned int,unsigned int>::key_type *)(v2 + 64));
                  v52 = v51;
                  v53 = *(_BYTE *)(((unsigned __int64)v51 >> 3) + 0x7FFF8000);
                  if ( v53 != 0 && (char)(((unsigned __int8)v51 & 7) + 3) >= v53 )
                  {
                    LOBYTE(v50) = v53 != 0;
                    __asan_report_store4(v51, v50, v51);
                  }
                  *v52 = v49;
                  google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3);
                }
                v54 = proto::PlayerItemCompBin::material_delete_return_record(proto_comp);
                if ( MaterialDeleteReturnRecord::fromBin(&this->material_delete_return_record_, v54) )
                {
                  common::milog::MiLogStream::create(
                    &v149,
                    &common::milog::MiLogDefault::default_log_obj_,
                    4u,
                    "./src/player/item/player_item_comp.cpp",
                    "fromBin",
                    373);
                  v55 = common::milog::MiLogStream::operator<<<char [55],(char *[55])0>(
                          &v149,
                          (const char (*)[55])"material_delete_return_record fromBin failed. player_:");
                  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                    __asan_report_load8();
                  operator<<(v55, this->player_);
                  common::milog::MiLogStream::~MiLogStream(&v149);
                  result = -1;
                }
                else
                {
                  __for_range_3 = proto::PlayerItemCompBin::output_control_record_map(proto_comp);
                  google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::begin(
                    (google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::const_iterator *)&__for_begin_0,
                    __for_range_3);
                  google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::end(
                    (google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::const_iterator *)&__for_end_0,
                    __for_range_3);
                  while ( google::protobuf::operator!=(
                            (const google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::const_iterator *)&__for_begin_0,
                            (const google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::const_iterator *)&__for_end_0) )
                  {
                    p_output_control_type = (const unsigned int *)google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::const_iterator::operator*((const google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::const_iterator *const)&__for_begin_0);
                    p_output_control_record_map = &this->output_control_record_map_;
                    if ( *(_BYTE *)(((unsigned __int64)p_output_control_type >> 3) + 0x7FFF8000) != 0
                      && *(_BYTE *)(((unsigned __int64)p_output_control_type >> 3) + 0x7FFF8000) <= 3 )
                    {
                      __asan_report_load4(p_output_control_type);
                    }
                    *(_DWORD *)(v2 + 64) = *p_output_control_type;
                    v57 = std::map<data::OutputControlType,OutputControlRecord>::operator[](
                            p_output_control_record_map,
                            (std::map<data::OutputControlType,OutputControlRecord>::key_type *)(v2 + 64));
                    OutputControlRecord::fromBin(
                      v57,
                      (const proto::OutputControlRecordBin *)(p_output_control_type + 2));
                    google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::const_iterator::operator++((google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::const_iterator *const)&__for_begin_0);
                  }
                  v58 = proto::PlayerItemCompBin::shop_output_record(proto_comp);
                  __for_range_4 = proto::ShopOutputRecordBin::shop_goods_output_record_list(v58);
                  __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::ShopGoodsOutputRecordBin>::begin(__for_range_4).it_;
                  __for_end_1.it_ = google::protobuf::RepeatedPtrField<proto::ShopGoodsOutputRecordBin>::end(__for_range_4).it_;
                  while ( google::protobuf::internal::RepeatedPtrIterator<proto::ShopGoodsOutputRecordBin const>::operator!=(
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::ShopGoodsOutputRecordBin> *const)&__for_begin_3,
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::ShopGoodsOutputRecordBin>::iterator *)&__for_end_1) )
                  {
                    shop_goods_output_record_bin = google::protobuf::internal::RepeatedPtrIterator<proto::ShopGoodsOutputRecordBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::ShopGoodsOutputRecordBin> *const)&__for_begin_3);
                    *(_DWORD *)(v2 + 64) = proto::ShopGoodsOutputRecordBin::goods_id(shop_goods_output_record_bin);
                    v59 = std::unordered_map<unsigned int,ShopGoodsOutputRecord>::operator[](
                            &this->shop_goods_output_record_map_,
                            (std::unordered_map<unsigned int,ShopGoodsOutputRecord>::key_type *)(v2 + 64));
                    ShopGoodsOutputRecord::fromBin(v59, shop_goods_output_record_bin);
                    google::protobuf::internal::RepeatedPtrIterator<proto::ShopGoodsOutputRecordBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::ShopGoodsOutputRecordBin> *const)&__for_begin_3);
                  }
                  __for_range_5 = proto::PlayerItemCompBin::bonus_record_list(proto_comp);
                  __for_begin_2.it_ = google::protobuf::RepeatedPtrField<proto::BonusRecordBin>::begin(__for_range_5).it_;
                  __for_end_2.it_ = google::protobuf::RepeatedPtrField<proto::BonusRecordBin>::end(__for_range_5).it_;
                  while ( google::protobuf::internal::RepeatedPtrIterator<proto::BonusRecordBin const>::operator!=(
                            &__for_begin_2,
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::BonusRecordBin>::iterator *)&__for_end_2) )
                  {
                    bonus_record_bin = google::protobuf::internal::RepeatedPtrIterator<proto::BonusRecordBin const>::operator*(&__for_begin_2);
                    *(_DWORD *)(v2 + 48) = proto::BonusRecordBin::bonus_source_type(bonus_record_bin);
                    __for_range_6 = proto::BonusRecordBin::single_bonus_record_list(bonus_record_bin);
                    __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::SingleBonusRecordBin>::begin(__for_range_6).it_;
                    __for_end_1.it_ = google::protobuf::RepeatedPtrField<proto::SingleBonusRecordBin>::end(__for_range_6).it_;
                    while ( google::protobuf::internal::RepeatedPtrIterator<proto::SingleBonusRecordBin const>::operator!=(
                              (const google::protobuf::internal::RepeatedPtrIterator<const proto::SingleBonusRecordBin> *const)&__for_begin_3,
                              (const google::protobuf::internal::RepeatedPtrIterator<const proto::SingleBonusRecordBin>::iterator *)&__for_end_1) )
                    {
                      single_record_bin = google::protobuf::internal::RepeatedPtrIterator<proto::SingleBonusRecordBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::SingleBonusRecordBin> *const)&__for_begin_3);
                      v60 = std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::operator[](
                              &this->bonus_record_map_,
                              (const std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::key_type *)(v2 + 48));
                      *(_DWORD *)(v2 + 64) = proto::SingleBonusRecordBin::config_id(single_record_bin);
                      v61 = std::unordered_map<unsigned int,SingleBonusRecord>::operator[](
                              v60,
                              (std::unordered_map<unsigned int,SingleBonusRecord>::key_type *)(v2 + 64));
                      SingleBonusRecord::fromBin(v61, single_record_bin);
                      google::protobuf::internal::RepeatedPtrIterator<proto::SingleBonusRecordBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::SingleBonusRecordBin> *const)&__for_begin_3);
                    }
                    google::protobuf::internal::RepeatedPtrIterator<proto::BonusRecordBin const>::operator++(&__for_begin_2);
                  }
                  v62 = proto::PlayerItemCompBin::equip_levelup_record_bin(proto_comp);
                  __for_range_7 = proto::EquipLevelupRecordBin::weapon_levelup_num_list(v62);
                  __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::begin(__for_range_7).it_;
                  __for_end_1.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::end(__for_range_7).it_;
                  while ( google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator!=(
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3,
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin>::iterator *)&__for_end_1) )
                  {
                    pair_bin_0 = google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3);
                    v63 = proto::Uint32PairBin::value(pair_bin_0);
                    *(_DWORD *)(v2 + 64) = proto::Uint32PairBin::key(pair_bin_0);
                    v64 = (char *)(v2 + 64);
                    v65 = std::unordered_map<unsigned int,unsigned int>::operator[](
                            &this->weapon_levelup_num_map_,
                            (std::unordered_map<unsigned int,unsigned int>::key_type *)(v2 + 64));
                    v66 = v65;
                    v67 = *(_BYTE *)(((unsigned __int64)v65 >> 3) + 0x7FFF8000);
                    if ( v67 != 0 && (char)(((unsigned __int8)v65 & 7) + 3) >= v67 )
                    {
                      LOBYTE(v64) = v67 != 0;
                      __asan_report_store4(v65, v64, v65);
                    }
                    *v66 = v63;
                    google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3);
                  }
                  v68 = proto::PlayerItemCompBin::equip_levelup_record_bin(proto_comp);
                  __for_range_8 = proto::EquipLevelupRecordBin::weapon_promote_levelup_num_list(v68);
                  __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::begin(__for_range_8).it_;
                  __for_end_1.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::end(__for_range_8).it_;
                  while ( google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator!=(
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3,
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin>::iterator *)&__for_end_1) )
                  {
                    pair_bin_1 = google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3);
                    v69 = proto::Uint32PairBin::value(pair_bin_1);
                    *(_DWORD *)(v2 + 64) = proto::Uint32PairBin::key(pair_bin_1);
                    v70 = (char *)(v2 + 64);
                    v71 = std::unordered_map<unsigned int,unsigned int>::operator[](
                            &this->weapon_promote_levelup_num_map_,
                            (std::unordered_map<unsigned int,unsigned int>::key_type *)(v2 + 64));
                    v72 = v71;
                    v73 = *(_BYTE *)(((unsigned __int64)v71 >> 3) + 0x7FFF8000);
                    if ( v73 != 0 && (char)(((unsigned __int8)v71 & 7) + 3) >= v73 )
                    {
                      LOBYTE(v70) = v73 != 0;
                      __asan_report_store4(v71, v70, v71);
                    }
                    *v72 = v69;
                    google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3);
                  }
                  v74 = proto::PlayerItemCompBin::equip_levelup_record_bin(proto_comp);
                  __for_range_9 = proto::EquipLevelupRecordBin::rank_reliquary_levelup_list(v74);
                  __for_begin_2.it_ = google::protobuf::RepeatedPtrField<proto::ReliquaryLevelupNumRecordBin>::begin(__for_range_9).it_;
                  __for_end_2.it_ = google::protobuf::RepeatedPtrField<proto::ReliquaryLevelupNumRecordBin>::end(__for_range_9).it_;
                  while ( google::protobuf::internal::RepeatedPtrIterator<proto::ReliquaryLevelupNumRecordBin const>::operator!=(
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquaryLevelupNumRecordBin> *const)&__for_begin_2,
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquaryLevelupNumRecordBin>::iterator *)&__for_end_2) )
                  {
                    levelup_num_record_bin = google::protobuf::internal::RepeatedPtrIterator<proto::ReliquaryLevelupNumRecordBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquaryLevelupNumRecordBin> *const)&__for_begin_2);
                    *(_DWORD *)(v2 + 48) = proto::ReliquaryLevelupNumRecordBin::rank_level(levelup_num_record_bin);
                    levelup_num_map = std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::operator[](
                                        &this->reliquary_levelup_num_map_,
                                        (const std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::key_type *)(v2 + 48));
                    __for_range_10 = proto::ReliquaryLevelupNumRecordBin::reliquary_levelup_num_list(levelup_num_record_bin);
                    __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::begin(__for_range_10).it_;
                    __for_end_1.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::end(__for_range_10).it_;
                    while ( google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator!=(
                              (const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3,
                              (const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin>::iterator *)&__for_end_1) )
                    {
                      pair_bin_2 = google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3);
                      v75 = proto::Uint32PairBin::value(pair_bin_2);
                      *(_DWORD *)(v2 + 64) = proto::Uint32PairBin::key(pair_bin_2);
                      v76 = (char *)(v2 + 64);
                      v77 = std::unordered_map<unsigned int,unsigned int>::operator[](
                              levelup_num_map,
                              (std::unordered_map<unsigned int,unsigned int>::key_type *)(v2 + 64));
                      v78 = v77;
                      v79 = *(_BYTE *)(((unsigned __int64)v77 >> 3) + 0x7FFF8000);
                      if ( v79 != 0 && (char)(((unsigned __int8)v77 & 7) + 3) >= v79 )
                      {
                        LOBYTE(v76) = v79 != 0;
                        __asan_report_store4(v77, v76, v77);
                      }
                      *v78 = v75;
                      google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3);
                    }
                    google::protobuf::internal::RepeatedPtrIterator<proto::ReliquaryLevelupNumRecordBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquaryLevelupNumRecordBin> *const)&__for_begin_2);
                  }
                  __for_range_11 = proto::PlayerItemCompBin::reliquary_suit_list(proto_comp);
                  __for_end_2.it_ = google::protobuf::RepeatedPtrField<proto::ReliquarySuitBin>::begin(__for_range_11).it_;
                  __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::ReliquarySuitBin>::end(__for_range_11).it_;
                  while ( google::protobuf::internal::RepeatedPtrIterator<proto::ReliquarySuitBin const>::operator!=(
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquarySuitBin> *const)&__for_end_2,
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquarySuitBin>::iterator *)&__for_begin_3) )
                  {
                    reliquary_suit_bin = google::protobuf::internal::RepeatedPtrIterator<proto::ReliquarySuitBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquarySuitBin> *const)&__for_end_2);
                    __for_range_12 = proto::ReliquarySuitBin::reliquary_type_list(reliquary_suit_bin);
                    __for_begin_1 = google::protobuf::RepeatedField<unsigned int>::begin(__for_range_12);
                    __for_end_3 = google::protobuf::RepeatedField<unsigned int>::end(__for_range_12);
                    while ( __for_begin_1 != __for_end_3 )
                    {
                      reliquary_type = __for_begin_1;
                      *(_DWORD *)(v2 + 48) = proto::ReliquarySuitBin::level(reliquary_suit_bin);
                      __x = proto::ReliquarySuitBin::reliquary_suit_id(reliquary_suit_bin);
                      __for_end_1.it_ = (void *const *)std::make_pair<unsigned int,unsigned int>(
                                                         &__x,
                                                         (unsigned int *)(v2 + 48));
                      v80 = std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int>>,std::equal_to<std::pair<unsigned int,unsigned int>>,std::allocator<std::pair<std::pair<unsigned int,unsigned int> const,std::set<data::EquipType>>>>::operator[](
                              &this->reliquary_set_map_,
                              (std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int> >,std::equal_to<std::pair<unsigned int,unsigned int> >,std::allocator<std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> > > >::key_type *)&__for_end_1);
                      if ( *(_BYTE *)(((unsigned __int64)reliquary_type >> 3) + 0x7FFF8000) != 0
                        && (char)(((unsigned __int8)reliquary_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reliquary_type >> 3)
                                                                                         + 0x7FFF8000) )
                      {
                        __asan_report_load4(reliquary_type);
                      }
                      *(_DWORD *)(v2 + 64) = *reliquary_type;
                      std::set<data::EquipType>::insert(v80, (std::set<data::EquipType>::value_type *)(v2 + 64));
                      ++__for_begin_1;
                    }
                    google::protobuf::internal::RepeatedPtrIterator<proto::ReliquarySuitBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquarySuitBin> *const)&__for_end_2);
                  }
                  __for_range_13 = proto::PlayerItemCompBin::activity_output_control_record_list(proto_comp);
                  __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::ActivityOutputControlRecordBin>::begin(__for_range_13).it_;
                  __for_end_1.it_ = google::protobuf::RepeatedPtrField<proto::ActivityOutputControlRecordBin>::end(__for_range_13).it_;
                  while ( google::protobuf::internal::RepeatedPtrIterator<proto::ActivityOutputControlRecordBin const>::operator!=(
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::ActivityOutputControlRecordBin> *const)&__for_begin_3,
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::ActivityOutputControlRecordBin>::iterator *)&__for_end_1) )
                  {
                    activity_output_control_record_bin = google::protobuf::internal::RepeatedPtrIterator<proto::ActivityOutputControlRecordBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::ActivityOutputControlRecordBin> *const)&__for_begin_3);
                    *(_DWORD *)(v2 + 64) = proto::ActivityOutputControlRecordBin::activity_type(activity_output_control_record_bin);
                    v81 = std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::operator[](
                            &this->activity_output_control_record_map_,
                            (const std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::key_type *)(v2 + 64));
                    ActivityOutputControlRecord::fromBin(v81, activity_output_control_record_bin);
                    google::protobuf::internal::RepeatedPtrIterator<proto::ActivityOutputControlRecordBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::ActivityOutputControlRecordBin> *const)&__for_begin_3);
                  }
                  __for_range_14 = proto::PlayerItemCompBin::reliquary_guarantee_depot_list(proto_comp);
                  __for_begin_2.it_ = google::protobuf::RepeatedPtrField<proto::ReliquaryGuaranteeDepotBin>::begin(__for_range_14).it_;
                  __for_end_2.it_ = google::protobuf::RepeatedPtrField<proto::ReliquaryGuaranteeDepotBin>::end(__for_range_14).it_;
                  while ( google::protobuf::internal::RepeatedPtrIterator<proto::ReliquaryGuaranteeDepotBin const>::operator!=(
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquaryGuaranteeDepotBin> *const)&__for_begin_2,
                            &__for_end_2) )
                  {
                    reliquary_guarantee_depot_bin = google::protobuf::internal::RepeatedPtrIterator<proto::ReliquaryGuaranteeDepotBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquaryGuaranteeDepotBin> *const)&__for_begin_2);
                    *(_DWORD *)(v2 + 64) = proto::ReliquaryGuaranteeDepotBin::guarantee_depot_id(reliquary_guarantee_depot_bin);
                    v82 = (char *)(v2 + 64);
                    depot = std::map<unsigned int,ReliquaryGuaranteeDepot>::operator[](
                              &this->reliquary_guarantee_depot_map_,
                              (std::map<unsigned int,ReliquaryGuaranteeDepot>::key_type *)(v2 + 64));
                    v83 = proto::ReliquaryGuaranteeDepotBin::guarantee_depot_id(reliquary_guarantee_depot_bin);
                    v84 = *(_BYTE *)(((unsigned __int64)depot >> 3) + 0x7FFF8000);
                    if ( v84 != 0 && v84 <= 3 )
                    {
                      LOBYTE(v82) = v84 != 0;
                      __asan_report_store4(depot, v82, v83);
                    }
                    depot->guarantee_depot_id = v83;
                    __for_range_15 = proto::ReliquaryGuaranteeDepotBin::main_prop_guarantee_data_list(reliquary_guarantee_depot_bin);
                    __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::ReliquaryMainPropGuaranteeDataBin>::begin(__for_range_15).it_;
                    __for_end_1.it_ = google::protobuf::RepeatedPtrField<proto::ReliquaryMainPropGuaranteeDataBin>::end(__for_range_15).it_;
                    while ( google::protobuf::internal::RepeatedPtrIterator<proto::ReliquaryMainPropGuaranteeDataBin const>::operator!=(
                              &__for_begin_3,
                              (const google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquaryMainPropGuaranteeDataBin>::iterator *)&__for_end_1) )
                    {
                      main_prop_guarantee_data_bin = google::protobuf::internal::RepeatedPtrIterator<proto::ReliquaryMainPropGuaranteeDataBin const>::operator*(&__for_begin_3);
                      p_main_prop_guarantee_data_map = &depot->main_prop_guarantee_data_map;
                      *(_DWORD *)(v2 + 64) = proto::ReliquaryMainPropGuaranteeDataBin::main_prop_id(main_prop_guarantee_data_bin);
                      v88 = (char *)(v2 + 64);
                      main_prop_guarantee_data = std::map<unsigned int,ReliquaryMainPropGuaranteeData>::operator[](
                                                   p_main_prop_guarantee_data_map,
                                                   (std::map<unsigned int,ReliquaryMainPropGuaranteeData>::key_type *)(v2 + 64));
                      v86 = proto::ReliquaryMainPropGuaranteeDataBin::miss_count(main_prop_guarantee_data_bin);
                      v87 = *(_BYTE *)(((unsigned __int64)main_prop_guarantee_data >> 3) + 0x7FFF8000);
                      LOBYTE(v88) = v87 != 0;
                      v89 = (v87 != 0) & (unsigned __int8)((char)(((unsigned __int8)main_prop_guarantee_data & 7) + 3) >= v87);
                      if ( (_BYTE)v89 )
                        __asan_report_store4(main_prop_guarantee_data, v88, v89);
                      main_prop_guarantee_data->miss_count = v86;
                      v90 = proto::ReliquaryMainPropGuaranteeDataBin::guarantee_count(main_prop_guarantee_data_bin);
                      v91 = *(_BYTE *)(((unsigned __int64)&main_prop_guarantee_data->guarantee_count >> 3) + 0x7FFF8000);
                      LOBYTE(v88) = v91 != 0;
                      v92 = (v91 != 0) & (unsigned __int8)((char)((((_BYTE)main_prop_guarantee_data + 4) & 7) + 3) >= v91);
                      if ( (_BYTE)v92 )
                        __asan_report_store4(&main_prop_guarantee_data->guarantee_count, v88, v92);
                      main_prop_guarantee_data->guarantee_count = v90;
                      google::protobuf::internal::RepeatedPtrIterator<proto::ReliquaryMainPropGuaranteeDataBin const>::operator++(&__for_begin_3);
                    }
                    google::protobuf::internal::RepeatedPtrIterator<proto::ReliquaryGuaranteeDepotBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::ReliquaryGuaranteeDepotBin> *const)&__for_begin_2);
                  }
                  __for_range_16 = proto::PlayerItemCompBin::reliquary_filter_state_list(proto_comp);
                  __for_begin_3.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::begin(__for_range_16).it_;
                  __for_end_1.it_ = google::protobuf::RepeatedPtrField<proto::Uint32PairBin>::end(__for_range_16).it_;
                  while ( google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator!=(
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3,
                            (const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin>::iterator *)&__for_end_1) )
                  {
                    pair_bin_3 = google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator*((const google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3);
                    v93 = proto::Uint32PairBin::value(pair_bin_3);
                    *(_DWORD *)(v2 + 64) = proto::Uint32PairBin::key(pair_bin_3);
                    v94 = (char *)(v2 + 64);
                    v95 = std::unordered_map<unsigned int,unsigned int>::operator[](
                            &this->reliquary_filter_state_map_,
                            (std::unordered_map<unsigned int,unsigned int>::key_type *)(v2 + 64));
                    v96 = v95;
                    v97 = *(_BYTE *)(((unsigned __int64)v95 >> 3) + 0x7FFF8000);
                    if ( v97 != 0 && (char)(((unsigned __int8)v95 & 7) + 3) >= v97 )
                    {
                      LOBYTE(v94) = v97 != 0;
                      __asan_report_store4(v95, v94, v95);
                    }
                    *v96 = v93;
                    google::protobuf::internal::RepeatedPtrIterator<proto::Uint32PairBin const>::operator++((google::protobuf::internal::RepeatedPtrIterator<const proto::Uint32PairBin> *const)&__for_begin_3);
                  }
                  result = 0;
                }
              }
            }
          }
        }
      }
    }
  }
  if ( v150 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 453: range 0000000017CBD84E-0000000017CBD90C
int32_t __cdecl PlayerItemComp::init(PlayerItemComp *const this)
{
  common::milog::MiLogStream v2; // [rsp+10h] [rbp-30h] BYREF

  if ( ItemStore::init(&this->pack_store_) )
  {
    common::milog::MiLogStream::create(
      &v2,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "init",
      457);
    common::milog::MiLogStream::operator()(&v2, "init for pack failed");
    common::milog::MiLogStream::~MiLogStream(&v2);
    return -1;
  }
  else
  {
    PlayerItemComp::init_auto_recover_items(this);
    PlayerItemComp::removeOutdatedOutputControlRecords(this);
    return 0;
  }
};

// Line 472: range 0000000017CBD90E-0000000017CBDC37
void __cdecl PlayerItemComp::init_auto_recover_items(PlayerItemComp *const this)
{
  unsigned __int64 p_pending_que; // rbx
  __int64 v2; // rax
  _DWORD *v3; // r13
  AutoRecoverItemProxy *v4; // rax
  std::weak_ptr<PlayerItemComp> *p_this_wtr; // [rsp+10h] [rbp-E0h]
  std::weak_ptr<PlayerItemComp> v6; // [rsp+20h] [rbp-D0h] BYREF
  PlayerEventComp varC0; // [rsp+30h] [rbp-C0h] BYREF

  p_pending_que = (unsigned __int64)&varC0.event_center_.context_.pending_que_;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v2 = __asan_stack_malloc_1(96LL);
    if ( v2 )
      p_pending_que = v2;
  }
  *(_QWORD *)p_pending_que = 1102416563LL;
  *(_QWORD *)(p_pending_que + 8) = "2 32 16 12 this_ptr:482 64 16 12 this_wtr:489";
  *(_QWORD *)(p_pending_que + 16) = PlayerItemComp::init_auto_recover_items;
  v3 = (_DWORD *)(p_pending_que >> 3);
  v3[536862720] = -235802127;
  v3[536862721] = -219021312;
  v3[536862722] = -202178560;
  if ( !std::operator==<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
  {
    v4 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    AutoRecoverItemProxy::init(v4, CONST_VALUE_RESIN_PARAM, 0x2Du);
    toThisPtr<PlayerItemComp>((PlayerItemComp *)(p_pending_que + 32));
    if ( std::operator==<PlayerItemComp>(0LL, (const std::shared_ptr<PlayerItemComp> *)(p_pending_que + 32)) )
    {
      common::milog::MiLogStream::create(
        (common::milog::MiLogStream *)&varC0._M_weak_this._M_refcount,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "init_auto_recover_items",
        485);
      common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
        (common::milog::MiLogStream *const)&varC0._M_weak_this._M_refcount,
        (const char (*)[17])"toThisPtr failed");
      common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&varC0._M_weak_this._M_refcount);
    }
    else
    {
      std::weak_ptr<PlayerItemComp>::weak_ptr<PlayerItemComp,void>(
        (std::weak_ptr<PlayerItemComp> *const)(p_pending_que + 64),
        (const std::shared_ptr<PlayerItemComp> *)(p_pending_que + 32));
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      p_this_wtr = (std::weak_ptr<PlayerItemComp> *)Player::getEventComp(this->player_);
      std::weak_ptr<PlayerItemComp>::weak_ptr(&v6, (const std::weak_ptr<PlayerItemComp> *)(p_pending_que + 64));
      PlayerEventComp::registerObserver<PlayerItemComp,OpenStateChangeEvent>(
        &varC0,
        p_this_wtr,
        (void (*)(PlayerItemComp *, const OpenStateChangeEvent *))&v6);
      std::weak_ptr<Observer>::operator=(&this->open_state_observer_, (std::weak_ptr<Observer> *)&varC0);
      std::weak_ptr<Observer>::~weak_ptr((std::weak_ptr<Observer> *const)&varC0);
      std::weak_ptr<PlayerItemComp>::~weak_ptr(&v6);
      std::weak_ptr<PlayerItemComp>::~weak_ptr((std::weak_ptr<PlayerItemComp> *const)(p_pending_que + 64));
    }
    std::shared_ptr<PlayerItemComp>::~shared_ptr((std::shared_ptr<PlayerItemComp> *const)(p_pending_que + 32));
  }
  if ( &varC0.event_center_.context_.pending_que_ == (std::queue<std::variant<std::weak_ptr<Observer>,std::shared_ptr<BaseEvent> >> *)p_pending_que )
  {
    *(_QWORD *)((p_pending_que >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((p_pending_que >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)p_pending_que = 1172321806LL;
    *(_QWORD *)((p_pending_que >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((p_pending_que >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 494: range 0000000017CBDC38-0000000017CBDD26
void __cdecl PlayerItemComp::onOpenStateChange(PlayerItemComp *const this, const OpenStateChangeEvent *event)
{
  AutoRecoverItemProxy *v2; // rcx

  if ( *(_BYTE *)(((unsigned __int64)&event->key >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&event->key >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&event->key);
  }
  if ( event->key == 45 && std::operator!=<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
  {
    v2 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    if ( *(_BYTE *)(((unsigned __int64)&event->value >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)event + 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&event->value >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&event->value);
    }
    if ( AutoRecoverItemProxy::onOpenStateChange(v2, event->value) == 1 )
      PlayerItemComp::onResinChange(this);
  }
};

// Line 515: range 0000000017CBDD28-0000000017CBDE8E
int32_t __cdecl PlayerItemComp::onLogin(PlayerItemComp *const this, bool is_new_player)
{
  AutoRecoverItemProxy *v3; // rax
  uint32_t Now; // edx
  common::milog::MiLogStream v5; // [rsp+20h] [rbp-30h] BYREF

  if ( std::operator==<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
  {
    common::milog::MiLogStream::create(
      &v5,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "onLogin",
      518);
    common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v5, (const char (*)[18])"resin ptr is null");
    common::milog::MiLogStream::~MiLogStream(&v5);
    return -1;
  }
  else
  {
    v3 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    if ( AutoRecoverItemProxy::onLogin(v3, 0) )
    {
      common::milog::MiLogStream::create(
        &v5,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "onLogin",
        523);
      common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(&v5, (const char (*)[22])"resin on login failed");
      common::milog::MiLogStream::~MiLogStream(&v5);
      return -1;
    }
    else
    {
      PlayerItemComp::onResinChange(this);
      Now = common::tools::TimeUtils::getNow();
      PlayerItemComp::checkAllMaterialDelete(this, Now);
      return 0;
    }
  }
};

// Line 534: range 0000000017CBDE90-0000000017CBDFD8
int32_t __cdecl PlayerItemComp::onFirstLogin(PlayerItemComp *const this)
{
  AutoRecoverItemProxy *v2; // rax
  common::milog::MiLogStream v3; // [rsp+10h] [rbp-30h] BYREF

  if ( std::operator==<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
  {
    common::milog::MiLogStream::create(
      &v3,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "onFirstLogin",
      537);
    common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v3, (const char (*)[18])"resin ptr is null");
    common::milog::MiLogStream::~MiLogStream(&v3);
    return -1;
  }
  else
  {
    v2 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    if ( AutoRecoverItemProxy::onLogin(v2, 1) )
    {
      common::milog::MiLogStream::create(
        &v3,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "onFirstLogin",
        542);
      common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(&v3, (const char (*)[22])"resin on login failed");
      common::milog::MiLogStream::~MiLogStream(&v3);
      return -1;
    }
    else
    {
      PlayerItemComp::onResinChange(this);
      return 0;
    }
  }
};

// Line 552: range 0000000017CBDFDA-0000000017CBE06E
int32_t __cdecl PlayerItemComp::onLogout(PlayerItemComp *const this)
{
  PlayerEventComp *EventComp; // rax
  AutoRecoverItemProxy *v2; // rax

  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  EventComp = Player::getEventComp(this->player_);
  PlayerEventComp::unregisterObserver(EventComp, &this->open_state_observer_);
  if ( std::operator!=<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
  {
    v2 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    AutoRecoverItemProxy::clear(v2);
  }
  return 0;
};

// Line 563: range 0000000017CBE070-0000000017CBE0B3
void __cdecl PlayerItemComp::onDailyRefresh(PlayerItemComp *const this)
{
  AutoRecoverItemProxy *v1; // rax

  if ( std::operator!=<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
  {
    v1 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    AutoRecoverItemProxy::onDailyRefresh(v1);
  }
};

// Line 572: range 0000000017CBE0B4-0000000017CBE1C1
int32_t __cdecl PlayerItemComp::notifyAllData(PlayerItemComp *const this)
{
  Player *player; // rbx
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v3; // rax
  int32_t ret; // [rsp+1Ch] [rbp-54h]
  std::shared_ptr<Config> v5; // [rsp+20h] [rbp-50h] BYREF
  proto::ClosedItemNotify v6; // [rsp+30h] [rbp-40h] BYREF

  ret = ItemStore::notifyAllData(&this->pack_store_);
  if ( ret )
    return ret;
  PlayerItemComp::notifyAllItemCd(this);
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  player = this->player_;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v5);
  v3 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v5);
  FeatureSwitchMgr::getClosedItemNotify(&v6, &v3->feature_switch_mgr);
  Player::sendProto(player, &v6);
  proto::ClosedItemNotify::~ClosedItemNotify(&v6);
  std::shared_ptr<Config>::~shared_ptr(&v5);
  PlayerItemComp::notifyReliquaryFilterState(this);
  return 0;
};

// Line 585: range 0000000017CBE1C2-0000000017CBE512
int32_t __cdecl PlayerItemComp::notifyReliquaryFilterState(PlayerItemComp *const this)
{
  unsigned __int64 v1; // r12
  __int64 v2; // rax
  _DWORD *v3; // r13
  std::__shared_ptr_access<proto::ReliquaryFilterStateNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v4; // rax
  std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::pointer v5; // rdx
  unsigned int *p_second; // rax
  unsigned int second; // r14d
  char *v8; // rsi
  unsigned int *v9; // rax
  unsigned int *v10; // rdx
  char v11; // cl
  char *v12; // rsi
  unsigned int *v13; // rax
  _DWORD *v14; // rdx
  char v15; // cl
  Player *player; // r14
  int32_t result; // eax
  std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> __y; // [rsp+10h] [rbp-D0h] BYREF
  google::protobuf::Map<unsigned int,unsigned int> *state_map; // [rsp+18h] [rbp-C8h]
  std::shared_ptr<proto::ReliquaryFilterStateNotify> __r; // [rsp+20h] [rbp-C0h] BYREF
  char v21[176]; // [rsp+30h] [rbp-B0h] BYREF

  v1 = (unsigned __int64)v21;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v2 = __asan_stack_malloc_1(128LL);
    if ( v2 )
      v1 = v2;
  }
  *(_QWORD *)v1 = 1102416563LL;
  *(_QWORD *)(v1 + 8) = "3 48 4 7 key:588 64 8 8 iter:590 96 16 14 notify_ptr:586";
  *(_QWORD *)(v1 + 16) = PlayerItemComp::notifyReliquaryFilterState;
  v3 = (_DWORD *)(v1 >> 3);
  v3[536862720] = -235802127;
  v3[536862721] = -234556943;
  v3[536862722] = -218959360;
  v3[536862723] = -202178560;
  common::tools::perf::make_shared<proto::ReliquaryFilterStateNotify>();
  v4 = std::__shared_ptr_access<proto::ReliquaryFilterStateNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ReliquaryFilterStateNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v1 + 96));
  state_map = proto::ReliquaryFilterStateNotify::mutable_reliquary_filter_state_map(v4);
  for ( *(_DWORD *)(v1 + 48) = 1; *(_DWORD *)(v1 + 48) <= 3u; ++*(_DWORD *)(v1 + 48) )
  {
    *(std::unordered_map<unsigned int,unsigned int>::iterator *)(v1 + 64) = std::unordered_map<unsigned int,unsigned int>::find(
                                                                              &this->reliquary_filter_state_map_,
                                                                              (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v1 + 48));
    __y._M_cur = std::unordered_map<unsigned int,unsigned int>::end(&this->reliquary_filter_state_map_)._M_cur;
    if ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(
           (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)(v1 + 64),
           &__y) )
    {
      v5 = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator->((const std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)(v1 + 64));
      p_second = &v5->second;
      if ( *(_BYTE *)(((unsigned __int64)p_second >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)p_second & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_second >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(p_second);
      }
      second = v5->second;
      v8 = (char *)(v1 + 48);
      v9 = google::protobuf::Map<unsigned int,unsigned int>::operator[](
             state_map,
             (const google::protobuf::Map<unsigned int,unsigned int>::key_type *)(v1 + 48));
      v10 = v9;
      v11 = *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000);
      if ( v11 != 0 && (char)(((unsigned __int8)v9 & 7) + 3) >= v11 )
      {
        LOBYTE(v8) = v11 != 0;
        __asan_report_store4(v9, v8, v9);
      }
      *v10 = second;
    }
    else
    {
      v12 = (char *)(v1 + 48);
      v13 = google::protobuf::Map<unsigned int,unsigned int>::operator[](
              state_map,
              (const google::protobuf::Map<unsigned int,unsigned int>::key_type *)(v1 + 48));
      v14 = v13;
      v15 = *(_BYTE *)(((unsigned __int64)v13 >> 3) + 0x7FFF8000);
      if ( v15 != 0 && (char)(((unsigned __int8)v13 & 7) + 3) >= v15 )
      {
        LOBYTE(v12) = v15 != 0;
        __asan_report_store4(v13, v12, v13);
      }
      *v14 = 0;
    }
  }
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  player = this->player_;
  std::dynamic_pointer_cast<google::protobuf::Message const,proto::ReliquaryFilterStateNotify>(&__r);
  Player::sendMessage(player, (common::minet::ConstMessagePtr *)&__r, 0LL);
  std::shared_ptr<google::protobuf::Message const>::~shared_ptr((std::shared_ptr<const google::protobuf::Message> *const)&__r);
  std::shared_ptr<proto::ReliquaryFilterStateNotify>::~shared_ptr((std::shared_ptr<proto::ReliquaryFilterStateNotify> *const)(v1 + 96));
  result = 0;
  if ( v21 == (char *)v1 )
  {
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v1 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v1 = 1172321806LL;
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v1 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 604: range 0000000017CBE514-0000000017CC0462
int32_t __cdecl PlayerItemComp::toBin(PlayerItemComp *const this, proto::PlayerDataBin *player_data_bin)
{
  common::milog::MiLogStream *v2; // rcx
  unsigned int *v4; // rax
  unsigned int *v5; // rdx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rdx
  std::tuple_element<1,std::pair<unsigned int const,long unsigned int> >::type v8; // rbx
  std::tuple_element<0,std::pair<unsigned int const,long unsigned int> >::type *v9; // rsi
  unsigned __int64 v10; // rax
  AutoRecoverItemProxy *v11; // rax
  std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::reference v12; // rax
  std::pair<unsigned int const,unsigned int> *v13; // rdx
  proto::MaterialDeleteReturnRecordBin *v14; // rax
  common::milog::MiLogStream *v15; // rcx
  proto::ShopOutputRecordBin *v16; // rax
  std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::reference v17; // rax
  std::pair<unsigned int const,unsigned int> *v18; // rdx
  std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::reference v19; // rax
  std::pair<unsigned int const,unsigned int> *v20; // rdx
  std::pair<unsigned int const,unsigned int> *v21; // rax
  std::pair<unsigned int const,unsigned int> *v22; // rdx
  google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::key_type key; // [rsp+18h] [rbp-308h] BYREF
  unsigned int history_item_id; // [rsp+1Ch] [rbp-304h]
  std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::iterator __for_begin_0; // [rsp+20h] [rbp-300h] BYREF
  std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int> >,std::equal_to<std::pair<unsigned int,unsigned int> >,std::allocator<std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> > > >::iterator __for_begin_1; // [rsp+28h] [rbp-2F8h] BYREF
  std::map<unsigned int,ReliquaryGuaranteeDepot>::iterator __for_end_0; // [rsp+30h] [rbp-2F0h] BYREF
  std::set<data::EquipType>::iterator __for_begin; // [rsp+38h] [rbp-2E8h] BYREF
  proto::PlayerItemCompBin *proto_comp; // [rsp+40h] [rbp-2E0h]
  proto::ItemStoreBin *proto_pack; // [rsp+48h] [rbp-2D8h]
  std::set<unsigned int> *__for_range; // [rsp+50h] [rbp-2D0h]
  google::protobuf::Map<unsigned int,long unsigned int> *proto_cd_map; // [rsp+58h] [rbp-2C8h]
  std::map<unsigned int,long unsigned int> *__for_range_0; // [rsp+60h] [rbp-2C0h]
  proto::AutoRecoverItemBin *resin_bin_data; // [rsp+68h] [rbp-2B8h]
  std::unordered_map<data::ItemLimitType,ItemLimitRecord> *__for_range_1; // [rsp+70h] [rbp-2B0h]
  std::unordered_map<unsigned int,unsigned int> *__for_range_2; // [rsp+78h] [rbp-2A8h]
  google::protobuf::Map<unsigned int,proto::OutputControlRecordBin> *proto_output_control_record_map; // [rsp+80h] [rbp-2A0h]
  std::map<data::OutputControlType,OutputControlRecord> *__for_range_3; // [rsp+88h] [rbp-298h]
  std::unordered_map<unsigned int,ShopGoodsOutputRecord> *__for_range_4; // [rsp+90h] [rbp-290h]
  std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>> *__for_range_5; // [rsp+98h] [rbp-288h]
  proto::EquipLevelupRecordBin *equip_levelup_record_bin; // [rsp+A0h] [rbp-280h]
  std::unordered_map<unsigned int,unsigned int> *__for_range_7; // [rsp+A8h] [rbp-278h]
  std::unordered_map<unsigned int,unsigned int> *__for_range_8; // [rsp+B0h] [rbp-270h]
  std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>> *__for_range_9; // [rsp+B8h] [rbp-268h]
  std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int> >,std::equal_to<std::pair<unsigned int,unsigned int> >,std::allocator<std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> > > > *__for_range_11; // [rsp+C0h] [rbp-260h]
  std::unordered_map<data::NewActivityType,ActivityOutputControlRecord> *__for_range_13; // [rsp+C8h] [rbp-258h]
  std::map<unsigned int,ReliquaryGuaranteeDepot> *__for_range_14; // [rsp+D0h] [rbp-250h]
  std::unordered_map<unsigned int,unsigned int> *__for_range_16; // [rsp+D8h] [rbp-248h]
  const std::pair<unsigned int const,unsigned int> *v49; // [rsp+E0h] [rbp-240h]
  std::tuple_element<0,const std::pair<unsigned int const,unsigned int> >::type *filter_key; // [rsp+E8h] [rbp-238h]
  std::tuple_element<1,const std::pair<unsigned int const,unsigned int> >::type *state; // [rsp+F0h] [rbp-230h]
  proto::Uint32PairBin *reliquary_state_filter_pair; // [rsp+F8h] [rbp-228h]
  const std::pair<unsigned int const,ReliquaryGuaranteeDepot> *v53; // [rsp+100h] [rbp-220h]
  std::tuple_element<0,const std::pair<unsigned int const,ReliquaryGuaranteeDepot> >::type *guarantee_depot_id; // [rsp+108h] [rbp-218h]
  std::tuple_element<1,const std::pair<unsigned int const,ReliquaryGuaranteeDepot> >::type *reliquary_gaurantee_depot; // [rsp+110h] [rbp-210h]
  proto::ReliquaryGuaranteeDepotBin *reliquary_gaurantee_depot_bin; // [rsp+118h] [rbp-208h]
  const std::map<unsigned int,ReliquaryMainPropGuaranteeData> *__for_range_15; // [rsp+120h] [rbp-200h]
  const std::pair<unsigned int const,ReliquaryMainPropGuaranteeData> *v58; // [rsp+128h] [rbp-1F8h]
  std::tuple_element<0,const std::pair<unsigned int const,ReliquaryMainPropGuaranteeData> >::type *main_prop_id; // [rsp+130h] [rbp-1F0h]
  std::tuple_element<1,const std::pair<unsigned int const,ReliquaryMainPropGuaranteeData> >::type *main_prop_guarantee_data; // [rsp+138h] [rbp-1E8h]
  proto::ReliquaryMainPropGuaranteeDataBin *main_prop_guarantee_data_bin; // [rsp+140h] [rbp-1E0h]
  const std::pair<const data::NewActivityType,ActivityOutputControlRecord> *v62; // [rsp+148h] [rbp-1D8h]
  std::tuple_element<0,const std::pair<const data::NewActivityType,ActivityOutputControlRecord> >::type *activity_type; // [rsp+150h] [rbp-1D0h]
  std::tuple_element<1,const std::pair<const data::NewActivityType,ActivityOutputControlRecord> >::type *activity_output_control_record; // [rsp+158h] [rbp-1C8h]
  proto::ActivityOutputControlRecordBin *activity_output_control_record_bin; // [rsp+160h] [rbp-1C0h]
  std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> > *v66; // [rsp+168h] [rbp-1B8h]
  std::tuple_element<0,std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> > >::type *suit_level_pair; // [rsp+170h] [rbp-1B0h]
  std::tuple_element<1,std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> > >::type *reliquary_type_set; // [rsp+178h] [rbp-1A8h]
  proto::ReliquarySuitBin *suit_bin; // [rsp+180h] [rbp-1A0h]
  std::set<data::EquipType> *__for_range_12; // [rsp+188h] [rbp-198h]
  const data::EquipType *reliquary_type; // [rsp+190h] [rbp-190h]
  const std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int> > *v72; // [rsp+198h] [rbp-188h]
  std::tuple_element<0,const std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int> > >::type *rank_level; // [rsp+1A0h] [rbp-180h]
  std::tuple_element<1,const std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int> > >::type *levelup_num_map; // [rsp+1A8h] [rbp-178h]
  proto::ReliquaryLevelupNumRecordBin *rank_reliquary_levelup_map_bin; // [rsp+1B0h] [rbp-170h]
  const std::unordered_map<unsigned int,unsigned int> *__for_range_10; // [rsp+1B8h] [rbp-168h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *level_0; // [rsp+1C0h] [rbp-160h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *num_1; // [rsp+1C8h] [rbp-158h]
  proto::Uint32PairBin *pair_bin_2; // [rsp+1D0h] [rbp-150h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *promote_level; // [rsp+1D8h] [rbp-148h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *num_0; // [rsp+1E0h] [rbp-140h]
  proto::Uint32PairBin *pair_bin_1; // [rsp+1E8h] [rbp-138h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *level; // [rsp+1F0h] [rbp-130h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *num; // [rsp+1F8h] [rbp-128h]
  proto::Uint32PairBin *pair_bin_0; // [rsp+200h] [rbp-120h]
  const std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> > *v86; // [rsp+208h] [rbp-118h]
  std::tuple_element<0,const std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> > >::type *bonus_source_type; // [rsp+210h] [rbp-110h]
  std::tuple_element<1,const std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> > >::type *bonus_map; // [rsp+218h] [rbp-108h]
  proto::BonusRecordBin *bonus_record_bin; // [rsp+220h] [rbp-100h]
  const std::unordered_map<unsigned int,SingleBonusRecord> *__for_range_6; // [rsp+228h] [rbp-F8h]
  const std::pair<unsigned int const,SingleBonusRecord> *v91; // [rsp+230h] [rbp-F0h]
  std::tuple_element<0,const std::pair<unsigned int const,SingleBonusRecord> >::type *config_id; // [rsp+238h] [rbp-E8h]
  std::tuple_element<1,const std::pair<unsigned int const,SingleBonusRecord> >::type *single_bonus_record; // [rsp+240h] [rbp-E0h]
  proto::SingleBonusRecordBin *single_record_bin; // [rsp+248h] [rbp-D8h]
  const std::pair<unsigned int const,ShopGoodsOutputRecord> *v95; // [rsp+250h] [rbp-D0h]
  std::tuple_element<0,const std::pair<unsigned int const,ShopGoodsOutputRecord> >::type *_; // [rsp+258h] [rbp-C8h]
  std::tuple_element<1,const std::pair<unsigned int const,ShopGoodsOutputRecord> >::type *shop_goods_output_record; // [rsp+260h] [rbp-C0h]
  proto::ShopGoodsOutputRecordBin *shop_goods_output_record_bin; // [rsp+268h] [rbp-B8h]
  const std::pair<const data::OutputControlType,OutputControlRecord> *v99; // [rsp+270h] [rbp-B0h]
  std::tuple_element<0,const std::pair<const data::OutputControlType,OutputControlRecord> >::type *output_control_type; // [rsp+278h] [rbp-A8h]
  std::tuple_element<1,const std::pair<const data::OutputControlType,OutputControlRecord> >::type *output_control_record; // [rsp+280h] [rbp-A0h]
  proto::OutputControlRecordBin *output_control_record_bin; // [rsp+288h] [rbp-98h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *item_id; // [rsp+290h] [rbp-90h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *total_obtain_count; // [rsp+298h] [rbp-88h]
  proto::Uint32PairBin *pair_bin; // [rsp+2A0h] [rbp-80h]
  const std::pair<const data::ItemLimitType,ItemLimitRecord> *v106; // [rsp+2A8h] [rbp-78h]
  std::tuple_element<0,const std::pair<const data::ItemLimitType,ItemLimitRecord> >::type *item_limit_type; // [rsp+2B0h] [rbp-70h]
  std::tuple_element<1,const std::pair<const data::ItemLimitType,ItemLimitRecord> >::type *item_limit_record; // [rsp+2B8h] [rbp-68h]
  proto::ItemLimitRecordBin *item_limit_record_bin; // [rsp+2C0h] [rbp-60h]
  std::tuple_element<0,std::pair<unsigned int const,long unsigned int> >::type *cd_group_id; // [rsp+2C8h] [rbp-58h]
  std::tuple_element<1,std::pair<unsigned int const,long unsigned int> >::type *cd_time; // [rsp+2D0h] [rbp-50h]
  std::pair<unsigned int const,unsigned int> __for_end; // [rsp+2D8h] [rbp-48h] BYREF
  std::pair<unsigned int const,long unsigned int> __in; // [rsp+2E0h] [rbp-40h] BYREF
  common::milog::MiLogStream v114; // [rsp+2F0h] [rbp-30h] BYREF

  proto_comp = proto::PlayerDataBin::mutable_item_bin(player_data_bin);
  proto_pack = proto::PlayerItemCompBin::mutable_pack_store(proto_comp);
  if ( PackItemStore::toBin(&this->pack_store_, proto_pack) )
  {
    common::milog::MiLogStream::create(
      &v114,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "toBin",
      612);
    v2 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(&v114, (const char (*)[12])"toBin fails");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v2, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v114);
    return -1;
  }
  else
  {
    __for_range = &this->history_item_set_;
    __for_begin._M_node = std::set<unsigned int>::begin(&this->history_item_set_)._M_node;
    __for_end = (std::pair<unsigned int const,unsigned int>)std::set<unsigned int>::end(&this->history_item_set_)._M_node;
    while ( std::operator!=(
              (const std::_Rb_tree_const_iterator<unsigned int>::_Self *)&__for_begin,
              (const std::_Rb_tree_const_iterator<unsigned int>::_Self *)&__for_end) )
    {
      v4 = (unsigned int *)std::_Rb_tree_const_iterator<unsigned int>::operator*((const std::_Rb_tree_const_iterator<unsigned int> *const)&__for_begin);
      v5 = v4;
      if ( *(_BYTE *)(((unsigned __int64)v4 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v4 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v4 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v4);
      }
      history_item_id = *v5;
      proto::PlayerItemCompBin::add_history_item_list(proto_comp, history_item_id);
      std::_Rb_tree_const_iterator<unsigned int>::operator++((std::_Rb_tree_const_iterator<unsigned int> *const)&__for_begin);
    }
    if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->hcoin_);
    }
    proto::PlayerItemCompBin::set_hcoin(proto_comp, this->hcoin_);
    if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->scoin_);
    }
    proto::PlayerItemCompBin::set_scoin(proto_comp, this->scoin_);
    if ( *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 36) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->mcoin_);
    }
    proto::PlayerItemCompBin::set_mcoin(proto_comp, this->mcoin_);
    if ( *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->psn_mcoin_);
    }
    proto::PlayerItemCompBin::set_psn_mcoin(proto_comp, this->psn_mcoin_);
    if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->home_coin_);
    }
    proto::PlayerItemCompBin::set_home_coin(proto_comp, this->home_coin_);
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->wait_sub_hcoin_);
    }
    proto::PlayerItemCompBin::set_wait_sub_hcoin(proto_comp, this->wait_sub_hcoin_);
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->wait_sub_scoin_);
    }
    proto::PlayerItemCompBin::set_wait_sub_scoin(proto_comp, this->wait_sub_scoin_);
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->wait_sub_mcoin_);
    }
    proto::PlayerItemCompBin::set_wait_sub_mcoin(proto_comp, this->wait_sub_mcoin_);
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->wait_sub_psn_mcoin_);
    }
    proto::PlayerItemCompBin::set_wait_sub_psn_mcoin(proto_comp, this->wait_sub_psn_mcoin_);
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3)
                                                         + 0x7FFF8000) )
    {
      __asan_report_load4(&this->wait_sub_home_coin_);
    }
    proto::PlayerItemCompBin::set_wait_sub_home_coin(proto_comp, this->wait_sub_home_coin_);
    if ( *(char *)(((unsigned __int64)&this->is_psn_version_modify_ >> 3) + 0x7FFF8000) < 0 )
      __asan_report_load1(&this->is_psn_version_modify_);
    proto::PlayerItemCompBin::set_is_psn_version_modify(proto_comp, this->is_psn_version_modify_);
    if ( *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->legendary_key_);
    }
    proto::PlayerItemCompBin::set_legendary_key(proto_comp, this->legendary_key_);
    proto_cd_map = proto::PlayerItemCompBin::mutable_item_cd_map(proto_comp);
    __for_range_0 = &this->item_cd_map_;
    __for_begin._M_node = std::map<unsigned int,unsigned long>::begin(&this->item_cd_map_)._M_node;
    __for_end = (std::pair<unsigned int const,unsigned int>)std::map<unsigned int,unsigned long>::end(__for_range_0)._M_node;
    while ( std::operator!=(
              (const std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> >::_Self *)&__for_begin,
              (const std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> >::_Self *)&__for_end) )
    {
      v6 = (unsigned __int64)std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned long>>::operator*((const std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> > *const)&__for_begin);
      if ( *(_WORD *)((v6 >> 3) + 0x7FFF8000) )
        v6 = __asan_report_load16(v6);
      v7 = *(_QWORD *)(v6 + 8);
      *(_QWORD *)&__in.first = *(_QWORD *)v6;
      __in.second = v7;
      cd_group_id = std::get<0ul,unsigned int const,unsigned long>(&__in);
      cd_time = std::get<1ul,unsigned int const,unsigned long>(&__in);
      if ( *(_BYTE *)(((unsigned __int64)cd_time >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v8 = *cd_time;
      v9 = cd_group_id;
      v10 = (unsigned __int64)google::protobuf::Map<unsigned int,unsigned long>::operator[](proto_cd_map, cd_group_id);
      if ( *(_BYTE *)((v10 >> 3) + 0x7FFF8000) )
        v10 = __asan_report_store8(v10, v9);
      *(_QWORD *)v10 = v8;
      std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned long>>::operator++((std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> > *const)&__for_begin);
    }
    resin_bin_data = proto::PlayerItemCompBin::mutable_resin_record(proto_comp);
    if ( std::operator==<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
    {
      common::milog::MiLogStream::create(
        &v114,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "toBin",
        644);
      common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v114, (const char (*)[18])"resin ptr is null");
      common::milog::MiLogStream::~MiLogStream(&v114);
      return -1;
    }
    else
    {
      v11 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
      AutoRecoverItemProxy::toBin(v11, resin_bin_data);
      __for_range_1 = &this->item_limit_record_map_;
      __for_begin._M_node = (std::_Rb_tree_const_iterator<data::EquipType>::_Base_ptr)std::unordered_map<data::ItemLimitType,ItemLimitRecord>::begin(&this->item_limit_record_map_)._M_cur;
      __for_end = (std::pair<unsigned int const,unsigned int>)std::unordered_map<data::ItemLimitType,ItemLimitRecord>::end(__for_range_1)._M_cur;
      while ( std::__detail::operator!=<std::pair<data::ItemLimitType const,ItemLimitRecord>,false>(
                (const std::__detail::_Node_iterator_base<std::pair<const data::ItemLimitType,ItemLimitRecord>,false> *)&__for_begin,
                (const std::__detail::_Node_iterator_base<std::pair<const data::ItemLimitType,ItemLimitRecord>,false> *)&__for_end) )
      {
        v106 = std::__detail::_Node_iterator<std::pair<data::ItemLimitType const,ItemLimitRecord>,false,false>::operator*((const std::__detail::_Node_iterator<std::pair<const data::ItemLimitType,ItemLimitRecord>,false,false> *const)&__for_begin);
        item_limit_type = std::get<0ul,data::ItemLimitType const,ItemLimitRecord>(v106);
        item_limit_record = (std::tuple_element<1,const std::pair<const data::ItemLimitType,ItemLimitRecord> >::type *)std::get<1ul,data::ItemLimitType const,ItemLimitRecord>(v106);
        item_limit_record_bin = proto::PlayerItemCompBin::add_item_limit_record_list(proto_comp);
        if ( *(_BYTE *)(((unsigned __int64)item_limit_type >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_limit_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_limit_type >> 3)
                                                                            + 0x7FFF8000) )
        {
          __asan_report_load4(item_limit_type);
        }
        proto::ItemLimitRecordBin::set_item_limit_type(item_limit_record_bin, *item_limit_type);
        ItemLimitRecord::toBin<proto::ItemLimitRecordBin>(item_limit_record, item_limit_record_bin);
        std::__detail::_Node_iterator<std::pair<data::ItemLimitType const,ItemLimitRecord>,false,false>::operator++((std::__detail::_Node_iterator<std::pair<const data::ItemLimitType,ItemLimitRecord>,false,false> *const)&__for_begin);
      }
      __for_range_2 = &this->item_total_obtain_count_map_;
      __for_end_0._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot> >::_Base_ptr)std::unordered_map<unsigned int,unsigned int>::begin(&this->item_total_obtain_count_map_)._M_cur;
      __for_begin._M_node = (std::_Rb_tree_const_iterator<data::EquipType>::_Base_ptr)std::unordered_map<unsigned int,unsigned int>::end(__for_range_2)._M_cur;
      while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(
                (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)&__for_end_0,
                (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)&__for_begin) )
      {
        v12 = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*((const std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)&__for_end_0);
        v13 = v12;
        if ( ((unsigned __int8)v12 & 7) >= *(_BYTE *)(((unsigned __int64)v12 >> 3) + 0x7FFF8000)
          && *(_BYTE *)(((unsigned __int64)v12 >> 3) + 0x7FFF8000) != 0
          || *(_BYTE *)((((unsigned __int64)&v12->second + 3) >> 3) + 0x7FFF8000) != 0
          && (((unsigned __int8)v12 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v12->second + 3) >> 3) + 0x7FFF8000) )
        {
          __asan_report_load_n(v12, 8LL);
        }
        __for_end = *v13;
        item_id = std::get<0ul,unsigned int const,unsigned int>(&__for_end);
        total_obtain_count = std::get<1ul,unsigned int const,unsigned int>(&__for_end);
        pair_bin = proto::PlayerItemCompBin::add_item_total_obtain_count_list(proto_comp);
        if ( *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_id);
        }
        proto::Uint32PairBin::set_key(pair_bin, *item_id);
        if ( *(_BYTE *)(((unsigned __int64)total_obtain_count >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)total_obtain_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)total_obtain_count >> 3)
                                                                               + 0x7FFF8000) )
        {
          __asan_report_load4(total_obtain_count);
        }
        proto::Uint32PairBin::set_value(pair_bin, *total_obtain_count);
        std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++((std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)&__for_end_0);
      }
      v14 = proto::PlayerItemCompBin::mutable_material_delete_return_record(proto_comp);
      if ( MaterialDeleteReturnRecord::toBin(&this->material_delete_return_record_, v14) )
      {
        common::milog::MiLogStream::create(
          &v114,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "toBin",
          665);
        v15 = common::milog::MiLogStream::operator<<<char [53],(char *[53])0>(
                &v114,
                (const char (*)[53])"material_delete_return_record toBin failed. player_:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v15, this->player_);
        common::milog::MiLogStream::~MiLogStream(&v114);
        return -1;
      }
      else
      {
        proto_output_control_record_map = proto::PlayerItemCompBin::mutable_output_control_record_map(proto_comp);
        __for_range_3 = &this->output_control_record_map_;
        __for_begin._M_node = std::map<data::OutputControlType,OutputControlRecord>::begin(&this->output_control_record_map_)._M_node;
        __for_end = (std::pair<unsigned int const,unsigned int>)std::map<data::OutputControlType,OutputControlRecord>::end(__for_range_3)._M_node;
        while ( std::operator!=(
                  (const std::_Rb_tree_iterator<std::pair<const data::OutputControlType,OutputControlRecord> >::_Self *)&__for_begin,
                  (const std::_Rb_tree_iterator<std::pair<const data::OutputControlType,OutputControlRecord> >::_Self *)&__for_end) )
        {
          v99 = std::_Rb_tree_iterator<std::pair<data::OutputControlType const,OutputControlRecord>>::operator*((const std::_Rb_tree_iterator<std::pair<const data::OutputControlType,OutputControlRecord> > *const)&__for_begin);
          output_control_type = std::get<0ul,data::OutputControlType const,OutputControlRecord>(v99);
          output_control_record = (std::tuple_element<1,const std::pair<const data::OutputControlType,OutputControlRecord> >::type *)std::get<1ul,data::OutputControlType const,OutputControlRecord>(v99);
          if ( *(_BYTE *)(((unsigned __int64)output_control_type >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)output_control_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)output_control_type >> 3)
                                                                                  + 0x7FFF8000) )
          {
            __asan_report_load4(output_control_type);
          }
          key = *output_control_type;
          output_control_record_bin = google::protobuf::Map<unsigned int,proto::OutputControlRecordBin>::operator[](
                                        proto_output_control_record_map,
                                        &key);
          OutputControlRecord::toBin(output_control_record, output_control_record_bin);
          std::_Rb_tree_iterator<std::pair<data::OutputControlType const,OutputControlRecord>>::operator++((std::_Rb_tree_iterator<std::pair<const data::OutputControlType,OutputControlRecord> > *const)&__for_begin);
        }
        __for_range_4 = &this->shop_goods_output_record_map_;
        __for_begin._M_node = (std::_Rb_tree_const_iterator<data::EquipType>::_Base_ptr)std::unordered_map<unsigned int,ShopGoodsOutputRecord>::begin(&this->shop_goods_output_record_map_)._M_cur;
        __for_end = (std::pair<unsigned int const,unsigned int>)std::unordered_map<unsigned int,ShopGoodsOutputRecord>::end(__for_range_4)._M_cur;
        while ( std::__detail::operator!=<std::pair<unsigned int const,ShopGoodsOutputRecord>,false>(
                  (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,ShopGoodsOutputRecord>,false> *)&__for_begin,
                  (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,ShopGoodsOutputRecord>,false> *)&__for_end) )
        {
          v95 = std::__detail::_Node_iterator<std::pair<unsigned int const,ShopGoodsOutputRecord>,false,false>::operator*((const std::__detail::_Node_iterator<std::pair<unsigned int const,ShopGoodsOutputRecord>,false,false> *const)&__for_begin);
          _ = std::get<0ul,unsigned int const,ShopGoodsOutputRecord>(v95);
          shop_goods_output_record = (std::tuple_element<1,const std::pair<unsigned int const,ShopGoodsOutputRecord> >::type *)std::get<1ul,unsigned int const,ShopGoodsOutputRecord>(v95);
          v16 = proto::PlayerItemCompBin::mutable_shop_output_record(proto_comp);
          shop_goods_output_record_bin = proto::ShopOutputRecordBin::add_shop_goods_output_record_list(v16);
          ShopGoodsOutputRecord::toBin(shop_goods_output_record, shop_goods_output_record_bin);
          std::__detail::_Node_iterator<std::pair<unsigned int const,ShopGoodsOutputRecord>,false,false>::operator++((std::__detail::_Node_iterator<std::pair<unsigned int const,ShopGoodsOutputRecord>,false,false> *const)&__for_begin);
        }
        __for_range_5 = &this->bonus_record_map_;
        __for_begin_1._M_cur = (std::__detail::_Node_iterator_base<std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> >,true>::__node_type *)std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::begin(&this->bonus_record_map_)._M_cur;
        __for_end_0._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot> >::_Base_ptr)std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::end(__for_range_5)._M_cur;
        while ( std::__detail::operator!=<std::pair<data::BonusSourceType const,std::unordered_map<unsigned int,SingleBonusRecord>>,false>(
                  (const std::__detail::_Node_iterator_base<std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> >,false> *)&__for_begin_1,
                  (const std::__detail::_Node_iterator_base<std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> >,false> *)&__for_end_0) )
        {
          v86 = std::__detail::_Node_iterator<std::pair<data::BonusSourceType const,std::unordered_map<unsigned int,SingleBonusRecord>>,false,false>::operator*((const std::__detail::_Node_iterator<std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> >,false,false> *const)&__for_begin_1);
          bonus_source_type = std::get<0ul,data::BonusSourceType const,std::unordered_map<unsigned int,SingleBonusRecord>>(v86);
          bonus_map = (std::tuple_element<1,const std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> > >::type *)std::get<1ul,data::BonusSourceType const,std::unordered_map<unsigned int,SingleBonusRecord>>(v86);
          bonus_record_bin = proto::PlayerItemCompBin::add_bonus_record_list(proto_comp);
          if ( *(_BYTE *)(((unsigned __int64)bonus_source_type >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)bonus_source_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)bonus_source_type >> 3)
                                                                                + 0x7FFF8000) )
          {
            __asan_report_load4(bonus_source_type);
          }
          proto::BonusRecordBin::set_bonus_source_type(bonus_record_bin, *bonus_source_type);
          __for_range_6 = bonus_map;
          __for_begin._M_node = (std::_Rb_tree_const_iterator<data::EquipType>::_Base_ptr)std::unordered_map<unsigned int,SingleBonusRecord>::begin(bonus_map)._M_cur;
          __for_end = (std::pair<unsigned int const,unsigned int>)std::unordered_map<unsigned int,SingleBonusRecord>::end(__for_range_6)._M_cur;
          while ( std::__detail::operator!=<std::pair<unsigned int const,SingleBonusRecord>,false>(
                    (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,SingleBonusRecord>,false> *)&__for_begin,
                    (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,SingleBonusRecord>,false> *)&__for_end) )
          {
            v91 = std::__detail::_Node_const_iterator<std::pair<unsigned int const,SingleBonusRecord>,false,false>::operator*((const std::__detail::_Node_const_iterator<std::pair<unsigned int const,SingleBonusRecord>,false,false> *const)&__for_begin);
            config_id = std::get<0ul,unsigned int const,SingleBonusRecord>(v91);
            single_bonus_record = (std::tuple_element<1,const std::pair<unsigned int const,SingleBonusRecord> >::type *)std::get<1ul,unsigned int const,SingleBonusRecord>(v91);
            single_record_bin = proto::BonusRecordBin::add_single_bonus_record_list(bonus_record_bin);
            if ( *(_BYTE *)(((unsigned __int64)config_id >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)config_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)config_id >> 3)
                                                                          + 0x7FFF8000) )
            {
              __asan_report_load4(config_id);
            }
            proto::SingleBonusRecordBin::set_config_id(single_record_bin, *config_id);
            SingleBonusRecord::toBin(single_bonus_record, single_record_bin);
            std::__detail::_Node_const_iterator<std::pair<unsigned int const,SingleBonusRecord>,false,false>::operator++((std::__detail::_Node_const_iterator<std::pair<unsigned int const,SingleBonusRecord>,false,false> *const)&__for_begin);
          }
          std::__detail::_Node_iterator<std::pair<data::BonusSourceType const,std::unordered_map<unsigned int,SingleBonusRecord>>,false,false>::operator++((std::__detail::_Node_iterator<std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> >,false,false> *const)&__for_begin_1);
        }
        equip_levelup_record_bin = proto::PlayerItemCompBin::mutable_equip_levelup_record_bin(proto_comp);
        __for_range_7 = &this->weapon_levelup_num_map_;
        __for_end_0._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot> >::_Base_ptr)std::unordered_map<unsigned int,unsigned int>::begin(&this->weapon_levelup_num_map_)._M_cur;
        __for_begin._M_node = (std::_Rb_tree_const_iterator<data::EquipType>::_Base_ptr)std::unordered_map<unsigned int,unsigned int>::end(__for_range_7)._M_cur;
        while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(
                  (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)&__for_end_0,
                  (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)&__for_begin) )
        {
          v17 = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*((const std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)&__for_end_0);
          v18 = v17;
          if ( ((unsigned __int8)v17 & 7) >= *(_BYTE *)(((unsigned __int64)v17 >> 3) + 0x7FFF8000)
            && *(_BYTE *)(((unsigned __int64)v17 >> 3) + 0x7FFF8000) != 0
            || *(_BYTE *)((((unsigned __int64)&v17->second + 3) >> 3) + 0x7FFF8000) != 0
            && (((unsigned __int8)v17 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v17->second + 3) >> 3) + 0x7FFF8000) )
          {
            __asan_report_load_n(v17, 8LL);
          }
          __for_end = *v18;
          level = std::get<0ul,unsigned int const,unsigned int>(&__for_end);
          num = std::get<1ul,unsigned int const,unsigned int>(&__for_end);
          pair_bin_0 = proto::EquipLevelupRecordBin::add_weapon_levelup_num_list(equip_levelup_record_bin);
          if ( *(_BYTE *)(((unsigned __int64)level >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)level & 7) + 3) >= *(_BYTE *)(((unsigned __int64)level >> 3) + 0x7FFF8000) )
          {
            __asan_report_load4(level);
          }
          proto::Uint32PairBin::set_key(pair_bin_0, *level);
          if ( *(_BYTE *)(((unsigned __int64)num >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)num & 7) + 3) >= *(_BYTE *)(((unsigned __int64)num >> 3) + 0x7FFF8000) )
          {
            __asan_report_load4(num);
          }
          proto::Uint32PairBin::set_value(pair_bin_0, *num);
          std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++((std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)&__for_end_0);
        }
        __for_range_8 = &this->weapon_promote_levelup_num_map_;
        __for_end_0._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot> >::_Base_ptr)std::unordered_map<unsigned int,unsigned int>::begin(&this->weapon_promote_levelup_num_map_)._M_cur;
        __for_begin._M_node = (std::_Rb_tree_const_iterator<data::EquipType>::_Base_ptr)std::unordered_map<unsigned int,unsigned int>::end(__for_range_8)._M_cur;
        while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(
                  (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)&__for_end_0,
                  (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)&__for_begin) )
        {
          v19 = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*((const std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)&__for_end_0);
          v20 = v19;
          if ( ((unsigned __int8)v19 & 7) >= *(_BYTE *)(((unsigned __int64)v19 >> 3) + 0x7FFF8000)
            && *(_BYTE *)(((unsigned __int64)v19 >> 3) + 0x7FFF8000) != 0
            || *(_BYTE *)((((unsigned __int64)&v19->second + 3) >> 3) + 0x7FFF8000) != 0
            && (((unsigned __int8)v19 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v19->second + 3) >> 3) + 0x7FFF8000) )
          {
            __asan_report_load_n(v19, 8LL);
          }
          __for_end = *v20;
          promote_level = std::get<0ul,unsigned int const,unsigned int>(&__for_end);
          num_0 = std::get<1ul,unsigned int const,unsigned int>(&__for_end);
          pair_bin_1 = proto::EquipLevelupRecordBin::add_weapon_promote_levelup_num_list(equip_levelup_record_bin);
          if ( *(_BYTE *)(((unsigned __int64)promote_level >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)promote_level & 7) + 3) >= *(_BYTE *)(((unsigned __int64)promote_level >> 3)
                                                                            + 0x7FFF8000) )
          {
            __asan_report_load4(promote_level);
          }
          proto::Uint32PairBin::set_key(pair_bin_1, *promote_level);
          if ( *(_BYTE *)(((unsigned __int64)num_0 >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)num_0 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)num_0 >> 3) + 0x7FFF8000) )
          {
            __asan_report_load4(num_0);
          }
          proto::Uint32PairBin::set_value(pair_bin_1, *num_0);
          std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++((std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)&__for_end_0);
        }
        __for_range_9 = &this->reliquary_levelup_num_map_;
        __for_begin_0._M_cur = std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::begin(&this->reliquary_levelup_num_map_)._M_cur;
        __for_begin_1._M_cur = (std::__detail::_Node_iterator_base<std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> >,true>::__node_type *)std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::end(__for_range_9)._M_cur;
        while ( std::__detail::operator!=<std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int>>,false>(
                  &__for_begin_0,
                  (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int> >,false> *)&__for_begin_1) )
        {
          v72 = std::__detail::_Node_iterator<std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int>>,false,false>::operator*(&__for_begin_0);
          rank_level = std::get<0ul,unsigned int const,std::unordered_map<unsigned int,unsigned int>>(v72);
          levelup_num_map = (std::tuple_element<1,const std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int> > >::type *)std::get<1ul,unsigned int const,std::unordered_map<unsigned int,unsigned int>>(v72);
          rank_reliquary_levelup_map_bin = proto::EquipLevelupRecordBin::add_rank_reliquary_levelup_list(equip_levelup_record_bin);
          if ( *(_BYTE *)(((unsigned __int64)rank_level >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)rank_level & 7) + 3) >= *(_BYTE *)(((unsigned __int64)rank_level >> 3)
                                                                         + 0x7FFF8000) )
          {
            __asan_report_load4(rank_level);
          }
          proto::ReliquaryLevelupNumRecordBin::set_rank_level(rank_reliquary_levelup_map_bin, *rank_level);
          __for_range_10 = levelup_num_map;
          __for_end_0._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot> >::_Base_ptr)std::unordered_map<unsigned int,unsigned int>::begin(levelup_num_map)._M_cur;
          __for_begin._M_node = (std::_Rb_tree_const_iterator<data::EquipType>::_Base_ptr)std::unordered_map<unsigned int,unsigned int>::end(__for_range_10)._M_cur;
          while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(
                    (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)&__for_end_0,
                    (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)&__for_begin) )
          {
            v21 = (std::pair<unsigned int const,unsigned int> *)std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*((const std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)&__for_end_0);
            v22 = v21;
            if ( ((unsigned __int8)v21 & 7) >= *(_BYTE *)(((unsigned __int64)v21 >> 3) + 0x7FFF8000)
              && *(_BYTE *)(((unsigned __int64)v21 >> 3) + 0x7FFF8000) != 0
              || *(_BYTE *)((((unsigned __int64)&v21->second + 3) >> 3) + 0x7FFF8000) != 0
              && (((unsigned __int8)v21 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v21->second + 3) >> 3) + 0x7FFF8000) )
            {
              __asan_report_load_n(v21, 8LL);
            }
            __for_end = *v22;
            level_0 = std::get<0ul,unsigned int const,unsigned int>(&__for_end);
            num_1 = std::get<1ul,unsigned int const,unsigned int>(&__for_end);
            pair_bin_2 = proto::ReliquaryLevelupNumRecordBin::add_reliquary_levelup_num_list(rank_reliquary_levelup_map_bin);
            if ( *(_BYTE *)(((unsigned __int64)level_0 >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)level_0 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)level_0 >> 3) + 0x7FFF8000) )
            {
              __asan_report_load4(level_0);
            }
            proto::Uint32PairBin::set_key(pair_bin_2, *level_0);
            if ( *(_BYTE *)(((unsigned __int64)num_1 >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)num_1 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)num_1 >> 3) + 0x7FFF8000) )
            {
              __asan_report_load4(num_1);
            }
            proto::Uint32PairBin::set_value(pair_bin_2, *num_1);
            std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++((std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)&__for_end_0);
          }
          std::__detail::_Node_iterator<std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int>>,false,false>::operator++(&__for_begin_0);
        }
        __for_range_11 = &this->reliquary_set_map_;
        __for_begin_1._M_cur = std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int>>,std::equal_to<std::pair<unsigned int,unsigned int>>,std::allocator<std::pair<std::pair<unsigned int,unsigned int> const,std::set<data::EquipType>>>>::begin(&this->reliquary_set_map_)._M_cur;
        __for_end_0._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot> >::_Base_ptr)std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int>>,std::equal_to<std::pair<unsigned int,unsigned int>>,std::allocator<std::pair<std::pair<unsigned int,unsigned int> const,std::set<data::EquipType>>>>::end(__for_range_11)._M_cur;
        while ( std::__detail::operator!=<std::pair<std::pair const<unsigned int,unsigned int>,std::set<data::EquipType>>,true>(
                  &__for_begin_1,
                  (const std::__detail::_Node_iterator_base<std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> >,true> *)&__for_end_0) )
        {
          v66 = std::__detail::_Node_iterator<std::pair<std::pair const<unsigned int,unsigned int>,std::set<data::EquipType>>,false,true>::operator*(&__for_begin_1);
          suit_level_pair = std::get<0ul,std::pair<unsigned int,unsigned int> const,std::set<data::EquipType>>(v66);
          reliquary_type_set = std::get<1ul,std::pair<unsigned int,unsigned int> const,std::set<data::EquipType>>(v66);
          suit_bin = proto::PlayerItemCompBin::add_reliquary_suit_list(proto_comp);
          __for_range_12 = reliquary_type_set;
          __for_begin._M_node = std::set<data::EquipType>::begin(reliquary_type_set)._M_node;
          __for_end = (std::pair<unsigned int const,unsigned int>)std::set<data::EquipType>::end(__for_range_12)._M_node;
          while ( std::operator!=(
                    &__for_begin,
                    (const std::_Rb_tree_const_iterator<data::EquipType>::_Self *)&__for_end) )
          {
            reliquary_type = std::_Rb_tree_const_iterator<data::EquipType>::operator*(&__for_begin);
            if ( *(_BYTE *)(((unsigned __int64)suit_level_pair >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)suit_level_pair & 7) + 3) >= *(_BYTE *)(((unsigned __int64)suit_level_pair >> 3)
                                                                                + 0x7FFF8000) )
            {
              __asan_report_load4(suit_level_pair);
            }
            proto::ReliquarySuitBin::set_reliquary_suit_id(suit_bin, suit_level_pair->first);
            if ( *(_BYTE *)(((unsigned __int64)&suit_level_pair->second >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)suit_level_pair + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&suit_level_pair->second >> 3)
                                                                            + 0x7FFF8000) )
            {
              __asan_report_load4(&suit_level_pair->second);
            }
            proto::ReliquarySuitBin::set_level(suit_bin, suit_level_pair->second);
            if ( *(_BYTE *)(((unsigned __int64)reliquary_type >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)reliquary_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reliquary_type >> 3)
                                                                               + 0x7FFF8000) )
            {
              __asan_report_load4(reliquary_type);
            }
            proto::ReliquarySuitBin::add_reliquary_type_list(suit_bin, *reliquary_type);
            std::_Rb_tree_const_iterator<data::EquipType>::operator++(&__for_begin);
          }
          std::__detail::_Node_iterator<std::pair<std::pair const<unsigned int,unsigned int>,std::set<data::EquipType>>,false,true>::operator++(&__for_begin_1);
        }
        __for_range_13 = &this->activity_output_control_record_map_;
        __for_begin._M_node = (std::_Rb_tree_const_iterator<data::EquipType>::_Base_ptr)std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::begin(&this->activity_output_control_record_map_)._M_cur;
        __for_end = (std::pair<unsigned int const,unsigned int>)std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::end(__for_range_13)._M_cur;
        while ( std::__detail::operator!=<std::pair<data::NewActivityType const,ActivityOutputControlRecord>,false>(
                  (const std::__detail::_Node_iterator_base<std::pair<const data::NewActivityType,ActivityOutputControlRecord>,false> *)&__for_begin,
                  (const std::__detail::_Node_iterator_base<std::pair<const data::NewActivityType,ActivityOutputControlRecord>,false> *)&__for_end) )
        {
          v62 = std::__detail::_Node_iterator<std::pair<data::NewActivityType const,ActivityOutputControlRecord>,false,false>::operator*((const std::__detail::_Node_iterator<std::pair<const data::NewActivityType,ActivityOutputControlRecord>,false,false> *const)&__for_begin);
          activity_type = std::get<0ul,data::NewActivityType const,ActivityOutputControlRecord>(v62);
          activity_output_control_record = (std::tuple_element<1,const std::pair<const data::NewActivityType,ActivityOutputControlRecord> >::type *)std::get<1ul,data::NewActivityType const,ActivityOutputControlRecord>(v62);
          activity_output_control_record_bin = proto::PlayerItemCompBin::add_activity_output_control_record_list(proto_comp);
          if ( *(_BYTE *)(((unsigned __int64)activity_type >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)activity_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)activity_type >> 3)
                                                                            + 0x7FFF8000) )
          {
            __asan_report_load4(activity_type);
          }
          proto::ActivityOutputControlRecordBin::set_activity_type(activity_output_control_record_bin, *activity_type);
          ActivityOutputControlRecord::toBin(activity_output_control_record, activity_output_control_record_bin);
          std::__detail::_Node_iterator<std::pair<data::NewActivityType const,ActivityOutputControlRecord>,false,false>::operator++((std::__detail::_Node_iterator<std::pair<const data::NewActivityType,ActivityOutputControlRecord>,false,false> *const)&__for_begin);
        }
        __for_range_14 = &this->reliquary_guarantee_depot_map_;
        __for_begin_1._M_cur = (std::__detail::_Node_iterator_base<std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> >,true>::__node_type *)std::map<unsigned int,ReliquaryGuaranteeDepot>::begin(&this->reliquary_guarantee_depot_map_)._M_node;
        __for_end_0._M_node = std::map<unsigned int,ReliquaryGuaranteeDepot>::end(__for_range_14)._M_node;
        while ( std::operator!=(
                  (const std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot> >::_Self *)&__for_begin_1,
                  &__for_end_0) )
        {
          v53 = std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot>>::operator*((const std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot> > *const)&__for_begin_1);
          guarantee_depot_id = std::get<0ul,unsigned int const,ReliquaryGuaranteeDepot>(v53);
          reliquary_gaurantee_depot = (std::tuple_element<1,const std::pair<unsigned int const,ReliquaryGuaranteeDepot> >::type *)std::get<1ul,unsigned int const,ReliquaryGuaranteeDepot>(v53);
          reliquary_gaurantee_depot_bin = proto::PlayerItemCompBin::add_reliquary_guarantee_depot_list(proto_comp);
          if ( *(_BYTE *)(((unsigned __int64)guarantee_depot_id >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)guarantee_depot_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)guarantee_depot_id >> 3)
                                                                                 + 0x7FFF8000) )
          {
            __asan_report_load4(guarantee_depot_id);
          }
          proto::ReliquaryGuaranteeDepotBin::set_guarantee_depot_id(reliquary_gaurantee_depot_bin, *guarantee_depot_id);
          __for_range_15 = &reliquary_gaurantee_depot->main_prop_guarantee_data_map;
          __for_begin._M_node = std::map<unsigned int,ReliquaryMainPropGuaranteeData>::begin(&reliquary_gaurantee_depot->main_prop_guarantee_data_map)._M_node;
          __for_end = (std::pair<unsigned int const,unsigned int>)std::map<unsigned int,ReliquaryMainPropGuaranteeData>::end(__for_range_15)._M_node;
          while ( std::operator!=(
                    (const std::_Rb_tree_const_iterator<std::pair<unsigned int const,ReliquaryMainPropGuaranteeData> >::_Self *)&__for_begin,
                    (const std::_Rb_tree_const_iterator<std::pair<unsigned int const,ReliquaryMainPropGuaranteeData> >::_Self *)&__for_end) )
          {
            v58 = std::_Rb_tree_const_iterator<std::pair<unsigned int const,ReliquaryMainPropGuaranteeData>>::operator*((const std::_Rb_tree_const_iterator<std::pair<unsigned int const,ReliquaryMainPropGuaranteeData> > *const)&__for_begin);
            main_prop_id = std::get<0ul,unsigned int const,ReliquaryMainPropGuaranteeData>(v58);
            main_prop_guarantee_data = (std::tuple_element<1,const std::pair<unsigned int const,ReliquaryMainPropGuaranteeData> >::type *)std::get<1ul,unsigned int const,ReliquaryMainPropGuaranteeData>(v58);
            main_prop_guarantee_data_bin = proto::ReliquaryGuaranteeDepotBin::add_main_prop_guarantee_data_list(reliquary_gaurantee_depot_bin);
            if ( *(_BYTE *)(((unsigned __int64)main_prop_id >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)main_prop_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)main_prop_id >> 3)
                                                                             + 0x7FFF8000) )
            {
              __asan_report_load4(main_prop_id);
            }
            proto::ReliquaryMainPropGuaranteeDataBin::set_main_prop_id(main_prop_guarantee_data_bin, *main_prop_id);
            if ( *(_BYTE *)(((unsigned __int64)main_prop_guarantee_data >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)main_prop_guarantee_data & 7) + 3) >= *(_BYTE *)(((unsigned __int64)main_prop_guarantee_data >> 3)
                                                                                         + 0x7FFF8000) )
            {
              __asan_report_load4(main_prop_guarantee_data);
            }
            proto::ReliquaryMainPropGuaranteeDataBin::set_miss_count(
              main_prop_guarantee_data_bin,
              main_prop_guarantee_data->miss_count);
            if ( *(_BYTE *)(((unsigned __int64)&main_prop_guarantee_data->guarantee_count >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)main_prop_guarantee_data + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&main_prop_guarantee_data->guarantee_count >> 3)
                                                                                     + 0x7FFF8000) )
            {
              __asan_report_load4(&main_prop_guarantee_data->guarantee_count);
            }
            proto::ReliquaryMainPropGuaranteeDataBin::set_guarantee_count(
              main_prop_guarantee_data_bin,
              main_prop_guarantee_data->guarantee_count);
            std::_Rb_tree_const_iterator<std::pair<unsigned int const,ReliquaryMainPropGuaranteeData>>::operator++((std::_Rb_tree_const_iterator<std::pair<unsigned int const,ReliquaryMainPropGuaranteeData> > *const)&__for_begin);
          }
          std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot>>::operator++((std::_Rb_tree_iterator<std::pair<unsigned int const,ReliquaryGuaranteeDepot> > *const)&__for_begin_1);
        }
        __for_range_16 = &this->reliquary_filter_state_map_;
        __for_begin._M_node = (std::_Rb_tree_const_iterator<data::EquipType>::_Base_ptr)std::unordered_map<unsigned int,unsigned int>::begin(&this->reliquary_filter_state_map_)._M_cur;
        __for_end = (std::pair<unsigned int const,unsigned int>)std::unordered_map<unsigned int,unsigned int>::end(__for_range_16)._M_cur;
        while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(
                  (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)&__for_begin,
                  (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)&__for_end) )
        {
          v49 = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*((const std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)&__for_begin);
          filter_key = std::get<0ul,unsigned int const,unsigned int>(v49);
          state = (std::tuple_element<1,const std::pair<unsigned int const,unsigned int> >::type *)std::get<1ul,unsigned int const,unsigned int>(v49);
          reliquary_state_filter_pair = proto::PlayerItemCompBin::add_reliquary_filter_state_list(proto_comp);
          if ( *(_BYTE *)(((unsigned __int64)filter_key >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)filter_key & 7) + 3) >= *(_BYTE *)(((unsigned __int64)filter_key >> 3)
                                                                         + 0x7FFF8000) )
          {
            __asan_report_load4(filter_key);
          }
          proto::Uint32PairBin::set_key(reliquary_state_filter_pair, *filter_key);
          if ( *(_BYTE *)(((unsigned __int64)state >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)state & 7) + 3) >= *(_BYTE *)(((unsigned __int64)state >> 3) + 0x7FFF8000) )
          {
            __asan_report_load4(state);
          }
          proto::Uint32PairBin::set_value(reliquary_state_filter_pair, *state);
          std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++((std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)&__for_begin);
        }
        return 0;
      }
    }
  }
};

// Line 764: range 0000000017CC0464-0000000017CC04BA
ItemPtr __cdecl PlayerItemComp::findItemInPack(PlayerItemComp *const this, uint64_t guid)
{
  __int64 v2; // rdx
  uint64_t v3; // rcx
  ItemPtr result; // rax
  __int64 guida; // [rsp+8h] [rbp-18h]

  guida = v2;
  v3 = guid + 32;
  if ( *(_WORD *)(((unsigned __int64)this >> 3) + 0x7FFF8000) )
    __asan_report_store16(this);
  ItemStore::findItem((ItemStore *const)this, v3, guida);
  result._M_ptr = (std::__shared_ptr<Item,(__gnu_cxx::_Lock_policy)2>::element_type *)this;
  return result;
};

// Line 769: range 0000000017CC04BC-0000000017CC0510
MaterialPtr __cdecl PlayerItemComp::findMaterial(PlayerItemComp *const this, uint32_t item_id)
{
  uint32_t v2; // ecx
  MaterialPtr result; // rax

  v2 = item_id + 32;
  if ( *(_WORD *)(((unsigned __int64)this >> 3) + 0x7FFF8000) )
    __asan_report_store16(this);
  result = ItemStore::findMaterial((ItemStore *const)this, v2);
  result._M_ptr = (std::__shared_ptr<Material,(__gnu_cxx::_Lock_policy)2>::element_type *)this;
  return result;
};

// Line 774: range 0000000017CC0512-0000000017CC0537
uint32_t __cdecl PlayerItemComp::getItemCount(PlayerItemComp *const this, uint32_t item_id)
{
  return ItemStore::getItemCount(&this->pack_store_, item_id);
};

// Line 779: range 0000000017CC0538-0000000017CC0924
int32_t __cdecl PlayerItemComp::dropItemFromPack(
        PlayerItemComp *const this,
        uint64_t guid,
        uint32_t count,
        ItemPtr *item_ptr)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  PlayerBasicComp *BasicComp; // rax
  int32_t v8; // r14d
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  uint32_t ItemId; // eax
  std::initializer_list<SubItemResult>::size_type v12; // rdx
  int32_t result; // eax
  std::string v14; // [rsp+0h] [rbp-190h]
  char *v15; // [rsp+0h] [rbp-190h]
  ItemPtr *item_ptra; // [rsp+10h] [rbp-180h]
  uint32_t counta; // [rsp+1Ch] [rbp-174h]
  std::allocator<SubItemResult> __a; // [rsp+3Bh] [rbp-155h] BYREF
  int32_t ret; // [rsp+3Ch] [rbp-154h]
  std::initializer_list<SubItemResult> __l; // [rsp+40h] [rbp-150h] BYREF
  __int64 v21; // [rsp+50h] [rbp-140h]
  std::string v22; // [rsp+60h] [rbp-130h] BYREF
  char v23[272]; // [rsp+80h] [rbp-110h] BYREF

  *((_DWORD *)&v14._anon_0._M_allocated_capacity + 3) = count;
  v14._anon_0._M_allocated_capacity = (std::string::size_type)item_ptr;
  v4 = (unsigned __int64)v23;
  v14._M_dataplus._M_p = v23;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(224LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "4 48 1 10 holder:780 64 8 19 sub_item_reason:798 96 24 14 sub_result:789 160 24 14 result_vec:797";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::dropItemFromPack;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234753551;
  v6[536862722] = -218959360;
  v6[536862723] = -234881024;
  v6[536862724] = -218959118;
  v6[536862725] = -218103808;
  v6[536862726] = -202116109;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&v22, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 48), 6u, v14);
  std::string::~string(&v22);
  ret = ItemStore::dropItem(
          &this->pack_store_,
          (std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2> *)guid,
          counta,
          item_ptra);
  if ( ret )
  {
    v8 = ret;
  }
  else
  {
    if ( std::operator!=<Item>(item_ptra, 0LL) )
    {
      *(_QWORD *)(v4 + 96) = guid;
      v9 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptra);
      *(_DWORD *)(v4 + 104) = Item::getItemId(v9);
      *(_DWORD *)(v4 + 108) = counta;
      v10 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptra);
      ItemId = Item::getItemId(v10);
      *(_DWORD *)(v4 + 112) = ItemStore::getItemCount(&this->pack_store_, ItemId);
      v12 = *(_QWORD *)(v4 + 104);
      __l._M_array = *(std::initializer_list<SubItemResult>::iterator *)(v4 + 96);
      __l._M_len = v12;
      v21 = *(_QWORD *)(v4 + 112);
      std::allocator<SubItemResult>::allocator(&__a);
      std::vector<SubItemResult>::vector(
        (std::vector<SubItemResult> *const)(v4 + 160),
        (std::initializer_list<SubItemResult>)__PAIR128__(1LL, &__l),
        &__a);
      std::allocator<SubItemResult>::~allocator(&__a);
      SubItemReason::SubItemReason((SubItemReason *const)(v4 + 64), ACTION_REASON_DROP_ITEM);
      PlayerItemComp::triggerItemSubEvent(
        this,
        (const std::vector<SubItemResult> *)(v4 + 160),
        (const SubItemReason *)(v4 + 64));
      std::vector<SubItemResult>::~vector((std::vector<SubItemResult> *const)(v4 + 160));
    }
    v8 = 0;
  }
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 48));
  result = v8;
  if ( v15 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8018) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8018) = -168430091;
  }
  return result;
};

// Line 805: range 0000000017CC0926-0000000017CC0987
proto::StoreType __cdecl PlayerItemComp::getItemStoreType(PlayerItemComp *const this, uint64_t guid)
{
  bool v2; // bl
  std::shared_ptr<Item> __a; // [rsp+10h] [rbp-20h] BYREF

  ItemStore::findItem((ItemStore *const)&__a, (uint64_t)&this->pack_store_, guid);
  v2 = std::operator!=<Item>(&__a, 0LL);
  std::shared_ptr<Item>::~shared_ptr(&__a);
  return v2;
};

// Line 814: range 0000000017CC0988-0000000017CC2190
__int64 __fastcall PlayerItemComp::checkUseItem(
        PlayerItemComp *const this,
        uint64_t item_guid,
        const ItemUseParam *use_param,
        unsigned __int64 reason)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  common::milog::MiLogStream *v7; // r14
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  unsigned int v10; // r14d
  common::milog::MiLogStream *v11; // r14
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v14; // rax
  unsigned __int64 v15; // rdx
  common::milog::MiLogStream *v16; // r14
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v19; // rax
  common::milog::MiLogStream *v20; // r14
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v23; // rax
  std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v24; // rax
  common::milog::MiLogStream *v25; // r14
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rax
  common::milog::MiLogStream *v32; // rax
  PlayerBasicComp *BasicComp; // rax
  uint32_t Level; // ecx
  char v35; // al
  common::milog::MiLogStream *v36; // r14
  common::milog::MiLogStream *v37; // rax
  common::milog::MiLogStream *v38; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v39; // rax
  PlayerGmComp *GmComp; // rax
  char v41; // al
  common::milog::MiLogStream *v42; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v43; // rax
  common::milog::MiLogStream *v44; // rax
  common::milog::MiLogStream *v45; // rax
  common::milog::MiLogStream *v46; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v47; // rax
  common::milog::MiLogStream *v48; // rax
  common::milog::MiLogStream *v49; // rcx
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v50; // rax
  common::milog::MiLogStream *v51; // r14
  common::milog::MiLogStream *v52; // rax
  common::milog::MiLogStream *v53; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v54; // rax
  common::milog::MiLogStream *v55; // rax
  common::milog::MiLogStream *v56; // rax
  common::milog::MiLogStream *v57; // rax
  common::milog::MiLogStream *v58; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v59; // rax
  unsigned __int64 v60; // rdx
  uint64_t target_guid; // rdi
  common::milog::MiLogStream *v62; // r14
  common::milog::MiLogStream *v63; // rax
  common::milog::MiLogStream *v64; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v65; // rax
  common::milog::MiLogStream *v66; // rax
  common::milog::MiLogStream *v67; // rax
  common::milog::MiLogStream *v68; // rax
  __int64 result; // rax
  unsigned int Uid; // [rsp+2Ch] [rbp-1E4h] BYREF
  unsigned int val; // [rsp+30h] [rbp-1E0h] BYREF
  uint32_t max_use_count; // [rsp+34h] [rbp-1DCh]
  std::vector<data::ItemUseConfig>::const_iterator __for_begin; // [rsp+38h] [rbp-1D8h] BYREF
  std::vector<data::ItemUseConfig>::const_iterator __for_end; // [rsp+40h] [rbp-1D0h] BYREF
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+48h] [rbp-1C8h]
  const std::vector<data::ItemUseConfig> *__for_range; // [rsp+50h] [rbp-1C0h]
  const data::ItemUseConfig *item_use_config; // [rsp+58h] [rbp-1B8h]
  common::milog::MiLogStream v81; // [rsp+60h] [rbp-1B0h] BYREF
  common::milog::MiLogStream v82; // [rsp+80h] [rbp-190h] BYREF
  char v83[368]; // [rsp+A0h] [rbp-170h] BYREF

  v4 = (unsigned __int64)v83;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_3(320LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "8 32 4 7 ret:876 48 4 11 drop_id:921 64 8 13 item_guid:813 96 16 12 item_ptr:821 128 16 16 mater"
                        "ial_ptr:834 160 16 14 item_param:884 192 24 14 target_vec:893 256 24 23 random_chest_reason:927";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkUseItem;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556924;
  v6[536862722] = -218959360;
  v6[536862723] = -219021312;
  v6[536862724] = -219021312;
  v6[536862725] = -219021312;
  v6[536862726] = -234881024;
  v6[536862727] = -218959118;
  v6[536862728] = -218103808;
  v6[536862729] = -202116109;
  *(_QWORD *)(v4 + 64) = item_guid;
  if ( *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(use_param);
  }
  if ( use_param->count )
  {
    ItemStore::findItem((ItemStore *const)(v4 + 96), (uint64_t)&this->pack_store_, *(_QWORD *)(v4 + 64));
    if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v4 + 96), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        824);
      v11 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
              &v82,
              (const char (*)[21])"findItem fails, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      *(_DWORD *)(v4 + 48) = Player::getUid(this->player_);
      v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v4 + 48));
      v13 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v12, (const char (*)[12])" item_guid:");
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v13, (const unsigned __int64 *)(v4 + 64));
      common::milog::MiLogStream::~MiLogStream(&v82);
      v10 = 601;
      goto LABEL_113;
    }
    v14 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
    if ( *(_BYTE *)(((unsigned __int64)v14 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v15 = (unsigned __int64)(v14->_vptr_Item + 9);
    if ( *(_BYTE *)((v15 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    if ( (*(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v15)(v14) != 2 )
    {
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        830);
      v16 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
              &v82,
              (const char (*)[22])"Item not usable, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, &val);
      v18 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v17, (const char (*)[10])" item_id:");
      v19 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
      *(_DWORD *)(v4 + 48) = Item::getItemId(v19);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, (const unsigned int *)(v4 + 48));
      common::milog::MiLogStream::~MiLogStream(&v82);
      v10 = 604;
      goto LABEL_113;
    }
    std::dynamic_pointer_cast<Material,Item>((const std::shared_ptr<Item> *)(v4 + 128));
    if ( std::operator==<Material>((const std::shared_ptr<Material> *)(v4 + 128), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        837);
      v20 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
              &v82,
              (const char (*)[34])"dynamic_pointer_cast failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
LABEL_25:
      val = Player::getUid(this->player_);
      v21 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &val);
      v22 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v21, (const char (*)[10])" item_id:");
      v23 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
      *(_DWORD *)(v4 + 48) = Item::getItemId(v23);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, (const unsigned int *)(v4 + 48));
      common::milog::MiLogStream::~MiLogStream(&v82);
      v10 = 604;
LABEL_112:
      std::shared_ptr<Material>::~shared_ptr((std::shared_ptr<Material> *const)(v4 + 128));
LABEL_113:
      std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v4 + 96));
      goto LABEL_114;
    }
    v24 = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 128));
    material_config_ptr = Material::getMaterialConfig(v24);
    if ( !material_config_ptr )
    {
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        844);
      v20 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
              &v82,
              (const char (*)[31])"getMaterialConfig failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_25;
    }
    if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->max_use_count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)material_config_ptr + 92) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->max_use_count >> 3)
                                                                         + 0x7FFF8000) )
    {
      __asan_report_load4(&material_config_ptr->max_use_count);
    }
    max_use_count = material_config_ptr->max_use_count;
    if ( *(char *)(((unsigned __int64)&material_config_ptr->use_on_gain >> 3) + 0x7FFF8000) < 0 )
      __asan_report_load1(&material_config_ptr->use_on_gain);
    if ( material_config_ptr->use_on_gain )
    {
      if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&material_config_ptr->stack_limit);
      }
      max_use_count = material_config_ptr->stack_limit;
    }
    if ( *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(use_param);
    }
    if ( max_use_count < use_param->count )
    {
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        856);
      v25 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
              &v82,
              (const char (*)[22])"Item not usable, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v26 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v25, &val);
      v27 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v26, (const char (*)[10])" item_id:");
      v28 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
      *(_DWORD *)(v4 + 48) = Item::getItemId(v28);
      v29 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, (const unsigned int *)(v4 + 48));
      v30 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v29, (const char (*)[16])" max_use_count:");
      v31 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
              v30,
              &material_config_ptr->max_use_count);
      v32 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v31, (const char (*)[8])" count:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v32, &use_param->count);
      common::milog::MiLogStream::~MiLogStream(&v82);
      v10 = 605;
      goto LABEL_112;
    }
    if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_level >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_level >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&material_config_ptr->use_level);
    }
    if ( !material_config_ptr->use_level )
      goto LABEL_53;
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    Level = PlayerBasicComp::getLevel(BasicComp);
    if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_level >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_level >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&material_config_ptr->use_level);
    }
    if ( Level < material_config_ptr->use_level )
      v35 = 1;
    else
LABEL_53:
      v35 = 0;
    if ( v35 )
    {
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        864);
      v36 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
              &v82,
              (const char (*)[22])"Item not usable, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v37 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v36, &val);
      v38 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v37, (const char (*)[10])" item_id:");
      v39 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
      *(_DWORD *)(v4 + 48) = Item::getItemId(v39);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v38, (const unsigned int *)(v4 + 48));
      common::milog::MiLogStream::~MiLogStream(&v82);
      v10 = 619;
      goto LABEL_112;
    }
    if ( !PlayerItemComp::isItemInCd(this, material_config_ptr) )
      goto LABEL_63;
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    GmComp = Player::getGmComp(this->player_);
    if ( PlayerGmComp::getGmSetValue<bool>(GmComp, 0) )
LABEL_63:
      v41 = 0;
    else
      v41 = 1;
    if ( v41 )
    {
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        871);
      v42 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
              &v82,
              (const char (*)[21])"item in cd, item_id:");
      v43 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
      *(_DWORD *)(v4 + 48) = Item::getItemId(v43);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v42, (const unsigned int *)(v4 + 48));
      common::milog::MiLogStream::~MiLogStream(&v82);
      v10 = 608;
      goto LABEL_112;
    }
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    *(_DWORD *)(v4 + 32) = Player::checkIsAllowUseItem(this->player_);
    if ( *(_DWORD *)(v4 + 32) )
    {
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        879);
      v44 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
              &v82,
              (const char (*)[31])"checkIsAllowUseItem fail, ret:");
      v45 = common::milog::MiLogStream::operator<<<int,(int *)0>(v44, (const int *)(v4 + 32));
      v46 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v45, (const char (*)[10])" item_id:");
      v47 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
      *(_DWORD *)(v4 + 48) = Item::getItemId(v47);
      v48 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v46, (const unsigned int *)(v4 + 48));
      v49 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v48, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v49, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v82);
      v10 = *(_DWORD *)(v4 + 32);
      goto LABEL_112;
    }
    *(_QWORD *)(v4 + 160) = 0LL;
    *(_QWORD *)(v4 + 168) = 0LL;
    v50 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
    *(_DWORD *)(v4 + 160) = Item::getItemId(v50);
    if ( *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(use_param);
    }
    *(_DWORD *)(v4 + 164) = use_param->count;
    if ( PlayerItemComp::checkSubItem(this, (const ItemParam *)(v4 + 160)) )
    {
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        887);
      v51 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
              &v82,
              (const char (*)[28])"Item use count exceed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Uid = Player::getUid(this->player_);
      v52 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v51, &Uid);
      v53 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v52, (const char (*)[10])" item_id:");
      v54 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
      val = Item::getItemId(v54);
      v55 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v53, &val);
      v56 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v55, (const char (*)[12])" use_count:");
      v57 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v56, &use_param->count);
      v58 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v57, (const char (*)[12])" cur_count:");
      v59 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
      if ( *(_BYTE *)(((unsigned __int64)v59 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v60 = (unsigned __int64)(v59->_vptr_Item + 8);
      if ( *(_BYTE *)((v60 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      *(_DWORD *)(v4 + 48) = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v60)(v59);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v58, (const unsigned int *)(v4 + 48));
      common::milog::MiLogStream::~MiLogStream(&v82);
      v10 = 605;
      goto LABEL_112;
    }
    std::vector<std::shared_ptr<Avatar>>::vector((std::vector<std::shared_ptr<Avatar>> *const)(v4 + 192));
    if ( *(_BYTE *)(((unsigned __int64)&use_param->target_guid >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    target_guid = use_param->target_guid;
    if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_target >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)material_config_ptr + 100) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_target >> 3)
                                                                          + 0x7FFF8000) )
    {
      target_guid = (uint64_t)&material_config_ptr->use_target;
      __asan_report_load4(&material_config_ptr->use_target);
    }
    *(_DWORD *)(v4 + 32) = PlayerItemComp::getUseTarget(
                             this,
                             material_config_ptr->use_target,
                             target_guid,
                             (std::vector<std::shared_ptr<Avatar>> *)(v4 + 192));
    if ( *(_DWORD *)(v4 + 32) )
    {
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        897);
      v62 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
              &v82,
              (const char (*)[33])"Item get use target failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    else
    {
      *(_DWORD *)(v4 + 32) = PlayerItemComp::filterUseTarget(
                               this,
                               material_config_ptr,
                               (std::vector<std::shared_ptr<Avatar>> *)(v4 + 192));
      if ( !*(_DWORD *)(v4 + 32) )
      {
        *(_DWORD *)(v4 + 32) = PlayerItemComp::checkItemUseConfig(this, material_config_ptr, use_param);
        if ( *(_DWORD *)(v4 + 32) )
        {
          v10 = *(_DWORD *)(v4 + 32);
        }
        else
        {
          __for_range = &material_config_ptr->item_use;
          __for_begin._M_current = std::vector<data::ItemUseConfig>::begin(&material_config_ptr->item_use)._M_current;
          __for_end._M_current = std::vector<data::ItemUseConfig>::end(&material_config_ptr->item_use)._M_current;
          while ( __gnu_cxx::operator!=<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>(
                    &__for_begin,
                    &__for_end) )
          {
            item_use_config = __gnu_cxx::__normal_iterator<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>::operator*(&__for_begin);
            if ( *(_BYTE *)(((unsigned __int64)&item_use_config->use_op >> 3) + 0x7FFF8000) != 0
              && *(_BYTE *)(((unsigned __int64)&item_use_config->use_op >> 3) + 0x7FFF8000) <= 3 )
            {
              __asan_report_load4(&item_use_config->use_op);
            }
            if ( item_use_config->use_op == ITEM_USE_OPEN_RANDOM_CHEST )
            {
              *(_DWORD *)(v4 + 48) = 0;
              if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
                     &item_use_config->use_param,
                     (unsigned int *)(v4 + 48)) )
              {
                common::milog::MiLogStream::create(
                  &v81,
                  &common::milog::MiLogDefault::default_log_obj_,
                  3u,
                  "./src/player/item/player_item_comp.cpp",
                  "checkUseItem",
                  924);
                common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(
                  &v81,
                  (const char (*)[18])"strVecToNum fails");
                common::milog::MiLogStream::~MiLogStream(&v81);
                v10 = -1;
                goto LABEL_111;
              }
              if ( *(_BYTE *)((reason >> 3) + 0x7FFF8000) != 0
                && (char)((reason & 7) + 3) >= *(_BYTE *)((reason >> 3) + 0x7FFF8000) )
              {
                __asan_report_load4(reason);
              }
              ActionReason::ActionReason(
                (ActionReason *const)(v4 + 256),
                *(proto::ActionReasonType *)reason,
                ITEM_LIMIT_RANDOM_CHEST);
              if ( *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) != 0
                && *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) <= 3 )
              {
                __asan_report_load4(use_param);
              }
              *(_DWORD *)(v4 + 32) = PlayerItemComp::checkFrontLooseGrantDropItems(
                                       this,
                                       *(_DWORD *)(v4 + 48),
                                       use_param->count,
                                       (const ActionReason *)(v4 + 256),
                                       0LL);
              if ( *(_DWORD *)(v4 + 32) )
              {
                common::milog::MiLogStream::create(
                  &v82,
                  &common::milog::MiLogDefault::default_log_obj_,
                  1u,
                  "./src/player/item/player_item_comp.cpp",
                  "checkUseItem",
                  931);
                v66 = common::milog::MiLogStream::operator<<<char [47],(char *[47])0>(
                        &v82,
                        (const char (*)[47])"checkFrontLooseGrantDropItems failed, drop_id:");
                v67 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                        v66,
                        (const unsigned int *)(v4 + 48));
                v68 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v67, (const char (*)[8])" count:");
                common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v68, &use_param->count);
                common::milog::MiLogStream::~MiLogStream(&v82);
                v10 = *(_DWORD *)(v4 + 32);
                goto LABEL_111;
              }
            }
            __gnu_cxx::__normal_iterator<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>::operator++(&__for_begin);
          }
          v10 = 0;
        }
        goto LABEL_111;
      }
      common::milog::MiLogStream::create(
        &v82,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkUseItem",
        905);
      v62 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
              &v82,
              (const char (*)[36])"Item filter use target failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    val = Player::getUid(this->player_);
    v63 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v62, &val);
    v64 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v63, (const char (*)[10])" item_id:");
    v65 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
    *(_DWORD *)(v4 + 48) = Item::getItemId(v65);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v64, (const unsigned int *)(v4 + 48));
    common::milog::MiLogStream::~MiLogStream(&v82);
    v10 = *(_DWORD *)(v4 + 32);
LABEL_111:
    std::vector<std::shared_ptr<Avatar>>::~vector((std::vector<std::shared_ptr<Avatar>> *const)(v4 + 192));
    goto LABEL_112;
  }
  common::milog::MiLogStream::create(
    &v82,
    &common::milog::MiLogDefault::default_log_obj_,
    3u,
    "./src/player/item/player_item_comp.cpp",
    "checkUseItem",
    817);
  v7 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
         &v82,
         (const char (*)[24])"Cannot use 0 item, uid:");
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  *(_DWORD *)(v4 + 48) = Player::getUid(this->player_);
  v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v4 + 48));
  v9 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v8, (const char (*)[12])" item_guid:");
  common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v9, (const unsigned __int64 *)(v4 + 64));
  common::milog::MiLogStream::~MiLogStream(&v82);
  v10 = -1;
LABEL_114:
  result = v10;
  if ( v83 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 942: range 0000000017CC2192-0000000017CC42AD
int32_t __cdecl PlayerItemComp::checkItemUseConfig(
        PlayerItemComp *const this,
        const data::MaterialExcelConfig *material_config,
        const ItemUseParam *use_param)
{
  int32_t v3; // r13d
  unsigned __int64 v4; // r14
  __int64 v5; // rax
  _DWORD *v6; // r12
  unsigned int *v7; // r8
  unsigned int *v8; // r9
  common::milog::MiLogStream *v9; // rcx
  PlayerAvatarComp *AvatarComp; // rax
  common::milog::MiLogStream *v11; // rcx
  PlayerAvatarComp *v12; // rcx
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rcx
  int v15; // r15d
  bool v16; // r15
  common::milog::MiLogStream *v17; // r13
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v18; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v19; // rax
  bool v20; // r15
  common::milog::MiLogStream *v21; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v22; // rax
  bool v23; // r15
  common::milog::MiLogStream *v24; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v25; // rax
  bool v26; // r15
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rax
  PlayerBattlePassComp *BattlePassComp; // r15
  PlayerBattlePassComp *v33; // rax
  uint32_t CurScheduleId; // eax
  PlayerRechargeComp *RechargeComp; // r15
  uint32_t PlatformType; // eax
  common::milog::MiLogStream *v37; // rax
  PlayerRechargeComp *v38; // rax
  common::milog::MiLogStream *v39; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v40; // rax
  bool v41; // r15
  common::milog::MiLogStream *v42; // rax
  common::milog::MiLogStream *v43; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v44; // rax
  bool v45; // r15
  common::milog::MiLogStream *v46; // rax
  common::milog::MiLogStream *v47; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v48; // rax
  bool v49; // r15
  common::milog::MiLogStream *v50; // rax
  common::milog::MiLogStream *v51; // rax
  PlayerHomeComp *HomeComp; // rax
  common::milog::MiLogStream *v54; // rax
  _BOOL4 v55; // r15d
  std::__shared_ptr_access<Home,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v56; // rax
  uint32_t HomeUid; // r15d
  _BOOL4 v58; // r15d
  Home *v59; // rax
  int v60; // r15d
  HomeModuleData *v61; // r15
  std::__shared_ptr_access<Scene,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v62; // rax
  uint32_t SceneId; // eax
  int32_t result; // eax
  int32_t ret_5; // [rsp+28h] [rbp-1D8h]
  int32_t ret_4; // [rsp+2Ch] [rbp-1D4h]
  int32_t ret_3; // [rsp+30h] [rbp-1D0h]
  int32_t ret_2; // [rsp+34h] [rbp-1CCh]
  int32_t ret_1; // [rsp+38h] [rbp-1C8h]
  unsigned int reward_id; // [rsp+3Ch] [rbp-1C4h]
  int32_t ret_0; // [rsp+40h] [rbp-1C0h]
  int32_t ret; // [rsp+44h] [rbp-1BCh]
  std::vector<data::ItemUseConfig>::const_iterator __for_begin; // [rsp+48h] [rbp-1B8h] BYREF
  std::vector<data::ItemUseConfig>::const_iterator __for_end; // [rsp+50h] [rbp-1B0h] BYREF
  const std::vector<data::ItemUseConfig> *__for_range; // [rsp+58h] [rbp-1A8h]
  const data::ItemUseConfig *item_use_config; // [rsp+60h] [rbp-1A0h]
  HomeSceneData *home_scene_data_ptr; // [rsp+68h] [rbp-198h]
  common::milog::MiLogStream v79; // [rsp+70h] [rbp-190h] BYREF
  char v80[368]; // [rsp+90h] [rbp-170h] BYREF

  v4 = (unsigned __int64)v80;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_3(320LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "9 48 4 18 need_item_num:1183 64 4 20 combine_item_id:1184 80 4 8 ret:1202 96 8 21 select_item_pa"
                        "ir:1103 128 16 19 home_world_ptr:1200 160 16 13 home_ptr:1201 192 16 18 cur_scene_ptr:1212 224 1"
                        "6 25 home_module_data_ptr:1217 256 24 20 add_item_reason:1112";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkItemUseConfig;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556943;
  v6[536862722] = -234556924;
  v6[536862723] = -218959360;
  v6[536862724] = -219021312;
  v6[536862725] = -219021312;
  v6[536862726] = -219021312;
  v6[536862727] = -219021312;
  v6[536862728] = -218103808;
  v6[536862729] = -202116109;
  __for_range = &material_config->item_use;
  __for_begin._M_current = std::vector<data::ItemUseConfig>::begin(&material_config->item_use)._M_current;
  __for_end._M_current = std::vector<data::ItemUseConfig>::end(&material_config->item_use)._M_current;
  while ( 2 )
  {
    if ( !__gnu_cxx::operator!=<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>(&__for_begin, &__for_end) )
    {
      v3 = 0;
      goto LABEL_146;
    }
    item_use_config = __gnu_cxx::__normal_iterator<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>::operator*(&__for_begin);
    if ( *(_BYTE *)(((unsigned __int64)&item_use_config->use_op >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&item_use_config->use_op >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&item_use_config->use_op);
    }
    switch ( item_use_config->use_op )
    {
      case ITEM_USE_ADD_EXP:
        common::milog::MiLogStream::create(
          &v79,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkItemUseConfig",
          952);
        v9 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(&v79, (const char (*)[35])off_2638C8E0);
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_11;
      case ITEM_USE_RELIVE_AVATAR:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        AvatarComp = Player::getAvatarComp(this->player_);
        if ( PlayerAvatarComp::isAllAvatarDead(AvatarComp) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            959);
          v11 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(&v79, (const char (*)[19])off_2638C940);
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          operator<<(v11, this->player_);
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = 114;
          goto LABEL_146;
        }
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v12 = Player::getAvatarComp(this->player_);
        if ( *(_BYTE *)(((unsigned __int64)&use_param->target_guid >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        PlayerAvatarComp::findAvatar((const PlayerAvatarComp *const)(v4 + 192), (uint64_t)v12, use_param->target_guid);
        if ( std::operator==<Avatar>((const std::shared_ptr<Avatar> *)(v4 + 192), 0LL) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            965);
          v13 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                  &v79,
                  (const char (*)[31])"findAvatar fails, target_guid:");
          v14 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v13, &use_param->target_guid);
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          operator<<(v14, this->player_);
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = 104;
          v15 = 0;
        }
        else
        {
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          Player::getAvatarComp(this->player_);
          PlayerAvatarComp::getCurAvatar((const PlayerAvatarComp *const)(v4 + 224));
          v16 = std::operator==<Avatar,Avatar>(
                  (const std::shared_ptr<Avatar> *)(v4 + 192),
                  (const std::shared_ptr<Avatar> *)(v4 + 224));
          std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v4 + 224));
          if ( v16 )
          {
            common::milog::MiLogStream::create(
              &v79,
              &common::milog::MiLogDefault::default_log_obj_,
              1u,
              "./src/player/item/player_item_comp.cpp",
              "checkItemUseConfig",
              970);
            v17 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
                    &v79,
                    (const char (*)[21])"avatar is cur avatar");
            v18 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 192));
            common::milog::MiLogStream::operator<<<Avatar,(Avatar*)0>(v17, v18);
            common::milog::MiLogStream::~MiLogStream(&v79);
            v3 = 124;
            v15 = 0;
          }
          else
          {
            v15 = 1;
          }
        }
        std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v4 + 192));
        if ( v15 != 1 )
          goto LABEL_146;
        goto LABEL_144;
      case ITEM_USE_UNLOCK_COOK_RECIPE:
        *(_DWORD *)(v4 + 80) = 0;
        if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
               &item_use_config->use_param,
               (unsigned int *)(v4 + 80)) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            980);
          common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v79, (const char (*)[18])"strVecToNum fails");
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)(v4 + 224));
        v19 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 224));
        v20 = data::CookExcelConfigMgrBase::findCookRecipeExcelConfig(
                &v19->design_config.txt_config_mgr.cook_config_mgr,
                *(_DWORD *)(v4 + 80)) == 0LL;
        std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 224));
        if ( !v20 )
          goto LABEL_144;
        common::milog::MiLogStream::create(
          &v79,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkItemUseConfig",
          985);
        v21 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                &v79,
                (const char (*)[35])"findCookRecipeExcelConfig failed: ");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, (const unsigned int *)(v4 + 80));
        common::milog::MiLogStream::~MiLogStream(&v79);
        v3 = -1;
        goto LABEL_146;
      case ITEM_USE_ADD_ITEM:
        *(_DWORD *)(v4 + 224) = 0;
        *(_DWORD *)(v4 + 228) = 0;
        *(_DWORD *)(v4 + 232) = 0;
        *(_DWORD *)(v4 + 236) = 0;
        if ( !common::tools::StringUtils::strVecToNum<0u,unsigned int,unsigned int &>(
                &item_use_config->use_param,
                (unsigned int *)(v4 + 224),
                (unsigned int *)(v4 + 228),
                (unsigned int *)&item_use_config->use_param) )
        {
          if ( *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(use_param);
          }
          *(_DWORD *)(v4 + 228) = SAFE_MULTIPLY<unsigned int,unsigned int>(*(_DWORD *)(v4 + 228), use_param->count);
          ActionReason::ActionReason((ActionReason *const)(v4 + 256), ACTION_REASON_NONE, ITEM_LIMIT_USE_ITEM);
          *(_BYTE *)(v4 + 270) = 0;
          ret = PlayerItemComp::checkAddItem(this, (const ItemParam *)(v4 + 224), (const ActionReason *)(v4 + 256));
          if ( ret == 661 )
          {
            v3 = 670;
            goto LABEL_146;
          }
          if ( ret )
          {
            v3 = ret;
            goto LABEL_146;
          }
LABEL_144:
          __gnu_cxx::__normal_iterator<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>::operator++(&__for_begin);
          continue;
        }
        common::milog::MiLogStream::create(
          &v79,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkItemUseConfig",
          1025);
        v28 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                &v79,
                (const char (*)[29])"strVecToNum fail, use_param:");
        v29 = common::milog::MiLogStream::operator<<<std::string>(v28, &item_use_config->use_param);
        v9 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v29, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
LABEL_11:
        operator<<(v9, this->player_);
        common::milog::MiLogStream::~MiLogStream(&v79);
        v3 = -1;
LABEL_146:
        result = v3;
        if ( v80 == (char *)v4 )
        {
          *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0LL;
        }
        else
        {
          *(_QWORD *)v4 = 1172321806LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
        }
        return result;
      case ITEM_USE_GRANT_SELECT_REWARD:
        if ( *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&use_param->option_idx);
        }
        reward_id = PlayerItemComp::getUseConfigSelectId<unsigned int>(this, item_use_config, use_param->option_idx);
        if ( !reward_id )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            1051);
          v30 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
                  &v79,
                  (const char (*)[38])"getUseConfigSelectId failed. item_id:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v30, &material_config->id);
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        ActionReason::ActionReason((ActionReason *const)(v4 + 256), ACTION_REASON_NONE, ITEM_LIMIT_USE_ITEM_REWARD);
        ret_0 = PlayerItemComp::checkGrantReward(this, reward_id, (const ActionReason *)(v4 + 256));
        if ( !ret_0 )
          goto LABEL_144;
        v3 = ret_0;
        goto LABEL_146;
      case ITEM_USE_ADD_SELECT_ITEM:
        *(_DWORD *)(v4 + 224) = 0;
        *(_DWORD *)(v4 + 228) = 0;
        *(_DWORD *)(v4 + 232) = 0;
        *(_DWORD *)(v4 + 236) = 0;
        if ( *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&use_param->option_idx);
        }
        *(_DWORD *)(v4 + 224) = PlayerItemComp::getUseConfigSelectId<unsigned int>(
                                  this,
                                  item_use_config,
                                  use_param->option_idx);
        if ( !*(_DWORD *)(v4 + 224) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            1068);
          v31 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
                  &v79,
                  (const char (*)[38])"getUseConfigSelectId failed. item_id:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v31, &material_config->id);
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        *(_DWORD *)(v4 + 228) = 1;
        ActionReason::ActionReason((ActionReason *const)(v4 + 256), ACTION_REASON_NONE, ITEM_LIMIT_USE_ITEM);
        *(_BYTE *)(v4 + 270) = 0;
        ret_1 = PlayerItemComp::checkAddItem(this, (const ItemParam *)(v4 + 224), (const ActionReason *)(v4 + 256));
        if ( !ret_1 )
          goto LABEL_144;
        v3 = ret_1;
        goto LABEL_146;
      case ITEM_USE_UNLOCK_PAID_BATTLE_PASS_NORMAL:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        BattlePassComp = Player::getBattlePassComp(this->player_);
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v33 = Player::getBattlePassComp(this->player_);
        CurScheduleId = PlayerBattlePassComp::getCurScheduleId(v33);
        ret_2 = PlayerBattlePassComp::checkCanBuyBattlePass(BattlePassComp, CurScheduleId, 1u);
        if ( !ret_2 )
          goto LABEL_144;
        v3 = ret_2;
        goto LABEL_146;
      case ITEM_USE_GAIN_CARD_PRODUCT:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        RechargeComp = Player::getRechargeComp(this->player_);
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        PlatformType = Player::getPlatformType(this->player_);
        ret_3 = PlayerRechargeComp::checkCanGetHcoinCardProduct(RechargeComp, 0LL, PlatformType);
        if ( !ret_3 )
          goto LABEL_144;
        common::milog::MiLogStream::create(
          &v79,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkItemUseConfig",
          1096);
        common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
          &v79,
          (const char (*)[34])"checkCanGetHcoinCardProduct fails");
        common::milog::MiLogStream::~MiLogStream(&v79);
        v3 = ret_3;
        goto LABEL_146;
      case ITEM_USE_UNLOCK_FORGE:
        *(_DWORD *)(v4 + 80) = 0;
        if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
               &item_use_config->use_param,
               (unsigned int *)(v4 + 80)) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            995);
          common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v79, (const char (*)[18])"strVecToNum fails");
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)(v4 + 224));
        v22 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 224));
        v23 = data::ForgeExcelConfigMgrBase::findForgeExcelConfig(
                &v22->design_config.txt_config_mgr.forge_config_mgr,
                *(_DWORD *)(v4 + 80)) == 0LL;
        std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 224));
        if ( !v23 )
          goto LABEL_144;
        common::milog::MiLogStream::create(
          &v79,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkItemUseConfig",
          1000);
        v24 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v79,
                (const char (*)[39])"findForgeExcelConfig failed, forge_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, (const unsigned int *)(v4 + 80));
        common::milog::MiLogStream::~MiLogStream(&v79);
        v3 = -1;
        goto LABEL_146;
      case ITEM_USE_UNLOCK_COMBINE:
        *(_DWORD *)(v4 + 80) = 0;
        if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
               &item_use_config->use_param,
               (unsigned int *)(v4 + 80)) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            1010);
          common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v79, (const char (*)[18])"strVecToNum fails");
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)(v4 + 224));
        v25 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 224));
        v26 = data::CombineExcelConfigMgrBase::findCombineExcelConfig(
                &v25->design_config.txt_config_mgr.combine_config_mgr,
                *(_DWORD *)(v4 + 80)) == 0LL;
        std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 224));
        if ( !v26 )
          goto LABEL_144;
        common::milog::MiLogStream::create(
          &v79,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkItemUseConfig",
          1015);
        v27 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                &v79,
                (const char (*)[43])"findCombineExcelConfig failed, combine_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, (const unsigned int *)(v4 + 80));
        common::milog::MiLogStream::~MiLogStream(&v79);
        v3 = -1;
        goto LABEL_146;
      case ITEM_USE_CHEST_SELECT_ITEM:
        if ( *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&use_param->option_idx);
        }
        *(std::pair<unsigned int,unsigned int> *)(v4 + 96) = PlayerItemComp::getUseConfigSelectIdAndCount(
                                                               this,
                                                               item_use_config,
                                                               use_param->option_idx);
        if ( !*(_DWORD *)(v4 + 96) || !*(_DWORD *)(v4 + 100) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            1106);
          v37 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                  &v79,
                  (const char (*)[46])"getUseConfigSelectIdAndCount failed, item_id:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v37, &material_config->id);
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        *(_DWORD *)(v4 + 224) = 0;
        *(_DWORD *)(v4 + 228) = 0;
        *(_DWORD *)(v4 + 232) = 0;
        *(_DWORD *)(v4 + 236) = 0;
        *(_DWORD *)(v4 + 224) = *(_DWORD *)(v4 + 96);
        if ( *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(use_param);
        }
        *(_DWORD *)(v4 + 228) = SAFE_MULTIPLY<unsigned int,unsigned int>(*(_DWORD *)(v4 + 100), use_param->count);
        ActionReason::ActionReason((ActionReason *const)(v4 + 256), ACTION_REASON_NONE, ITEM_LIMIT_USE_ITEM);
        *(_BYTE *)(v4 + 270) = 0;
        ret_4 = PlayerItemComp::checkAddItem(this, (const ItemParam *)(v4 + 224), (const ActionReason *)(v4 + 256));
        if ( !ret_4 )
          goto LABEL_144;
        v3 = ret_4;
        goto LABEL_146;
      case ITEM_USE_GAIN_RESIN_CARD_PRODUCT:
        *(_DWORD *)(v4 + 80) = 0;
        if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
               &item_use_config->use_param,
               (unsigned int *)(v4 + 80)) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            1126);
          common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v79, (const char (*)[18])"strVecToNum fails");
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v38 = Player::getRechargeComp(this->player_);
        ret_5 = PlayerRechargeComp::checkCanGetResinCardProduct(v38, *(_DWORD *)(v4 + 80));
        if ( !ret_5 )
          goto LABEL_144;
        v3 = ret_5;
        goto LABEL_146;
      case ITEM_USE_UNLOCK_FURNITURE_FORMULA:
        *(_DWORD *)(v4 + 80) = 0;
        if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
               &item_use_config->use_param,
               (unsigned int *)(v4 + 80)) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            1141);
          v39 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                  &v79,
                  (const char (*)[29])"strVecToNum fail, use_param:");
          common::milog::MiLogStream::operator<<<std::string>(v39, &item_use_config->use_param);
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)(v4 + 224));
        v40 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 224));
        v41 = data::HomeWorldExcelConfigMgrBase::findHomeWorldFurnitureExcelConfig(
                &v40->design_config.txt_config_mgr.home_config_mgr,
                *(_DWORD *)(v4 + 80)) == 0LL;
        std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 224));
        if ( !v41 )
          goto LABEL_144;
        common::milog::MiLogStream::create(
          &v79,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkItemUseConfig",
          1146);
        v42 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                &v79,
                (const char (*)[43])"findHomeWorldFurnitureExcelConfig failed: ");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v42, (const unsigned int *)(v4 + 80));
        common::milog::MiLogStream::~MiLogStream(&v79);
        v3 = -1;
        goto LABEL_146;
      case ITEM_USE_UNLOCK_FURNITURE_SUITE:
        *(_DWORD *)(v4 + 80) = 0;
        if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
               &item_use_config->use_param,
               (unsigned int *)(v4 + 80)) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            1156);
          v43 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                  &v79,
                  (const char (*)[29])"strVecToNum fail, use_param:");
          common::milog::MiLogStream::operator<<<std::string>(v43, &item_use_config->use_param);
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)(v4 + 224));
        v44 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 224));
        v45 = data::HomeWorldExcelConfigMgrBase::findFurnitureSuiteExcelConfig(
                &v44->design_config.txt_config_mgr.home_config_mgr,
                *(_DWORD *)(v4 + 80)) == 0LL;
        std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 224));
        if ( !v45 )
          goto LABEL_144;
        common::milog::MiLogStream::create(
          &v79,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkItemUseConfig",
          1161);
        v46 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v79,
                (const char (*)[39])"findFurnitureSuiteExcelConfig failed: ");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v46, (const unsigned int *)(v4 + 80));
        common::milog::MiLogStream::~MiLogStream(&v79);
        v3 = -1;
        goto LABEL_146;
      case ITEM_USE_ADD_CHANNELLER_SLAB_BUFF:
        *(_DWORD *)(v4 + 80) = 0;
        if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
               &item_use_config->use_param,
               (unsigned int *)(v4 + 80)) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            1171);
          v47 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                  &v79,
                  (const char (*)[29])"strVecToNum fail, use_param:");
          common::milog::MiLogStream::operator<<<std::string>(v47, &item_use_config->use_param);
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)(v4 + 224));
        v48 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 224));
        v49 = data::ActivityChannellerSlabExcelConfigMgrBase::findChannellerSlabBuffExcelConfig(
                &v48->design_config.txt_config_mgr.activity_channeller_slab_config_mgr,
                *(_DWORD *)(v4 + 80)) == 0LL;
        std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 224));
        if ( !v49 )
          goto LABEL_144;
        common::milog::MiLogStream::create(
          &v79,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkItemUseConfig",
          1176);
        v50 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                &v79,
                (const char (*)[43])"findChannellerSlabBuffExcelConfig failed: ");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v50, (const unsigned int *)(v4 + 80));
        common::milog::MiLogStream::~MiLogStream(&v79);
        v3 = -1;
        goto LABEL_146;
      case ITEM_USE_COMBINE_ITEM:
        *(_DWORD *)(v4 + 48) = 0;
        *(_DWORD *)(v4 + 64) = 0;
        *(_DWORD *)(v4 + 80) = 0;
        if ( common::tools::StringUtils::strVecToNum<0u,unsigned int,unsigned int &,unsigned int &>(
               &item_use_config->use_param,
               (unsigned int *)(v4 + 48),
               (unsigned int *)(v4 + 64),
               (unsigned int *)(v4 + 80),
               v7,
               v8) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            1188);
          v51 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                  &v79,
                  (const char (*)[29])"strVecToNum fail, use_param:");
          common::milog::MiLogStream::operator<<<std::string>(v51, &item_use_config->use_param);
          common::milog::MiLogStream::~MiLogStream(&v79);
          v3 = -1;
          goto LABEL_146;
        }
        if ( *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(use_param);
        }
        if ( use_param->count == *(_DWORD *)(v4 + 48) )
          goto LABEL_144;
        v3 = 700;
        goto LABEL_146;
      case ITEM_USE_UNLOCK_HOME_BGM:
        std::shared_ptr<HomeWorld>::shared_ptr((std::shared_ptr<HomeWorld> *const)(v4 + 128), 0LL);
        std::shared_ptr<Home>::shared_ptr((std::shared_ptr<Home> *const)(v4 + 160), 0LL);
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        HomeComp = Player::getHomeComp(this->player_);
        *(_DWORD *)(v4 + 80) = PlayerHomeComp::getCurHomeWorldAndHome(
                                 HomeComp,
                                 (HomeWorldPtr *)(v4 + 128),
                                 (HomePtr *)(v4 + 160));
        if ( *(_DWORD *)(v4 + 80)
          || std::operator==<HomeWorld>((const std::shared_ptr<HomeWorld> *)(v4 + 128), 0LL)
          || std::operator==<Home>((const std::shared_ptr<Home> *)(v4 + 160), 0LL) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "checkItemUseConfig",
            1205);
          v54 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                  &v79,
                  (const char (*)[36])"getCurHomeWorldAndHome failed. ret:");
          common::milog::MiLogStream::operator<<<int,(int *)0>(v54, (const int *)(v4 + 80));
          common::milog::MiLogStream::~MiLogStream(&v79);
          if ( *(_DWORD *)(v4 + 80) )
            v3 = *(_DWORD *)(v4 + 80);
          else
            v3 = -1;
          v55 = 0;
        }
        else
        {
          v56 = std::__shared_ptr_access<Home,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Home,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 160));
          HomeUid = Home::getHomeUid(v56);
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          if ( HomeUid == Player::getUid(this->player_) )
          {
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            Player::getSceneComp(this->player_);
            PlayerSceneComp::getCurScene((const PlayerSceneComp *const)(v4 + 192));
            if ( std::operator==<Scene>((const std::shared_ptr<Scene> *)(v4 + 192), 0LL) )
            {
              v3 = 555;
              v58 = 0;
            }
            else
            {
              v59 = std::__shared_ptr_access<Home,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Home,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 160));
              Home::getSceneComp(v59);
              HomeSceneComp::getCurHomeModuleData((HomeSceneComp *const)(v4 + 224));
              if ( std::operator==<HomeModuleData>((const std::shared_ptr<HomeModuleData> *)(v4 + 224), 0LL) )
              {
                common::milog::MiLogStream::create(
                  &v79,
                  &common::milog::MiLogDefault::default_log_obj_,
                  1u,
                  "./src/player/item/player_item_comp.cpp",
                  "checkItemUseConfig",
                  1220);
                common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                  &v79,
                  (const char (*)[36])"getCurHomeModuleData() return null.");
                common::milog::MiLogStream::~MiLogStream(&v79);
                v3 = 9701;
                v60 = 0;
              }
              else
              {
                v61 = std::__shared_ptr_access<HomeModuleData,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<HomeModuleData,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 224));
                v62 = std::__shared_ptr_access<Scene,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Scene,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 192));
                SceneId = Scene::getSceneId(v62);
                home_scene_data_ptr = HomeModuleData::findHomeSceneData(v61, SceneId);
                if ( home_scene_data_ptr )
                {
                  if ( *(char *)(((unsigned __int64)&home_scene_data_ptr->arrangement_data.has_change_bgm_furniture >> 3)
                               + 0x7FFF8000) < 0 )
                    __asan_report_load1(&home_scene_data_ptr->arrangement_data.has_change_bgm_furniture);
                  if ( !home_scene_data_ptr->arrangement_data.has_change_bgm_furniture )
                  {
                    v3 = 9794;
                    v60 = 0;
                  }
                  else
                  {
                    v60 = 1;
                  }
                }
                else
                {
                  v3 = 9713;
                  v60 = 0;
                }
              }
              std::shared_ptr<HomeModuleData>::~shared_ptr((std::shared_ptr<HomeModuleData> *const)(v4 + 224));
              v58 = v60 != 0;
            }
            std::shared_ptr<Scene>::~shared_ptr((std::shared_ptr<Scene> *const)(v4 + 192));
            v55 = v58;
          }
          else
          {
            v3 = 9714;
            v55 = 0;
          }
        }
        std::shared_ptr<Home>::~shared_ptr((std::shared_ptr<Home> *const)(v4 + 160));
        std::shared_ptr<HomeWorld>::~shared_ptr((std::shared_ptr<HomeWorld> *const)(v4 + 128));
        if ( v55 )
          goto LABEL_144;
        goto LABEL_146;
      default:
        goto LABEL_144;
    }
  }
};

// Line 1242: range 0000000017CC42AE-0000000017CC50F1
void __fastcall PlayerItemComp::useItem(
        PlayerItemComp *const this,
        uint64_t item_guid,
        const ItemUseParam *use_param,
        const SubItemReason *reason)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  common::milog::MiLogStream *v7; // r14
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  unsigned __int64 v11; // rdx
  common::milog::MiLogStream *v12; // r14
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v15; // rax
  common::milog::MiLogStream *v16; // r14
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v19; // rax
  std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v20; // rax
  uint64_t target_guid; // rdi
  common::milog::MiLogStream *v22; // r14
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v25; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v26; // rax
  common::milog::MiLogStream *v27; // r14
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v30; // rax
  common::milog::MiLogStream *v31; // rax
  common::milog::MiLogStream *v32; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v33; // rax
  PlayerEventComp *EventComp; // r14
  PlayerGmComp *GmComp; // rax
  unsigned int Uid; // [rsp+2Ch] [rbp-194h] BYREF
  unsigned int val; // [rsp+30h] [rbp-190h] BYREF
  int ret; // [rsp+34h] [rbp-18Ch]
  std::vector<data::ItemUseConfig>::const_iterator __for_begin; // [rsp+38h] [rbp-188h] BYREF
  std::vector<data::ItemUseConfig>::const_iterator __for_end; // [rsp+40h] [rbp-180h] BYREF
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+48h] [rbp-178h]
  const std::vector<data::ItemUseConfig> *__for_range; // [rsp+50h] [rbp-170h]
  const data::ItemUseConfig *item_use_config; // [rsp+58h] [rbp-168h]
  std::shared_ptr<UseItemEvent> __r; // [rsp+60h] [rbp-160h] BYREF
  common::milog::MiLogStream v48; // [rsp+70h] [rbp-150h] BYREF
  char v49[304]; // [rsp+90h] [rbp-130h] BYREF

  v4 = (unsigned __int64)v49;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(256LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "6 32 8 14 item_guid:1241 64 16 13 item_ptr:1243 96 16 17 material_ptr:1256 128 16 15 item_param:"
                        "1285 160 16 14 event_ptr:1299 192 24 15 target_vec:1270";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::useItem;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -218959360;
  v6[536862722] = -219021312;
  v6[536862723] = -219021312;
  v6[536862724] = -219021312;
  v6[536862725] = -219021312;
  v6[536862726] = -218103808;
  v6[536862727] = -202116109;
  *(_QWORD *)(v4 + 32) = item_guid;
  ItemStore::findItem((ItemStore *const)(v4 + 64), (uint64_t)&this->pack_store_, *(_QWORD *)(v4 + 32));
  if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v4 + 64), 0LL) )
  {
    common::milog::MiLogStream::create(
      &v48,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "useItem",
      1246);
    v7 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
           &v48,
           (const char (*)[21])"findItem fails, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &val);
    v9 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v8, (const char (*)[12])" item_guid:");
    common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v9, (const unsigned __int64 *)(v4 + 32));
    common::milog::MiLogStream::~MiLogStream(&v48);
    goto LABEL_56;
  }
  v10 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
  if ( *(_BYTE *)(((unsigned __int64)v10 >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  v11 = (unsigned __int64)(v10->_vptr_Item + 9);
  if ( *(_BYTE *)((v11 >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  if ( (*(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v11)(v10) == 2 )
  {
    std::dynamic_pointer_cast<Material,Item>((const std::shared_ptr<Item> *)(v4 + 96));
    if ( std::operator==<Material>((const std::shared_ptr<Material> *)(v4 + 96), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v48,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "useItem",
        1259);
      v16 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
              &v48,
              (const char (*)[34])"dynamic_pointer_cast failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
LABEL_19:
      Uid = Player::getUid(this->player_);
      v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, &Uid);
      v18 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v17, (const char (*)[10])" item_id:");
      v19 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
      val = Item::getItemId(v19);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, &val);
      common::milog::MiLogStream::~MiLogStream(&v48);
LABEL_55:
      std::shared_ptr<Material>::~shared_ptr((std::shared_ptr<Material> *const)(v4 + 96));
      goto LABEL_56;
    }
    v20 = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
    material_config_ptr = Material::getMaterialConfig(v20);
    if ( !material_config_ptr )
    {
      common::milog::MiLogStream::create(
        &v48,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "useItem",
        1266);
      v16 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
              &v48,
              (const char (*)[31])"getMaterialConfig failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_19;
    }
    std::vector<std::shared_ptr<Avatar>>::vector((std::vector<std::shared_ptr<Avatar>> *const)(v4 + 192));
    if ( *(_BYTE *)(((unsigned __int64)&use_param->target_guid >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    target_guid = use_param->target_guid;
    if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_target >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)material_config_ptr + 100) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_target >> 3)
                                                                          + 0x7FFF8000) )
    {
      target_guid = (uint64_t)&material_config_ptr->use_target;
      __asan_report_load4(&material_config_ptr->use_target);
    }
    ret = PlayerItemComp::getUseTarget(
            this,
            material_config_ptr->use_target,
            target_guid,
            (std::vector<std::shared_ptr<Avatar>> *)(v4 + 192));
    if ( ret )
    {
      common::milog::MiLogStream::create(
        &v48,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "useItem",
        1274);
      v22 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
              &v48,
              (const char (*)[33])"Item get use target failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    else
    {
      ret = PlayerItemComp::filterUseTarget(
              this,
              material_config_ptr,
              (std::vector<std::shared_ptr<Avatar>> *)(v4 + 192));
      if ( !ret )
      {
        *(_QWORD *)(v4 + 128) = 0LL;
        *(_QWORD *)(v4 + 136) = 0LL;
        v26 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        *(_DWORD *)(v4 + 128) = Item::getItemId(v26);
        if ( *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(use_param);
        }
        *(_DWORD *)(v4 + 132) = use_param->count;
        if ( PlayerItemComp::subItem(this, (const ItemParam *)(v4 + 128), reason) )
        {
          common::milog::MiLogStream::create(
            &v48,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "useItem",
            1288);
          v27 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
                  &v48,
                  (const char (*)[21])"subItem failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          Uid = Player::getUid(this->player_);
          v28 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, &Uid);
          v29 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v28, (const char (*)[10])" item_id:");
          v30 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          val = Item::getItemId(v30);
          v31 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v29, &val);
          v32 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v31, (const char (*)[8])" count:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v32, &use_param->count);
          common::milog::MiLogStream::~MiLogStream(&v48);
        }
        else
        {
          __for_range = &material_config_ptr->item_use;
          __for_begin._M_current = std::vector<data::ItemUseConfig>::begin(&material_config_ptr->item_use)._M_current;
          __for_end._M_current = std::vector<data::ItemUseConfig>::end(&material_config_ptr->item_use)._M_current;
          while ( __gnu_cxx::operator!=<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>(
                    &__for_begin,
                    &__for_end) )
          {
            item_use_config = __gnu_cxx::__normal_iterator<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>::operator*(&__for_begin);
            if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_target >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)material_config_ptr + 100) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_target >> 3)
                                                                                  + 0x7FFF8000) )
            {
              __asan_report_load4(&material_config_ptr->use_target);
            }
            PlayerItemComp::internalUseItem(
              this,
              item_use_config,
              (const ItemParam *)(v4 + 128),
              material_config_ptr->use_target,
              (const std::vector<std::shared_ptr<Avatar>> *)(v4 + 192),
              use_param,
              reason);
            __gnu_cxx::__normal_iterator<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>::operator++(&__for_begin);
          }
          PlayerItemComp::afterUseItem(
            this,
            material_config_ptr,
            (const std::vector<std::shared_ptr<Avatar>> *)(v4 + 192),
            use_param);
          v33 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          val = Item::getItemId(v33);
          common::tools::perf::make_shared<UseItemEvent,unsigned int,unsigned int const&>(
            (unsigned int *)&__r,
            &val,
            &use_param->count,
            &val);
          std::shared_ptr<BaseEvent>::shared_ptr<UseItemEvent,void>((std::shared_ptr<BaseEvent> *const)(v4 + 160), &__r);
          std::shared_ptr<UseItemEvent>::~shared_ptr(&__r);
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          EventComp = Player::getEventComp(this->player_);
          std::shared_ptr<BaseEvent>::shared_ptr(
            (std::shared_ptr<BaseEvent> *const)&__r,
            (const std::shared_ptr<BaseEvent> *)(v4 + 160));
          PlayerEventComp::notifyEvent(EventComp, (BaseEventPtr *)&__r);
          std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)&__r);
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          GmComp = Player::getGmComp(this->player_);
          if ( !PlayerGmComp::getGmSetValue<bool>(GmComp, 0) )
            PlayerItemComp::updateItemCd(this, material_config_ptr);
          std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)(v4 + 160));
        }
        goto LABEL_54;
      }
      common::milog::MiLogStream::create(
        &v48,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "useItem",
        1281);
      v22 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
              &v48,
              (const char (*)[36])"Item filter use target failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    Uid = Player::getUid(this->player_);
    v23 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, &Uid);
    v24 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v23, (const char (*)[10])" item_id:");
    v25 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
    val = Item::getItemId(v25);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, &val);
    common::milog::MiLogStream::~MiLogStream(&v48);
LABEL_54:
    std::vector<std::shared_ptr<Avatar>>::~vector((std::vector<std::shared_ptr<Avatar>> *const)(v4 + 192));
    goto LABEL_55;
  }
  common::milog::MiLogStream::create(
    &v48,
    &common::milog::MiLogDefault::default_log_obj_,
    4u,
    "./src/player/item/player_item_comp.cpp",
    "useItem",
    1252);
  v12 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
          &v48,
          (const char (*)[22])"Item not usable, uid:");
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  Uid = Player::getUid(this->player_);
  v13 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v12, &Uid);
  v14 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v13, (const char (*)[10])" item_id:");
  v15 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
  val = Item::getItemId(v15);
  common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &val);
  common::milog::MiLogStream::~MiLogStream(&v48);
LABEL_56:
  std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v4 + 64));
  if ( v49 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 1311: range 0000000017CC50F2-0000000017CC5B28
AddItemResult *__fastcall PlayerItemComp::autoUseItem(
        unsigned __int64 retstr,
        PlayerItemComp *const this,
        uint32_t item_id,
        unsigned __int64 item_count,
        const ActionReason *reason)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rsi
  __int64 v13; // rdx
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  __int64 v18; // rsi
  uint32_t v19; // ecx
  char v20; // dl
  __int64 v21; // rdx
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  PlayerEventComp *EventComp; // r14
  std::vector<data::ItemUseConfig>::const_iterator __for_begin; // [rsp+30h] [rbp-180h] BYREF
  std::vector<data::ItemUseConfig>::const_iterator __for_end; // [rsp+38h] [rbp-178h] BYREF
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+40h] [rbp-170h]
  const std::vector<data::ItemUseConfig> *__for_range; // [rsp+48h] [rbp-168h]
  const data::ItemUseConfig *item_use_config; // [rsp+50h] [rbp-160h]
  SubItemReason v36; // [rsp+58h] [rbp-158h] BYREF
  common::milog::MiLogStream v37; // [rsp+60h] [rbp-150h] BYREF
  char v38[304]; // [rsp+80h] [rbp-130h] BYREF

  v5 = (unsigned __int64)v38;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(256LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "6 32 4 14 use_count:1324 48 4 12 item_id:1310 64 16 14 event_ptr:1362 96 16 19 use_item_param:13"
                        "56 128 24 14 use_param:1335 192 24 15 target_vec:1344";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::autoUseItem;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556924;
  v7[536862722] = -219021312;
  v7[536862723] = -219021312;
  v7[536862724] = -234881024;
  v7[536862725] = -218959118;
  v7[536862726] = -218103808;
  v7[536862727] = -202116109;
  *(_DWORD *)(v5 + 48) = item_id;
  if ( *(_BYTE *)((retstr >> 3) + 0x7FFF8000) )
    __asan_report_store8(retstr, this);
  *(_QWORD *)retstr = 0LL;
  if ( *(_BYTE *)(((retstr + 8) >> 3) + 0x7FFF8000) != 0 && *(_BYTE *)(((retstr + 8) >> 3) + 0x7FFF8000) <= 3 )
    __asan_report_store4(retstr + 8, this, retstr + 8);
  *(_DWORD *)(retstr + 8) = 0;
  v8 = (((_BYTE)retstr + 12) & 7u) + 3;
  v9 = (*(_BYTE *)(((retstr + 12) >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((retstr + 12) & 7) + 3) >= *(_BYTE *)(((retstr + 12) >> 3) + 0x7FFF8000));
  if ( (_BYTE)v9 )
    __asan_report_store4(retstr + 12, v8, v9);
  *(_DWORD *)(retstr + 12) = 0;
  if ( *(_BYTE *)(((retstr + 16) >> 3) + 0x7FFF8000) != 0 && *(_BYTE *)(((retstr + 16) >> 3) + 0x7FFF8000) <= 3 )
    __asan_report_store4(retstr + 16, v8, retstr + 16);
  *(_DWORD *)(retstr + 16) = 0;
  v10 = ((_BYTE)retstr + 20) & 7;
  v11 = (*(_BYTE *)(((retstr + 20) >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)v10 >= *(_BYTE *)(((retstr + 20) >> 3) + 0x7FFF8000));
  if ( (_BYTE)v11 )
    __asan_report_store1(retstr + 20, v10, v11);
  *(_BYTE *)(retstr + 20) = 0;
  v12 = ((_BYTE)retstr + 21) & 7;
  v13 = (*(_BYTE *)(((retstr + 21) >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)v12 >= *(_BYTE *)(((retstr + 21) >> 3) + 0x7FFF8000));
  if ( (_BYTE)v13 )
    __asan_report_store1(retstr + 21, v12, v13);
  *(_BYTE *)(retstr + 21) = 0;
  *(_DWORD *)(retstr + 8) = *(_DWORD *)(v5 + 48);
  *(_BYTE *)(retstr + 20) = 1;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)(v5 + 96));
  v14 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
  material_config_ptr = data::MaterialExcelConfigMgrBase::findMaterialExcelConfig(
                          &v14->design_config.txt_config_mgr.material_config_mgr,
                          *(_DWORD *)(v5 + 48));
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v5 + 96));
  if ( material_config_ptr )
  {
    if ( *(char *)(((unsigned __int64)&material_config_ptr->use_on_gain >> 3) + 0x7FFF8000) < 0 )
      __asan_report_load1(&material_config_ptr->use_on_gain);
    if ( material_config_ptr->use_on_gain )
    {
      if ( *(_BYTE *)((item_count >> 3) + 0x7FFF8000) != 0
        && (char)((item_count & 7) + 3) >= *(_BYTE *)((item_count >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_count);
      }
      *(_DWORD *)(v5 + 32) = *(_DWORD *)item_count;
      if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->material_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)material_config_ptr + 76) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->material_type >> 3)
                                                                           + 0x7FFF8000) )
      {
        __asan_report_load4(&material_config_ptr->material_type);
      }
      if ( material_config_ptr->material_type == MATERIAL_AVATAR && *(_DWORD *)(v5 + 32) )
        *(_DWORD *)(v5 + 32) = 1;
      if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&material_config_ptr->stack_limit);
      }
      if ( material_config_ptr->stack_limit < *(_DWORD *)(v5 + 32) )
        *(_DWORD *)(v5 + 32) = material_config_ptr->stack_limit;
      *(_DWORD *)(v5 + 128) = 0;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_DWORD *)(v5 + 144) = 0;
      *(_DWORD *)(v5 + 128) = *(_DWORD *)(v5 + 32);
      if ( !PlayerItemComp::checkItemUseConfig(this, material_config_ptr, (const ItemUseParam *)(v5 + 128)) )
      {
        std::vector<std::shared_ptr<Avatar>>::vector((std::vector<std::shared_ptr<Avatar>> *const)(v5 + 192));
        if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_target >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)material_config_ptr + 100) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_target >> 3)
                                                                              + 0x7FFF8000) )
        {
          __asan_report_load4(&material_config_ptr->use_target);
        }
        if ( PlayerItemComp::getUseTarget(
               this,
               material_config_ptr->use_target,
               0LL,
               (std::vector<std::shared_ptr<Avatar>> *)(v5 + 192)) )
        {
          common::milog::MiLogStream::create(
            &v37,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "autoUseItem",
            1347);
          v15 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                  &v37,
                  (const char (*)[31])"getUseTarget fail. use_target:");
          v16 = common::milog::MiLogStream::operator<<<data::ItemUseTarget,(data::ItemUseTarget*)0>(
                  v15,
                  &material_config_ptr->use_target);
          v17 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v16, (const char (*)[10])" item_id:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, (const unsigned int *)(v5 + 48));
          common::milog::MiLogStream::~MiLogStream(&v37);
        }
        else
        {
          v18 = (unsigned int)(item_count & 7) + 3;
          if ( *(_BYTE *)((item_count >> 3) + 0x7FFF8000) != 0
            && (char)((item_count & 7) + 3) >= *(_BYTE *)((item_count >> 3) + 0x7FFF8000) )
          {
            __asan_report_load4(item_count);
          }
          *(_DWORD *)item_count -= *(_DWORD *)(v5 + 32);
          v19 = *(_DWORD *)(v5 + 32);
          v20 = *(_BYTE *)(((retstr + 12) >> 3) + 0x7FFF8000);
          LOBYTE(v18) = v20 != 0;
          v21 = (v20 != 0) & (unsigned __int8)((char)(((retstr + 12) & 7) + 3) >= v20);
          if ( (_BYTE)v21 )
            __asan_report_store4(retstr + 12, v18, v21);
          *(_DWORD *)(retstr + 12) = v19;
          __for_range = &material_config_ptr->item_use;
          __for_begin._M_current = std::vector<data::ItemUseConfig>::begin(&material_config_ptr->item_use)._M_current;
          __for_end._M_current = std::vector<data::ItemUseConfig>::end(&material_config_ptr->item_use)._M_current;
          while ( __gnu_cxx::operator!=<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>(
                    &__for_begin,
                    &__for_end) )
          {
            item_use_config = __gnu_cxx::__normal_iterator<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>::operator*(&__for_begin);
            *(_QWORD *)(v5 + 96) = 0LL;
            *(_QWORD *)(v5 + 104) = 0LL;
            *(_DWORD *)(v5 + 96) = *(_DWORD *)(v5 + 48);
            *(_DWORD *)(v5 + 100) = *(_DWORD *)(v5 + 32);
            SubItemReason::SubItemReason(&v36, reason);
            if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_target >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)material_config_ptr + 100) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->use_target >> 3)
                                                                                  + 0x7FFF8000) )
            {
              __asan_report_load4(&material_config_ptr->use_target);
            }
            PlayerItemComp::internalUseItem(
              this,
              item_use_config,
              (const ItemParam *)(v5 + 96),
              material_config_ptr->use_target,
              (const std::vector<std::shared_ptr<Avatar>> *)(v5 + 192),
              (const ItemUseParam *)(v5 + 128),
              &v36);
            __gnu_cxx::__normal_iterator<data::ItemUseConfig const*,std::vector<data::ItemUseConfig>>::operator++(&__for_begin);
          }
          common::milog::MiLogStream::create(
            &v37,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "autoUseItem",
            1360);
          v22 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
                  &v37,
                  (const char (*)[24])"auto use item. item_id:");
          v23 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v22,
                  (const unsigned int *)(v5 + 48));
          v24 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v23, (const char (*)[12])" use_count:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, (const unsigned int *)(v5 + 32));
          common::milog::MiLogStream::~MiLogStream(&v37);
          common::tools::perf::make_shared<UseItemEvent,unsigned int &,unsigned int &>(
            (unsigned int *)(v5 + 96),
            (unsigned int *)(v5 + 48),
            (unsigned int *)(v5 + 32),
            (unsigned int *)(v5 + 48));
          std::shared_ptr<BaseEvent>::shared_ptr<UseItemEvent,void>(
            (std::shared_ptr<BaseEvent> *const)(v5 + 64),
            (std::shared_ptr<UseItemEvent> *)(v5 + 96));
          std::shared_ptr<UseItemEvent>::~shared_ptr((std::shared_ptr<UseItemEvent> *const)(v5 + 96));
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          EventComp = Player::getEventComp(this->player_);
          std::shared_ptr<BaseEvent>::shared_ptr(
            (std::shared_ptr<BaseEvent> *const)(v5 + 96),
            (const std::shared_ptr<BaseEvent> *)(v5 + 64));
          PlayerEventComp::notifyEvent(EventComp, (BaseEventPtr *)(v5 + 96));
          std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)(v5 + 96));
          std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)(v5 + 64));
        }
        std::vector<std::shared_ptr<Avatar>>::~vector((std::vector<std::shared_ptr<Avatar>> *const)(v5 + 192));
      }
    }
  }
  if ( v38 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8018) = 0LL;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return (AddItemResult *)retstr;
};

// Line 1371: range 0000000017CC5B2A-0000000017CC5E1D
std::vector<ItemParam> *__cdecl PlayerItemComp::autoUseItemBatch(
        std::vector<ItemParam> *retstr,
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec,
        std::vector<AddItemResult> *result_vec,
        const ActionReason *reason)
{
  unsigned __int64 v5; // rbx
  __int64 v6; // rax
  _DWORD *v7; // r13
  const ItemParam *v8; // rax
  uint32_t item_id; // [rsp+3Ch] [rbp-D4h]
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+40h] [rbp-D0h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+48h] [rbp-C8h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+50h] [rbp-C0h]
  const ItemParam *item_param; // [rsp+58h] [rbp-B8h]
  std::vector<ItemParam>::value_type __x; // [rsp+60h] [rbp-B0h] BYREF
  char v19[160]; // [rsp+70h] [rbp-A0h] BYREF

  v5 = (unsigned __int64)v19;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_1(128LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "2 48 4 15 item_count:1376 64 24 15 add_result:1377";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::autoUseItemBatch;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556943;
  v7[536862722] = -218103808;
  v7[536862723] = -202116109;
  std::vector<ItemParam>::vector(retstr);
  __for_range = item_param_vec;
  __for_begin._M_current = std::vector<ItemParam>::begin(item_param_vec)._M_current;
  __for_end._M_current = std::vector<ItemParam>::end(item_param_vec)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
  {
    v8 = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
    item_param = v8;
    if ( *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v8 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v8);
    }
    item_id = item_param->item_id;
    if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&item_param->count);
    }
    *(_DWORD *)(v5 + 48) = item_param->count;
    PlayerItemComp::autoUseItem(v5 + 64, this, item_id, v5 + 48, reason);
    if ( *(_DWORD *)(v5 + 48) )
    {
      __x.item_id = item_id;
      __x.count = *(_DWORD *)(v5 + 48);
      __x.level = 0;
      __x.promote_level = 0;
      std::vector<ItemParam>::push_back(retstr, &__x);
    }
    if ( *(_DWORD *)(v5 + 76) )
      std::vector<AddItemResult>::push_back(result_vec, (const std::vector<AddItemResult>::value_type *)(v5 + 64));
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
  }
  if ( v19 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return retstr;
};

// Line 1393: range 0000000017CC5E1E-0000000017CC659C
std::vector<std::shared_ptr<Item>> *__cdecl PlayerItemComp::autoUseItemBatch(
        std::vector<std::shared_ptr<Item>> *retstr,
        PlayerItemComp *const this,
        const std::vector<std::shared_ptr<Item>> *item_vec,
        std::vector<AddItemResult> *result_vec,
        const ActionReason *reason)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  const std::shared_ptr<Item> *v8; // rax
  common::milog::MiLogStream *v9; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v11; // rax
  unsigned __int64 v12; // rdx
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v13; // rax
  common::milog::MiLogStream *v14; // r14
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // r14
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  Material *v20; // rax
  unsigned int val; // [rsp+3Ch] [rbp-144h] BYREF
  std::vector<std::shared_ptr<Item>>::const_iterator __for_begin; // [rsp+40h] [rbp-140h] BYREF
  std::vector<std::shared_ptr<Item>>::const_iterator __for_end; // [rsp+48h] [rbp-138h] BYREF
  const std::vector<std::shared_ptr<Item>> *__for_range; // [rsp+50h] [rbp-130h]
  const data::ItemConfig *item_config_ptr; // [rsp+58h] [rbp-128h]
  std::shared_ptr<Config> v30; // [rsp+60h] [rbp-120h] BYREF
  common::milog::MiLogStream v31; // [rsp+70h] [rbp-110h] BYREF
  char v32[240]; // [rsp+90h] [rbp-F0h] BYREF

  v5 = (unsigned __int64)v32;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(192LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "5 32 4 12 item_id:1403 48 4 15 item_count:1404 64 16 13 item_ptr:1395 96 16 17 material_ptr:1418"
                        " 128 24 15 add_result:1425";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::autoUseItemBatch;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556924;
  v7[536862722] = -219021312;
  v7[536862723] = -219021312;
  v7[536862724] = -218103808;
  v7[536862725] = -202116109;
  std::vector<std::shared_ptr<Item>>::vector(retstr);
  __for_range = item_vec;
  __for_begin._M_current = std::vector<std::shared_ptr<Item>>::begin(item_vec)._M_current;
  __for_end._M_current = std::vector<std::shared_ptr<Item>>::end(item_vec)._M_current;
  while ( __gnu_cxx::operator!=<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>(
            &__for_begin,
            &__for_end) )
  {
    v8 = __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator*(&__for_begin);
    std::shared_ptr<Item>::shared_ptr((std::shared_ptr<Item> *const)(v5 + 64), v8);
    if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v5 + 64), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v31,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "autoUseItemBatch",
        1399);
      v9 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
             &v31,
             (const char (*)[26])"item_ptr is nullptr, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &val);
      common::milog::MiLogStream::~MiLogStream(&v31);
    }
    else
    {
      v10 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
      *(_DWORD *)(v5 + 32) = Item::getItemId(v10);
      v11 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
      if ( *(_BYTE *)(((unsigned __int64)v11 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v12 = (unsigned __int64)(v11->_vptr_Item + 8);
      if ( *(_BYTE *)((v12 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      *(_DWORD *)(v5 + 48) = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v12)(v11);
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v30);
      v13 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v30);
      item_config_ptr = ItemExcelConfigMgr::findItemConfig(
                          &v13->design_config.txt_config_mgr.item_config_mgr,
                          *(_DWORD *)(v5 + 32));
      std::shared_ptr<Config>::~shared_ptr(&v30);
      if ( item_config_ptr )
      {
        if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                         + 0x7FFF8000) )
        {
          __asan_report_load4(&item_config_ptr->item_type);
        }
        if ( item_config_ptr->item_type == ITEM_MATERIAL )
        {
          std::dynamic_pointer_cast<Material,Item>((const std::shared_ptr<Item> *)(v5 + 96));
          if ( std::operator==<Material>((const std::shared_ptr<Material> *)(v5 + 96), 0LL) )
          {
            common::milog::MiLogStream::create(
              &v31,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "autoUseItemBatch",
              1421);
            v17 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
                    &v31,
                    (const char (*)[34])"dynamic_pointer_cast failed, uid:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, &val);
            v19 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v18, (const char (*)[10])" item_id:");
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v19, (const unsigned int *)(v5 + 32));
            common::milog::MiLogStream::~MiLogStream(&v31);
          }
          else
          {
            PlayerItemComp::autoUseItem(v5 + 128, this, *(_DWORD *)(v5 + 32), v5 + 48, reason);
            if ( *(_DWORD *)(v5 + 48) )
            {
              v20 = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
              Material::setCount(v20, *(_DWORD *)(v5 + 48));
              std::shared_ptr<Item>::shared_ptr<Material,void>(
                (std::shared_ptr<Item> *const)&v30,
                (const std::shared_ptr<Material> *)(v5 + 96));
              std::vector<std::shared_ptr<Item>>::push_back(
                retstr,
                (std::vector<std::shared_ptr<Item>>::value_type *)&v30);
              std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)&v30);
            }
            if ( *(_DWORD *)(v5 + 140) )
              std::vector<AddItemResult>::push_back(
                result_vec,
                (const std::vector<AddItemResult>::value_type *)(v5 + 128));
          }
          std::shared_ptr<Material>::~shared_ptr((std::shared_ptr<Material> *const)(v5 + 96));
        }
        else
        {
          std::vector<std::shared_ptr<Item>>::push_back(
            retstr,
            (const std::vector<std::shared_ptr<Item>>::value_type *)(v5 + 64));
        }
      }
      else
      {
        common::milog::MiLogStream::create(
          &v31,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "autoUseItemBatch",
          1409);
        v14 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
                &v31,
                (const char (*)[28])"findItemConfig failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        v15 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &val);
        v16 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v15, (const char (*)[10])" item_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, (const unsigned int *)(v5 + 32));
        common::milog::MiLogStream::~MiLogStream(&v31);
      }
    }
    std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v5 + 64));
    __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator++(&__for_begin);
  }
  if ( v32 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0LL;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return retstr;
};

// Line 1442: range 0000000017CC659E-0000000017CCC471
void __cdecl PlayerItemComp::internalUseItem(
        PlayerItemComp *const this,
        const data::ItemUseConfig *item_use_config,
        const ItemParam *use_item_param,
        data::ItemUseTarget target,
        const std::vector<std::shared_ptr<Avatar>> *target_vec,
        const ItemUseParam *use_param,
        const SubItemReason *reason)
{
  unsigned __int64 v7; // r13
  __int64 v8; // rax
  _DWORD *v9; // r12
  std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  FormalAvatar *v11; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  common::milog::MiLogStream *v13; // r14
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // r14
  TransferItemParam *v19; // rax
  TransferItemParam *v20; // rdx
  common::milog::MiLogStream *v21; // rcx
  std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v22; // rax
  FormalAvatar *v23; // rax
  const std::shared_ptr<Avatar> *v24; // rax
  Avatar *v25; // rax
  __m128i v26; // xmm0
  PlayerBasicComp *BasicComp; // rax
  PlayerBasicComp *v28; // rax
  PlayerBasicComp *v29; // rax
  __m128i v30; // xmm0
  const std::shared_ptr<Avatar> *v31; // rax
  __int64 v32; // rsi
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v33; // rax
  unsigned __int64 v34; // rax
  char v35; // dl
  __int64 v36; // rdx
  std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v37; // rax
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v38; // r14
  common::milog::MiLogStream *v39; // rcx
  PlayerAvatarComp *AvatarComp; // rax
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v41; // rax
  float *v42; // r8
  float *v43; // r9
  common::milog::MiLogStream *v44; // r14
  common::milog::MiLogStream *v45; // rax
  common::milog::MiLogStream *v46; // rax
  __m128i v47; // xmm0
  __m128i v48; // xmm0
  char *v49; // rsi
  const std::shared_ptr<Avatar> *v50; // rax
  common::milog::MiLogStream *v51; // rcx
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v52; // rax
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v53; // rax
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v54; // rax
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v55; // rax
  unsigned __int64 v56; // rax
  char v57; // dl
  __int64 v58; // rdx
  std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v59; // rax
  __int64 v60; // rax
  char v61; // dl
  char *v62; // rsi
  _BOOL8 v63; // rdx
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v64; // rax
  unsigned __int64 v65; // rdx
  char v66; // al
  __m128i v67; // xmm0
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v68; // rax
  float *v69; // rax
  float *v70; // rdx
  __m128i v71; // xmm0
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v72; // rax
  uint64_t Guid; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v74; // rax
  __m128i v75; // xmm0
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v76; // r14
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v77; // r14
  PlayerEventComp *EventComp; // r14
  PlayerAvatarComp *v79; // rax
  const std::shared_ptr<Avatar> *v80; // rax
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v81; // rax
  BuffComp *BuffComp; // rax
  PlayerAvatarComp *v83; // rax
  const std::shared_ptr<Avatar> *v84; // rax
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v85; // rax
  BuffComp *v86; // rax
  PlayerCookComp *CookComp; // rax
  common::milog::MiLogStream *v88; // rax
  PlayerForgeComp *ForgeComp; // rax
  common::milog::MiLogStream *v90; // rax
  PlayerCombineComp *CombineComp; // rax
  common::milog::MiLogStream *v92; // rax
  uint32_t v93; // esi
  uint32_t LogLevel; // eax
  common::milog::MiLogStream *v95; // rax
  common::milog::MiLogStream *v96; // rax
  common::milog::MiLogStream *v97; // rax
  PlayerAvatarComp *v98; // rcx
  common::milog::MiLogStream *v99; // rax
  PlayerSocialComp *SocialComp; // rcx
  common::milog::MiLogStream *v101; // rax
  PlayerBattlePassComp *BattlePassComp; // r14
  uint32_t PlatformType; // r15d
  PlayerBattlePassComp *v104; // rax
  uint32_t CurScheduleId; // eax
  common::milog::MiLogStream *v106; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v107; // rax
  PlayerRechargeComp *RechargeComp; // rax
  common::milog::MiLogStream *v109; // rax
  common::milog::MiLogStream *v110; // rax
  common::milog::MiLogStream *v111; // rcx
  PlayerCodexComp *CodexComp; // rax
  common::milog::MiLogStream *v113; // rax
  common::milog::MiLogStream *v114; // rax
  common::milog::MiLogStream *v115; // rax
  PlayerRechargeComp *v116; // rax
  common::milog::MiLogStream *v117; // rax
  PlayerHomeComp *HomeComp; // rax
  common::milog::MiLogStream *v119; // rax
  common::milog::MiLogStream *v120; // rax
  PlayerHomeComp *v121; // rax
  common::milog::MiLogStream *v122; // rax
  common::milog::MiLogStream *v123; // rax
  common::milog::MiLogStream *v124; // rcx
  ChannellerSlabActivity *v125; // rax
  common::milog::MiLogStream *v126; // rax
  common::milog::MiLogStream *v127; // rax
  PlayerAvatarComp *v128; // rcx
  common::milog::MiLogStream *v129; // rax
  common::milog::MiLogStream *v130; // rax
  common::milog::MiLogStream *v131; // rax
  common::milog::MiLogStream *v132; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v133; // rax
  common::milog::MiLogStream *v134; // rax
  common::milog::MiLogStream *v135; // rax
  PlayerHomeComp *v136; // rax
  common::milog::MiLogStream *v137; // rax
  char v138; // r14
  char v139; // r15
  const std::string *v140; // rax
  common::milog::MiLogStream *v141; // rax
  PlayerHomeComp *v142; // rax
  common::milog::MiLogStream *v143; // rax
  common::milog::MiLogStream *v144; // rax
  const std::string *v145; // rax
  common::milog::MiLogStream *v146; // rbx
  const std::string *v147; // rax
  common::milog::MiLogStream *v148; // rax
  common::milog::MiLogStream *v149; // rax
  common::milog::MiLogStream *v150; // rax
  __m128i v151; // xmm0
  PlayerRegionalPlayComp *v152; // rax
  PlayerRegionalPlayComp *RegionalPlayComp; // rax
  common::milog::MiLogStream *v154; // rax
  common::milog::MiLogStream *v155; // rax
  common::milog::MiLogStream *v156; // rcx
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v157; // rax
  ExtraPropComp *ExtraPropComp; // rax
  common::milog::MiLogStream *v159; // r14
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v160; // rax
  common::milog::MiLogStream *v161; // rax
  common::milog::MiLogStream *v162; // rax
  common::milog::MiLogStream *v163; // rax
  PlayerGCGComp *GCGComp; // rax
  GCGDeckSystem *DeckSystem; // rax
  common::milog::MiLogStream *v166; // rax
  common::milog::MiLogStream *v167; // rax
  common::milog::MiLogStream *v168; // rax
  common::milog::MiLogStream *v169; // rax
  const std::string *v170; // rax
  common::milog::MiLogStream *v171; // rax
  const std::string *v172; // rax
  common::milog::MiLogStream *v173; // rax
  PlayerGCGComp *v174; // rax
  GCGDeckSystem *v175; // rax
  common::milog::MiLogStream *v176; // rax
  common::milog::MiLogStream *v177; // rax
  common::milog::MiLogStream *v178; // r14
  common::milog::MiLogStream *v179; // rax
  common::milog::MiLogStream *v180; // rax
  common::milog::MiLogStream *v181; // rax
  PlayerGCGComp *v182; // rax
  GCGDeckSystem *v183; // rax
  common::milog::MiLogStream *v184; // rax
  common::milog::MiLogStream *v185; // rax
  common::milog::MiLogStream *v186; // rax
  common::milog::MiLogStream *v187; // rax
  PlayerGCGComp *v188; // rax
  GCGDeckSystem *v189; // rax
  common::milog::MiLogStream *v190; // rax
  common::milog::MiLogStream *v191; // rax
  common::milog::MiLogStream *v192; // rax
  float CurEnergy; // [rsp+20h] [rbp-450h]
  bool v196; // [rsp+20h] [rbp-450h]
  std::allocator<char> __a; // [rsp+4Dh] [rbp-423h] BYREF
  bool is_cur_avatar; // [rsp+4Eh] [rbp-422h]
  bool is_new_item; // [rsp+4Fh] [rbp-421h]
  float final_add_energy; // [rsp+50h] [rbp-420h]
  uint32_t count; // [rsp+54h] [rbp-41Ch]
  uint32_t config_id; // [rsp+5Ch] [rbp-414h]
  uint32_t reward_id; // [rsp+60h] [rbp-410h]
  uint32_t buff_time_ms; // [rsp+64h] [rbp-40Ch]
  uint32_t cur_team_size; // [rsp+68h] [rbp-408h]
  float charge_efficiency; // [rsp+6Ch] [rbp-404h]
  float energy_charge_ratio; // [rsp+70h] [rbp-400h]
  uint32_t avatar_repeat_count; // [rsp+74h] [rbp-3FCh]
  std::vector<data::IdCountConfig>::const_iterator __for_begin; // [rsp+78h] [rbp-3F8h] BYREF
  const data::HomeworldModuleExcelConfig *module_config_ptr; // [rsp+80h] [rbp-3F0h]
  const std::vector<std::shared_ptr<Avatar>> *__for_range_6; // [rsp+88h] [rbp-3E8h]
  const std::vector<std::shared_ptr<Avatar>> *__for_range_5; // [rsp+90h] [rbp-3E0h]
  uint64_t cur_avatar_guid; // [rsp+98h] [rbp-3D8h]
  const std::vector<std::shared_ptr<Avatar>> *__for_range_2; // [rsp+A0h] [rbp-3D0h]
  std::vector<std::shared_ptr<Avatar>> *__for_range_3; // [rsp+A8h] [rbp-3C8h]
  std::vector<std::shared_ptr<Avatar>> *__for_range_4; // [rsp+B0h] [rbp-3C0h]
  AvatarPtr *avatar_ptr_0; // [rsp+B8h] [rbp-3B8h]
  AvatarPtr *avatar_ptr; // [rsp+C0h] [rbp-3B0h]
  const std::vector<std::shared_ptr<Avatar>> *__for_range_1; // [rsp+C8h] [rbp-3A8h]
  const std::vector<std::shared_ptr<Avatar>> *__for_range_0; // [rsp+D0h] [rbp-3A0h]
  PlayerAvatarComp *avatar_comp; // [rsp+D8h] [rbp-398h]
  const std::vector<data::IdCountConfig> *award_item_vec_ptr; // [rsp+E0h] [rbp-390h]
  const std::vector<data::IdCountConfig> *__for_range; // [rsp+E8h] [rbp-388h]
  const data::IdCountConfig *award_item; // [rsp+F0h] [rbp-380h]
  proto::AddNoGachaAvatarCardTransferItem *proto_item_param; // [rsp+F8h] [rbp-378h]
  common::milog::MiLogStream v229; // [rsp+100h] [rbp-370h] BYREF
  char v230[848]; // [rsp+120h] [rbp-350h] BYREF

  v7 = (unsigned __int64)v230;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v8 = __asan_stack_malloc_4(800LL);
    if ( v8 )
      v7 = v8;
  }
  *(_QWORD *)v7 = 1102416563LL;
  *(_QWORD *)(v7 + 8) = "18 32 4 12 item_id:1443 48 4 14 elem_type:1608 64 4 20 elem_add_energy:1609 80 4 12 card_id:2102"
                        " 96 4 13 field_id:2143 112 4 8 ret:2149 128 8 21 select_item_pair:1889 160 16 19 cur_avatar_ptr:"
                        "1597 192 16 21 notify_param_ptr:1656 224 16 14 event_ptr:1683 256 16 22 player_avatar_ptr:2074 2"
                        "88 20 24 transfer_item_param:1488 352 24 13 cur_team:1604 416 24 24 random_chest_reason:1783 480"
                        " 24 20 home_bgm_id_vec:2016 544 28 10 param:1561 608 48 21 fight_prop_guard:1509 688 72 16 show_notify:1462";
  *(_QWORD *)(v7 + 16) = PlayerItemComp::internalUseItem;
  v9 = (_DWORD *)(v7 >> 3);
  v9[536862720] = -235802127;
  v9[536862721] = -234556924;
  v9[536862722] = -234556924;
  v9[536862723] = -234556924;
  v9[536862724] = -218959360;
  v9[536862725] = -219021312;
  v9[536862726] = -219021312;
  v9[536862727] = -219021312;
  v9[536862728] = -219021312;
  v9[536862729] = -234618880;
  v9[536862730] = -218959118;
  v9[536862731] = -234881024;
  v9[536862732] = -218959118;
  v9[536862733] = -234881024;
  v9[536862734] = -218959118;
  v9[536862735] = -234881024;
  v9[536862736] = -218959118;
  v9[536862737] = 0x4000000;
  v9[536862738] = -218959118;
  v9[536862740] = -219021312;
  v9[536862741] = 62194;
  v9[536862743] = -218103808;
  v9[536862744] = -202116109;
  if ( *(_BYTE *)(((unsigned __int64)use_item_param >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)use_item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)use_item_param >> 3)
                                                                     + 0x7FFF8000) )
  {
    __asan_report_load4(use_item_param);
  }
  *(_DWORD *)(v7 + 32) = use_item_param->item_id;
  if ( *(_BYTE *)(((unsigned __int64)&use_item_param->count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)use_item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&use_item_param->count >> 3)
                                                                 + 0x7FFF8000) )
  {
    __asan_report_load4(&use_item_param->count);
  }
  count = use_item_param->count;
  if ( *(_BYTE *)(((unsigned __int64)&item_use_config->use_op >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&item_use_config->use_op >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&item_use_config->use_op);
  }
  switch ( item_use_config->use_op )
  {
    case ITEM_USE_GAIN_AVATAR:
      *(_DWORD *)(v7 + 48) = 0;
      *(_DWORD *)(v7 + 64) = 1;
      *(_DWORD *)(v7 + 80) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 48)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1459);
        common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v229, (const char (*)[18])"strVecToNum fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
        goto LABEL_378;
      }
      proto::AddNoGachaAvatarCardNotify::AddNoGachaAvatarCardNotify((proto::AddNoGachaAvatarCardNotify *const)(v7 + 688));
      proto::AddNoGachaAvatarCardNotify::set_item_id(
        (proto::AddNoGachaAvatarCardNotify *const)(v7 + 688),
        *(_DWORD *)(v7 + 32));
      common::tools::StringUtils::strVecToNum<1u,unsigned int,unsigned int &>(
        &item_use_config->use_param,
        (unsigned int *)(v7 + 64),
        (unsigned int *)(v7 + 80),
        (unsigned int *)&item_use_config->use_param);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      avatar_comp = Player::getAvatarComp(this->player_);
      PlayerAvatarComp::findFormalAvatarByAvatarId((const PlayerAvatarComp *const)(v7 + 224), (uint32_t)avatar_comp);
      if ( std::operator!=<FormalAvatar>((const std::shared_ptr<FormalAvatar> *)(v7 + 224), 0LL) )
      {
        v10 = std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 224));
        avatar_repeat_count = FormalAvatar::getAvatarRepeatCount(v10);
        v11 = std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 224));
        FormalAvatar::setAvatarRepeatCount(v11, avatar_repeat_count + 1);
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)(v7 + 256));
        v12 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
        award_item_vec_ptr = MaterialExcelConfigMgr::findAvatarRepeatAward(
                               &v12->design_config.txt_config_mgr.material_config_mgr,
                               *(_DWORD *)(v7 + 48),
                               avatar_repeat_count + 1);
        std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v7 + 256));
        if ( !award_item_vec_ptr )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1474);
          v13 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                  &v229,
                  (const char (*)[35])"findAvatarRepeatAward failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          *(_DWORD *)(v7 + 96) = Player::getUid(this->player_);
          v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v13,
                  (const unsigned int *)(v7 + 96));
          v15 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v14, (const char (*)[12])" avatar_id:");
          v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v15,
                  (const unsigned int *)(v7 + 48));
          v17 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(
                  v16,
                  (const char (*)[15])" repeat_count:");
          *(_DWORD *)(v7 + 112) = avatar_repeat_count + 1;
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, (const unsigned int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
          goto LABEL_53;
        }
        if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(reason);
        }
        ActionReason::ActionReason((ActionReason *const)(v7 + 480), reason->reason_type, ITEM_LIMIT_UNLIMITED);
        *(_BYTE *)(v7 + 492) = 1;
        *(_BYTE *)(v7 + 494) = 0;
        if ( PlayerItemComp::checkAddItemBatch(this, award_item_vec_ptr, (const ActionReason *)(v7 + 480)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1482);
          v18 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                  &v229,
                  (const char (*)[31])"checkAddItemBatch failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          *(_DWORD *)(v7 + 112) = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, (const unsigned int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
          goto LABEL_53;
        }
        __for_range = award_item_vec_ptr;
        __for_begin._M_current = std::vector<data::IdCountConfig>::begin(award_item_vec_ptr)._M_current;
        *(std::vector<data::IdCountConfig>::const_iterator *)(v7 + 128) = std::vector<data::IdCountConfig>::end(award_item_vec_ptr);
        while ( __gnu_cxx::operator!=<data::IdCountConfig const*,std::vector<data::IdCountConfig>>(
                  &__for_begin,
                  (const __gnu_cxx::__normal_iterator<const data::IdCountConfig*,std::vector<data::IdCountConfig> > *)(v7 + 128)) )
        {
          award_item = __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator*(&__for_begin);
          if ( *(_BYTE *)(((unsigned __int64)&award_item->id >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)&award_item->id >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(&award_item->id);
          }
          is_new_item = PlayerItemComp::isNewItem(this, award_item->id);
          *(_DWORD *)(v7 + 288) = 0;
          *(_DWORD *)(v7 + 292) = 0;
          *(_DWORD *)(v7 + 296) = 0;
          *(_DWORD *)(v7 + 300) = 0;
          *(_BYTE *)(v7 + 304) = 0;
          if ( *(_BYTE *)(((unsigned __int64)&award_item->id >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)&award_item->id >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(&award_item->id);
          }
          *(_DWORD *)(v7 + 288) = award_item->id;
          if ( *(_BYTE *)(((unsigned __int64)&award_item->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)award_item + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&award_item->count >> 3)
                                                                      + 0x7FFF8000) )
          {
            __asan_report_load4(&award_item->count);
          }
          *(_DWORD *)(v7 + 292) = award_item->count;
          *(_BYTE *)(v7 + 304) = is_new_item;
          v19 = std::move<TransferItemParam &>((TransferItemParam *)(v7 + 288));
          std::vector<TransferItemParam>::emplace_back<TransferItemParam>(&this->transfer_item_vec_, v19, v20);
          proto_item_param = proto::AddNoGachaAvatarCardNotify::add_transfer_item_list((proto::AddNoGachaAvatarCardNotify *const)(v7 + 688));
          if ( *(_BYTE *)(((unsigned __int64)&award_item->id >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)&award_item->id >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(&award_item->id);
          }
          proto::AddNoGachaAvatarCardTransferItem::set_item_id(proto_item_param, award_item->id);
          if ( *(_BYTE *)(((unsigned __int64)&award_item->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)award_item + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&award_item->count >> 3)
                                                                      + 0x7FFF8000) )
          {
            __asan_report_load4(&award_item->count);
          }
          proto::AddNoGachaAvatarCardTransferItem::set_count(proto_item_param, award_item->count);
          proto::AddNoGachaAvatarCardTransferItem::set_is_new(proto_item_param, is_new_item);
          __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator++(&__for_begin);
        }
        PlayerItemComp::addItemBatch(this, award_item_vec_ptr, (const ActionReason *)(v7 + 480), 0LL);
        proto::AddNoGachaAvatarCardNotify::set_is_transfer_to_item(
          (proto::AddNoGachaAvatarCardNotify *const)(v7 + 688),
          1);
        goto LABEL_47;
      }
      if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(reason);
      }
      PlayerAvatarComp::addFormalAvatar(
        (PlayerAvatarComp *const)(v7 + 256),
        avatar_comp,
        *(_DWORD *)(v7 + 48),
        1u,
        4u,
        reason->reason_type);
      std::shared_ptr<FormalAvatar>::operator=(
        (std::shared_ptr<FormalAvatar> *const)(v7 + 224),
        (std::shared_ptr<FormalAvatar> *)(v7 + 256));
      std::shared_ptr<FormalAvatar>::~shared_ptr((std::shared_ptr<FormalAvatar> *const)(v7 + 256));
      if ( !std::operator==<FormalAvatar>(0LL, (const std::shared_ptr<FormalAvatar> *)(v7 + 224)) )
      {
        FightPropGuard::FightPropGuard((FightPropGuard *const)(v7 + 608));
        v22 = std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 224));
        FightPropGuard::addCreature((FightPropGuard *const)(v7 + 608), v22, 0);
        v23 = std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 224));
        FormalAvatar::setInitialLevelAndPromoteLevel(v23, *(_DWORD *)(v7 + 64), *(_DWORD *)(v7 + 80));
        proto::AddNoGachaAvatarCardNotify::set_avatar_id(
          (proto::AddNoGachaAvatarCardNotify *const)(v7 + 688),
          *(_DWORD *)(v7 + 48));
        proto::AddNoGachaAvatarCardNotify::set_initial_level(
          (proto::AddNoGachaAvatarCardNotify *const)(v7 + 688),
          *(_DWORD *)(v7 + 64));
        proto::AddNoGachaAvatarCardNotify::set_initial_promote_level(
          (proto::AddNoGachaAvatarCardNotify *const)(v7 + 688),
          *(_DWORD *)(v7 + 80));
        proto::AddNoGachaAvatarCardNotify::set_is_transfer_to_item(
          (proto::AddNoGachaAvatarCardNotify *const)(v7 + 688),
          0);
        FightPropGuard::~FightPropGuard((FightPropGuard *const)(v7 + 608));
LABEL_47:
        if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(reason);
        }
        if ( reason->reason_type != ACTION_REASON_GACHA )
        {
          proto::AddNoGachaAvatarCardNotify::set_reason(
            (proto::AddNoGachaAvatarCardNotify *const)(v7 + 688),
            reason->reason_type);
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          Player::sendProto(this->player_, (const google::protobuf::Message *)(v7 + 688));
        }
        goto LABEL_53;
      }
      common::milog::MiLogStream::create(
        &v229,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "internalUseItem",
        1506);
      v21 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
              &v229,
              (const char (*)[22])"addFormalAvatar fails");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v21, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v229);
LABEL_53:
      std::shared_ptr<FormalAvatar>::~shared_ptr((std::shared_ptr<FormalAvatar> *const)(v7 + 224));
      proto::AddNoGachaAvatarCardNotify::~AddNoGachaAvatarCardNotify((proto::AddNoGachaAvatarCardNotify *const)(v7 + 688));
      goto LABEL_378;
    case ITEM_USE_RELIVE_AVATAR:
      __for_range_0 = target_vec;
      __for_begin._M_current = (const data::IdCountConfig *)std::vector<std::shared_ptr<Avatar>>::begin(target_vec)._M_current;
      *(std::vector<std::shared_ptr<Avatar>>::const_iterator *)(v7 + 128) = std::vector<std::shared_ptr<Avatar>>::end(target_vec);
      while ( __gnu_cxx::operator!=<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>(
                (const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)&__for_begin,
                (const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)(v7 + 128)) )
      {
        v24 = __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator*((const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
        std::shared_ptr<Avatar>::shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 256), v24);
        v25 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
        Avatar::setLifeAlive(v25, 0x67u, 0LL, 1);
        std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 256));
        __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator++((__gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
      }
      goto LABEL_378;
    case ITEM_USE_ADD_PERSIST_STAMINA:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,float>(&item_use_config->use_param, (float *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1535);
        common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v229, (const char (*)[18])"strVecToNum fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        v26 = _mm_cvtsi32_si128(*(_DWORD *)(v7 + 112));
        *(float *)v26.m128i_i32 = SAFE_MULTIPLY<float,unsigned int>(*(float *)v26.m128i_i32, count);
        *(_DWORD *)(v7 + 112) = _mm_cvtsi128_si32(v26);
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        BasicComp = Player::getBasicComp(this->player_);
        PlayerBasicComp::addPersistStaminaLimit(BasicComp, *(float *)(v7 + 112), 1, PROP_CHANGE_ITEM);
      }
      goto LABEL_378;
    case ITEM_USE_ADD_TEMPORARY_STAMINA:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,float>(&item_use_config->use_param, (float *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1547);
        common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v229, (const char (*)[18])"strVecToNum fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v28 = Player::getBasicComp(this->player_);
        PlayerBasicComp::setTemporaryStamina(v28, *(float *)(v7 + 112), 1, PROP_CHANGE_ITEM);
      }
      goto LABEL_378;
    case ITEM_USE_ADD_CUR_STAMINA:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,float>(&item_use_config->use_param, (float *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1558);
        common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v229, (const char (*)[18])"strVecToNum fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        *(_QWORD *)(v7 + 544) = 0LL;
        *(_QWORD *)(v7 + 552) = 0LL;
        *(_QWORD *)(v7 + 560) = 0LL;
        *(_DWORD *)(v7 + 568) = 0;
        *(_DWORD *)(v7 + 544) = 7;
        *(_DWORD *)(v7 + 568) = 5;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v29 = Player::getBasicComp(this->player_);
        PlayerBasicComp::changeCurStamina(v29, *(float *)(v7 + 112), v7 + 544, 1);
      }
      goto LABEL_378;
    case ITEM_USE_ADD_CUR_HP:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,float>(&item_use_config->use_param, (float *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1572);
        common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v229, (const char (*)[18])"strVecToNum fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        v30 = _mm_cvtsi32_si128(*(_DWORD *)(v7 + 112));
        *(float *)v30.m128i_i32 = SAFE_MULTIPLY<float,unsigned int>(*(float *)v30.m128i_i32, count);
        *(_DWORD *)(v7 + 112) = _mm_cvtsi128_si32(v30);
        __for_range_1 = target_vec;
        __for_begin._M_current = (const data::IdCountConfig *)std::vector<std::shared_ptr<Avatar>>::begin(target_vec)._M_current;
        *(std::vector<std::shared_ptr<Avatar>>::const_iterator *)(v7 + 128) = std::vector<std::shared_ptr<Avatar>>::end(target_vec);
        while ( __gnu_cxx::operator!=<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>(
                  (const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)&__for_begin,
                  (const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)(v7 + 128)) )
        {
          v31 = __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator*((const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
          std::shared_ptr<Avatar>::shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 192), v31);
          v32 = 0LL;
          if ( std::operator==<Avatar>((const std::shared_ptr<Avatar> *)(v7 + 192), 0LL) )
          {
            common::milog::MiLogStream::create(
              &v229,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "internalUseItem",
              1580);
            common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
              &v229,
              (const char (*)[22])"avatar_ptr is nullptr");
            common::milog::MiLogStream::~MiLogStream(&v229);
          }
          else
          {
            v33 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192));
            if ( Creature::getLifeState(v33) == LIFE_ALIVE )
            {
              common::tools::perf::make_shared<FightPropNtfParam>();
              v34 = (unsigned __int64)std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 224));
              v35 = *(_BYTE *)((v34 >> 3) + 0x7FFF8000);
              LOBYTE(v32) = v35 != 0;
              v36 = (v35 != 0) & (unsigned __int8)(v35 <= 3);
              if ( (_BYTE)v36 )
                v34 = __asan_report_store4(v34, v32, v36);
              *(_DWORD *)v34 = 5;
              v37 = std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 224));
              std::vector<unsigned int>::push_back(
                &v37->param_vec,
                (const std::vector<unsigned int>::value_type *)(v7 + 32));
              v38 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192));
              std::shared_ptr<FightPropNtfParam>::shared_ptr(
                (std::shared_ptr<FightPropNtfParam> *const)(v7 + 256),
                (const std::shared_ptr<FightPropNtfParam> *)(v7 + 224));
              Creature::changeCurHp(
                v38,
                *(float *)(v7 + 112),
                CHANGE_HP_ADD_ITEM,
                1,
                (FightPropNtfParamPtr *)(v7 + 256));
              std::shared_ptr<FightPropNtfParam>::~shared_ptr((std::shared_ptr<FightPropNtfParam> *const)(v7 + 256));
              std::shared_ptr<FightPropNtfParam>::~shared_ptr((std::shared_ptr<FightPropNtfParam> *const)(v7 + 224));
            }
          }
          std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 192));
          __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator++((__gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
        }
      }
      goto LABEL_378;
    case ITEM_USE_ADD_ELEM_ENERGY:
    case ITEM_USE_ADD_ALL_ENERGY:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getAvatarComp(this->player_);
      PlayerAvatarComp::getCurAvatar((const PlayerAvatarComp *const)(v7 + 160));
      if ( !std::operator==<Avatar>((const std::shared_ptr<Avatar> *)(v7 + 160), 0LL) )
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        AvatarComp = Player::getAvatarComp(this->player_);
        PlayerAvatarComp::getMyAvatarTeamInSceneTeam((std::vector<long unsigned int> *)(v7 + 352), AvatarComp);
        v41 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 160));
        cur_avatar_guid = Avatar::getGuid(v41);
        cur_team_size = std::vector<unsigned long>::size((const std::vector<long unsigned int> *const)(v7 + 352));
        *(_DWORD *)(v7 + 48) = 0;
        *(_DWORD *)(v7 + 64) = 0;
        *(_DWORD *)(v7 + 80) = 0;
        if ( *(_BYTE *)(((unsigned __int64)&item_use_config->use_op >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&item_use_config->use_op >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&item_use_config->use_op);
        }
        if ( item_use_config->use_op == ITEM_USE_ADD_ELEM_ENERGY )
        {
          if ( common::tools::StringUtils::strVecToNum<0u,int,float &,float &>(
                 &item_use_config->use_param,
                 (int *)(v7 + 48),
                 (float *)(v7 + 64),
                 (float *)(v7 + 80),
                 v42,
                 v43) )
          {
            common::milog::MiLogStream::create(
              &v229,
              &common::milog::MiLogDefault::default_log_obj_,
              4u,
              "./src/player/item/player_item_comp.cpp",
              "internalUseItem",
              1615);
            v44 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
                    &v229,
                    (const char (*)[24])"strVecToNum fails, uid:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
LABEL_97:
            *(_DWORD *)(v7 + 112) = Player::getUid(this->player_);
            v45 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v44,
                    (const unsigned int *)(v7 + 112));
            v46 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(
                    v45,
                    (const char (*)[12])" use_param:");
            common::milog::MiLogStream::operator<<<std::string>(v46, &item_use_config->use_param);
            common::milog::MiLogStream::~MiLogStream(&v229);
LABEL_143:
            std::vector<unsigned long>::~vector((std::vector<long unsigned int> *const)(v7 + 352));
            goto LABEL_144;
          }
          v47 = _mm_cvtsi32_si128(*(_DWORD *)(v7 + 80));
          *(float *)v47.m128i_i32 = SAFE_MULTIPLY<float,unsigned int>(*(float *)v47.m128i_i32, count);
          *(_DWORD *)(v7 + 80) = _mm_cvtsi128_si32(v47);
        }
        else if ( common::tools::StringUtils::strVecToNum<0u,float>(&item_use_config->use_param, (float *)(v7 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1624);
          v44 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
                  &v229,
                  (const char (*)[24])"strVecToNum fails, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          goto LABEL_97;
        }
        v48 = _mm_cvtsi32_si128(*(_DWORD *)(v7 + 64));
        *(float *)v48.m128i_i32 = SAFE_MULTIPLY<float,unsigned int>(*(float *)v48.m128i_i32, count);
        *(_DWORD *)(v7 + 64) = _mm_cvtsi128_si32(v48);
        std::vector<std::shared_ptr<Avatar>>::vector((std::vector<std::shared_ptr<Avatar>> *const)(v7 + 416));
        std::vector<std::shared_ptr<Avatar>>::vector((std::vector<std::shared_ptr<Avatar>> *const)(v7 + 480));
        __for_range_2 = target_vec;
        __for_begin._M_current = (const data::IdCountConfig *)std::vector<std::shared_ptr<Avatar>>::begin(target_vec)._M_current;
        *(std::vector<std::shared_ptr<Avatar>>::const_iterator *)(v7 + 128) = std::vector<std::shared_ptr<Avatar>>::end(target_vec);
        while ( 1 )
        {
          v49 = (char *)(v7 + 128);
          if ( !__gnu_cxx::operator!=<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>(
                  (const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)&__for_begin,
                  (const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)(v7 + 128)) )
            break;
          v50 = __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator*((const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
          std::shared_ptr<Avatar>::shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 256), v50);
          if ( std::operator==<Avatar>((const std::shared_ptr<Avatar> *)(v7 + 256), 0LL) )
          {
            common::milog::MiLogStream::create(
              &v229,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "internalUseItem",
              1635);
            v51 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                    &v229,
                    (const char (*)[31])"avatar_ptr is nullptr, player_");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            operator<<(v51, this->player_);
            common::milog::MiLogStream::~MiLogStream(&v229);
          }
          else
          {
            v52 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
            if ( Creature::getLifeState(v52) == LIFE_ALIVE )
            {
              v53 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
              if ( Creature::getMaxEnergy(v53) >= 0.00000011920929 )
              {
                v54 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
                CurEnergy = Creature::getCurEnergy(v54);
                v55 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
                if ( Creature::getMaxEnergy(v55) <= CurEnergy )
                  std::vector<std::shared_ptr<Avatar>>::push_back(
                    (std::vector<std::shared_ptr<Avatar>> *const)(v7 + 480),
                    (const std::vector<std::shared_ptr<Avatar>>::value_type *)(v7 + 256));
                else
                  std::vector<std::shared_ptr<Avatar>>::push_back(
                    (std::vector<std::shared_ptr<Avatar>> *const)(v7 + 416),
                    (const std::vector<std::shared_ptr<Avatar>>::value_type *)(v7 + 256));
              }
            }
          }
          std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 256));
          __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator++((__gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
        }
        common::tools::perf::make_shared<FightPropNtfParam>();
        v56 = (unsigned __int64)std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192));
        v57 = *(_BYTE *)((v56 >> 3) + 0x7FFF8000);
        LOBYTE(v49) = v57 != 0;
        v58 = (v57 != 0) & (unsigned __int8)(v57 <= 3);
        if ( (_BYTE)v58 )
          v56 = __asan_report_store4(v56, v49, v58);
        *(_DWORD *)v56 = 2;
        v59 = std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192));
        v62 = (char *)(v7 + 32);
        std::vector<unsigned int>::push_back(&v59->param_vec, (const std::vector<unsigned int>::value_type *)(v7 + 32));
        v60 = (__int64)std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FightPropNtfParam,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192));
        v61 = *(_BYTE *)(((unsigned __int64)(v60 + 32) >> 3) + 0x7FFF8000);
        LOBYTE(v62) = v61 != 0;
        v63 = v61 < 0;
        if ( v63 )
          v60 = __asan_report_store1(v60 + 32, v62, v63);
        *(_BYTE *)(v60 + 32) = 0;
        __for_range_3 = (std::vector<std::shared_ptr<Avatar>> *)(v7 + 416);
        __for_begin._M_current = (const data::IdCountConfig *)std::vector<std::shared_ptr<Avatar>>::begin((std::vector<std::shared_ptr<Avatar>> *const)(v7 + 416))._M_current;
        *(std::vector<std::shared_ptr<Avatar>>::iterator *)(v7 + 128) = std::vector<std::shared_ptr<Avatar>>::end(__for_range_3);
        while ( __gnu_cxx::operator!=<std::shared_ptr<Avatar> *,std::vector<std::shared_ptr<Avatar>>>(
                  (const __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)&__for_begin,
                  (const __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)(v7 + 128)) )
        {
          avatar_ptr = __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> *,std::vector<std::shared_ptr<Avatar>>>::operator*((const __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
          final_add_energy = 0.0;
          if ( *(_BYTE *)(((unsigned __int64)&item_use_config->use_op >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)&item_use_config->use_op >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(&item_use_config->use_op);
          }
          if ( item_use_config->use_op != ITEM_USE_ADD_ELEM_ENERGY )
            goto LABEL_130;
          v64 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)avatar_ptr);
          if ( *(_BYTE *)(((unsigned __int64)v64 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v65 = *(_QWORD *)v64->baseclass_0 + 280LL;
          if ( *(_BYTE *)((v65 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          if ( (*(unsigned int (__fastcall **)(std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v65)(v64) == *(_DWORD *)(v7 + 48) )
LABEL_130:
            v66 = 0;
          else
            v66 = 1;
          if ( v66 )
          {
            v67 = (__m128i)*(unsigned int *)(v7 + 80);
            final_add_energy = *(float *)(v7 + 80);
          }
          else
          {
            v67 = (__m128i)*(unsigned int *)(v7 + 64);
            final_add_energy = *(float *)(v7 + 64);
          }
          v68 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)avatar_ptr);
          *(float *)v67.m128i_i32 = Creature::getProp(v68, FIGHT_PROP_CHARGE_EFFICIENCY);
          *(_DWORD *)(v7 + 112) = _mm_cvtsi128_si32(v67);
          *(_DWORD *)(v7 + 96) = 0;
          v69 = (float *)std::max<float>((const float *)(v7 + 96), (const float *)(v7 + 112));
          v70 = v69;
          if ( *(_BYTE *)(((unsigned __int64)v69 >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)v69 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v69 >> 3) + 0x7FFF8000) )
          {
            __asan_report_load4(v69);
          }
          charge_efficiency = *v70;
          v71 = _mm_cvtsi32_si128(LODWORD(final_add_energy));
          *(float *)v71.m128i_i32 = SAFE_MULTIPLY<float,float>(*(float *)v71.m128i_i32, charge_efficiency);
          LODWORD(final_add_energy) = _mm_cvtsi128_si32(v71);
          v72 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)avatar_ptr);
          Guid = Avatar::getGuid(v72);
          is_cur_avatar = cur_avatar_guid == Guid;
          ServiceBox::findService<GameserverService>();
          GameserverService::getConfig((GameserverService *const)(v7 + 256));
          v74 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
          *(float *)v71.m128i_i32 = ConstValueExcelConfigMgr::getEnergyRechargeRatio(
                                      &v74->design_config.txt_config_mgr.const_value_config_mgr,
                                      is_cur_avatar,
                                      cur_team_size);
          LODWORD(energy_charge_ratio) = _mm_cvtsi128_si32(v71);
          std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v7 + 256));
          v75 = _mm_cvtsi32_si128(LODWORD(final_add_energy));
          *(float *)v75.m128i_i32 = SAFE_MULTIPLY<float,float>(*(float *)v75.m128i_i32, energy_charge_ratio);
          LODWORD(final_add_energy) = _mm_cvtsi128_si32(v75);
          v76 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)avatar_ptr);
          std::shared_ptr<FightPropNtfParam>::shared_ptr(
            (std::shared_ptr<FightPropNtfParam> *const)(v7 + 256),
            (const std::shared_ptr<FightPropNtfParam> *)(v7 + 192));
          Creature::changeCurEnergy(v76, final_add_energy, 1, (FightPropNtfParamPtr *)(v7 + 256));
          std::shared_ptr<FightPropNtfParam>::~shared_ptr((std::shared_ptr<FightPropNtfParam> *const)(v7 + 256));
          __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> *,std::vector<std::shared_ptr<Avatar>>>::operator++((__gnu_cxx::__normal_iterator<std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
        }
        __for_range_4 = (std::vector<std::shared_ptr<Avatar>> *)(v7 + 480);
        __for_begin._M_current = (const data::IdCountConfig *)std::vector<std::shared_ptr<Avatar>>::begin((std::vector<std::shared_ptr<Avatar>> *const)(v7 + 480))._M_current;
        *(std::vector<std::shared_ptr<Avatar>>::iterator *)(v7 + 128) = std::vector<std::shared_ptr<Avatar>>::end(__for_range_4);
        while ( __gnu_cxx::operator!=<std::shared_ptr<Avatar> *,std::vector<std::shared_ptr<Avatar>>>(
                  (const __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)&__for_begin,
                  (const __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)(v7 + 128)) )
        {
          avatar_ptr_0 = __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> *,std::vector<std::shared_ptr<Avatar>>>::operator*((const __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
          v77 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)avatar_ptr_0);
          std::shared_ptr<FightPropNtfParam>::shared_ptr(
            (std::shared_ptr<FightPropNtfParam> *const)(v7 + 256),
            (const std::shared_ptr<FightPropNtfParam> *)(v7 + 192));
          Creature::changeCurEnergy(v77, 0.0, 1, (FightPropNtfParamPtr *)(v7 + 256));
          std::shared_ptr<FightPropNtfParam>::~shared_ptr((std::shared_ptr<FightPropNtfParam> *const)(v7 + 256));
          __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> *,std::vector<std::shared_ptr<Avatar>>>::operator++((__gnu_cxx::__normal_iterator<std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
        }
        common::tools::perf::make_shared<UseElementEnergyItemEvent,unsigned int &>(
          (unsigned int *)(v7 + 256),
          (unsigned int *)(v7 + 32));
        std::shared_ptr<BaseEvent>::shared_ptr<UseElementEnergyItemEvent,void>(
          (std::shared_ptr<BaseEvent> *const)(v7 + 224),
          (std::shared_ptr<UseElementEnergyItemEvent> *)(v7 + 256));
        std::shared_ptr<UseElementEnergyItemEvent>::~shared_ptr((std::shared_ptr<UseElementEnergyItemEvent> *const)(v7 + 256));
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        EventComp = Player::getEventComp(this->player_);
        std::shared_ptr<BaseEvent>::shared_ptr(
          (std::shared_ptr<BaseEvent> *const)(v7 + 256),
          (const std::shared_ptr<BaseEvent> *)(v7 + 224));
        PlayerEventComp::notifyEvent(EventComp, (BaseEventPtr *)(v7 + 256));
        std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)(v7 + 256));
        std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)(v7 + 224));
        std::shared_ptr<FightPropNtfParam>::~shared_ptr((std::shared_ptr<FightPropNtfParam> *const)(v7 + 192));
        std::vector<std::shared_ptr<Avatar>>::~vector((std::vector<std::shared_ptr<Avatar>> *const)(v7 + 480));
        std::vector<std::shared_ptr<Avatar>>::~vector((std::vector<std::shared_ptr<Avatar>> *const)(v7 + 416));
        goto LABEL_143;
      }
      common::milog::MiLogStream::create(
        &v229,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "internalUseItem",
        1600);
      v39 = common::milog::MiLogStream::operator<<<char [23],(char *[23])0>(
              &v229,
              (const char (*)[23])"cur_avatar_ptr is null");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v39, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v229);
LABEL_144:
      std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 160));
LABEL_378:
      if ( v230 == (char *)v7 )
      {
        *(_QWORD *)((v7 >> 3) + 0x7FFF8000) = 0LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8044) = 0LL;
        memset(
          (void *)((unsigned __int64)(v9 + 536862722) & 0xFFFFFFFFFFFFFFF8LL),
          0,
          8LL * ((((_DWORD)v9 + 2147450880 - (((_DWORD)v9 + 2147450888) & 0xFFFFFFF8) + 76) & 0xFFFFFFF8) >> 3));
        *(_QWORD *)((v7 >> 3) + 0x7FFF8050) = 0LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF805C) = 0LL;
      }
      else
      {
        *(_QWORD *)v7 = 1172321806LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8028) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8030) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8038) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8040) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8048) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8050) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v7 >> 3) + 0x7FFF8058) = 0xF5F5F5F5F5F5F5F5LL;
        *(_DWORD *)((v7 >> 3) + 0x7FFF8060) = -168430091;
      }
      return;
    case ITEM_USE_ADD_DUNGEON_COND_TIME:
      PlayerItemComp::useItemAddDungeonCondTime(this, item_use_config, count);
      goto LABEL_378;
    case ITEM_USE_ADD_SERVER_BUFF:
      *(_DWORD *)(v7 + 96) = 0;
      *(_DWORD *)(v7 + 112) = 0;
      common::tools::StringUtils::strVecToNum<0u,unsigned int,float &>(
        &item_use_config->use_param,
        (unsigned int *)(v7 + 96),
        (float *)(v7 + 112),
        (float *)&item_use_config->use_param);
      if ( *(_DWORD *)(v7 + 96) )
      {
        buff_time_ms = (int)(float)(1000.0 * *(float *)(v7 + 112));
        if ( target == ITEM_USE_TARGET_CUR_TEAM )
        {
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v79 = Player::getAvatarComp(this->player_);
          PlayerAvatarComp::addTeamBuff(v79, *(_DWORD *)(v7 + 96), buff_time_ms);
        }
        else
        {
          __for_range_5 = target_vec;
          __for_begin._M_current = (const data::IdCountConfig *)std::vector<std::shared_ptr<Avatar>>::begin(target_vec)._M_current;
          *(std::vector<std::shared_ptr<Avatar>>::const_iterator *)(v7 + 128) = std::vector<std::shared_ptr<Avatar>>::end(target_vec);
          while ( __gnu_cxx::operator!=<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>(
                    (const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)&__for_begin,
                    (const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)(v7 + 128)) )
          {
            v80 = __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator*((const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
            std::shared_ptr<Avatar>::shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 256), v80);
            v81 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
            BuffComp = Avatar::getBuffComp(v81);
            BuffComp::addBuff(BuffComp, *(_DWORD *)(v7 + 96), buff_time_ms);
            std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 256));
            __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator++((__gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
          }
        }
      }
      else
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1697);
        common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(&v229, (const char (*)[16])"invalid buff_id");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      goto LABEL_378;
    case ITEM_USE_DEL_SERVER_BUFF:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1718);
        common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v229, (const char (*)[18])"strVecToNum fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else if ( target == ITEM_USE_TARGET_CUR_TEAM )
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v83 = Player::getAvatarComp(this->player_);
        PlayerAvatarComp::delTeamBuff(v83, *(_DWORD *)(v7 + 112));
      }
      else
      {
        __for_range_6 = target_vec;
        __for_begin._M_current = (const data::IdCountConfig *)std::vector<std::shared_ptr<Avatar>>::begin(target_vec)._M_current;
        *(std::vector<std::shared_ptr<Avatar>>::const_iterator *)(v7 + 128) = std::vector<std::shared_ptr<Avatar>>::end(target_vec);
        while ( __gnu_cxx::operator!=<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>(
                  (const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)&__for_begin,
                  (const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *)(v7 + 128)) )
        {
          v84 = __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator*((const __gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
          std::shared_ptr<Avatar>::shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 256), v84);
          v85 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
          v86 = Avatar::getBuffComp(v85);
          BuffComp::delBuff(v86, *(_DWORD *)(v7 + 112));
          std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 256));
          __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator++((__gnu_cxx::__normal_iterator<const std::shared_ptr<Avatar>*,std::vector<std::shared_ptr<Avatar>> > *const)&__for_begin);
        }
      }
      goto LABEL_378;
    case ITEM_USE_UNLOCK_COOK_RECIPE:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1738);
        common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v229, (const char (*)[18])"strVecToNum fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        CookComp = Player::getCookComp(this->player_);
        if ( (unsigned int)PlayerCookComp::unlockRecipe(CookComp, *(_DWORD *)(v7 + 112)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1743);
          v88 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
                  &v229,
                  (const char (*)[22])"unlockRecipe failed: ");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v88, (const unsigned int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_OPEN_RANDOM_CHEST:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1780);
        common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v229, (const char (*)[18])"strVecToNum fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(reason);
        }
        ActionReason::ActionReason((ActionReason *const)(v7 + 416), reason->reason_type, ITEM_LIMIT_RANDOM_CHEST);
        std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v7 + 480));
        v93 = *(_DWORD *)(v7 + 112);
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        *(OutputResult *)(v7 + 128) = DropUtils::dropItems(
                                        this->player_,
                                        v93,
                                        count,
                                        (const ActionReason *)(v7 + 416),
                                        (std::vector<ItemParam> *)(v7 + 480));
        if ( *(_DWORD *)(v7 + 128) )
        {
          LogLevel = OutputResult::getLogLevel((const OutputResult *const)(v7 + 128));
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            LogLevel,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1788);
          v95 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
                  &v229,
                  (const char (*)[27])"dropItems failed, drop_id:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v95, (const unsigned int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
        else
        {
          PlayerItemComp::addItemBatch(
            this,
            (const std::vector<ItemParam> *)(v7 + 480),
            (const ActionReason *)(v7 + 416),
            0LL);
        }
        std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v7 + 480));
      }
      goto LABEL_378;
    case ITEM_USE_MAKE_GADGET:
      PlayerItemComp::useItemMakeGadget(this, item_use_config);
      goto LABEL_378;
    case ITEM_USE_ADD_ITEM:
      *(_DWORD *)(v7 + 256) = 0;
      *(_DWORD *)(v7 + 260) = 0;
      *(_DWORD *)(v7 + 264) = 0;
      *(_DWORD *)(v7 + 268) = 0;
      if ( !common::tools::StringUtils::strVecToNum<0u,unsigned int,unsigned int &>(
              &item_use_config->use_param,
              (unsigned int *)(v7 + 256),
              (unsigned int *)(v7 + 260),
              (unsigned int *)&item_use_config->use_param) )
      {
        *(_DWORD *)(v7 + 260) = SAFE_MULTIPLY<unsigned int,unsigned int>(*(_DWORD *)(v7 + 260), count);
        if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(reason);
        }
        goto LABEL_296;
      }
      common::milog::MiLogStream::create(
        &v229,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "internalUseItem",
        1804);
      v96 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
              &v229,
              (const char (*)[27])"strVecToNum fail, item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v96, (const unsigned int *)(v7 + 32));
      common::milog::MiLogStream::~MiLogStream(&v229);
      goto LABEL_378;
    case ITEM_USE_GRANT_SELECT_REWARD:
      if ( *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&use_param->option_idx);
      }
      reward_id = PlayerItemComp::getUseConfigSelectId<unsigned int>(this, item_use_config, use_param->option_idx);
      if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(reason);
      }
      ActionReason::ActionReason((ActionReason *const)(v7 + 480), reason->reason_type, ITEM_LIMIT_USE_ITEM_REWARD);
      PlayerItemComp::grantReward(this, reward_id, (const ActionReason *)(v7 + 480), 0LL);
      goto LABEL_378;
    case ITEM_USE_ADD_SELECT_ITEM:
      *(_DWORD *)(v7 + 256) = 0;
      *(_DWORD *)(v7 + 260) = 0;
      *(_DWORD *)(v7 + 264) = 0;
      *(_DWORD *)(v7 + 268) = 0;
      if ( *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&use_param->option_idx);
      }
      *(_DWORD *)(v7 + 256) = PlayerItemComp::getUseConfigSelectId<unsigned int>(
                                this,
                                item_use_config,
                                use_param->option_idx);
      *(_DWORD *)(v7 + 260) = 1;
      if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(reason);
      }
      goto LABEL_296;
    case ITEM_USE_GAIN_FLYCLOAK:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1833);
        v97 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                &v229,
                (const char (*)[31])"strVecToNum fail, flycloak_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v97, (const unsigned int *)(v7 + 112));
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v98 = Player::getAvatarComp(this->player_);
        if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(reason);
        }
        if ( (unsigned int)PlayerAvatarComp::addFlycloak(v98, *(_DWORD *)(v7 + 112), reason->reason_type) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1839);
          v99 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(&v229, (const char (*)[35])off_2638D900);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v99, (const unsigned int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_GAIN_NAME_CARD:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      SocialComp = Player::getSocialComp(this->player_);
      if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(reason);
      }
      if ( PlayerSocialComp::unlockNameCard(SocialComp, *(_DWORD *)(v7 + 32), reason->reason_type) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1848);
        v101 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
                 &v229,
                 (const char (*)[38])"unlockNameCard failed, name_card_id: ");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v101, (const unsigned int *)(v7 + 32));
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      goto LABEL_378;
    case ITEM_USE_UNLOCK_PAID_BATTLE_PASS_NORMAL:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      BattlePassComp = Player::getBattlePassComp(this->player_);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      PlatformType = Player::getPlatformType(this->player_);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v104 = Player::getBattlePassComp(this->player_);
      CurScheduleId = PlayerBattlePassComp::getCurScheduleId(v104);
      if ( (unsigned int)PlayerBattlePassComp::normalUnlockPaidBattlePass(BattlePassComp, CurScheduleId, PlatformType) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1857);
        v106 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v229,
                 (const char (*)[44])"normalUnlockPaidBattlePass failed, item_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v106, (const unsigned int *)(v7 + 32));
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      goto LABEL_378;
    case ITEM_USE_GAIN_CARD_PRODUCT:
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)(v7 + 256));
      v107 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
      config_id = ShopmallExcelConfigMgr::getHcoinCardProductConfigId(&v107->design_config.txt_config_mgr.shopmall_config_mgr);
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v7 + 256));
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      RechargeComp = Player::getRechargeComp(this->player_);
      if ( PlayerRechargeComp::useCardProductMaterial(RechargeComp, config_id) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1867);
        common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
          &v229,
          (const char (*)[29])"useCardProductMaterial fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      goto LABEL_378;
    case ITEM_USE_UNLOCK_FORGE:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1752);
        common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v229, (const char (*)[18])"strVecToNum fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        ForgeComp = Player::getForgeComp(this->player_);
        if ( (unsigned int)PlayerForgeComp::unlockForgeByFormula(ForgeComp, *(_DWORD *)(v7 + 112)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1757);
          v90 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                  &v229,
                  (const char (*)[39])"unlockForgeByFormula failed, forge_id:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v90, (const unsigned int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_UNLOCK_COMBINE:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1766);
        common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v229, (const char (*)[18])"strVecToNum fails");
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        CombineComp = Player::getCombineComp(this->player_);
        if ( (unsigned int)PlayerCombineComp::unlockCombineByFormula(CombineComp, *(_DWORD *)(v7 + 112)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1771);
          v92 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                  &v229,
                  (const char (*)[43])"unlockCombineByFormula failed, combine_id:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v92, (const unsigned int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_UNLOCK_CODEX:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1877);
        v109 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
                 &v229,
                 (const char (*)[27])"strVecToNum fail, item_id:");
        v110 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                 v109,
                 (const unsigned int *)(v7 + 32));
        v111 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v110, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_291;
      }
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      CodexComp = Player::getCodexComp(this->player_);
      if ( !PlayerCodexComp::recordBooksCodex(CodexComp, *(_DWORD *)(v7 + 112)) )
        goto LABEL_378;
      common::milog::MiLogStream::create(
        &v229,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "internalUseItem",
        1882);
      v113 = common::milog::MiLogStream::operator<<<char [47],(char *[47])0>(
               &v229,
               (const char (*)[47])"recordBooksCodexOnUseItem fail, book_codex_id:");
      v114 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
               v113,
               (const unsigned int *)(v7 + 112));
      v111 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v114, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_291;
    case ITEM_USE_CHEST_SELECT_ITEM:
      if ( *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&use_param->option_idx >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&use_param->option_idx);
      }
      *(std::pair<unsigned int,unsigned int> *)(v7 + 128) = PlayerItemComp::getUseConfigSelectIdAndCount(
                                                              this,
                                                              item_use_config,
                                                              use_param->option_idx);
      *(_DWORD *)(v7 + 256) = 0;
      *(_DWORD *)(v7 + 260) = 0;
      *(_DWORD *)(v7 + 264) = 0;
      *(_DWORD *)(v7 + 268) = 0;
      *(_DWORD *)(v7 + 256) = *(_DWORD *)(v7 + 128);
      if ( *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)use_param >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(use_param);
      }
      *(_DWORD *)(v7 + 260) = SAFE_MULTIPLY<unsigned int,unsigned int>(*(_DWORD *)(v7 + 132), use_param->count);
      if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(reason);
      }
      goto LABEL_296;
    case ITEM_USE_GAIN_RESIN_CARD_PRODUCT:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1902);
        v115 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                 &v229,
                 (const char (*)[29])"strVecToNum fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v115, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v116 = Player::getRechargeComp(this->player_);
        if ( PlayerRechargeComp::useCardProductMaterial(v116, *(_DWORD *)(v7 + 112)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1907);
          common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
            &v229,
            (const char (*)[29])"useCardProductMaterial fails");
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_UNLOCK_FURNITURE_FORMULA:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1917);
        v117 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                 &v229,
                 (const char (*)[29])"strVecToNum fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v117, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        HomeComp = Player::getHomeComp(this->player_);
        if ( (unsigned int)PlayerHomeComp::unlockFurnitureFormula(HomeComp, *(_DWORD *)(v7 + 112)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1922);
          v119 = common::milog::MiLogStream::operator<<<char [32],(char *[32])0>(
                   &v229,
                   (const char (*)[32])"unlockFurnitureFormula failed: ");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v119, (const unsigned int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_UNLOCK_FURNITURE_SUITE:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1931);
        v120 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                 &v229,
                 (const char (*)[29])"strVecToNum fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v120, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v121 = Player::getHomeComp(this->player_);
        if ( (unsigned int)PlayerHomeComp::unlockFurnitureSuite(v121, *(_DWORD *)(v7 + 112)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1936);
          v122 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                   &v229,
                   (const char (*)[30])"unlockFurnitureSuite failed: ");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v122, (const unsigned int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_ADD_CHANNELLER_SLAB_BUFF:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1945);
        v123 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                 &v229,
                 (const char (*)[29])"strVecToNum fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v123, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<ChannellerSlabActivity>((PlayerActivityComp *const)(v7 + 256));
        if ( std::operator==<ChannellerSlabActivity>(0LL, (const std::shared_ptr<ChannellerSlabActivity> *)(v7 + 256)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1951);
          v124 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                   &v229,
                   (const char (*)[44])"[CHANNELLER SLAB] activity is not opening. ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          operator<<(v124, this->player_);
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
        else
        {
          v125 = std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
          if ( ChannellerSlabActivity::addBuff(v125, *(_DWORD *)(v7 + 112)) )
          {
            common::milog::MiLogStream::create(
              &v229,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "internalUseItem",
              1956);
            v126 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                     &v229,
                     (const char (*)[17])"addBuff failed: ");
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
              v126,
              (const unsigned int *)(v7 + 112));
            common::milog::MiLogStream::~MiLogStream(&v229);
          }
        }
        std::shared_ptr<ChannellerSlabActivity>::~shared_ptr((std::shared_ptr<ChannellerSlabActivity> *const)(v7 + 256));
      }
      goto LABEL_378;
    case ITEM_USE_GAIN_COSTUME:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1965);
        v127 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                 &v229,
                 (const char (*)[29])"strVecToNum fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v127, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v128 = Player::getAvatarComp(this->player_);
        if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(reason);
        }
        if ( (unsigned int)PlayerAvatarComp::addCostume(v128, *(_DWORD *)(v7 + 112), reason->reason_type) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1970);
          v129 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                   &v229,
                   (const char (*)[30])"addCostume failed. costume id");
          v130 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                   v129,
                   (const unsigned int *)(v7 + 112));
          v111 = common::milog::MiLogStream::operator<<<char [2],(char *[2])0>(v130, (const char (*)[2])" ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
LABEL_291:
          operator<<(v111, this->player_);
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_COMBINE_ITEM:
      *(_DWORD *)(v7 + 112) = 0;
      *(_DWORD *)(v7 + 256) = 0;
      *(_DWORD *)(v7 + 260) = 0;
      *(_DWORD *)(v7 + 264) = 0;
      *(_DWORD *)(v7 + 268) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int,unsigned int &,unsigned int &>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112),
             (unsigned int *)(v7 + 256),
             (unsigned int *)(v7 + 260),
             (unsigned int *)target_vec,
             &use_param->count) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1980);
        v131 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                 &v229,
                 (const char (*)[29])"strVecToNum fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v131, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(reason);
        }
LABEL_296:
        ActionReason::ActionReason((ActionReason *const)(v7 + 480), reason->reason_type, ITEM_LIMIT_USE_ITEM);
        PlayerItemComp::addItem(this, (const ItemParam *)(v7 + 256), (const ActionReason *)(v7 + 480), 0LL);
      }
      goto LABEL_378;
    case ITEM_USE_UNLOCK_HOME_MODULE:
      *(_DWORD *)(v7 + 112) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 112)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          1992);
        v132 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                 &v229,
                 (const char (*)[29])"strVecToNum fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v132, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)(v7 + 256));
        v133 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
        module_config_ptr = data::HomeWorldExcelConfigMgrBase::findHomeworldModuleExcelConfig(
                              &v133->design_config.txt_config_mgr.home_config_mgr,
                              *(_DWORD *)(v7 + 112));
        std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v7 + 256));
        if ( module_config_ptr )
        {
          if ( *(_BYTE *)(((unsigned __int64)&module_config_ptr->is_free >> 3) + 0x7FFF8000) != 0
            && (((unsigned __int8)module_config_ptr + 12) & 7) >= *(_BYTE *)(((unsigned __int64)&module_config_ptr->is_free >> 3)
                                                                           + 0x7FFF8000) )
          {
            __asan_report_load1(&module_config_ptr->is_free);
          }
          if ( module_config_ptr->is_free )
          {
            common::milog::MiLogStream::create(
              &v229,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "internalUseItem",
              2003);
            v135 = common::milog::MiLogStream::operator<<<char [62],(char *[62])0>(
                     &v229,
                     (const char (*)[62])byte_2638DCA0);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
              v135,
              (const unsigned int *)(v7 + 112));
            common::milog::MiLogStream::~MiLogStream(&v229);
          }
          else
          {
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            v136 = Player::getHomeComp(this->player_);
            if ( (unsigned int)PlayerHomeComp::unlockModule(v136, *(_DWORD *)(v7 + 112), 1) )
            {
              common::milog::MiLogStream::create(
                &v229,
                &common::milog::MiLogDefault::default_log_obj_,
                3u,
                "./src/player/item/player_item_comp.cpp",
                "internalUseItem",
                2010);
              v137 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(
                       &v229,
                       (const char (*)[20])"unlock module fail.");
              common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v137,
                (const unsigned int *)(v7 + 112));
              common::milog::MiLogStream::~MiLogStream(&v229);
            }
          }
        }
        else
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            1998);
          v134 = common::milog::MiLogStream::operator<<<char [68],(char *[68])0>(
                   &v229,
                   (const char (*)[68])byte_2638DC20);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v134, (const unsigned int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_UNLOCK_HOME_BGM:
      std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v7 + 480));
      v138 = 0;
      v139 = 0;
      v196 = 1;
      if ( !std::vector<std::string>::empty(&item_use_config->use_param) )
      {
        std::allocator<char>::allocator(&__a);
        v138 = 1;
        std::string::basic_string<std::allocator<char>>((std::string *const)&v229, ";", &__a);
        v139 = 1;
        v140 = std::vector<std::string>::operator[](&item_use_config->use_param, 0LL);
        if ( !common::tools::StringUtils::splitToList<unsigned int>(
                v140,
                (const std::string *)&v229,
                (std::vector<unsigned int> *)(v7 + 480),
                0) )
          v196 = 0;
      }
      if ( v139 )
        std::string::~string(&v229);
      if ( v138 )
        std::allocator<char>::~allocator(&__a);
      if ( v196 )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          2019);
        v141 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
                 &v229,
                 (const char (*)[34])"parse bgm_id_vec fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v141, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v142 = Player::getHomeComp(this->player_);
        if ( PlayerHomeComp::unlockHomeBgm(v142, (const std::vector<unsigned int> *)(v7 + 480)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            2024);
          v143 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                   &v229,
                   (const char (*)[31])"unlockHomeBgm fail, use_param:");
          common::milog::MiLogStream::operator<<<std::string>(v143, &item_use_config->use_param);
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v7 + 480));
      goto LABEL_378;
    case ITEM_USE_ADD_REGIONAL_PLAY_VAR:
      if ( std::vector<std::string>::size(&item_use_config->use_param) > 1 )
      {
        *(_DWORD *)(v7 + 96) = 2500;
        v145 = std::vector<std::string>::operator[](&item_use_config->use_param, 0LL);
        if ( !data::enumStrToVal(v145, (data::RegionalPlayVarType *)(v7 + 96)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            2038);
          v146 = common::milog::MiLogStream::operator<<<char [32],(char *[32])0>(
                   &v229,
                   (const char (*)[32])"invalid regional_play_var_type:");
          v147 = std::vector<std::string>::operator[](&item_use_config->use_param, 0LL);
          v148 = common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(v146, v147);
          v149 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(
                   v148,
                   (const char (*)[12])" use_param:");
          common::milog::MiLogStream::operator<<<std::string>(v149, &item_use_config->use_param);
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
        else
        {
          *(_DWORD *)(v7 + 112) = 0;
          if ( common::tools::StringUtils::strVecToNum<1u,float>(&item_use_config->use_param, (float *)(v7 + 112)) )
          {
            common::milog::MiLogStream::create(
              &v229,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "internalUseItem",
              2044);
            v150 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                     &v229,
                     (const char (*)[29])"strVecToNum fail, use_param:");
            common::milog::MiLogStream::operator<<<std::string>(v150, &item_use_config->use_param);
            common::milog::MiLogStream::~MiLogStream(&v229);
          }
          else
          {
            v151 = _mm_cvtsi32_si128(*(_DWORD *)(v7 + 112));
            *(float *)v151.m128i_i32 = SAFE_MULTIPLY<float,unsigned int>(*(float *)v151.m128i_i32, count);
            *(_DWORD *)(v7 + 112) = _mm_cvtsi128_si32(v151);
            if ( *(float *)(v7 + 112) <= 0.0 )
            {
              if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                __asan_report_load8();
              RegionalPlayComp = Player::getRegionalPlayComp(this->player_);
              PlayerRegionalPlayComp::subVarValue(RegionalPlayComp, *(_DWORD *)(v7 + 96), -*(float *)(v7 + 112));
            }
            else
            {
              if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                __asan_report_load8();
              v152 = Player::getRegionalPlayComp(this->player_);
              PlayerRegionalPlayComp::addVarValue(v152, *(_DWORD *)(v7 + 96), *(float *)(v7 + 112));
            }
          }
        }
      }
      else
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          2032);
        v144 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v229,
                 (const char (*)[44])"use_param's size is less than 2! use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v144, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      goto LABEL_378;
    case ITEM_USE_ADD_AVATAR_EXTRA_PROPERTY:
      if ( std::vector<std::string>::size(&item_use_config->use_param) )
      {
        *(_DWORD *)(v7 + 96) = 0;
        if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
               &item_use_config->use_param,
               (unsigned int *)(v7 + 96)) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            2068);
          v155 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                   &v229,
                   (const char (*)[29])"strVecToNum fail, use_param:");
          common::milog::MiLogStream::operator<<<std::string>(v155, &item_use_config->use_param);
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
        else if ( target == ITEM_USE_TARGET_PLAYER_AVATAR )
        {
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          Player::getAvatarComp(this->player_);
          PlayerAvatarComp::getPlayerAvatarPtr((PlayerAvatarComp *const)(v7 + 256));
          if ( std::operator==<Avatar>(0LL, (const std::shared_ptr<Avatar> *)(v7 + 256)) )
          {
            common::milog::MiLogStream::create(
              &v229,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "internalUseItem",
              2077);
            v156 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                     &v229,
                     (const char (*)[35])"cannot find player avatar, player:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            operator<<(v156, this->player_);
            common::milog::MiLogStream::~MiLogStream(&v229);
          }
          else
          {
            v157 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
            ExtraPropComp = Avatar::getExtraPropComp(v157);
            ExtraPropComp::addExtraProp(
              ExtraPropComp,
              *(_DWORD *)(v7 + 96),
              count,
              CHANGE_AVATAR_EXTRA_PROP_REASON_ITEM);
            common::milog::MiLogStream::create(
              &v229,
              &common::milog::MiLogDefault::default_log_obj_,
              1u,
              "./src/player/item/player_item_comp.cpp",
              "internalUseItem",
              2081);
            v159 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(&v229, (const char (*)[8])"avatar:");
            v160 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 256));
            *(_DWORD *)(v7 + 112) = Avatar::getAvatarId(v160);
            v161 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                     v159,
                     (const unsigned int *)(v7 + 112));
            v162 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
                     v161,
                     (const char (*)[21])" add extra prop, id:");
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
              v162,
              (const unsigned int *)(v7 + 96));
            common::milog::MiLogStream::~MiLogStream(&v229);
          }
          std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v7 + 256));
        }
      }
      else
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          2062);
        v154 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v229,
                 (const char (*)[44])"use_param's size is less than 1! use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v154, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      goto LABEL_378;
    case ITEM_USE_GAIN_GCG_CARD:
      *(_DWORD *)(v7 + 96) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          2090);
        v163 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                 &v229,
                 (const char (*)[29])"strVecToNum fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v163, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        GCGComp = Player::getGCGComp(this->player_);
        DeckSystem = PlayerGCGComp::getDeckSystem(GCGComp);
        *(_DWORD *)(v7 + 112) = GCGDeckSystem::addCard(DeckSystem, *(_DWORD *)(v7 + 96), count, 1);
        if ( *(_DWORD *)(v7 + 112) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            2096);
          v166 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
                   &v229,
                   (const char (*)[24])"addCard fail. card_id: ");
          v167 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                   v166,
                   (const unsigned int *)(v7 + 96));
          v168 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v167, (const char (*)[7])" ret: ");
          common::milog::MiLogStream::operator<<<int,(int *)0>(v168, (const int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_GAIN_GCG_CARD_FACE:
      *(_DWORD *)(v7 + 80) = 0;
      *(_DWORD *)(v7 + 96) = 0;
      if ( std::vector<std::string>::size(&item_use_config->use_param) > 1 )
      {
        v170 = std::vector<std::string>::operator[](&item_use_config->use_param, 0LL);
        if ( common::tools::StringUtils::strToNum<unsigned int>(v170, (unsigned int *)(v7 + 80), 1) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            2111);
          v171 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                   &v229,
                   (const char (*)[29])"strVecToNum fail, use_param:");
          common::milog::MiLogStream::operator<<<std::string>(v171, &item_use_config->use_param);
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
        else
        {
          v172 = std::vector<std::string>::operator[](&item_use_config->use_param, 1uLL);
          if ( common::tools::StringUtils::strToEnum<data::GCGCardFaceType>(v172, (data::GCGCardFaceType *)(v7 + 96)) )
          {
            common::milog::MiLogStream::create(
              &v229,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "internalUseItem",
              2116);
            v173 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
                     &v229,
                     (const char (*)[27])"strToEnum fail, use_param:");
            common::milog::MiLogStream::operator<<<std::string>(v173, &item_use_config->use_param);
            common::milog::MiLogStream::~MiLogStream(&v229);
          }
          else
          {
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            v174 = Player::getGCGComp(this->player_);
            v175 = PlayerGCGComp::getDeckSystem(v174);
            *(_DWORD *)(v7 + 112) = GCGDeckSystem::unlockCardFace(v175, *(_DWORD *)(v7 + 80), *(_DWORD *)(v7 + 96));
            if ( *(_DWORD *)(v7 + 112) )
            {
              common::milog::MiLogStream::create(
                &v229,
                &common::milog::MiLogDefault::default_log_obj_,
                3u,
                "./src/player/item/player_item_comp.cpp",
                "internalUseItem",
                2122);
              v176 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                       &v229,
                       (const char (*)[31])"unlockCardFace fail. card_id: ");
              v177 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                       v176,
                       (const unsigned int *)(v7 + 80));
              v178 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(
                       v177,
                       (const char (*)[13])" face_type: ");
              *(_QWORD *)(v7 + 128) = data::enumValToStr((data::GCGCardFaceType)*(_DWORD *)(v7 + 96));
              v179 = common::milog::MiLogStream::operator<<<char const*,(char const**)0>(
                       v178,
                       (const char *const *)(v7 + 128));
              v180 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v179, (const char (*)[7])" ret: ");
              common::milog::MiLogStream::operator<<<int,(int *)0>(v180, (const int *)(v7 + 112));
              common::milog::MiLogStream::~MiLogStream(&v229);
            }
          }
        }
      }
      else
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          2106);
        v169 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v229,
                 (const char (*)[44])"use_param's size is less than 2! use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v169, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      goto LABEL_378;
    case ITEM_USE_GAIN_GCG_CARD_BACK:
      *(_DWORD *)(v7 + 96) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          2131);
        v181 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                 &v229,
                 (const char (*)[29])"strVecToNum fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v181, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v182 = Player::getGCGComp(this->player_);
        v183 = PlayerGCGComp::getDeckSystem(v182);
        *(_DWORD *)(v7 + 112) = GCGDeckSystem::unlockCardBack(v183, *(_DWORD *)(v7 + 96));
        if ( *(_DWORD *)(v7 + 112) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            2137);
          v184 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                   &v229,
                   (const char (*)[36])"unlockCardBack fail. card_back_id: ");
          v185 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                   v184,
                   (const unsigned int *)(v7 + 96));
          v186 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v185, (const char (*)[7])" ret: ");
          common::milog::MiLogStream::operator<<<int,(int *)0>(v186, (const int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    case ITEM_USE_GAIN_GCG_CARD_FIELD:
      *(_DWORD *)(v7 + 96) = 0;
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(
             &item_use_config->use_param,
             (unsigned int *)(v7 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v229,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "internalUseItem",
          2146);
        v187 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                 &v229,
                 (const char (*)[29])"strVecToNum fail, use_param:");
        common::milog::MiLogStream::operator<<<std::string>(v187, &item_use_config->use_param);
        common::milog::MiLogStream::~MiLogStream(&v229);
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v188 = Player::getGCGComp(this->player_);
        v189 = PlayerGCGComp::getDeckSystem(v188);
        *(_DWORD *)(v7 + 112) = GCGDeckSystem::unlockField(v189, *(_DWORD *)(v7 + 96));
        if ( *(_DWORD *)(v7 + 112) )
        {
          common::milog::MiLogStream::create(
            &v229,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "internalUseItem",
            2152);
          v190 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                   &v229,
                   (const char (*)[29])"unlockField fail. field_id: ");
          v191 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                   v190,
                   (const unsigned int *)(v7 + 96));
          v192 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v191, (const char (*)[7])" ret: ");
          common::milog::MiLogStream::operator<<<int,(int *)0>(v192, (const int *)(v7 + 112));
          common::milog::MiLogStream::~MiLogStream(&v229);
        }
      }
      goto LABEL_378;
    default:
      goto LABEL_378;
  }
};

// Line 2163: range 0000000017CCC472-0000000017CCCEB5
void __fastcall PlayerItemComp::useItemAddDungeonCondTime(
        PlayerItemComp *const this,
        const data::ItemUseConfig *use_config,
        uint32_t count)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  const std::string *v6; // rax
  common::milog::MiLogStream *v7; // rbx
  const std::string *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // r14
  common::milog::MiLogStream *v11; // rax
  std::__shared_ptr_access<DungeonScene,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  common::milog::MiLogStream *v13; // r14
  common::milog::MiLogStream *v14; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // r14
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  const std::string *v22; // rax
  common::milog::MiLogStream *v23; // r14
  const std::string *v24; // rax
  common::milog::MiLogStream *v25; // rax
  DungeonScene *v26; // rax
  common::milog::MiLogStream *v27; // r14
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rax
  unsigned int val; // [rsp+2Ch] [rbp-114h] BYREF
  PlayerDungeonComp *dungeon_comp; // [rsp+30h] [rbp-110h]
  const data::DungeonExcelConfig *dungeon_config_ptr; // [rsp+38h] [rbp-108h]
  std::shared_ptr<Config> v36; // [rsp+40h] [rbp-100h] BYREF
  common::milog::MiLogStream v37; // [rsp+50h] [rbp-F0h] BYREF
  char v38[208]; // [rsp+70h] [rbp-D0h] BYREF

  v3 = (unsigned __int64)v38;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(160LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "7 32 4 11 param1:2169 48 4 17 dungeon_type:2175 64 4 15 dungeon_id:2185 80 4 11 param2:2203 96 4"
                        " 15 total_secs:2216 112 4 10 count:2162 128 16 16 dungeon_ptr:2179";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::useItemAddDungeonCondTime;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556924;
  v5[536862722] = -234556924;
  v5[536862723] = -234556924;
  v5[536862724] = -202178560;
  *(_DWORD *)(v3 + 112) = count;
  if ( std::vector<std::string>::size(&use_config->use_param) > 1 )
  {
    *(_DWORD *)(v3 + 32) = 0;
    v6 = std::vector<std::string>::operator[](&use_config->use_param, 0LL);
    if ( common::tools::StringUtils::strToNum<unsigned int>(v6, (unsigned int *)(v3 + 32), 1) )
    {
      common::milog::MiLogStream::create(
        &v37,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "useItemAddDungeonCondTime",
        2172);
      v7 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(&v37, (const char (*)[15])"use_param[0]: ");
      v8 = std::vector<std::string>::operator[](&use_config->use_param, 0LL);
      v9 = common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(v7, v8);
      common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v9, (const char (*)[17])" strToNum failed");
      common::milog::MiLogStream::~MiLogStream(&v37);
    }
    else
    {
      *(_DWORD *)(v3 + 48) = *(_DWORD *)(v3 + 32);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      dungeon_comp = Player::getDungeonComp(this->player_);
      PlayerDungeonComp::getCurDungeon((PlayerDungeonComp *const)(v3 + 128));
      if ( std::operator==<DungeonScene>((const std::shared_ptr<DungeonScene> *)(v3 + 128), 0LL) )
      {
        common::milog::MiLogStream::create(
          &v37,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "useItemAddDungeonCondTime",
          2182);
        v10 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(&v37, (const char (*)[6])"uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        v11 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, &val);
        common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
          v11,
          (const char (*)[22])" getCurDungeon failed");
        common::milog::MiLogStream::~MiLogStream(&v37);
      }
      else
      {
        v12 = std::__shared_ptr_access<DungeonScene,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DungeonScene,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
        *(_DWORD *)(v3 + 64) = DungeonScene::getDungeonId(v12);
        if ( *(_DWORD *)(v3 + 64) )
        {
          ServiceBox::findService<GameserverService>();
          GameserverService::getConfig((GameserverService *const)&v36);
          v15 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v36);
          dungeon_config_ptr = data::DungeonExcelConfigMgrBase::findDungeonExcelConfig(
                                 &v15->design_config.txt_config_mgr.dungeon_config_mgr,
                                 *(_DWORD *)(v3 + 64));
          std::shared_ptr<Config>::~shared_ptr(&v36);
          if ( dungeon_config_ptr )
          {
            if ( !*(_DWORD *)(v3 + 48) )
              goto LABEL_27;
            if ( *(_BYTE *)(((unsigned __int64)&dungeon_config_ptr->play_type >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)dungeon_config_ptr + 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&dungeon_config_ptr->play_type >> 3)
                                                                                + 0x7FFF8000) )
            {
              __asan_report_load4(&dungeon_config_ptr->play_type);
            }
            if ( dungeon_config_ptr->play_type == *(_DWORD *)(v3 + 48) )
            {
LABEL_27:
              *(_DWORD *)(v3 + 80) = 0;
              v22 = std::vector<std::string>::operator[](&use_config->use_param, 1uLL);
              if ( common::tools::StringUtils::strToNum<unsigned int>(v22, (unsigned int *)(v3 + 80), 1) )
              {
                common::milog::MiLogStream::create(
                  &v37,
                  &common::milog::MiLogDefault::default_log_obj_,
                  3u,
                  "./src/player/item/player_item_comp.cpp",
                  "useItemAddDungeonCondTime",
                  2206);
                v23 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(
                        &v37,
                        (const char (*)[15])"use_param[1]: ");
                v24 = std::vector<std::string>::operator[](&use_config->use_param, 1uLL);
                v25 = common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(v23, v24);
                common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                  v25,
                  (const char (*)[17])" strToNum failed");
                common::milog::MiLogStream::~MiLogStream(&v37);
              }
              else if ( *(_DWORD *)(v3 + 80) )
              {
                *(_DWORD *)(v3 + 96) = SAFE_MULTIPLY<unsigned int,unsigned int>(
                                         *(_DWORD *)(v3 + 80),
                                         *(_DWORD *)(v3 + 112));
                v26 = std::__shared_ptr_access<DungeonScene,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DungeonScene,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
                DungeonScene::relaxTimeRestriction(v26, *(_DWORD *)(v3 + 96));
                common::milog::MiLogStream::create(
                  &v37,
                  &common::milog::MiLogDefault::default_log_obj_,
                  1u,
                  "./src/player/item/player_item_comp.cpp",
                  "useItemAddDungeonCondTime",
                  2218);
                v27 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(&v37, (const char (*)[6])"uid: ");
                if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                  __asan_report_load8();
                val = Player::getUid(this->player_);
                v28 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, &val);
                v29 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                        v28,
                        (const char (*)[35])" useItemAddDungeonCondTime count: ");
                v30 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                        v29,
                        (const unsigned int *)(v3 + 112));
                v31 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(
                        v30,
                        (const char (*)[14])" total secs: ");
                common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v31,
                  (const unsigned int *)(v3 + 96));
                common::milog::MiLogStream::~MiLogStream(&v37);
              }
              else
              {
                common::milog::MiLogStream::create(
                  &v37,
                  &common::milog::MiLogDefault::default_log_obj_,
                  3u,
                  "./src/player/item/player_item_comp.cpp",
                  "useItemAddDungeonCondTime",
                  2211);
                common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                  &v37,
                  (const char (*)[43])"ITEM_USE_ADD_DUNGEON_COND_TIME param2 == 0");
                common::milog::MiLogStream::~MiLogStream(&v37);
              }
            }
            else
            {
              common::milog::MiLogStream::create(
                &v37,
                &common::milog::MiLogDefault::default_log_obj_,
                3u,
                "./src/player/item/player_item_comp.cpp",
                "useItemAddDungeonCondTime",
                2199);
              v17 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(&v37, (const char (*)[6])"uid: ");
              if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                __asan_report_load8();
              val = Player::getUid(this->player_);
              v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, &val);
              v19 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(
                      v18,
                      (const char (*)[20])" cur dungeon type: ");
              v20 = common::milog::MiLogStream::operator<<<data::DungeonPlayType,(data::DungeonPlayType*)0>(
                      v19,
                      &dungeon_config_ptr->play_type);
              v21 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(
                      v20,
                      (const char (*)[25])" material dungeon type: ");
              common::milog::MiLogStream::operator<<<data::DungeonPlayType,(data::DungeonPlayType*)0>(
                v21,
                (const data::DungeonPlayType *)(v3 + 48));
              common::milog::MiLogStream::~MiLogStream(&v37);
            }
          }
          else
          {
            common::milog::MiLogStream::create(
              &v37,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "useItemAddDungeonCondTime",
              2194);
            v16 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                    &v37,
                    (const char (*)[35])"findDungeonExcelConfig failed for ");
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, (const unsigned int *)(v3 + 64));
            common::milog::MiLogStream::~MiLogStream(&v37);
          }
        }
        else
        {
          common::milog::MiLogStream::create(
            &v37,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "useItemAddDungeonCondTime",
            2188);
          v13 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(&v37, (const char (*)[6])"uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, &val);
          common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v14, (const char (*)[16])" not in dungeon");
          common::milog::MiLogStream::~MiLogStream(&v37);
        }
      }
      std::shared_ptr<DungeonScene>::~shared_ptr((std::shared_ptr<DungeonScene> *const)(v3 + 128));
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v37,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "useItemAddDungeonCondTime",
      2166);
    common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(&v37, (const char (*)[22])"use_param.size() != 2");
    common::milog::MiLogStream::~MiLogStream(&v37);
  }
  if ( v38 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8010) = -168430091;
  }
};

// Line 2222: range 0000000017CCCEB6-0000000017CCD77A
void __cdecl PlayerItemComp::useItemMakeGadget(PlayerItemComp *const this, const data::ItemUseConfig *use_config)
{
  unsigned __int64 v2; // r13
  __int64 v3; // rax
  _DWORD *v4; // r12
  common::milog::MiLogStream *v5; // rbx
  common::milog::MiLogStream *v6; // r14
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  unsigned __int64 Rotation; // rax
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  const Vector3 *Position; // rax
  Scene *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // r14
  std::__shared_ptr_access<Gadget,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v15; // r14
  unsigned __int64 v16; // rax
  std::__shared_ptr_access<Scene,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v17; // rsi
  void (__fastcall *v18)(std::__shared_ptr_access<Gadget,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, std::__shared_ptr_access<Scene,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, VisionContext *); // [rsp+8h] [rbp-4F8h]
  unsigned int val; // [rsp+28h] [rbp-4D8h] BYREF
  Vector3 vec; // [rsp+2Ch] [rbp-4D4h] BYREF
  Vector3 v21; // [rsp+38h] [rbp-4C8h] BYREF
  Vector3 right; // [rsp+44h] [rbp-4BCh] BYREF
  common::milog::MiLogStream v23; // [rsp+50h] [rbp-4B0h] BYREF
  char v24[1168]; // [rsp+70h] [rbp-490h] BYREF

  v2 = (unsigned __int64)v24;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_5(1120LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "6 32 4 14 gadget_id:2223 48 16 15 avatar_ptr:2229 80 16 14 scene_ptr:2235 112 16 8 qua:2245 144 "
                        "16 15 gadget_ptr:2249 176 816 17 gadget_param:2241";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::useItemMakeGadget;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = 61956;
  v4[536862722] = 62194;
  v4[536862723] = 62194;
  v4[536862724] = 62194;
  v4[536862725] = 62194;
  v4[536862751] = -202116109;
  v4[536862752] = -202116109;
  v4[536862753] = -202116109;
  v4[536862754] = -202116109;
  *(_DWORD *)(v2 + 32) = 0;
  if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(&use_config->use_param, (unsigned int *)(v2 + 32)) )
  {
    common::milog::MiLogStream::create(
      &v23,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "useItemMakeGadget",
      2226);
    v5 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(
           &v23,
           (const char (*)[25])"strVecToNum fails, uid: ");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &val);
    common::milog::MiLogStream::~MiLogStream(&v23);
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    Player::getCurAvatar((Player *const)(v2 + 48));
    if ( std::operator==<Avatar>((const std::shared_ptr<Avatar> *)(v2 + 48), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v23,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "useItemMakeGadget",
        2232);
      common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(&v23, (const char (*)[19])"getCurAvatar fails");
      common::milog::MiLogStream::~MiLogStream(&v23);
    }
    else
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getSceneComp(this->player_);
      PlayerSceneComp::getCurScene((const PlayerSceneComp *const)(v2 + 80));
      if ( std::operator==<Scene>((const std::shared_ptr<Scene> *)(v2 + 80), 0LL) )
      {
        common::milog::MiLogStream::create(
          &v23,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "useItemMakeGadget",
          2238);
        v6 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(
               &v23,
               (const char (*)[25])"getCurScene fails, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, &val);
        common::milog::MiLogStream::~MiLogStream(&v23);
      }
      else
      {
        GadgetParam::GadgetParam((GadgetParam *const)(v2 + 176));
        *(_DWORD *)(v2 + 176) = *(_DWORD *)(v2 + 32);
        v7 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 48));
        Rotation = (unsigned __int64)Entity::getRotation((const Entity *const)v7);
        if ( (char)(Rotation & 7) >= *(_BYTE *)((Rotation >> 3) + 0x7FFF8000)
          && *(_BYTE *)((Rotation >> 3) + 0x7FFF8000) != 0
          || *(_BYTE *)(((Rotation + 11) >> 3) + 0x7FFF8000) != 0
          && (char)((Rotation + 11) & 7) >= *(_BYTE *)(((Rotation + 11) >> 3) + 0x7FFF8000) )
        {
          Rotation = __asan_report_load_n(Rotation, 12LL);
        }
        *(_QWORD *)(v2 + 200) = *(_QWORD *)Rotation;
        *(_DWORD *)(v2 + 208) = *(_DWORD *)(Rotation + 8);
        *(_DWORD *)(v2 + 268) = 6;
        Quaternion::Quaternion((Quaternion *const)(v2 + 112));
        Quaternion::fromEuler((Quaternion *const)(v2 + 112), (const Vector3 *)(v2 + 200));
        Vector3::Vector3(&vec, 0.0, 0.0, 1.0);
        v21 = Quaternion::rotateVector3((const Quaternion *const)(v2 + 112), &vec);
        right = Vector3::operator*(&v21, 1.0);
        v9 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 48));
        Position = Entity::getPosition((const Entity *const)v9);
        *(Vector3 *)(v2 + 188) = operator+(Position, &right);
        v11 = std::__shared_ptr_access<Scene,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Scene,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 80));
        *(_DWORD *)(v2 + 184) = Scene::genNewEntityId(v11, PROT_ENTITY_GADGET);
        EntityMgr::createGadget((const GadgetParam *)(v2 + 144));
        if ( std::operator==<Gadget>((const std::shared_ptr<Gadget> *)(v2 + 144), 0LL) )
        {
          common::milog::MiLogStream::create(
            &v23,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "useItemMakeGadget",
            2252);
          v12 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(
                  &v23,
                  (const char (*)[14])"createGadget ");
          v13 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v12,
                  (const unsigned int *)(v2 + 32));
          v14 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(
                  v13,
                  (const char (*)[14])" fails, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &val);
          common::milog::MiLogStream::~MiLogStream(&v23);
        }
        else
        {
          v15 = std::__shared_ptr_access<Gadget,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Gadget,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 144));
          if ( *(_BYTE *)(((unsigned __int64)v15 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v16 = *(_QWORD *)v15->baseclass_0 + 56LL;
          if ( *(_BYTE *)((v16 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v18 = *(void (__fastcall **)(std::__shared_ptr_access<Gadget,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, std::__shared_ptr_access<Scene,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, VisionContext *))v16;
          v17 = std::__shared_ptr_access<Scene,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<Scene,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 80));
          v18(v15, v17, &VisionContext::meet_context);
        }
        std::shared_ptr<Gadget>::~shared_ptr((std::shared_ptr<Gadget> *const)(v2 + 144));
        GadgetParam::~GadgetParam((GadgetParam *const)(v2 + 176));
      }
      std::shared_ptr<Scene>::~shared_ptr((std::shared_ptr<Scene> *const)(v2 + 80));
    }
    std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v2 + 48));
  }
  if ( v24 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF807C) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8084) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    __asan_stack_free_5(v2, 1120LL, v24);
  }
};

// Line 2259: range 0000000017CCD80E-0000000017CCE359
__int64 __fastcall PlayerItemComp::getUseTarget(
        PlayerItemComp *const this,
        data::ItemUseTarget use_target,
        uint64_t target_guid,
        std::vector<std::shared_ptr<Avatar>> *target_vec)
{
  unsigned int v4; // r14d
  unsigned __int64 v5; // r12
  __int64 v6; // rax
  _DWORD *v7; // r13
  common::milog::MiLogStream *v8; // r14
  int v9; // r15d
  std::shared_ptr<Avatar> *v10; // rax
  PlayerAvatarComp *v11; // rax
  common::milog::MiLogStream *v12; // r14
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  int v15; // r15d
  std::shared_ptr<Avatar> *v16; // rax
  PlayerAvatarComp *v17; // rax
  common::milog::MiLogStream *v18; // rcx
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  int v21; // r15d
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v22; // rax
  common::milog::MiLogStream *v23; // r14
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v24; // rax
  std::shared_ptr<Avatar> *v25; // rax
  PlayerAvatarComp *v26; // rax
  common::milog::MiLogStream *v27; // rcx
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  int v30; // r15d
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v31; // rax
  common::milog::MiLogStream *v32; // r14
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v33; // rax
  std::shared_ptr<Avatar> *v34; // rax
  PlayerAvatarComp *AvatarComp; // rbx
  common::milog::MiLogStream *v36; // rcx
  int v37; // r15d
  std::shared_ptr<Avatar> *v38; // rax
  __int64 result; // rax
  unsigned int val; // [rsp+3Ch] [rbp-B4h] BYREF
  common::milog::MiLogStream v43; // [rsp+40h] [rbp-B0h] BYREF
  char v44[144]; // [rsp+60h] [rbp-90h] BYREF

  v5 = (unsigned __int64)v44;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_1(96LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "2 32 8 16 target_guid:2258 64 16 22 player_avatar_ptr:2328";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::getUseTarget;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -218959360;
  v7[536862722] = -202178560;
  *(_QWORD *)(v5 + 32) = target_guid;
  switch ( use_target )
  {
    case ITEM_USE_TARGET_CUR_AVATAR:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getCurAvatar((Player *const)(v5 + 64));
      if ( std::operator==<Avatar>((const std::shared_ptr<Avatar> *)(v5 + 64), 0LL) )
      {
        common::milog::MiLogStream::create(
          &v43,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "getUseTarget",
          2268);
        v8 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(&v43, (const char (*)[28])off_2638E8A0);
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, &val);
        common::milog::MiLogStream::~MiLogStream(&v43);
        v4 = 610;
        v9 = 0;
      }
      else
      {
        v10 = std::move<std::shared_ptr<Avatar> &>((std::shared_ptr<Avatar> *)(v5 + 64));
        std::vector<std::shared_ptr<Avatar>>::emplace_back<std::shared_ptr<Avatar>>(target_vec, v10, v10);
        v9 = 1;
      }
      std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v5 + 64));
      if ( v9 == 1 )
        goto LABEL_56;
      goto LABEL_57;
    case ITEM_USE_TARGET_CUR_TEAM:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      AvatarComp = Player::getAvatarComp(this->player_);
      std::function<ForeachPolicy ()(Avatar &)>::function<PlayerItemComp::getUseTarget(data::ItemUseTarget,unsigned long,std::vector<std::shared_ptr<Avatar>> &)::{lambda(Avatar &)#1},void,void>(
        (std::function<ForeachPolicy(Avatar&)> *const)&v43,
        (PlayerItemComp::getUseTarget::<lambda(Avatar&)>)target_vec);
      PlayerAvatarComp::foreachMyAvatarInSceneTeam(AvatarComp, (std::function<ForeachPolicy(Avatar&)> *)&v43);
      std::function<ForeachPolicy ()(Avatar &)>::~function((std::function<ForeachPolicy(Avatar&)> *const)&v43);
      goto LABEL_56;
    case ITEM_USE_TARGET_SPECIFY_AVATAR:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v11 = Player::getAvatarComp(this->player_);
      PlayerAvatarComp::findAvatar((const PlayerAvatarComp *const)(v5 + 64), (uint64_t)v11, *(_QWORD *)(v5 + 32));
      if ( std::operator==<Avatar>((const std::shared_ptr<Avatar> *)(v5 + 64), 0LL) )
      {
        common::milog::MiLogStream::create(
          &v43,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "getUseTarget",
          2279);
        v12 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
                &v43,
                (const char (*)[24])"findAvatar failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        v13 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v12, &val);
        v14 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v13, (const char (*)[14])" target_guid:");
        common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
          v14,
          (const unsigned __int64 *)(v5 + 32));
        common::milog::MiLogStream::~MiLogStream(&v43);
        v4 = 610;
        v15 = 0;
      }
      else
      {
        v16 = std::move<std::shared_ptr<Avatar> &>((std::shared_ptr<Avatar> *)(v5 + 64));
        std::vector<std::shared_ptr<Avatar>>::emplace_back<std::shared_ptr<Avatar>>(target_vec, v16, v16);
        v15 = 1;
      }
      std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v5 + 64));
      if ( v15 == 1 )
        goto LABEL_56;
      goto LABEL_57;
    case ITEM_USE_TARGET_SPECIFY_ALIVE_AVATAR:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v17 = Player::getAvatarComp(this->player_);
      PlayerAvatarComp::findAvatar((const PlayerAvatarComp *const)(v5 + 64), (uint64_t)v17, *(_QWORD *)(v5 + 32));
      if ( std::operator==<Avatar>((const std::shared_ptr<Avatar> *)(v5 + 64), 0LL) )
      {
        common::milog::MiLogStream::create(
          &v43,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "getUseTarget",
          2290);
        v18 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
                &v43,
                (const char (*)[28])"invalid use target, player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v19 = operator<<(v18, this->player_);
        v20 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v19, (const char (*)[7])" guid:");
        common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
          v20,
          (const unsigned __int64 *)(v5 + 32));
        common::milog::MiLogStream::~MiLogStream(&v43);
        v4 = 610;
        v21 = 0;
      }
      else
      {
        v22 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
        if ( Creature::getLifeState(v22) == LIFE_ALIVE )
        {
          v25 = std::move<std::shared_ptr<Avatar> &>((std::shared_ptr<Avatar> *)(v5 + 64));
          std::vector<std::shared_ptr<Avatar>>::emplace_back<std::shared_ptr<Avatar>>(target_vec, v25, v25);
          v21 = 1;
        }
        else
        {
          common::milog::MiLogStream::create(
            &v43,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "getUseTarget",
            2295);
          v23 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
                  &v43,
                  (const char (*)[21])"avatar is not alive:");
          v24 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
          common::milog::MiLogStream::operator<<<Avatar,(Avatar*)0>(v23, v24);
          common::milog::MiLogStream::~MiLogStream(&v43);
          v4 = 102;
          v21 = 0;
        }
      }
      std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v5 + 64));
      if ( v21 == 1 )
        goto LABEL_56;
      goto LABEL_57;
    case ITEM_USE_TARGET_SPECIFY_DEAD_AVATAR:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v26 = Player::getAvatarComp(this->player_);
      PlayerAvatarComp::findAvatar((const PlayerAvatarComp *const)(v5 + 64), (uint64_t)v26, *(_QWORD *)(v5 + 32));
      if ( std::operator==<Avatar>((const std::shared_ptr<Avatar> *)(v5 + 64), 0LL) )
      {
        common::milog::MiLogStream::create(
          &v43,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "getUseTarget",
          2306);
        v27 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
                &v43,
                (const char (*)[28])"invalid use target, player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v28 = operator<<(v27, this->player_);
        v29 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v28, (const char (*)[7])" guid:");
        common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
          v29,
          (const unsigned __int64 *)(v5 + 32));
        common::milog::MiLogStream::~MiLogStream(&v43);
        v4 = 610;
        v30 = 0;
      }
      else
      {
        v31 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
        if ( Creature::getLifeState(v31) == LIFE_DEAD )
        {
          v34 = std::move<std::shared_ptr<Avatar> &>((std::shared_ptr<Avatar> *)(v5 + 64));
          std::vector<std::shared_ptr<Avatar>>::emplace_back<std::shared_ptr<Avatar>>(target_vec, v34, v34);
          v30 = 1;
        }
        else
        {
          common::milog::MiLogStream::create(
            &v43,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "getUseTarget",
            2311);
          v32 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(
                  &v43,
                  (const char (*)[20])"avatar is not dead:");
          v33 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
          common::milog::MiLogStream::operator<<<Avatar,(Avatar*)0>(v32, v33);
          common::milog::MiLogStream::~MiLogStream(&v43);
          v4 = 113;
          v30 = 0;
        }
      }
      std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v5 + 64));
      if ( v30 == 1 )
        goto LABEL_56;
      goto LABEL_57;
    case ITEM_USE_TARGET_PLAYER_AVATAR:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getAvatarComp(this->player_);
      PlayerAvatarComp::getPlayerAvatarPtr((PlayerAvatarComp *const)(v5 + 64));
      if ( std::operator==<Avatar>(0LL, (const std::shared_ptr<Avatar> *)(v5 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v43,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "getUseTarget",
          2331);
        v36 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                &v43,
                (const char (*)[35])"cannot find player avatar, player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v36, this->player_);
        common::milog::MiLogStream::~MiLogStream(&v43);
        v4 = 104;
        v37 = 0;
      }
      else
      {
        v38 = std::move<std::shared_ptr<Avatar> &>((std::shared_ptr<Avatar> *)(v5 + 64));
        std::vector<std::shared_ptr<Avatar>>::emplace_back<std::shared_ptr<Avatar>>(target_vec, v38, v38);
        v37 = 1;
      }
      std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v5 + 64));
      if ( v37 == 1 )
        goto LABEL_56;
      goto LABEL_57;
    default:
LABEL_56:
      v4 = 0;
LABEL_57:
      result = v4;
      if ( v44 == (char *)v5 )
      {
        *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
        *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = 0;
      }
      else
      {
        *(_QWORD *)v5 = 1172321806LL;
        *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
        *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = -168430091;
      }
      return result;
  }
};

// Line 2319: range 0000000017CCD77C-0000000017CCD80C
ForeachPolicy __cdecl PlayerItemComp::getUseTarget(data::ItemUseTarget,unsigned long,std::vector<std::shared_ptr<Avatar>> &)::{lambda(Avatar&)#1}::operator()(
        const PlayerItemComp::getUseTarget::<lambda(Avatar&)> *const __closure,
        Avatar *avatar)
{
  std::vector<std::shared_ptr<Avatar>> *target_vec; // rbx
  std::shared_ptr<Avatar> v3; // rax
  std::shared_ptr<Avatar> v5; // [rsp+10h] [rbp-20h] BYREF

  if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  target_vec = __closure->__target_vec;
  v3 = toThisPtr<Avatar>((Avatar *)&v5);
  std::vector<std::shared_ptr<Avatar>>::emplace_back<std::shared_ptr<Avatar>>(
    target_vec,
    &v5,
    (std::shared_ptr<Avatar> *)v3._M_refcount._M_pi);
  std::shared_ptr<Avatar>::~shared_ptr(&v5);
  return 0;
};

// Line 2346: range 0000000017CCE35A-0000000017CCE6E1
int32_t __cdecl PlayerItemComp::filterUseTarget(
        PlayerItemComp *const this,
        const data::MaterialExcelConfig *material_config,
        std::vector<std::shared_ptr<Avatar>> *target_vec)
{
  int32_t v3; // r14d
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r13
  const std::shared_ptr<Avatar> *v7; // rax
  Avatar *v8; // rax
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  common::milog::MiLogStream *v10; // r14
  int v11; // r15d
  int32_t result; // eax
  unsigned int val; // [rsp+24h] [rbp-ECh] BYREF
  std::vector<std::shared_ptr<Avatar>>::iterator __for_begin; // [rsp+28h] [rbp-E8h] BYREF
  std::vector<std::shared_ptr<Avatar>>::iterator __for_end; // [rsp+30h] [rbp-E0h] BYREF
  std::vector<std::shared_ptr<Avatar>> *__for_range; // [rsp+38h] [rbp-D8h]
  common::milog::MiLogStream v18; // [rsp+40h] [rbp-D0h] BYREF
  char v19[176]; // [rsp+60h] [rbp-B0h] BYREF

  v4 = (unsigned __int64)v19;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "2 32 16 15 avatar_ptr:2351 64 24 22 result_target_vec:2350";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::filterUseTarget;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -219021312;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  if ( std::vector<unsigned int>::empty(&material_config->satiation_params) )
    goto LABEL_18;
  std::vector<std::shared_ptr<Avatar>>::vector((std::vector<std::shared_ptr<Avatar>> *const)(v4 + 64));
  __for_range = target_vec;
  __for_begin._M_current = std::vector<std::shared_ptr<Avatar>>::begin(target_vec)._M_current;
  __for_end._M_current = std::vector<std::shared_ptr<Avatar>>::end(target_vec)._M_current;
  while ( __gnu_cxx::operator!=<std::shared_ptr<Avatar> *,std::vector<std::shared_ptr<Avatar>>>(
            &__for_begin,
            &__for_end) )
  {
    v7 = __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> *,std::vector<std::shared_ptr<Avatar>>>::operator*(&__for_begin);
    std::shared_ptr<Avatar>::shared_ptr((std::shared_ptr<Avatar> *const)(v4 + 32), v7);
    if ( !std::operator==<Avatar>(0LL, (const std::shared_ptr<Avatar> *)(v4 + 32)) )
    {
      v8 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 32));
      if ( !Avatar::isSatiationFull(v8) )
      {
        v9 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 32));
        if ( Creature::getLifeState(v9) == LIFE_ALIVE )
          std::vector<std::shared_ptr<Avatar>>::push_back(
            (std::vector<std::shared_ptr<Avatar>> *const)(v4 + 64),
            (const std::vector<std::shared_ptr<Avatar>>::value_type *)(v4 + 32));
      }
    }
    std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v4 + 32));
    __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> *,std::vector<std::shared_ptr<Avatar>>>::operator++(&__for_begin);
  }
  if ( std::vector<std::shared_ptr<Avatar>>::empty((const std::vector<std::shared_ptr<Avatar>> *const)(v4 + 64)) )
  {
    common::milog::MiLogStream::create(
      &v18,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "filterUseTarget",
      2371);
    v10 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
            &v18,
            (const char (*)[34])"no avatar satisfy satiation, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, &val);
    common::milog::MiLogStream::~MiLogStream(&v18);
    v3 = 672;
    v11 = 0;
  }
  else
  {
    std::vector<std::shared_ptr<Avatar>>::swap(target_vec, (std::vector<std::shared_ptr<Avatar>> *)(v4 + 64));
    v11 = 1;
  }
  std::vector<std::shared_ptr<Avatar>>::~vector((std::vector<std::shared_ptr<Avatar>> *const)(v4 + 64));
  if ( v11 == 1 )
LABEL_18:
    v3 = 0;
  result = v3;
  if ( v19 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 2380: range 0000000017CCE6E2-0000000017CCEF31
void __cdecl PlayerItemComp::afterUseItem(
        PlayerItemComp *const this,
        const data::MaterialExcelConfig *material_config,
        const std::vector<std::shared_ptr<Avatar>> *target_vec,
        const ItemUseParam *use_param)
{
  __m128i v4; // xmm0
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  PlayerBasicComp *BasicComp; // rax
  const std::shared_ptr<Avatar> *v9; // rax
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  Avatar *v11; // r15
  uint32_t v12; // r14d
  __gnu_cxx::__alloc_traits<std::allocator<unsigned int>,unsigned int>::value_type *v13; // rax
  int *v14; // rdx
  __gnu_cxx::__alloc_traits<std::allocator<unsigned int>,unsigned int>::value_type *v15; // rax
  int *v16; // rdx
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v17; // r14
  proto::AvatarSatiationData *v18; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v19; // r14
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v20; // rax
  unsigned __int64 v21; // rdx
  google::protobuf::uint32 v22; // eax
  std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v23; // r14
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v24; // rax
  uint32_t AvatarId; // eax
  std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v26; // r14
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v27; // rax
  float SatiationVal; // xmm0_4
  std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v29; // r14
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v30; // rax
  float v31; // xmm0_4
  std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v32; // r14
  std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v33; // rax
  google::protobuf::uint32 v34; // eax
  std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v35; // rcx
  std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v36; // rcx
  Player *player; // r14
  const google::protobuf::RepeatedPtrField<proto::AvatarSatiationData> *v38; // rax
  std::string v39; // [rsp+0h] [rbp-190h]
  float material_param_b; // [rsp+Ch] [rbp-184h]
  float old_satiation_val; // [rsp+3Ch] [rbp-154h]
  std::vector<std::shared_ptr<Avatar>>::const_iterator __for_begin; // [rsp+40h] [rbp-150h] BYREF
  std::vector<std::shared_ptr<Avatar>>::const_iterator __for_end; // [rsp+48h] [rbp-148h] BYREF
  const std::vector<unsigned int> *params; // [rsp+50h] [rbp-140h]
  const std::vector<std::shared_ptr<Avatar>> *__for_range; // [rsp+58h] [rbp-138h]
  std::shared_ptr<google::protobuf::Message> p_body_ptr; // [rsp+60h] [rbp-130h] BYREF
  std::shared_ptr<google::protobuf::Message> p_body_ext_ptr; // [rsp+70h] [rbp-120h] BYREF
  std::string v48; // [rsp+80h] [rbp-110h] BYREF
  char v49[240]; // [rsp+A0h] [rbp-F0h] BYREF

  *(&v39._anon_0._M_allocated_capacity + 1) = (std::string::size_type)target_vec;
  v39._anon_0._M_allocated_capacity = (std::string::size_type)use_param;
  v5 = (unsigned __int64)v49;
  v39._M_dataplus._M_p = v49;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(192LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "4 32 1 23 log_context_holder:2385 48 16 15 avatar_ptr:2388 80 16 12 log_ptr:2399 112 48 11 notify:2387";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::afterUseItem;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = 61953;
  v7[536862722] = 62194;
  v7[536862723] = 62194;
  v7[536862725] = -202116109;
  params = &material_config->satiation_params;
  if ( std::vector<unsigned int>::size(&material_config->satiation_params) > 1 )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      *(double *)v4.m128i_i64 = __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11](&v48, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 32), 0x651u, v39);
    std::string::~string(&v48);
    proto::AvatarSatiationDataNotify::AvatarSatiationDataNotify((proto::AvatarSatiationDataNotify *const)(v5 + 112));
    __for_range = (const std::vector<std::shared_ptr<Avatar>> *)*(&v39._anon_0._M_allocated_capacity + 1);
    __for_begin._M_current = std::vector<std::shared_ptr<Avatar>>::begin(*((const std::vector<std::shared_ptr<Avatar>> *const *)&v39._anon_0._M_allocated_capacity
                                                                         + 1))._M_current;
    __for_end._M_current = std::vector<std::shared_ptr<Avatar>>::end(*((const std::vector<std::shared_ptr<Avatar>> *const *)&v39._anon_0._M_allocated_capacity
                                                                     + 1))._M_current;
    while ( __gnu_cxx::operator!=<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>(
              &__for_begin,
              &__for_end) )
    {
      v9 = __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator*(&__for_begin);
      std::shared_ptr<Avatar>::shared_ptr((std::shared_ptr<Avatar> *const)(v5 + 48), v9);
      if ( !std::operator==<Avatar>(0LL, (const std::shared_ptr<Avatar> *)(v5 + 48)) )
      {
        v10 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 48));
        *(float *)v4.m128i_i32 = Avatar::getSatiationVal(v10);
        old_satiation_val = COERCE_FLOAT(_mm_cvtsi128_si32(v4));
        v11 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 48));
        if ( *(_BYTE *)((v39._anon_0._M_allocated_capacity >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)((v39._anon_0._M_allocated_capacity >> 3) + 0x7FFF8000) <= 3 )
        {
          *(double *)v4.m128i_i64 = __asan_report_load4(v39._anon_0._M_allocated_capacity);
        }
        v12 = *(_DWORD *)v39._anon_0._M_allocated_capacity;
        v13 = (__gnu_cxx::__alloc_traits<std::allocator<unsigned int>,unsigned int>::value_type *)std::vector<unsigned int>::operator[](
                                                                                                    params,
                                                                                                    1uLL);
        v14 = (int *)v13;
        if ( *(_BYTE *)(((unsigned __int64)v13 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v13 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v13 >> 3) + 0x7FFF8000) )
        {
          *(double *)v4.m128i_i64 = __asan_report_load4(v13);
        }
        material_param_b = (float)*v14;
        v15 = (__gnu_cxx::__alloc_traits<std::allocator<unsigned int>,unsigned int>::value_type *)std::vector<unsigned int>::operator[](
                                                                                                    params,
                                                                                                    0LL);
        v16 = (int *)v15;
        if ( *(_BYTE *)(((unsigned __int64)v15 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v15 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v15 >> 3) + 0x7FFF8000) )
        {
          *(double *)v4.m128i_i64 = __asan_report_load4(v15);
        }
        *(float *)v4.m128i_i32 = (float)*v16;
        Avatar::addSatiation(v11, *(float *)v4.m128i_i32, material_param_b, v12);
        v17 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 48));
        v18 = proto::AvatarSatiationDataNotify::add_satiation_data_list((proto::AvatarSatiationDataNotify *const)(v5 + 112));
        Avatar::getProtoSatiationData(v17, v18);
        common::tools::perf::make_shared<proto_log::PlayerLogBodySatiationChange>();
        v19 = std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 80));
        v20 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 48));
        if ( *(_BYTE *)(((unsigned __int64)v20 >> 3) + 0x7FFF8000) )
          *(double *)v4.m128i_i64 = __asan_report_load8();
        v21 = *(_QWORD *)v20->baseclass_0 + 400LL;
        if ( *(_BYTE *)((v21 >> 3) + 0x7FFF8000) )
          *(double *)v4.m128i_i64 = __asan_report_load8();
        v22 = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, double))v21)(
                v20,
                *(double *)v4.m128i_i64);
        proto_log::PlayerLogBodySatiationChange::set_avatar_type(v19, v22);
        v23 = std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 80));
        v24 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 48));
        AvatarId = Avatar::getAvatarId(v24);
        proto_log::PlayerLogBodySatiationChange::set_avatar_id(v23, AvatarId);
        v26 = std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 80));
        v27 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 48));
        SatiationVal = Avatar::getSatiationVal(v27);
        proto_log::PlayerLogBodySatiationChange::set_satiation_change(
          v26,
          (int)(float)(SatiationVal - old_satiation_val));
        v29 = std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 80));
        v30 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 48));
        v31 = Avatar::getSatiationVal(v30);
        proto_log::PlayerLogBodySatiationChange::set_satiation_val(v29, (int)v31);
        v32 = std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 80));
        v33 = std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Avatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 48));
        if ( Avatar::getSatiationPenaltyTime(v33) == 0.0 )
          v34 = 2;
        else
          v34 = 1;
        proto_log::PlayerLogBodySatiationChange::set_is_overeat(v32, v34);
        v35 = std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 80));
        if ( *(_BYTE *)(((unsigned __int64)&material_config->id >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&material_config->id >> 3) + 0x7FFF8000) <= 3 )
        {
          *(double *)v4.m128i_i64 = __asan_report_load4(&material_config->id);
        }
        proto_log::PlayerLogBodySatiationChange::set_item_id(v35, material_config->id);
        v36 = std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodySatiationChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 80));
        if ( *(_BYTE *)((v39._anon_0._M_allocated_capacity >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)((v39._anon_0._M_allocated_capacity >> 3) + 0x7FFF8000) <= 3 )
        {
          *(double *)v4.m128i_i64 = __asan_report_load4(v39._anon_0._M_allocated_capacity);
        }
        proto_log::PlayerLogBodySatiationChange::set_item_count(v36, *(_DWORD *)v39._anon_0._M_allocated_capacity);
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          *(double *)v4.m128i_i64 = __asan_report_load8();
        player = this->player_;
        std::shared_ptr<google::protobuf::Message>::shared_ptr(&p_body_ext_ptr, 0LL);
        std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodySatiationChange,void>(
          &p_body_ptr,
          (const std::shared_ptr<proto_log::PlayerLogBodySatiationChange> *)(v5 + 80));
        Player::printStatLog(player, &p_body_ptr, &p_body_ext_ptr, 0xEu);
        std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ptr);
        std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ext_ptr);
        std::shared_ptr<proto_log::PlayerLogBodySatiationChange>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodySatiationChange> *const)(v5 + 80));
      }
      std::shared_ptr<Avatar>::~shared_ptr((std::shared_ptr<Avatar> *const)(v5 + 48));
      __gnu_cxx::__normal_iterator<std::shared_ptr<Avatar> const*,std::vector<std::shared_ptr<Avatar>>>::operator++(&__for_begin);
    }
    v38 = proto::AvatarSatiationDataNotify::satiation_data_list((const proto::AvatarSatiationDataNotify *const)(v5 + 112));
    if ( !google::protobuf::RepeatedPtrField<proto::AvatarSatiationData>::empty(v38) )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::sendProto(this->player_, (const google::protobuf::Message *)(v5 + 112));
    }
    proto::AvatarSatiationDataNotify::~AvatarSatiationDataNotify((proto::AvatarSatiationDataNotify *const)(v5 + 112));
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 32));
  }
  if ( v39._M_dataplus._M_p == (std::string::pointer)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8014) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 2418: range 0000000017CCEF32-0000000017CCF17B
int32_t __cdecl PlayerItemComp::checkAddItem(
        PlayerItemComp *const this,
        const ItemParam *item_param,
        const ActionReason *reason)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  std::initializer_list<ItemParam>::size_type v6; // rdx
  int32_t v7; // r14d
  int32_t result; // eax
  std::allocator<ItemParam> __a; // [rsp+2Fh] [rbp-A1h] BYREF
  std::initializer_list<ItemParam> __l; // [rsp+30h] [rbp-A0h] BYREF
  char v12[144]; // [rsp+40h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v12;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 24 19 item_param_vec:2419";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkAddItem;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  if ( ((unsigned __int8)item_param & 7) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000)
    && *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    || *(_BYTE *)((((unsigned __int64)&item_param->promote_level + 3) >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)item_param + 15) & 7) >= *(_BYTE *)((((unsigned __int64)&item_param->promote_level + 3) >> 3)
                                                            + 0x7FFF8000) )
  {
    __asan_report_load_n(item_param, 16LL);
  }
  v6 = *(_QWORD *)&item_param->level;
  __l._M_array = *(std::initializer_list<ItemParam>::iterator *)&item_param->item_id;
  __l._M_len = v6;
  std::allocator<ItemParam>::allocator(&__a);
  std::vector<ItemParam>::vector(
    (std::vector<ItemParam> *const)(v3 + 32),
    (std::initializer_list<ItemParam>)__PAIR128__(1LL, &__l),
    &__a);
  std::allocator<ItemParam>::~allocator(&__a);
  v7 = PlayerItemComp::checkAddItemBatch(this, (const std::vector<ItemParam> *)(v3 + 32), reason);
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 32));
  result = v7;
  if ( v12 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 2424: range 0000000017CCF17C-0000000017CCF41F
int32_t __cdecl PlayerItemComp::checkAddItemBatch(
        PlayerItemComp *const this,
        const std::vector<data::IdCountConfig> *item_vec,
        const ActionReason *reason)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  uint32_t *p_count; // rax
  int32_t v7; // r14d
  int32_t result; // eax
  std::vector<data::IdCountConfig>::const_iterator __for_begin; // [rsp+20h] [rbp-C0h] BYREF
  std::vector<data::IdCountConfig>::const_iterator __for_end; // [rsp+28h] [rbp-B8h] BYREF
  const std::vector<data::IdCountConfig> *__for_range; // [rsp+30h] [rbp-B0h]
  const data::IdCountConfig *config; // [rsp+38h] [rbp-A8h]
  std::vector<ItemParam>::value_type __x; // [rsp+40h] [rbp-A0h] BYREF
  char v15[144]; // [rsp+50h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v15;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 24 14 param_vec:2425";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkAddItemBatch;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v3 + 32));
  __for_range = item_vec;
  __for_begin._M_current = std::vector<data::IdCountConfig>::begin(item_vec)._M_current;
  __for_end._M_current = std::vector<data::IdCountConfig>::end(item_vec)._M_current;
  while ( __gnu_cxx::operator!=<data::IdCountConfig const*,std::vector<data::IdCountConfig>>(&__for_begin, &__for_end) )
  {
    config = __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator*(&__for_begin);
    p_count = &config->count;
    if ( *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)p_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(p_count);
    }
    if ( config->count )
    {
      if ( *(_BYTE *)(((unsigned __int64)&config->id >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&config->id >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&config->id);
      }
      __x.item_id = config->id;
      __x.count = config->count;
      __x.level = 0;
      __x.promote_level = 0;
      std::vector<ItemParam>::push_back((std::vector<ItemParam> *const)(v3 + 32), &__x);
    }
    __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator++(&__for_begin);
  }
  v7 = PlayerItemComp::checkAddItemBatch(this, (const std::vector<ItemParam> *)(v3 + 32), reason);
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 32));
  result = v7;
  if ( v15 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 2437: range 0000000017CCF420-0000000017CD4EA5
int32_t __cdecl PlayerItemComp::checkAddVirtualItem(
        PlayerItemComp *const this,
        const ItemParam *item_param,
        const ActionReason *reason)
{
  int32_t v3; // r12d
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r14
  common::milog::MiLogStream *v7; // rbx
  common::milog::MiLogStream *v8; // rbx
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rbx
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rbx
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rbx
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // r12
  int v21; // r15d
  std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v22; // rcx
  common::milog::MiLogStream *v23; // r12
  common::milog::MiLogStream *v24; // r12
  int v25; // r15d
  std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v26; // rcx
  common::milog::MiLogStream *v27; // r12
  common::milog::MiLogStream *v28; // r12
  int v29; // r15d
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v30; // rcx
  common::milog::MiLogStream *v31; // r12
  common::milog::MiLogStream *v32; // r12
  int v33; // r15d
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v34; // rcx
  common::milog::MiLogStream *v35; // r12
  common::milog::MiLogStream *v36; // r12
  int v37; // r15d
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v38; // rcx
  common::milog::MiLogStream *v39; // r12
  common::milog::MiLogStream *v40; // rcx
  int v41; // r15d
  std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v42; // rcx
  common::milog::MiLogStream *v43; // r12
  common::milog::MiLogStream *v44; // r12
  int v45; // r15d
  std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v46; // rcx
  common::milog::MiLogStream *v47; // r12
  common::milog::MiLogStream *v48; // r12
  int v49; // r15d
  std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v50; // rcx
  common::milog::MiLogStream *v51; // r12
  PlayerMechanicusComp *MechanicusComp; // rcx
  common::milog::MiLogStream *v53; // rax
  common::milog::MiLogStream *v54; // rax
  common::milog::MiLogStream *v55; // rbx
  common::milog::MiLogStream *v56; // r12
  int v57; // r15d
  std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v58; // rcx
  common::milog::MiLogStream *v59; // r12
  common::milog::MiLogStream *v60; // r12
  int v61; // r15d
  std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v62; // rcx
  common::milog::MiLogStream *v63; // r12
  common::milog::MiLogStream *v64; // r12
  int v65; // r15d
  std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v66; // rcx
  common::milog::MiLogStream *v67; // r12
  common::milog::MiLogStream *v68; // rbx
  common::milog::MiLogStream *v69; // rax
  common::milog::MiLogStream *v70; // rax
  common::milog::MiLogStream *v71; // r12
  int v72; // r15d
  ChannellerSlabActivity *v73; // rcx
  common::milog::MiLogStream *v74; // r12
  common::milog::MiLogStream *v75; // r12
  int v76; // r15d
  std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v77; // rcx
  common::milog::MiLogStream *v78; // r12
  common::milog::MiLogStream *v79; // r12
  int v80; // r15d
  std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v81; // rcx
  common::milog::MiLogStream *v82; // r12
  common::milog::MiLogStream *v83; // r12
  int v84; // r15d
  std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v85; // rcx
  common::milog::MiLogStream *v86; // r12
  common::milog::MiLogStream *v87; // r12
  int v88; // r15d
  std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v89; // rcx
  common::milog::MiLogStream *v90; // r12
  common::milog::MiLogStream *v91; // r12
  int v92; // r15d
  std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v93; // rcx
  common::milog::MiLogStream *v94; // r12
  common::milog::MiLogStream *v95; // r12
  int v96; // r15d
  std::__shared_ptr_access<LunaRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v97; // rcx
  common::milog::MiLogStream *v98; // r12
  common::milog::MiLogStream *v99; // r12
  int v100; // r15d
  std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v101; // rcx
  common::milog::MiLogStream *v102; // r12
  common::milog::MiLogStream *v103; // r12
  int v104; // r15d
  std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v105; // rcx
  common::milog::MiLogStream *v106; // r12
  common::milog::MiLogStream *v107; // r12
  int v108; // r15d
  std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v109; // rcx
  common::milog::MiLogStream *v110; // r12
  common::milog::MiLogStream *v111; // r12
  int v112; // r15d
  std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v113; // rcx
  common::milog::MiLogStream *v114; // r12
  common::milog::MiLogStream *v115; // r12
  int v116; // r15d
  std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v117; // rcx
  common::milog::MiLogStream *v118; // r12
  common::milog::MiLogStream *v119; // r12
  int v120; // r15d
  std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v121; // rcx
  common::milog::MiLogStream *v122; // r12
  common::milog::MiLogStream *v123; // r12
  int v124; // r15d
  std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v125; // rcx
  common::milog::MiLogStream *v126; // r12
  common::milog::MiLogStream *v127; // r12
  int v128; // r15d
  std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v129; // rcx
  common::milog::MiLogStream *v130; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v131; // rax
  common::milog::MiLogStream *v132; // rax
  uint32_t ActivityComp; // eax
  std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v134; // rax
  common::milog::MiLogStream *v136; // r12
  int v137; // r15d
  std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v138; // rax
  unsigned __int64 v139; // rdx
  __int64 (__fastcall *v140)(std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, _QWORD, _QWORD); // r8
  common::milog::MiLogStream *v141; // r12
  common::milog::MiLogStream *v142; // rdx
  int32_t result; // eax
  unsigned int val; // [rsp+20h] [rbp-160h] BYREF
  int32_t ret_15; // [rsp+24h] [rbp-15Ch]
  int32_t ret_0; // [rsp+28h] [rbp-158h]
  int32_t ret; // [rsp+2Ch] [rbp-154h]
  uint32_t activity_id; // [rsp+30h] [rbp-150h]
  int32_t ret_31; // [rsp+34h] [rbp-14Ch]
  proto::VirtualItem coin_type_7; // [rsp+38h] [rbp-148h]
  int32_t ret_30; // [rsp+3Ch] [rbp-144h]
  proto::VirtualItem coin_type_6; // [rsp+40h] [rbp-140h]
  int32_t ret_29; // [rsp+44h] [rbp-13Ch]
  proto::VirtualItem coin_type_5; // [rsp+48h] [rbp-138h]
  int32_t ret_28; // [rsp+4Ch] [rbp-134h]
  proto::VirtualItem coin_type_3; // [rsp+50h] [rbp-130h]
  int32_t ret_26; // [rsp+54h] [rbp-12Ch]
  proto::VirtualItem coin_type_4; // [rsp+58h] [rbp-128h]
  int32_t ret_27; // [rsp+5Ch] [rbp-124h]
  proto::VirtualItem coin_type_2; // [rsp+60h] [rbp-120h]
  int32_t ret_25; // [rsp+64h] [rbp-11Ch]
  proto::VirtualItem coin_type_1; // [rsp+68h] [rbp-118h]
  int32_t ret_24; // [rsp+6Ch] [rbp-114h]
  proto::VirtualItem coin_type_0; // [rsp+70h] [rbp-110h]
  int32_t ret_23; // [rsp+74h] [rbp-10Ch]
  int32_t ret_22; // [rsp+78h] [rbp-108h]
  int32_t ret_21; // [rsp+7Ch] [rbp-104h]
  proto::VirtualItem coin_type; // [rsp+80h] [rbp-100h]
  int32_t ret_20; // [rsp+84h] [rbp-FCh]
  int32_t ret_19; // [rsp+88h] [rbp-F8h]
  int32_t ret_18; // [rsp+8Ch] [rbp-F4h]
  int32_t ret_17; // [rsp+90h] [rbp-F0h]
  int32_t ret_16; // [rsp+94h] [rbp-ECh]
  int32_t ret_14; // [rsp+98h] [rbp-E8h]
  int32_t ret_13; // [rsp+9Ch] [rbp-E4h]
  int32_t ret_12; // [rsp+A0h] [rbp-E0h]
  int32_t ret_11; // [rsp+A4h] [rbp-DCh]
  int32_t ret_10; // [rsp+A8h] [rbp-D8h]
  int32_t ret_9; // [rsp+ACh] [rbp-D4h]
  int32_t ret_8; // [rsp+B0h] [rbp-D0h]
  int32_t ret_7; // [rsp+B4h] [rbp-CCh]
  int32_t ret_6; // [rsp+B8h] [rbp-C8h]
  int32_t ret_5; // [rsp+BCh] [rbp-C4h]
  int32_t ret_4; // [rsp+C0h] [rbp-C0h]
  int32_t ret_3; // [rsp+C4h] [rbp-BCh]
  int32_t ret_2; // [rsp+C8h] [rbp-B8h]
  int32_t ret_1; // [rsp+CCh] [rbp-B4h]
  common::milog::MiLogStream v189; // [rsp+D0h] [rbp-B0h] BYREF
  char v190[144]; // [rsp+F0h] [rbp-90h] BYREF

  v4 = (unsigned __int64)v190;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(96LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "2 48 4 14 coin_type:2973 64 16 17 activity_ptr:2980";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkAddVirtualItem;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556943;
  v6[536862722] = -202178560;
  if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(item_param);
  }
  switch ( item_param->item_id )
  {
    case 0x65u:
    case 0x66u:
    case 0x69u:
    case 0x81u:
    case 0x92u:
    case 0x13Au:
    case 0x13Bu:
    case 0x13Cu:
    case 0x13Du:
      goto LABEL_483;
    case 0x6Au:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      ret_1 = PlayerItemComp::checkAddResin(this, item_param->count);
      if ( !ret_1 )
        goto LABEL_483;
      common::milog::MiLogStream::create(
        &v189,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddVirtualItem",
        2476);
      v14 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
              &v189,
              (const char (*)[31])"resin add overflow, cur_resin:");
      val = PlayerItemComp::getResin(this);
      v15 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &val);
      v16 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v15, (const char (*)[8])" count:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, &item_param->count);
      common::milog::MiLogStream::~MiLogStream(&v189);
      v3 = ret_1;
      break;
    case 0x6Bu:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      ret_2 = PlayerItemComp::checkAddLegendaryKey(this, item_param->count);
      if ( !ret_2 )
        goto LABEL_483;
      common::milog::MiLogStream::create(
        &v189,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddVirtualItem",
        2486);
      v17 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
              &v189,
              (const char (*)[39])"legendary add overflow, cur_legendary:");
      val = PlayerItemComp::getLegendaryKey(this);
      v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, &val);
      v19 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v18, (const char (*)[8])" count:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v19, &item_param->count);
      common::milog::MiLogStream::~MiLogStream(&v189);
      v3 = ret_2;
      break;
    case 0x6Cu:
      common::milog::MiLogStream::create(
        &v189,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddVirtualItem",
        2494);
      v7 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(
             &v189,
             (const char (*)[48])"cannot add aster progress by virutal item, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_207;
    case 0x6Du:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<AsterActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<AsterActivity>(0LL, (const std::shared_ptr<AsterActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2502);
        v20 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v189,
                (const char (*)[39])"[ASTER] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v21 = 0;
      }
      else
      {
        v22 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_3 = AsterActivity::checkAddAsterCredit(v22, item_param->count);
        if ( ret_3 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2508);
          v23 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                  &v189,
                  (const char (*)[42])"[ASTER] checkAddAsterCredit failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v23, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_3;
          v21 = 0;
        }
        else
        {
          v21 = 1;
        }
      }
      std::shared_ptr<AsterActivity>::~shared_ptr((std::shared_ptr<AsterActivity> *const)(v4 + 64));
      if ( !v21 )
        break;
      goto LABEL_483;
    case 0x6Eu:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<AsterActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<AsterActivity>(0LL, (const std::shared_ptr<AsterActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2518);
        v24 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v189,
                (const char (*)[39])"[ASTER] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v25 = 0;
      }
      else
      {
        v26 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_4 = AsterActivity::checkAddAsterToken(v26, item_param->count);
        if ( ret_4 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2524);
          v27 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                  &v189,
                  (const char (*)[41])"[ASTER] checkAddAsterToken failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_4;
          v25 = 0;
        }
        else
        {
          v25 = 1;
        }
      }
      std::shared_ptr<AsterActivity>::~shared_ptr((std::shared_ptr<AsterActivity> *const)(v4 + 64));
      if ( !v25 )
        break;
      goto LABEL_483;
    case 0x6Fu:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2541);
        v28 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v189,
                (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v28, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v29 = 0;
      }
      else
      {
        v30 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_5 = DragonSpineActivity::checkAddShimmeringEssence(v30, item_param->count);
        if ( ret_5 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2547);
          v31 = common::milog::MiLogStream::operator<<<char [55],(char *[55])0>(
                  &v189,
                  (const char (*)[55])"[DRAGON_SPINE] checkAddShimmeringEssence failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v31, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_5;
          v29 = 0;
        }
        else
        {
          v29 = 1;
        }
      }
      std::shared_ptr<DragonSpineActivity>::~shared_ptr((std::shared_ptr<DragonSpineActivity> *const)(v4 + 64));
      if ( !v29 )
        break;
      goto LABEL_483;
    case 0x70u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2557);
        v32 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v189,
                (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v32, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v33 = 0;
      }
      else
      {
        v34 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_6 = DragonSpineActivity::checkAddWarmEssence(v34, item_param->count);
        if ( ret_6 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2563);
          v35 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                  &v189,
                  (const char (*)[49])"[DRAGON_SPINE] checkAddWarmEssence failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v35, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_6;
          v33 = 0;
        }
        else
        {
          v33 = 1;
        }
      }
      std::shared_ptr<DragonSpineActivity>::~shared_ptr((std::shared_ptr<DragonSpineActivity> *const)(v4 + 64));
      if ( !v33 )
        break;
      goto LABEL_483;
    case 0x71u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2573);
        v36 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v189,
                (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v36, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v37 = 0;
      }
      else
      {
        v38 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_7 = DragonSpineActivity::checkAddWondrousEssence(v38, item_param->count);
        if ( ret_7 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2579);
          v39 = common::milog::MiLogStream::operator<<<char [53],(char *[53])0>(
                  &v189,
                  (const char (*)[53])"[DRAGON_SPINE] checkAddWondrousEssence failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v39, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_7;
          v37 = 0;
        }
        else
        {
          v37 = 1;
        }
      }
      std::shared_ptr<DragonSpineActivity>::~shared_ptr((std::shared_ptr<DragonSpineActivity> *const)(v4 + 64));
      if ( !v37 )
        break;
      goto LABEL_483;
    case 0x72u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<TreasureMapActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<TreasureMapActivity>(0LL, (const std::shared_ptr<TreasureMapActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2589);
        v40 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v189,
                (const char (*)[46])"[TREASURE_MAP] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v40, this->player_);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v41 = 0;
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(reason);
        }
        if ( reason->reason_type == ACTION_REASON_GM )
          goto LABEL_119;
        v42 = std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_8 = TreasureMapActivity::checkAddToken(v42, item_param->count);
        if ( !ret_8 )
        {
LABEL_119:
          v41 = 1;
        }
        else
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2597);
          v43 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                  &v189,
                  (const char (*)[43])"[TREASURE_MAP] checkAddToken failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v43, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_8;
          v41 = 0;
        }
      }
      std::shared_ptr<TreasureMapActivity>::~shared_ptr((std::shared_ptr<TreasureMapActivity> *const)(v4 + 64));
      if ( !v41 )
        break;
      goto LABEL_483;
    case 0x73u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SeaLampActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<SeaLampActivity>(0LL, (const std::shared_ptr<SeaLampActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2608);
        v44 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                &v189,
                (const char (*)[42])"[SEA_LAMP] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v44, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v45 = 0;
      }
      else
      {
        v46 = std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_9 = SeaLampActivity::checkAddSeaLampCoin(v46, item_param->count);
        if ( ret_9 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2614);
          v47 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                  &v189,
                  (const char (*)[43])"[SEA_LAMP] checkAddSeaLampCoin fails, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v47, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_9;
          v45 = 0;
        }
        else
        {
          v45 = 1;
        }
      }
      std::shared_ptr<SeaLampActivity>::~shared_ptr((std::shared_ptr<SeaLampActivity> *const)(v4 + 64));
      if ( !v45 )
        break;
      goto LABEL_483;
    case 0x74u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SeaLampActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<SeaLampActivity>(0LL, (const std::shared_ptr<SeaLampActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2624);
        v48 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                &v189,
                (const char (*)[42])"[SEA_LAMP] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v48, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v49 = 0;
      }
      else
      {
        v50 = std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_10 = SeaLampActivity::checkAddPopularity(v50, item_param->count);
        if ( ret_10 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2630);
          v51 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                  &v189,
                  (const char (*)[49])"[SEA_LAMP] checkAddSeaLampPopularity fails, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v51, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_10;
          v49 = 0;
        }
        else
        {
          v49 = 1;
        }
      }
      std::shared_ptr<SeaLampActivity>::~shared_ptr((std::shared_ptr<SeaLampActivity> *const)(v4 + 64));
      if ( !v49 )
        break;
      goto LABEL_483;
    case 0x75u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      MechanicusComp = Player::getMechanicusComp(this->player_);
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      ret_11 = PlayerMechanicusComp::checkAddCoin(MechanicusComp, item_param->count);
      if ( !ret_11 )
        goto LABEL_483;
      common::milog::MiLogStream::create(
        &v189,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddVirtualItem",
        2640);
      v53 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(
              &v189,
              (const char (*)[25])"checkAddCoin mechanicus:");
      v54 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v53, &item_param->count);
      v55 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v54, (const char (*)[13])" fails, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v55, &val);
      common::milog::MiLogStream::~MiLogStream(&v189);
      v3 = ret_11;
      break;
    case 0x76u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<FleurFairActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<FleurFairActivity>(0LL, (const std::shared_ptr<FleurFairActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2650);
        v56 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                &v189,
                (const char (*)[44])"[FLEUR_FAIR] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v56, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v57 = 0;
      }
      else
      {
        v58 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_12 = FleurFairActivity::checkAddCredit(v58, item_param->count);
        if ( ret_12 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2656);
          v59 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                  &v189,
                  (const char (*)[42])"[FLEUR_FAIR] checkAddCredit failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v59, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_12;
          v57 = 0;
        }
        else
        {
          v57 = 1;
        }
      }
      std::shared_ptr<FleurFairActivity>::~shared_ptr((std::shared_ptr<FleurFairActivity> *const)(v4 + 64));
      if ( !v57 )
        break;
      goto LABEL_483;
    case 0x77u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<FleurFairActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<FleurFairActivity>(0LL, (const std::shared_ptr<FleurFairActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2666);
        v60 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                &v189,
                (const char (*)[44])"[FLEUR_FAIR] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v60, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v61 = 0;
      }
      else
      {
        v62 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_13 = FleurFairActivity::checkAddToken(v62, item_param->count);
        if ( ret_13 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2672);
          v63 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                  &v189,
                  (const char (*)[41])"[FLEUR_FAIR] checkAddToken failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v63, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_13;
          v61 = 0;
        }
        else
        {
          v61 = 1;
        }
      }
      std::shared_ptr<FleurFairActivity>::~shared_ptr((std::shared_ptr<FleurFairActivity> *const)(v4 + 64));
      if ( !v61 )
        break;
      goto LABEL_483;
    case 0x78u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<WaterSpiritActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<WaterSpiritActivity>(0LL, (const std::shared_ptr<WaterSpiritActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2682);
        v64 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v189,
                (const char (*)[46])"[WATER_SPIRIT] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v64, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v65 = 0;
      }
      else
      {
        v66 = std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_14 = WaterSpiritActivity::checkAddSpiritCoin(v66, item_param->count);
        if ( ret_14 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2688);
          v67 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                  &v189,
                  (const char (*)[42])"[WATER_SPIRIT] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v67, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_14;
          v65 = 0;
        }
        else
        {
          v65 = 1;
        }
      }
      std::shared_ptr<WaterSpiritActivity>::~shared_ptr((std::shared_ptr<WaterSpiritActivity> *const)(v4 + 64));
      if ( !v65 )
        break;
      goto LABEL_483;
    case 0x79u:
      common::milog::MiLogStream::create(
        &v189,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddVirtualItem",
        2695);
      v7 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
             &v189,
             (const char (*)[42])"cannot add home exp by virutal item, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_207;
    case 0x7Au:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<ChannellerSlabActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<ChannellerSlabActivity>(0LL, (const std::shared_ptr<ChannellerSlabActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2713);
        v71 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                &v189,
                (const char (*)[49])"[CHANNELLER_SLAB] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v71, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v72 = 0;
      }
      else
      {
        v73 = std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_16 = ChannellerSlabActivity::checkAddToken(v73, item_param->count);
        if ( ret_16 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2719);
          v74 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                  &v189,
                  (const char (*)[46])"[CHANNELLER_SLAB] checkAddToken failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v74, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_16;
          v72 = 0;
        }
        else
        {
          v72 = 1;
        }
      }
      std::shared_ptr<ChannellerSlabActivity>::~shared_ptr((std::shared_ptr<ChannellerSlabActivity> *const)(v4 + 64));
      if ( !v72 )
        break;
      goto LABEL_483;
    case 0x7Cu:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SummerTimeActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<SummerTimeActivity>(0LL, (const std::shared_ptr<SummerTimeActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2729);
        v75 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                &v189,
                (const char (*)[45])"[SUMMER_TIME] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v75, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v76 = 0;
      }
      else
      {
        v77 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_17 = SummerTimeActivity::checkAddDraftWood(v77, item_param->count);
        if ( ret_17 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2735);
          v78 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                  &v189,
                  (const char (*)[46])"[SUMMER_TIME] checkAddDraftWood failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v78, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_17;
          v76 = 0;
        }
        else
        {
          v76 = 1;
        }
      }
      std::shared_ptr<SummerTimeActivity>::~shared_ptr((std::shared_ptr<SummerTimeActivity> *const)(v4 + 64));
      if ( !v76 )
        break;
      goto LABEL_483;
    case 0x7Du:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SummerTimeActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<SummerTimeActivity>(0LL, (const std::shared_ptr<SummerTimeActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2745);
        v79 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                &v189,
                (const char (*)[45])"[SUMMER_TIME] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v79, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v80 = 0;
      }
      else
      {
        v81 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_18 = SummerTimeActivity::checkAddMiniHarpastum(v81, item_param->count);
        if ( ret_18 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2751);
          v82 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
                  &v189,
                  (const char (*)[50])"[SUMMER_TIME] checkAddMiniHarpastum failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v82, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_18;
          v80 = 0;
        }
        else
        {
          v80 = 1;
        }
      }
      std::shared_ptr<SummerTimeActivity>::~shared_ptr((std::shared_ptr<SummerTimeActivity> *const)(v4 + 64));
      if ( !v80 )
        break;
      goto LABEL_483;
    case 0x7Eu:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<BounceConjuringActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<BounceConjuringActivity>(0LL, (const std::shared_ptr<BounceConjuringActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2761);
        v83 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
                &v189,
                (const char (*)[50])"[BOUNCE_CONJURING] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v83, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v84 = 0;
      }
      else
      {
        v85 = std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_19 = BounceConjuringActivity::checkAddCoin(v85, item_param->count);
        if ( ret_19 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2767);
          v86 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                  &v189,
                  (const char (*)[46])"[BOUNCE_CONJURING] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v86, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_19;
          v84 = 0;
        }
        else
        {
          v84 = 1;
        }
      }
      std::shared_ptr<BounceConjuringActivity>::~shared_ptr((std::shared_ptr<BounceConjuringActivity> *const)(v4 + 64));
      if ( !v84 )
        break;
      goto LABEL_483;
    case 0x7Fu:
    case 0x80u:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      coin_type = item_param->item_id;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<BlitzRushActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<BlitzRushActivity>(0LL, (const std::shared_ptr<BlitzRushActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2779);
        v87 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                &v189,
                (const char (*)[44])"[BLITZ_RUSH] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v87, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v88 = 0;
      }
      else
      {
        v89 = std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_20 = BlitzRushActivity::checkAddActivityCoin(v89, coin_type, item_param->count);
        if ( ret_20 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2785);
          v90 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                  &v189,
                  (const char (*)[40])"[BLITZ_RUSH] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v90, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_20;
          v88 = 0;
        }
        else
        {
          v88 = 1;
        }
      }
      std::shared_ptr<BlitzRushActivity>::~shared_ptr((std::shared_ptr<BlitzRushActivity> *const)(v4 + 64));
      if ( !v88 )
        break;
      goto LABEL_483;
    case 0x82u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<ChessActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<ChessActivity>(0LL, (const std::shared_ptr<ChessActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2795);
        v91 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v189,
                (const char (*)[39])"[CHESS] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v91, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v92 = 0;
      }
      else
      {
        v93 = std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_21 = ChessActivity::checkAddCoin(v93, item_param->count);
        if ( ret_21 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2801);
          v94 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                  &v189,
                  (const char (*)[35])"[CHESS] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v94, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_21;
          v92 = 0;
        }
        else
        {
          v92 = 1;
        }
      }
      std::shared_ptr<ChessActivity>::~shared_ptr((std::shared_ptr<ChessActivity> *const)(v4 + 64));
      if ( !v92 )
        break;
      goto LABEL_483;
    case 0x83u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<LunaRiteActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<LunaRiteActivity>(0LL, (const std::shared_ptr<LunaRiteActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2811);
        v95 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                &v189,
                (const char (*)[42])"[LUNARITE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v95, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v96 = 0;
      }
      else
      {
        v97 = std::__shared_ptr_access<LunaRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<LunaRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_22 = LunaRiteActivity::checkAddAtmosphere(v97, item_param->count);
        if ( ret_22 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2817);
          v98 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
                  &v189,
                  (const char (*)[38])"[LUNARITE] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v98, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_22;
          v96 = 0;
        }
        else
        {
          v96 = 1;
        }
      }
      std::shared_ptr<LunaRiteActivity>::~shared_ptr((std::shared_ptr<LunaRiteActivity> *const)(v4 + 64));
      if ( !v96 )
        break;
      goto LABEL_483;
    case 0x84u:
    case 0x85u:
    case 0x86u:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      coin_type_0 = item_param->item_id;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<RoguelikeDungeonActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<RoguelikeDungeonActivity>(0LL, (const std::shared_ptr<RoguelikeDungeonActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2830);
        v99 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                &v189,
                (const char (*)[43])"[ROGUELIKE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v99, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v100 = 0;
      }
      else
      {
        v101 = std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_23 = RoguelikeDungeonActivity::checkAddActivityCoin(v101, coin_type_0, item_param->count);
        if ( ret_23 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2836);
          v102 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                   &v189,
                   (const char (*)[39])"[ROGUELIKE] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v102, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_23;
          v100 = 0;
        }
        else
        {
          v100 = 1;
        }
      }
      std::shared_ptr<RoguelikeDungeonActivity>::~shared_ptr((std::shared_ptr<RoguelikeDungeonActivity> *const)(v4 + 64));
      if ( !v100 )
        break;
      goto LABEL_483;
    case 0x87u:
    case 0x88u:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      coin_type_1 = item_param->item_id;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<WinterCampActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<WinterCampActivity>(0LL, (const std::shared_ptr<WinterCampActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2848);
        v103 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v189,
                 (const char (*)[44])"[WinterCamp] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v103, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v104 = 0;
      }
      else
      {
        v105 = std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_24 = WinterCampActivity::checkAddActivityCoin(v105, coin_type_1, item_param->count);
        if ( ret_24 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2854);
          v106 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                   &v189,
                   (const char (*)[40])"[WinterCamp] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v106, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_24;
          v104 = 0;
        }
        else
        {
          v104 = 1;
        }
      }
      std::shared_ptr<WinterCampActivity>::~shared_ptr((std::shared_ptr<WinterCampActivity> *const)(v4 + 64));
      if ( !v104 )
        break;
      goto LABEL_483;
    case 0x89u:
    case 0x8Au:
    case 0x8Bu:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      coin_type_2 = item_param->item_id;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<LanternRiteActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<LanternRiteActivity>(0LL, (const std::shared_ptr<LanternRiteActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2867);
        v107 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                 &v189,
                 (const char (*)[45])"[LanternRite] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v107, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v108 = 0;
      }
      else
      {
        v109 = std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_25 = LanternRiteActivity::checkAddActivityCoin(v109, coin_type_2, item_param->count);
        if ( ret_25 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2873);
          v110 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                   &v189,
                   (const char (*)[41])"[LanternRite] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v110, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_25;
          v108 = 0;
        }
        else
        {
          v108 = 1;
        }
      }
      std::shared_ptr<LanternRiteActivity>::~shared_ptr((std::shared_ptr<LanternRiteActivity> *const)(v4 + 64));
      if ( !v108 )
        break;
      goto LABEL_483;
    case 0x8Cu:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      coin_type_4 = item_param->item_id;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<RogueDiaryActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<RogueDiaryActivity>(0LL, (const std::shared_ptr<RogueDiaryActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2901);
        v115 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v189,
                 (const char (*)[44])"[RogueDiary] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v115, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v116 = 0;
      }
      else
      {
        v117 = std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_27 = RogueDiaryActivity::checkAddActivityCoin(v117, coin_type_4, item_param->count);
        if ( ret_27 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2907);
          v118 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                   &v189,
                   (const char (*)[40])"[RogueDiary] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v118, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_27;
          v116 = 0;
        }
        else
        {
          v116 = 1;
        }
      }
      std::shared_ptr<RogueDiaryActivity>::~shared_ptr((std::shared_ptr<RogueDiaryActivity> *const)(v4 + 64));
      if ( !v116 )
        break;
      goto LABEL_483;
    case 0x8Du:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      coin_type_3 = item_param->item_id;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SummerTimeV2Activity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<SummerTimeV2Activity>(0LL, (const std::shared_ptr<SummerTimeV2Activity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2884);
        v111 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(
                 &v189,
                 (const char (*)[48])"[SUMMER_TIME_V2] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v111, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v112 = 0;
      }
      else
      {
        v113 = std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_26 = SummerTimeV2Activity::checkAddActivityCoin(v113, coin_type_3, item_param->count);
        if ( ret_26 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2890);
          v114 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                   &v189,
                   (const char (*)[44])"[SUMMER_TIME_V2] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v114, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_26;
          v112 = 0;
        }
        else
        {
          v112 = 1;
        }
      }
      std::shared_ptr<SummerTimeV2Activity>::~shared_ptr((std::shared_ptr<SummerTimeV2Activity> *const)(v4 + 64));
      if ( !v112 )
        break;
      goto LABEL_483;
    case 0x8Fu:
    case 0x90u:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      coin_type_5 = item_param->item_id;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<GravenInnocenceActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<GravenInnocenceActivity>(0LL, (const std::shared_ptr<GravenInnocenceActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2919);
        v119 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                 &v189,
                 (const char (*)[49])"[GravenInnocence] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v119, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v120 = 0;
      }
      else
      {
        v121 = std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_28 = GravenInnocenceActivity::checkAddActivityCoin(v121, coin_type_5, item_param->count);
        if ( ret_28 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2925);
          v122 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                   &v189,
                   (const char (*)[45])"[GravenInnocence] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v122, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_28;
          v120 = 0;
        }
        else
        {
          v120 = 1;
        }
      }
      std::shared_ptr<GravenInnocenceActivity>::~shared_ptr((std::shared_ptr<GravenInnocenceActivity> *const)(v4 + 64));
      if ( !v120 )
        break;
      goto LABEL_483;
    case 0x91u:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      coin_type_6 = item_param->item_id;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<TreasureSeelieActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<TreasureSeelieActivity>(0LL, (const std::shared_ptr<TreasureSeelieActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2936);
        v123 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                 &v189,
                 (const char (*)[49])"[TREASURE SEELIE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v123, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v124 = 0;
      }
      else
      {
        v125 = std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_29 = TreasureSeelieActivity::checkAddActivityCoin(v125, coin_type_6, item_param->count);
        if ( ret_29 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2942);
          v126 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                   &v189,
                   (const char (*)[45])"[TREASURE SEELIE] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v126, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_29;
          v124 = 0;
        }
        else
        {
          v124 = 1;
        }
      }
      std::shared_ptr<TreasureSeelieActivity>::~shared_ptr((std::shared_ptr<TreasureSeelieActivity> *const)(v4 + 64));
      if ( !v124 )
        break;
      goto LABEL_483;
    case 0x93u:
    case 0x94u:
    case 0x95u:
    case 0x96u:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      coin_type_7 = item_param->item_id;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<VintageActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<VintageActivity>(0LL, (const std::shared_ptr<VintageActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2956);
        v127 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                 &v189,
                 (const char (*)[41])"[VINTAGE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v127, &val);
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = 860;
        v128 = 0;
      }
      else
      {
        v129 = std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_30 = VintageActivity::checkAddActivityCoin(v129, coin_type_7, item_param->count);
        if ( ret_30 )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2962);
          v130 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                   &v189,
                   (const char (*)[37])"[VINTAGE] checkAddCoin failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v130, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = ret_30;
          v128 = 0;
        }
        else
        {
          v128 = 1;
        }
      }
      std::shared_ptr<VintageActivity>::~shared_ptr((std::shared_ptr<VintageActivity> *const)(v4 + 64));
      if ( !v128 )
        break;
      goto LABEL_483;
    case 0x97u:
    case 0x98u:
    case 0x99u:
    case 0x9Au:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      *(_DWORD *)(v4 + 48) = item_param->item_id;
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)(v4 + 64));
      v131 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
      activity_id = NewActivityExcelConfigMgr::findActivityIdByCoinType(
                      &v131->design_config.txt_config_mgr.new_activity_config_mgr,
                      *(proto::VirtualItem *)(v4 + 48));
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 64));
      if ( activity_id )
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        ActivityComp = (unsigned int)Player::getActivityComp(this->player_);
        PlayerActivityComp::findBaseActivity((PlayerActivityComp *const)(v4 + 64), ActivityComp);
        if ( std::operator==<BaseActivity>(0LL, (const std::shared_ptr<BaseActivity> *)(v4 + 64))
          || (v134 = std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64)),
              !BaseActivity::isOpening(v134, 0)) )
        {
          common::milog::MiLogStream::create(
            &v189,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddVirtualItem",
            2983);
          v136 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                   &v189,
                   (const char (*)[31])"activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v136, &val);
          common::milog::MiLogStream::~MiLogStream(&v189);
          v3 = 860;
          v137 = 0;
        }
        else
        {
          v138 = std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          if ( *(_BYTE *)(((unsigned __int64)v138 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v139 = (unsigned __int64)(v138->_vptr_DescribalBase + 12);
          if ( *(_BYTE *)((v139 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v140 = *(__int64 (__fastcall **)(std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, _QWORD, _QWORD))v139;
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_31 = v140(v138, *(unsigned int *)(v4 + 48), item_param->count);
          if ( ret_31 )
          {
            common::milog::MiLogStream::create(
              &v189,
              &common::milog::MiLogDefault::default_log_obj_,
              4u,
              "./src/player/item/player_item_comp.cpp",
              "checkAddVirtualItem",
              2989);
            v141 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
                     &v189,
                     (const char (*)[26])"checkAddCoin failed, uid:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v141, &val);
            common::milog::MiLogStream::~MiLogStream(&v189);
            v3 = ret_31;
            v137 = 0;
          }
          else
          {
            v137 = 1;
          }
        }
        std::shared_ptr<BaseActivity>::~shared_ptr((std::shared_ptr<BaseActivity> *const)(v4 + 64));
        if ( v137 )
LABEL_483:
          v3 = 0;
      }
      else
      {
        common::milog::MiLogStream::create(
          &v189,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "checkAddVirtualItem",
          2977);
        v132 = common::milog::MiLogStream::operator<<<char [64],(char *[64])0>(
                 &v189,
                 (const char (*)[64])"virutal coin cannot find corresponding activity id, coin_type: ");
        common::milog::MiLogStream::operator<<<proto::VirtualItem,(proto::VirtualItem*)0>(
          v132,
          (const proto::VirtualItem *)(v4 + 48));
        common::milog::MiLogStream::~MiLogStream(&v189);
        v3 = -1;
      }
      break;
    case 0xC9u:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      ret = PlayerItemComp::checkAddHcoin(this, item_param->count);
      if ( !ret )
        goto LABEL_483;
      common::milog::MiLogStream::create(
        &v189,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddVirtualItem",
        2456);
      v8 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
             &v189,
             (const char (*)[29])"hcoin add failed, cur_hcoin:");
      val = PlayerItemComp::getHcoin(this);
      v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, &val);
      v10 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v9, (const char (*)[8])" count:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, &item_param->count);
      common::milog::MiLogStream::~MiLogStream(&v189);
      v3 = ret;
      break;
    case 0xCAu:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      ret_0 = PlayerItemComp::checkAddScoin(this, item_param->count);
      if ( !ret_0 )
        goto LABEL_483;
      common::milog::MiLogStream::create(
        &v189,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddVirtualItem",
        2466);
      v11 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
              &v189,
              (const char (*)[31])"scoin add overflow, cur_scoin:");
      val = PlayerItemComp::getScoin(this);
      v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &val);
      v13 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v12, (const char (*)[8])" count:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, &item_param->count);
      common::milog::MiLogStream::~MiLogStream(&v189);
      v3 = ret_0;
      break;
    case 0xCBu:
      common::milog::MiLogStream::create(
        &v189,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddVirtualItem",
        2448);
      v7 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
             &v189,
             (const char (*)[39])"cannot add mcoin by virutal item, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
LABEL_207:
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &val);
      common::milog::MiLogStream::~MiLogStream(&v189);
      v3 = -1;
      break;
    case 0xCCu:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      ret_15 = PlayerItemComp::checkAddHomeCoin(this, item_param->count);
      if ( !ret_15 )
        goto LABEL_483;
      common::milog::MiLogStream::create(
        &v189,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddVirtualItem",
        2703);
      v68 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
              &v189,
              (const char (*)[39])"home_coin add overflow, cur_home_coin:");
      val = PlayerItemComp::getHomeCoin(this);
      v69 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v68, &val);
      v70 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v69, (const char (*)[8])" count:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v70, &item_param->count);
      common::milog::MiLogStream::~MiLogStream(&v189);
      v3 = ret_15;
      break;
    default:
      common::milog::MiLogStream::create(
        &v189,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddVirtualItem",
        2996);
      v142 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
               &v189,
               (const char (*)[30])"unkown virutal item, item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v142, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v189);
      v3 = -1;
      break;
  }
  result = v3;
  if ( v190 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 3005: range 0000000017CD4EA6-0000000017CDAC1F
void __fastcall PlayerItemComp::addVirtualItem(
        PlayerItemComp *const this,
        uint32_t item_id,
        uint32_t item_count,
        ActionReason *reason,
        std::vector<AddItemResult> *temp_result_vec)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  PlayerAvatarComp *AvatarComp; // rax
  AddItemResult *v9; // rax
  PlayerBasicComp *BasicComp; // rax
  float CurMultiPlayFetterExpRatio; // xmm0_4
  PlayerAvatarComp *v12; // rax
  AddItemResult *v13; // rax
  common::milog::MiLogStream *v14; // rbx
  common::milog::MiLogStream *v15; // rax
  AddItemResult *v16; // rax
  common::milog::MiLogStream *v17; // rax
  AddItemResult *v18; // rax
  common::milog::MiLogStream *v19; // rax
  AddItemResult *v20; // rax
  common::milog::MiLogStream *v21; // rax
  AddItemResult *v22; // rax
  common::milog::MiLogStream *v23; // r14
  AsterActivity *v24; // rax
  common::milog::MiLogStream *v25; // r14
  std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v26; // rax
  AddItemResult *v27; // rax
  AsterActivity *v28; // rax
  common::milog::MiLogStream *v29; // r14
  std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v30; // rax
  AddItemResult *v31; // rax
  PlayerReputationComp *ReputationComp; // rdi
  AddItemResult *v33; // rax
  common::milog::MiLogStream *v34; // r14
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v35; // rax
  common::milog::MiLogStream *v36; // r14
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v37; // rax
  AddItemResult *v38; // rax
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v39; // rax
  common::milog::MiLogStream *v40; // r14
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v41; // rax
  AddItemResult *v42; // rax
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v43; // rax
  common::milog::MiLogStream *v44; // r14
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v45; // rax
  AddItemResult *v46; // rax
  common::milog::MiLogStream *v47; // r14
  std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v48; // rcx
  common::milog::MiLogStream *v49; // r14
  std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v50; // rax
  AddItemResult *v51; // rax
  common::milog::MiLogStream *v52; // r14
  SeaLampActivity *v53; // rax
  common::milog::MiLogStream *v54; // r14
  std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v55; // rax
  AddItemResult *v56; // rax
  SeaLampActivity *v57; // rax
  common::milog::MiLogStream *v58; // r14
  std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v59; // rax
  AddItemResult *v60; // rax
  PlayerMechanicusComp *MechanicusComp; // rax
  common::milog::MiLogStream *v62; // rax
  common::milog::MiLogStream *v63; // rax
  common::milog::MiLogStream *v64; // r14
  PlayerMechanicusComp *v65; // rax
  AddItemResult *v66; // rax
  common::milog::MiLogStream *v67; // r14
  FleurFairActivity *v68; // rax
  common::milog::MiLogStream *v69; // r14
  std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v70; // rax
  AddItemResult *v71; // rax
  FleurFairActivity *v72; // rax
  common::milog::MiLogStream *v73; // rax
  common::milog::MiLogStream *v74; // rax
  common::milog::MiLogStream *v75; // rax
  FleurFairActivity *v76; // rax
  common::milog::MiLogStream *v77; // r14
  std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v78; // rax
  AddItemResult *v79; // rax
  common::milog::MiLogStream *v80; // r14
  std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v81; // rax
  common::milog::MiLogStream *v82; // r14
  std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v83; // rax
  AddItemResult *v84; // rax
  common::milog::MiLogStream *v85; // rax
  AddItemResult *v86; // rax
  common::milog::MiLogStream *v87; // r14
  ChannellerSlabActivity *v88; // rax
  common::milog::MiLogStream *v89; // r14
  std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v90; // rax
  AddItemResult *v91; // rax
  common::milog::MiLogStream *v92; // r14
  SummerTimeActivity *v93; // rax
  common::milog::MiLogStream *v94; // r14
  std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v95; // rax
  AddItemResult *v96; // rax
  SummerTimeActivity *v97; // rax
  common::milog::MiLogStream *v98; // r14
  std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v99; // rax
  AddItemResult *v100; // rax
  common::milog::MiLogStream *v101; // r14
  BounceConjuringActivity *v102; // rax
  common::milog::MiLogStream *v103; // r14
  std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v104; // rax
  AddItemResult *v105; // rax
  common::milog::MiLogStream *v106; // r14
  std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v107; // rax
  common::milog::MiLogStream *v108; // r14
  std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v109; // rax
  AddItemResult *v110; // rax
  common::milog::MiLogStream *v111; // r14
  ChessActivity *v112; // rax
  ChessActivity *v113; // rax
  common::milog::MiLogStream *v114; // r14
  AddItemResult *v115; // rax
  ChessActivity *v116; // rax
  common::milog::MiLogStream *v117; // r14
  std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v118; // rax
  AddItemResult *v119; // rax
  common::milog::MiLogStream *v120; // r14
  LunaRiteActivity *v121; // rax
  common::milog::MiLogStream *v122; // r14
  std::__shared_ptr_access<LunaRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v123; // rax
  AddItemResult *v124; // rax
  common::milog::MiLogStream *v125; // r14
  RoguelikeDungeonActivity *v126; // rax
  common::milog::MiLogStream *v127; // r14
  std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v128; // rax
  AddItemResult *v129; // rax
  common::milog::MiLogStream *v130; // r14
  WinterCampActivity *v131; // rax
  common::milog::MiLogStream *v132; // r14
  std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v133; // rax
  AddItemResult *v134; // rax
  common::milog::MiLogStream *v135; // r14
  LanternRiteActivity *v136; // rax
  common::milog::MiLogStream *v137; // r14
  std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v138; // rax
  AddItemResult *v139; // rax
  common::milog::MiLogStream *v140; // r14
  SummerTimeV2Activity *v141; // rax
  common::milog::MiLogStream *v142; // r14
  std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v143; // rax
  AddItemResult *v144; // rax
  common::milog::MiLogStream *v145; // r14
  RogueDiaryActivity *v146; // rax
  common::milog::MiLogStream *v147; // r14
  std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v148; // rax
  AddItemResult *v149; // rax
  common::milog::MiLogStream *v150; // r14
  GravenInnocenceActivity *v151; // rax
  common::milog::MiLogStream *v152; // r14
  std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v153; // rax
  AddItemResult *v154; // rax
  common::milog::MiLogStream *v155; // r14
  TreasureSeelieActivity *v156; // rax
  common::milog::MiLogStream *v157; // r14
  std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v158; // rax
  AddItemResult *v159; // rax
  common::milog::MiLogStream *v160; // r14
  VintageActivity *v161; // rax
  common::milog::MiLogStream *v162; // r14
  std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v163; // rax
  AddItemResult *v164; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v165; // rax
  common::milog::MiLogStream *v166; // rax
  uint32_t ActivityComp; // eax
  std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v168; // rax
  common::milog::MiLogStream *v170; // r14
  BaseActivity *v171; // rax
  common::milog::MiLogStream *v172; // r14
  std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v173; // rax
  AddItemResult *v174; // rax
  PlayerGCGComp *GCGComp; // rax
  AddItemResult *v176; // rax
  common::milog::MiLogStream *v177; // rax
  unsigned int val; // [rsp+20h] [rbp-150h] BYREF
  uint32_t activity_id; // [rsp+24h] [rbp-14Ch]
  proto::VirtualItem coin_type_7; // [rsp+28h] [rbp-148h]
  proto::VirtualItem coin_type_6; // [rsp+2Ch] [rbp-144h]
  proto::VirtualItem coin_type_5; // [rsp+30h] [rbp-140h]
  proto::VirtualItem coin_type_3; // [rsp+34h] [rbp-13Ch]
  proto::VirtualItem coin_type_4; // [rsp+38h] [rbp-138h]
  proto::VirtualItem coin_type_2; // [rsp+3Ch] [rbp-134h]
  proto::VirtualItem coin_type_1; // [rsp+40h] [rbp-130h]
  proto::VirtualItem coin_type_0; // [rsp+44h] [rbp-12Ch]
  uint32_t remain_exp; // [rsp+48h] [rbp-128h]
  proto::VirtualItem coin_type; // [rsp+4Ch] [rbp-124h]
  uint32_t available_num; // [rsp+5Ch] [rbp-114h]
  common::milog::MiLogStream v197; // [rsp+60h] [rbp-110h] BYREF
  char v198[240]; // [rsp+80h] [rbp-F0h] BYREF

  v5 = (unsigned __int64)v198;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(192LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "5 48 4 14 coin_type:3860 64 4 12 item_id:3004 80 4 15 item_count:3004 96 16 17 activity_ptr:3867"
                        " 128 24 15 add_result:3890";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::addVirtualItem;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556943;
  v7[536862722] = -234556924;
  v7[536862723] = -219021312;
  v7[536862724] = -218103808;
  v7[536862725] = -202116109;
  *(_DWORD *)(v5 + 64) = item_id;
  *(_DWORD *)(v5 + 80) = item_count;
  switch ( *(_DWORD *)(v5 + 64) )
  {
    case 0x65:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      AvatarComp = Player::getAvatarComp(this->player_);
      PlayerAvatarComp::addMyAvatarExpForTeam(AvatarComp, *(_DWORD *)(v5 + 80), reason, 1);
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 101;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      v9 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v9, v9);
      goto LABEL_403;
    case 0x66:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      BasicComp = Player::getBasicComp(this->player_);
      PlayerBasicComp::addExp(BasicComp, *(_DWORD *)(v5 + 80), reason, 1, temp_result_vec);
      goto LABEL_403;
    case 0x69:
      CurMultiPlayFetterExpRatio = PlayerItemComp::getCurMultiPlayFetterExpRatio(this);
      *(_DWORD *)(v5 + 80) = (int)(float)(SAFE_MULTIPLY<unsigned int,float>(
                                            *(_DWORD *)(v5 + 80),
                                            CurMultiPlayFetterExpRatio)
                                        + 0.00000011920929);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v12 = Player::getAvatarComp(this->player_);
      PlayerAvatarComp::addMyAvatarFetterExpForTeam(v12, *(_DWORD *)(v5 + 80), reason);
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 105;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      v13 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v13, v13);
      goto LABEL_403;
    case 0x6A:
      if ( PlayerItemComp::addResin(this, *(_DWORD *)(v5 + 80), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3083);
        v19 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(&v197, (const char (*)[25])off_26390680);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v19, (const unsigned int *)(v5 + 80));
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 106;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      *(_DWORD *)(v5 + 144) = PlayerItemComp::getResin(this);
      v20 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v20, v20);
      goto LABEL_403;
    case 0x6B:
      if ( PlayerItemComp::addLegendaryKey(this, *(_DWORD *)(v5 + 80), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3099);
        v21 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                &v197,
                (const char (*)[31])"addLegendaryKey failed, count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, (const unsigned int *)(v5 + 80));
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 107;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      *(_DWORD *)(v5 + 144) = PlayerItemComp::getLegendaryKey(this);
      v22 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v22, v22);
      goto LABEL_403;
    case 0x6C:
      common::milog::MiLogStream::create(
        &v197,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "addVirtualItem",
        3114);
      v14 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(
              &v197,
              (const char (*)[48])"cannot add aster progress by virutal item, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_183;
    case 0x6D:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<AsterActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<AsterActivity>(0LL, (const std::shared_ptr<AsterActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3122);
        v23 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v197,
                (const char (*)[39])"[ASTER] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_37;
      }
      v24 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      if ( AsterActivity::addAsterCredit(v24, *(_DWORD *)(v5 + 80), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3128);
        v25 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                &v197,
                (const char (*)[36])"[ASTER] addAsterCredit failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v25, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 109;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      v26 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      *(_DWORD *)(v5 + 144) = AsterActivity::getAsterCredit(v26);
      v27 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v27, v27);
      goto LABEL_43;
    case 0x6E:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<AsterActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<AsterActivity>(0LL, (const std::shared_ptr<AsterActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3146);
        v23 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v197,
                (const char (*)[39])"[ASTER] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
LABEL_37:
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v23, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v28 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( AsterActivity::addAsterToken(v28, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3152);
          v29 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                  &v197,
                  (const char (*)[35])"[ASTER] addAsterToken failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v29, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 110;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v30 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = AsterActivity::getAsterToken(v30);
        v31 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v31, v31);
      }
LABEL_43:
      std::shared_ptr<AsterActivity>::~shared_ptr((std::shared_ptr<AsterActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x6F:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3187);
        v34 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v197,
                (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_76;
      }
      v35 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      if ( DragonSpineActivity::addShimmeringEssence(v35, *(_DWORD *)(v5 + 80), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3193);
        v36 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                &v197,
                (const char (*)[49])"[DRAGON_SPINE] addShimmeringEssence failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v36, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 111;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      v37 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      *(_DWORD *)(v5 + 144) = DragonSpineActivity::getShimmeringEssence(v37);
      v38 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v38, v38);
      goto LABEL_93;
    case 0x70:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3211);
        v34 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v197,
                (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_76;
      }
      v39 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      if ( DragonSpineActivity::addWarmEssence(v39, *(_DWORD *)(v5 + 80), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3217);
        v40 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                &v197,
                (const char (*)[43])"[DRAGON_SPINE] addWarmEssence failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v40, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 112;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      v41 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      *(_DWORD *)(v5 + 144) = DragonSpineActivity::getWarmEssence(v41);
      v42 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v42, v42);
      goto LABEL_93;
    case 0x71:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3235);
        v34 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v197,
                (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
LABEL_76:
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v34, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v43 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( DragonSpineActivity::addWondrousEssence(v43, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3241);
          v44 = common::milog::MiLogStream::operator<<<char [47],(char *[47])0>(
                  &v197,
                  (const char (*)[47])"[DRAGON_SPINE] addWondrousEssence failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v44, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 113;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v45 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = DragonSpineActivity::getWondrousEssence(v45);
        v46 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v46, v46);
      }
LABEL_93:
      std::shared_ptr<DragonSpineActivity>::~shared_ptr((std::shared_ptr<DragonSpineActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x72:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<TreasureMapActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<TreasureMapActivity>(0LL, (const std::shared_ptr<TreasureMapActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3259);
        v47 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v197,
                (const char (*)[46])"[TREASURE_MAP] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v47, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v48 = std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(reason);
        }
        if ( TreasureMapActivity::addToken(v48, (uint32_t *)(v5 + 80), reason->reason_type == ACTION_REASON_GM) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3265);
          v49 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                  &v197,
                  (const char (*)[37])"[TREASURE_MAP] addToken failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v49, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 114;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v50 = std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = TreasureMapActivity::getToken(v50);
        v51 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v51, v51);
      }
      std::shared_ptr<TreasureMapActivity>::~shared_ptr((std::shared_ptr<TreasureMapActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x73:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SeaLampActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<SeaLampActivity>(0LL, (const std::shared_ptr<SeaLampActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3283);
        v52 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                &v197,
                (const char (*)[29])"[SEA_LAMP] not opening, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_113;
      }
      v53 = std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      if ( SeaLampActivity::addSeaLampCoin(v53, *(_DWORD *)(v5 + 80), reason) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3288);
        v54 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
                &v197,
                (const char (*)[38])"[SEA_LAMP] addSeaLampCoin fails, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v54, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 115;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      v55 = std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      *(_DWORD *)(v5 + 144) = SeaLampActivity::getSeaLampCoin(v55);
      v56 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v56, v56);
      goto LABEL_119;
    case 0x74:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SeaLampActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<SeaLampActivity>(0LL, (const std::shared_ptr<SeaLampActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3305);
        v52 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                &v197,
                (const char (*)[29])"[SEA_LAMP] not opening, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
LABEL_113:
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v52, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v57 = std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( SeaLampActivity::addPopularity(v57, *(_DWORD *)(v5 + 80), reason) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3310);
          v58 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                  &v197,
                  (const char (*)[37])"[SEA_LAMP] addPopularity fails, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v58, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 116;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v59 = std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = SeaLampActivity::getPopularity(v59);
        v60 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v60, v60);
      }
LABEL_119:
      std::shared_ptr<SeaLampActivity>::~shared_ptr((std::shared_ptr<SeaLampActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x75:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      MechanicusComp = Player::getMechanicusComp(this->player_);
      if ( PlayerMechanicusComp::addCoin(MechanicusComp, *(_DWORD *)(v5 + 80), reason) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3326);
        v62 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(
                &v197,
                (const char (*)[20])"addCoin Mechanicus:");
        v63 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v62,
                (const unsigned int *)(v5 + 80));
        v64 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v63, (const char (*)[13])" fails, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v64, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 117;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v65 = Player::getMechanicusComp(this->player_);
      *(_DWORD *)(v5 + 144) = PlayerMechanicusComp::getCoin(v65);
      v66 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v66, v66);
      goto LABEL_403;
    case 0x76:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<FleurFairActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<FleurFairActivity>(0LL, (const std::shared_ptr<FleurFairActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3343);
        v67 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                &v197,
                (const char (*)[44])"[FLEUR_FAIR] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_145;
      }
      v68 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      if ( FleurFairActivity::addCredit(v68, *(_DWORD *)(v5 + 80), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3349);
        v69 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                &v197,
                (const char (*)[36])"[FLEUR_FAIR] addCredit failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v69, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 118;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      v70 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      *(_DWORD *)(v5 + 144) = FleurFairActivity::getCredit(v70);
      v71 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v71, v71);
      goto LABEL_151;
    case 0x77:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<FleurFairActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<FleurFairActivity>(0LL, (const std::shared_ptr<FleurFairActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3368);
        v67 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                &v197,
                (const char (*)[44])"[FLEUR_FAIR] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
LABEL_145:
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v67, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
        goto LABEL_151;
      }
      v72 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      available_num = FleurFairActivity::getAvailableObtainCoinNum(v72);
      if ( !available_num )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3375);
        v67 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
                &v197,
                (const char (*)[38])"[FLEUR_FAIR] token reach limit, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_145;
      }
      *(_DWORD *)(v5 + 48) = *(_DWORD *)(v5 + 80);
      if ( available_num < *(_DWORD *)(v5 + 48) )
      {
        *(_DWORD *)(v5 + 48) = available_num;
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3383);
        v73 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                &v197,
                (const char (*)[40])"[FLEUR_FAIR] change token add_num from ");
        v74 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v73,
                (const unsigned int *)(v5 + 80));
        v75 = common::milog::MiLogStream::operator<<<char [5],(char *[5])0>(v74, (const char (*)[5])off_26390BA0);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v75, (const unsigned int *)(v5 + 48));
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      v76 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      if ( FleurFairActivity::addToken(v76, *(_DWORD *)(v5 + 48), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3388);
        v77 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                &v197,
                (const char (*)[35])"[FLEUR_FAIR] addToken failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v77, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 119;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 48);
      v78 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      *(_DWORD *)(v5 + 144) = FleurFairActivity::getToken(v78);
      v79 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v79, v79);
LABEL_151:
      std::shared_ptr<FleurFairActivity>::~shared_ptr((std::shared_ptr<FleurFairActivity> *const)(v5 + 96));
LABEL_403:
      if ( v198 == (char *)v5 )
      {
        *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
        *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
        *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0LL;
      }
      else
      {
        *(_QWORD *)v5 = 1172321806LL;
        *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
      }
      return;
    case 0x78:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<WaterSpiritActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<WaterSpiritActivity>(0LL, (const std::shared_ptr<WaterSpiritActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3407);
        v80 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v197,
                (const char (*)[46])"[WATER_SPIRIT] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v80, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v81 = std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( WaterSpiritActivity::addSpiritCoin(v81, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3413);
          v82 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                  &v197,
                  (const char (*)[36])"[WATER_SPIRIT] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v82, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 120;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v83 = std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = WaterSpiritActivity::getSpiritCoin(v83);
        v84 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v84, v84);
      }
      std::shared_ptr<WaterSpiritActivity>::~shared_ptr((std::shared_ptr<WaterSpiritActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x79:
      common::milog::MiLogStream::create(
        &v197,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "addVirtualItem",
        3429);
      v14 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
              &v197,
              (const char (*)[42])"cannot add home exp by virutal item, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_183;
    case 0x7A:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<ChannellerSlabActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<ChannellerSlabActivity>(0LL, (const std::shared_ptr<ChannellerSlabActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3453);
        v87 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                &v197,
                (const char (*)[49])"[CHANNELLER_SLAB] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v87, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v88 = std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( ChannellerSlabActivity::addToken(v88, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3459);
          v89 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                  &v197,
                  (const char (*)[41])"[CHANNELLER_SLAB] addToken failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v89, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 122;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v90 = std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = ChannellerSlabActivity::getToken(v90);
        v91 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v91, v91);
      }
      std::shared_ptr<ChannellerSlabActivity>::~shared_ptr((std::shared_ptr<ChannellerSlabActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x7C:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SummerTimeActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<SummerTimeActivity>(0LL, (const std::shared_ptr<SummerTimeActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3477);
        v92 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                &v197,
                (const char (*)[45])"[SUMMER_TIME] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_204;
      }
      v93 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      if ( SummerTimeActivity::addDraftWood(v93, *(_DWORD *)(v5 + 80), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3483);
        v94 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                &v197,
                (const char (*)[41])"[SUMMER_TIME] addDraftWood failed, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v94, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 124;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      v95 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      *(_DWORD *)(v5 + 144) = SummerTimeActivity::getDraftWood(v95);
      v96 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v96, v96);
      goto LABEL_210;
    case 0x7D:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SummerTimeActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<SummerTimeActivity>(0LL, (const std::shared_ptr<SummerTimeActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3501);
        v92 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                &v197,
                (const char (*)[45])"[SUMMER_TIME] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
LABEL_204:
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v92, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v97 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( SummerTimeActivity::addMiniHarpastum(v97, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3507);
          v98 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                  &v197,
                  (const char (*)[45])"[SUMMER_TIME] addMiniHarpastum failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v98, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 125;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v99 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = SummerTimeActivity::getMiniHarpastum(v99);
        v100 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v100, v100);
      }
LABEL_210:
      std::shared_ptr<SummerTimeActivity>::~shared_ptr((std::shared_ptr<SummerTimeActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x7E:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<BounceConjuringActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<BounceConjuringActivity>(0LL, (const std::shared_ptr<BounceConjuringActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3525);
        v101 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
                 &v197,
                 (const char (*)[50])"[BOUNCE_CONJURING] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v101, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v102 = std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( BounceConjuringActivity::addCoin(v102, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3531);
          v103 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                   &v197,
                   (const char (*)[40])"[BOUNCE_CONJURING] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v103, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 126;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v104 = std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = BounceConjuringActivity::getCoin(v104);
        v105 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v105, v105);
      }
      std::shared_ptr<BounceConjuringActivity>::~shared_ptr((std::shared_ptr<BounceConjuringActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x7F:
    case 0x80:
      coin_type = *(_DWORD *)(v5 + 64);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<BlitzRushActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<BlitzRushActivity>(0LL, (const std::shared_ptr<BlitzRushActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3552);
        v106 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v197,
                 (const char (*)[44])"[BLITZ_RUSH] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v106, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v107 = std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( BlitzRushActivity::addActivityCoin(v107, coin_type, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3558);
          v108 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
                   &v197,
                   (const char (*)[34])"[BLITZ_RUSH] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v108, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v109 = std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = BlitzRushActivity::getActivityCoin(v109, coin_type);
        v110 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v110, v110);
      }
      std::shared_ptr<BlitzRushActivity>::~shared_ptr((std::shared_ptr<BlitzRushActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x81:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<ChessActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<ChessActivity>(0LL, (const std::shared_ptr<ChessActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3577);
        v111 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                 &v197,
                 (const char (*)[39])"[CHESS] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_266;
      }
      v112 = std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      remain_exp = ChessActivity::getRemainExp(v112);
      if ( remain_exp < *(_DWORD *)(v5 + 80) )
        *(_DWORD *)(v5 + 80) = remain_exp;
      if ( *(_DWORD *)(v5 + 80) )
      {
        v113 = std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( ChessActivity::addExp(v113, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3594);
          v114 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
                   &v197,
                   (const char (*)[28])"[CHESS] addExp failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v114, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 129;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v115 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v115, v115);
      }
      goto LABEL_272;
    case 0x82:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<ChessActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<ChessActivity>(0LL, (const std::shared_ptr<ChessActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3613);
        v111 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                 &v197,
                 (const char (*)[39])"[CHESS] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
LABEL_266:
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v111, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v116 = std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( ChessActivity::addCoin(v116, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3619);
          v117 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                   &v197,
                   (const char (*)[29])"[CHESS] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v117, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 130;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v118 = std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = ChessActivity::getCoin(v118);
        v119 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v119, v119);
      }
LABEL_272:
      std::shared_ptr<ChessActivity>::~shared_ptr((std::shared_ptr<ChessActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x83:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<LunaRiteActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<LunaRiteActivity>(0LL, (const std::shared_ptr<LunaRiteActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3638);
        v120 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                 &v197,
                 (const char (*)[42])"[LUNARITE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v120, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v121 = std::__shared_ptr_access<LunaRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<LunaRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( LunaRiteActivity::addAtmosphere(v121, *(_DWORD *)(v5 + 80), reason) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3644);
          v122 = common::milog::MiLogStream::operator<<<char [32],(char *[32])0>(
                   &v197,
                   (const char (*)[32])"[LUNARITE] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v122, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = 131;
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v123 = std::__shared_ptr_access<LunaRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<LunaRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = LunaRiteActivity::getAtmosphere(v123);
        v124 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v124, v124);
      }
      std::shared_ptr<LunaRiteActivity>::~shared_ptr((std::shared_ptr<LunaRiteActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x84:
    case 0x85:
    case 0x86:
      coin_type_0 = *(_DWORD *)(v5 + 64);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<RoguelikeDungeonActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<RoguelikeDungeonActivity>(0LL, (const std::shared_ptr<RoguelikeDungeonActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3666);
        v125 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                 &v197,
                 (const char (*)[43])"[ROGUELIKE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v125, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v126 = std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( (unsigned int)RoguelikeDungeonActivity::addActivityCoin(v126, coin_type_0, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3672);
          v127 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
                   &v197,
                   (const char (*)[33])"[ROGUELIKE] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v127, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v128 = std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = RoguelikeDungeonActivity::getActivityCoin(v128, coin_type_0);
        v129 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v129, v129);
      }
      std::shared_ptr<RoguelikeDungeonActivity>::~shared_ptr((std::shared_ptr<RoguelikeDungeonActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x87:
    case 0x88:
      coin_type_1 = *(_DWORD *)(v5 + 64);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<WinterCampActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<WinterCampActivity>(0LL, (const std::shared_ptr<WinterCampActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3693);
        v130 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v197,
                 (const char (*)[44])"[WinterCamp] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v130, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v131 = std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( (unsigned int)WinterCampActivity::addActivityCoin(v131, coin_type_1, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3698);
          v132 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
                   &v197,
                   (const char (*)[34])"[WinterCamp] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v132, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v133 = std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = WinterCampActivity::getActivityCoin(v133, coin_type_1);
        v134 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v134, v134);
      }
      std::shared_ptr<WinterCampActivity>::~shared_ptr((std::shared_ptr<WinterCampActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x89:
    case 0x8A:
    case 0x8B:
      coin_type_2 = *(_DWORD *)(v5 + 64);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<LanternRiteActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<LanternRiteActivity>(0LL, (const std::shared_ptr<LanternRiteActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3718);
        v135 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                 &v197,
                 (const char (*)[45])"[LanternRite] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v135, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v136 = std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( LanternRiteActivity::addActivityCoin(v136, coin_type_2, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3723);
          v137 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                   &v197,
                   (const char (*)[35])"[LanternRite] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v137, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v138 = std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = LanternRiteActivity::getActivityCoin(v138, coin_type_2);
        v139 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v139, v139);
      }
      std::shared_ptr<LanternRiteActivity>::~shared_ptr((std::shared_ptr<LanternRiteActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x8C:
      coin_type_4 = *(_DWORD *)(v5 + 64);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<RogueDiaryActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<RogueDiaryActivity>(0LL, (const std::shared_ptr<RogueDiaryActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3764);
        v145 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v197,
                 (const char (*)[44])"[RogueDiary] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v145, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v146 = std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( RogueDiaryActivity::addActivityCoin(v146, coin_type_4, *(_DWORD *)(v5 + 80), reason) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3769);
          v147 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
                   &v197,
                   (const char (*)[34])"[RogueDiary] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v147, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v148 = std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = RogueDiaryActivity::getActivityCoin(v148, coin_type_4);
        v149 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v149, v149);
      }
      std::shared_ptr<RogueDiaryActivity>::~shared_ptr((std::shared_ptr<RogueDiaryActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x8D:
      coin_type_3 = *(_DWORD *)(v5 + 64);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SummerTimeV2Activity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<SummerTimeV2Activity>(0LL, (const std::shared_ptr<SummerTimeV2Activity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3741);
        v140 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(
                 &v197,
                 (const char (*)[48])"[SUMMER_TIME_V2] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v140, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v141 = std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( (unsigned int)SummerTimeV2Activity::addActivityCoin(v141, coin_type_3, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3746);
          v142 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
                   &v197,
                   (const char (*)[38])"[SUMMER_TIME_V2] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v142, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v143 = std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = SummerTimeV2Activity::getActivityCoin(v143, coin_type_3);
        v144 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v144, v144);
      }
      std::shared_ptr<SummerTimeV2Activity>::~shared_ptr((std::shared_ptr<SummerTimeV2Activity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x8F:
    case 0x90:
      coin_type_5 = *(_DWORD *)(v5 + 64);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<GravenInnocenceActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<GravenInnocenceActivity>(0LL, (const std::shared_ptr<GravenInnocenceActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3788);
        v150 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                 &v197,
                 (const char (*)[49])"[GravenInnocence] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v150, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v151 = std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( GravenInnocenceActivity::addActivityCoin(v151, coin_type_5, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3793);
          v152 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                   &v197,
                   (const char (*)[39])"[GravenInnocence] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v152, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v153 = std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = GravenInnocenceActivity::getActivityCoin(v153, coin_type_5);
        v154 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v154, v154);
      }
      std::shared_ptr<GravenInnocenceActivity>::~shared_ptr((std::shared_ptr<GravenInnocenceActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x91:
      coin_type_6 = *(_DWORD *)(v5 + 64);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<TreasureSeelieActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<TreasureSeelieActivity>(0LL, (const std::shared_ptr<TreasureSeelieActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3811);
        v155 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                 &v197,
                 (const char (*)[49])"[TREASURE SEELIE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v155, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v156 = std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( TreasureSeelieActivity::addActivityCoin(v156, coin_type_6, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3816);
          v157 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                   &v197,
                   (const char (*)[39])"[TREASURE SEELIE] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v157, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v158 = std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = TreasureSeelieActivity::getActivityCoin(v158, coin_type_6);
        v159 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v159, v159);
      }
      std::shared_ptr<TreasureSeelieActivity>::~shared_ptr((std::shared_ptr<TreasureSeelieActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x92:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      GCGComp = Player::getGCGComp(this->player_);
      PlayerGCGComp::addExp(GCGComp, *(_DWORD *)(v5 + 80), reason);
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 146;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      v176 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v176, v176);
      goto LABEL_403;
    case 0x93:
    case 0x94:
    case 0x95:
    case 0x96:
      coin_type_7 = *(_DWORD *)(v5 + 64);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<VintageActivity>((PlayerActivityComp *const)(v5 + 96));
      if ( std::operator==<VintageActivity>(0LL, (const std::shared_ptr<VintageActivity> *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3837);
        v160 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                 &v197,
                 (const char (*)[41])"[VINTAGE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v160, &val);
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      else
      {
        v161 = std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        if ( (unsigned int)VintageActivity::addActivityCoin(v161, coin_type_7, *(_DWORD *)(v5 + 80), reason, 1) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3842);
          v162 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                   &v197,
                   (const char (*)[31])"[VINTAGE] addCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v162, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        *(_QWORD *)(v5 + 128) = 0LL;
        *(_QWORD *)(v5 + 136) = 0LL;
        *(_QWORD *)(v5 + 144) = 0LL;
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
        *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
        v163 = std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
        *(_DWORD *)(v5 + 144) = VintageActivity::getActivityCoin(v163, coin_type_7);
        v164 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
        std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v164, v164);
      }
      std::shared_ptr<VintageActivity>::~shared_ptr((std::shared_ptr<VintageActivity> *const)(v5 + 96));
      goto LABEL_403;
    case 0x97:
    case 0x98:
    case 0x99:
    case 0x9A:
      *(_DWORD *)(v5 + 48) = *(_DWORD *)(v5 + 64);
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)(v5 + 96));
      v165 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
      activity_id = NewActivityExcelConfigMgr::findActivityIdByCoinType(
                      &v165->design_config.txt_config_mgr.new_activity_config_mgr,
                      *(proto::VirtualItem *)(v5 + 48));
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v5 + 96));
      if ( activity_id )
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        ActivityComp = (unsigned int)Player::getActivityComp(this->player_);
        PlayerActivityComp::findBaseActivity((PlayerActivityComp *const)(v5 + 96), ActivityComp);
        if ( std::operator==<BaseActivity>(0LL, (const std::shared_ptr<BaseActivity> *)(v5 + 96))
          || (v168 = std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96)),
              !BaseActivity::isOpening(v168, 0)) )
        {
          common::milog::MiLogStream::create(
            &v197,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "addVirtualItem",
            3870);
          v170 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                   &v197,
                   (const char (*)[31])"activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v170, &val);
          common::milog::MiLogStream::~MiLogStream(&v197);
        }
        else
        {
          v171 = std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
          if ( BaseActivity::addActivityGeneralCoin(
                 v171,
                 *(proto::VirtualItem *)(v5 + 48),
                 *(_DWORD *)(v5 + 80),
                 reason,
                 1) )
          {
            common::milog::MiLogStream::create(
              &v197,
              &common::milog::MiLogDefault::default_log_obj_,
              4u,
              "./src/player/item/player_item_comp.cpp",
              "addVirtualItem",
              3875);
            v172 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
                     &v197,
                     (const char (*)[22])"addCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v172, &val);
            common::milog::MiLogStream::~MiLogStream(&v197);
          }
          *(_QWORD *)(v5 + 128) = 0LL;
          *(_QWORD *)(v5 + 136) = 0LL;
          *(_QWORD *)(v5 + 144) = 0LL;
          *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
          *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
          v173 = std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 96));
          *(_DWORD *)(v5 + 144) = BaseActivity::getActivityGeneralCoin(v173, *(proto::VirtualItem *)(v5 + 48));
          v174 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
          std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v174, v174);
        }
        std::shared_ptr<BaseActivity>::~shared_ptr((std::shared_ptr<BaseActivity> *const)(v5 + 96));
      }
      else
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3864);
        v166 = common::milog::MiLogStream::operator<<<char [64],(char *[64])0>(
                 &v197,
                 (const char (*)[64])"virutal coin cannot find corresponding activity id, coin_type: ");
        common::milog::MiLogStream::operator<<<proto::VirtualItem,(proto::VirtualItem*)0>(
          v166,
          (const proto::VirtualItem *)(v5 + 48));
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      goto LABEL_403;
    case 0xC9:
      if ( PlayerItemComp::addHcoin(this, *(_DWORD *)(v5 + 80), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3051);
        v15 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
                &v197,
                (const char (*)[24])"addHcoin failed, count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, (const unsigned int *)(v5 + 80));
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 201;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      *(_DWORD *)(v5 + 144) = PlayerItemComp::getHcoin(this);
      v16 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v16, v16);
      goto LABEL_403;
    case 0xCA:
      if ( PlayerItemComp::addScoin(this, *(_DWORD *)(v5 + 80), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3067);
        v17 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
                &v197,
                (const char (*)[24])"addScoin failed, count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, (const unsigned int *)(v5 + 80));
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 202;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      *(_DWORD *)(v5 + 144) = PlayerItemComp::getScoin(this);
      v18 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v18, v18);
      goto LABEL_403;
    case 0xCB:
      common::milog::MiLogStream::create(
        &v197,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "addVirtualItem",
        3044);
      v14 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
              &v197,
              (const char (*)[39])"cannot add mcoin by virutal item, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
LABEL_183:
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &val);
      common::milog::MiLogStream::~MiLogStream(&v197);
      goto LABEL_403;
    case 0xCC:
      if ( PlayerItemComp::addHomeCoin(this, *(_DWORD *)(v5 + 80), reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v197,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addVirtualItem",
          3436);
        v85 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
                &v197,
                (const char (*)[27])"addHomeCoin failed, count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v85, (const unsigned int *)(v5 + 80));
        common::milog::MiLogStream::~MiLogStream(&v197);
      }
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = 204;
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      *(_DWORD *)(v5 + 144) = PlayerItemComp::getHomeCoin(this);
      v86 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v86, v86);
      goto LABEL_403;
    case 0x13A:
    case 0x13B:
    case 0x13C:
    case 0x13D:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      ReputationComp = Player::getReputationComp(this->player_);
      if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
      {
        ReputationComp = (PlayerReputationComp *)reason;
        __asan_report_load4(reason);
      }
      PlayerReputationComp::addExpItem(ReputationComp, *(_DWORD *)(v5 + 64), *(_DWORD *)(v5 + 80), reason->reason_type);
      *(_QWORD *)(v5 + 128) = 0LL;
      *(_QWORD *)(v5 + 136) = 0LL;
      *(_QWORD *)(v5 + 144) = 0LL;
      *(_DWORD *)(v5 + 136) = *(_DWORD *)(v5 + 64);
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(v5 + 80);
      v33 = std::move<AddItemResult &>((AddItemResult *)(v5 + 128));
      std::vector<AddItemResult>::emplace_back<AddItemResult>(temp_result_vec, v33, v33);
      goto LABEL_403;
    default:
      common::milog::MiLogStream::create(
        &v197,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "addVirtualItem",
        3901);
      v177 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
               &v197,
               (const char (*)[30])"unkown virutal item, item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v177, (const unsigned int *)(v5 + 64));
      common::milog::MiLogStream::~MiLogStream(&v197);
      goto LABEL_403;
  }
};

// Line 3908: range 0000000017CDAC20-0000000017CDB1F3
int32_t __cdecl PlayerItemComp::checkAddItemBatch(
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec,
        const ActionReason *reason)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  int32_t v6; // r14d
  common::milog::MiLogStream *v7; // rdx
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rcx
  ItemExcelConfigMgr *p_item_config_mgr; // rcx
  common::milog::MiLogStream *v11; // r14
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  int32_t result; // eax
  unsigned int val; // [rsp+2Ch] [rbp-F4h] BYREF
  int32_t ret; // [rsp+30h] [rbp-F0h]
  int32_t ret_0; // [rsp+34h] [rbp-ECh]
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+38h] [rbp-E8h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+40h] [rbp-E0h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+48h] [rbp-D8h]
  const ItemParam *item_param; // [rsp+50h] [rbp-D0h]
  const data::ItemConfig *item_config_ptr; // [rsp+58h] [rbp-C8h]
  std::shared_ptr<Config> v24; // [rsp+60h] [rbp-C0h] BYREF
  common::milog::MiLogStream v25; // [rsp+70h] [rbp-B0h] BYREF
  char v26[144]; // [rsp+90h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v26;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 24 30 item_param_vec_no_virtual:3922";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkAddItemBatch;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  if ( std::vector<ItemParam>::size(item_param_vec) )
  {
    ret = PlayerItemComp::checkOutputLimitBeforeCheckAddItemBatch<ItemParam>(this, item_param_vec, reason);
    if ( ret )
    {
      common::milog::MiLogStream::create(
        &v25,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddItemBatch",
        3918);
      v7 = common::milog::MiLogStream::operator<<<char [62],(char *[62])0>(
             &v25,
             (const char (*)[62])"checkOutputLimitBeforeCheckAddItemBatch fail, item_param_vec:");
      v8 = common::milog::MiLogStream::operator<<<ItemParam>(v7, item_param_vec);
      v9 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v8, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v9, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v25);
      v6 = ret;
    }
    else
    {
      std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v3 + 32));
      __for_range = item_param_vec;
      __for_begin._M_current = std::vector<ItemParam>::begin(item_param_vec)._M_current;
      __for_end._M_current = std::vector<ItemParam>::end(item_param_vec)._M_current;
      while ( 1 )
      {
        if ( !__gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
        {
          v6 = PackItemStore::checkAddItemBatch(&this->pack_store_, (const std::vector<ItemParam> *)(v3 + 32), reason);
          goto LABEL_26;
        }
        item_param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)&v24);
        p_item_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v24)->design_config.txt_config_mgr.item_config_mgr;
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        item_config_ptr = ItemExcelConfigMgr::findItemConfig(p_item_config_mgr, item_param->item_id);
        std::shared_ptr<Config>::~shared_ptr(&v24);
        if ( !item_config_ptr )
          break;
        if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                         + 0x7FFF8000) )
        {
          __asan_report_load4(&item_config_ptr->item_type);
        }
        if ( item_config_ptr->item_type == ITEM_VIRTUAL )
        {
          ret_0 = PlayerItemComp::checkAddVirtualItem(this, item_param, reason);
          if ( ret_0 )
          {
            v6 = ret_0;
            goto LABEL_26;
          }
        }
        else
        {
          std::vector<ItemParam>::emplace_back<ItemParam const&>(
            (std::vector<ItemParam> *const)(v3 + 32),
            item_param,
            item_param);
        }
        __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
      }
      common::milog::MiLogStream::create(
        &v25,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddItemBatch",
        3929);
      v11 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
              &v25,
              (const char (*)[28])"findItemConfig failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &val);
      v13 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v12, (const char (*)[10])" item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v25);
      v6 = -1;
LABEL_26:
      std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 32));
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v25,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkAddItemBatch",
      3911);
    common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(&v25, (const char (*)[24])"item_param_vec is empty");
    common::milog::MiLogStream::~MiLogStream(&v25);
    v6 = -1;
  }
  result = v6;
  if ( v26 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 3948: range 0000000017CDB1F4-0000000017CDB448
int32_t __cdecl PlayerItemComp::addItem(
        PlayerItemComp *const this,
        const ItemParam *item_param,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  _DWORD *v6; // r12
  std::initializer_list<ItemParam>::size_type v7; // rdx
  int32_t v8; // r14d
  int32_t result; // eax
  std::allocator<ItemParam> __a; // [rsp+3Fh] [rbp-A1h] BYREF
  std::initializer_list<ItemParam> __l; // [rsp+40h] [rbp-A0h] BYREF
  char v14[144]; // [rsp+50h] [rbp-90h] BYREF

  v4 = (unsigned __int64)v14;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(96LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 24 19 item_param_vec:3949";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addItem;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -218103808;
  v6[536862722] = -202116109;
  if ( ((unsigned __int8)item_param & 7) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000)
    && *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    || *(_BYTE *)((((unsigned __int64)&item_param->promote_level + 3) >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)item_param + 15) & 7) >= *(_BYTE *)((((unsigned __int64)&item_param->promote_level + 3) >> 3)
                                                            + 0x7FFF8000) )
  {
    __asan_report_load_n(item_param, 16LL);
  }
  v7 = *(_QWORD *)&item_param->level;
  __l._M_array = *(std::initializer_list<ItemParam>::iterator *)&item_param->item_id;
  __l._M_len = v7;
  std::allocator<ItemParam>::allocator(&__a);
  std::vector<ItemParam>::vector(
    (std::vector<ItemParam> *const)(v4 + 32),
    (std::initializer_list<ItemParam>)__PAIR128__(1LL, &__l),
    &__a);
  std::allocator<ItemParam>::~allocator(&__a);
  v8 = PlayerItemComp::addItemBatch(this, (const std::vector<ItemParam> *)(v4 + 32), reason, result_vec_ptr);
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 32));
  result = v8;
  if ( v14 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 3954: range 0000000017CDB91C-0000000017CDB977
int32_t __cdecl PlayerItemComp::addMaterialBatchWithStackLimit(
        PlayerItemComp *const this,
        std::vector<ItemParam> *item_param_vec,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  common::tools::MiscUtils::erase_if<ItemParam,PlayerItemComp::addMaterialBatchWithStackLimit(std::vector<ItemParam> &,ActionReason const&,std::vector*<AddItemResult,std::allocator<std::vector*>>)::{lambda(ItemParam&)#1}>(
    item_param_vec,
    (PlayerItemComp::addMaterialBatchWithStackLimit::<lambda(ItemParam&)>)this);
  if ( std::vector<ItemParam>::empty(item_param_vec) )
    return 0;
  else
    return PlayerItemComp::addItemBatch(this, item_param_vec, reason, result_vec_ptr);
};

// Line 3955: range 0000000017CDB44A-0000000017CDB91B
bool __cdecl PlayerItemComp::addMaterialBatchWithStackLimit(std::vector<ItemParam> &,ActionReason const&,std::vector*<AddItemResult,std::allocator<std::vector*>>)::{lambda(ItemParam&)#1}::operator()(
        const PlayerItemComp::addMaterialBatchWithStackLimit::<lambda(ItemParam&)> *const __closure,
        ItemParam *item_param)
{
  MaterialExcelConfigMgr *p_material_config_mgr; // rcx
  common::milog::MiLogStream *v3; // rdx
  PlayerItemComp *this; // rcx
  uint32_t v6; // ecx
  common::milog::MiLogStream *v7; // rdx
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  uint32_t *p_count; // rax
  __int64 v11; // rsi
  __int64 v12; // rdx
  common::milog::MiLogStream *v13; // rdx
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rcx
  unsigned int *p_val; // rsi
  uint32_t v19; // ecx
  char v20; // dl
  __int64 v21; // rdx
  unsigned int val; // [rsp+10h] [rbp-50h] BYREF
  uint32_t cur_count; // [rsp+14h] [rbp-4Ch]
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+18h] [rbp-48h]
  std::shared_ptr<Config> v26; // [rsp+20h] [rbp-40h] BYREF
  common::milog::MiLogStream v27; // [rsp+30h] [rbp-30h] BYREF

  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v26);
  p_material_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v26)->design_config.txt_config_mgr.material_config_mgr;
  if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(item_param);
  }
  material_config_ptr = data::MaterialExcelConfigMgrBase::findMaterialExcelConfig(
                          p_material_config_mgr,
                          item_param->item_id);
  std::shared_ptr<Config>::~shared_ptr(&v26);
  if ( material_config_ptr )
  {
    if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    this = __closure->__this;
    if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_param);
    }
    cur_count = PlayerItemComp::getPackMaterialCount(this, item_param->item_id);
    if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&item_param->count);
    }
    v6 = item_param->count + cur_count;
    if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&material_config_ptr->stack_limit);
    }
    if ( v6 <= material_config_ptr->stack_limit )
    {
      return 0;
    }
    else if ( cur_count < material_config_ptr->stack_limit )
    {
      common::milog::MiLogStream::create(
        &v27,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "operator()",
        3978);
      v13 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
              &v27,
              (const char (*)[17])"stacklimit item:");
      v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, &item_param->item_id);
      v15 = common::milog::MiLogStream::operator<<<char [2],(char *[2])0>(v14, (const char (*)[2])" ");
      v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, &item_param->count);
      v17 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v16, (const char (*)[10])" forceto ");
      if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&material_config_ptr->stack_limit);
      }
      val = material_config_ptr->stack_limit - cur_count;
      p_val = &val;
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, &val);
      common::milog::MiLogStream::~MiLogStream(&v27);
      if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&material_config_ptr->stack_limit);
      }
      v19 = material_config_ptr->stack_limit - cur_count;
      v20 = *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000);
      LOBYTE(p_val) = v20 != 0;
      v21 = (v20 != 0) & (unsigned __int8)((char)((((_BYTE)item_param + 4) & 7) + 3) >= v20);
      if ( (_BYTE)v21 )
        __asan_report_store4(&item_param->count, p_val, v21);
      item_param->count = v19;
      return 0;
    }
    else
    {
      common::milog::MiLogStream::create(
        &v27,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "operator()",
        3970);
      v7 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(&v27, (const char (*)[31])off_263917A0);
      v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &item_param->item_id);
      v9 = common::milog::MiLogStream::operator<<<char [2],(char *[2])0>(v8, (const char (*)[2])",");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &item_param->count);
      common::milog::MiLogStream::~MiLogStream(&v27);
      p_count = &item_param->count;
      v11 = (((_BYTE)item_param + 4) & 7u) + 3;
      v12 = (*(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000));
      if ( (_BYTE)v12 )
        __asan_report_store4(p_count, v11, v12);
      item_param->count = 0;
      return 1;
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v27,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "operator()",
      3960);
    v3 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(&v27, (const char (*)[35])off_26391740);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v3, &item_param->item_id);
    common::milog::MiLogStream::~MiLogStream(&v27);
    return 1;
  }
};

// Line 3995: range 0000000017CDBF82-0000000017CDBFDD
int32_t __cdecl PlayerItemComp::addItemBatchWithStackLimit(
        PlayerItemComp *const this,
        std::vector<ItemParam> *item_param_vec,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  common::tools::MiscUtils::erase_if<ItemParam,PlayerItemComp::addItemBatchWithStackLimit(std::vector<ItemParam> &,ActionReason const&,std::vector*<AddItemResult,std::allocator<std::vector*>>)::{lambda(ItemParam&)#1}>(
    item_param_vec,
    (PlayerItemComp::addItemBatchWithStackLimit::<lambda(ItemParam&)>)this);
  if ( std::vector<ItemParam>::empty(item_param_vec) )
    return 0;
  else
    return PlayerItemComp::addItemBatch(this, item_param_vec, reason, result_vec_ptr);
};

// Line 3996: range 0000000017CDB978-0000000017CDBF80
bool __cdecl PlayerItemComp::addItemBatchWithStackLimit(std::vector<ItemParam> &,ActionReason const&,std::vector*<AddItemResult,std::allocator<std::vector*>>)::{lambda(ItemParam&)#1}::operator()(
        const PlayerItemComp::addItemBatchWithStackLimit::<lambda(ItemParam&)> *const __closure,
        ItemParam *item_param)
{
  ItemExcelConfigMgr *p_item_config_mgr; // rcx
  MaterialExcelConfigMgr *p_material_config_mgr; // rcx
  HomeWorldExcelConfigMgr *p_home_config_mgr; // rcx
  PlayerItemComp *this; // rcx
  common::milog::MiLogStream *v7; // rdx
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  uint32_t v12; // ecx
  char v13; // dl
  unsigned int *p_val; // rsi
  __int64 v15; // rdx
  common::milog::MiLogStream *v16; // rdx
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  uint32_t *p_count; // rax
  __int64 v20; // rsi
  __int64 v21; // rdx
  unsigned int val; // [rsp+1Ch] [rbp-64h] BYREF
  uint32_t stack_limit; // [rsp+20h] [rbp-60h]
  data::ItemType item_type; // [rsp+24h] [rbp-5Ch]
  uint32_t cur_count; // [rsp+28h] [rbp-58h]
  uint32_t total_count; // [rsp+2Ch] [rbp-54h]
  const data::HomeWorldFurnitureExcelConfig *furniture_config_ptr; // [rsp+30h] [rbp-50h]
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+38h] [rbp-48h]
  std::shared_ptr<Config> v30; // [rsp+40h] [rbp-40h] BYREF
  common::milog::MiLogStream v31; // [rsp+50h] [rbp-30h] BYREF

  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v30);
  p_item_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v30)->design_config.txt_config_mgr.item_config_mgr;
  if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(item_param);
  }
  item_type = ItemExcelConfigMgr::getItemType(p_item_config_mgr, item_param->item_id);
  std::shared_ptr<Config>::~shared_ptr(&v30);
  stack_limit = 0;
  if ( item_type == ITEM_MATERIAL )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v30);
    p_material_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v30)->design_config.txt_config_mgr.material_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_param);
    }
    material_config_ptr = data::MaterialExcelConfigMgrBase::findMaterialExcelConfig(
                            p_material_config_mgr,
                            item_param->item_id);
    std::shared_ptr<Config>::~shared_ptr(&v30);
    if ( !material_config_ptr )
      return 0;
    if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&material_config_ptr->stack_limit);
    }
    if ( !material_config_ptr->stack_limit )
      return 0;
    if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&material_config_ptr->stack_limit);
    }
    stack_limit = material_config_ptr->stack_limit;
  }
  else
  {
    if ( item_type != ITEM_FURNITURE )
      return 0;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v30);
    p_home_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v30)->design_config.txt_config_mgr.home_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_param);
    }
    furniture_config_ptr = data::HomeWorldExcelConfigMgrBase::findHomeWorldFurnitureExcelConfig(
                             p_home_config_mgr,
                             item_param->item_id);
    std::shared_ptr<Config>::~shared_ptr(&v30);
    if ( !furniture_config_ptr )
      return 0;
    if ( *(_BYTE *)(((unsigned __int64)&furniture_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)furniture_config_ptr - 108) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&furniture_config_ptr->stack_limit >> 3)
                                                                           + 0x7FFF8000) )
    {
      __asan_report_load4(&furniture_config_ptr->stack_limit);
    }
    stack_limit = furniture_config_ptr->stack_limit;
  }
  if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  this = __closure->__this;
  if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(item_param);
  }
  cur_count = PlayerItemComp::getPackMaterialCount(this, item_param->item_id);
  if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&item_param->count);
  }
  total_count = SAFE_ADD<unsigned int,unsigned int>(cur_count, item_param->count);
  if ( total_count <= stack_limit )
    return 0;
  if ( stack_limit <= cur_count )
  {
    common::milog::MiLogStream::create(
      &v31,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "operator()",
      4044);
    v16 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(&v31, (const char (*)[31])off_263917A0);
    v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, &item_param->item_id);
    v18 = common::milog::MiLogStream::operator<<<char [2],(char *[2])0>(v17, (const char (*)[2])",");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, &item_param->count);
    common::milog::MiLogStream::~MiLogStream(&v31);
    p_count = &item_param->count;
    v20 = (((_BYTE)item_param + 4) & 7u) + 3;
    v21 = (*(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000));
    if ( (_BYTE)v21 )
      __asan_report_store4(p_count, v20, v21);
    item_param->count = 0;
    return 1;
  }
  else
  {
    common::milog::MiLogStream::create(
      &v31,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "operator()",
      4035);
    v7 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(&v31, (const char (*)[17])"stacklimit item:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &item_param->item_id);
    v9 = common::milog::MiLogStream::operator<<<char [2],(char *[2])0>(v8, (const char (*)[2])" ");
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &item_param->count);
    v11 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v10, (const char (*)[10])" forceto ");
    val = stack_limit - cur_count;
    p_val = &val;
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &val);
    common::milog::MiLogStream::~MiLogStream(&v31);
    v12 = stack_limit - cur_count;
    v13 = *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000);
    LOBYTE(p_val) = v13 != 0;
    v15 = (v13 != 0) & (unsigned __int8)((char)((((_BYTE)item_param + 4) & 7) + 3) >= v13);
    if ( (_BYTE)v15 )
      __asan_report_store4(&item_param->count, p_val, v15);
    item_param->count = v12;
    return 0;
  }
};

// Line 4060: range 0000000017CDC440-0000000017CDC736
int32_t __cdecl PlayerItemComp::addItemBatchWithStackLimit(
        PlayerItemComp *const this,
        const std::vector<std::shared_ptr<Item>> *item_vec,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  std::vector<std::shared_ptr<Item>>::size_type v7; // rax
  const std::shared_ptr<Item> *v8; // rax
  bool v9; // r14
  int32_t v10; // r14d
  int32_t result; // eax
  std::vector<std::shared_ptr<Item>>::const_iterator __for_begin; // [rsp+28h] [rbp-F8h] BYREF
  std::vector<std::shared_ptr<Item>>::const_iterator __for_end; // [rsp+30h] [rbp-F0h] BYREF
  const std::vector<std::shared_ptr<Item>> *__for_range; // [rsp+38h] [rbp-E8h]
  std::shared_ptr<Item> p_item_ptr; // [rsp+40h] [rbp-E0h] BYREF
  char v18[208]; // [rsp+50h] [rbp-D0h] BYREF

  v4 = (unsigned __int64)v18;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(160LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 8 26 check_or_modify_count:4061 64 16 13 item_ptr:4097 96 24 22 modified_item_vec:4095";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addItemBatchWithStackLimit;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -218959360;
  v6[536862722] = -219021312;
  v6[536862723] = -218103808;
  v6[536862724] = -202116109;
  *(_QWORD *)(v4 + 32) = this;
  std::vector<std::shared_ptr<Item>>::vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 96));
  v7 = std::vector<std::shared_ptr<Item>>::size(item_vec);
  std::vector<std::shared_ptr<Item>>::reserve((std::vector<std::shared_ptr<Item>> *const)(v4 + 96), v7);
  __for_range = item_vec;
  __for_begin._M_current = std::vector<std::shared_ptr<Item>>::begin(item_vec)._M_current;
  __for_end._M_current = std::vector<std::shared_ptr<Item>>::end(item_vec)._M_current;
  while ( __gnu_cxx::operator!=<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>(
            &__for_begin,
            &__for_end) )
  {
    v8 = __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator*(&__for_begin);
    std::shared_ptr<Item>::shared_ptr((std::shared_ptr<Item> *const)(v4 + 64), v8);
    std::shared_ptr<Item>::shared_ptr(&p_item_ptr, (const std::shared_ptr<Item> *)(v4 + 64));
    v9 = PlayerItemComp::addItemBatchWithStackLimit(std::vector<std::shared_ptr<Item>> const&,ActionReason const&,std::vector*<AddItemResult,std::allocator<std::vector*>>)::{lambda(std::shared_ptr<Item>)#1}::operator()(
           (const PlayerItemComp::addItemBatchWithStackLimit::<lambda(ItemPtr)> *const)(v4 + 32),
           &p_item_ptr);
    std::shared_ptr<Item>::~shared_ptr(&p_item_ptr);
    if ( v9 )
      std::vector<std::shared_ptr<Item>>::push_back(
        (std::vector<std::shared_ptr<Item>> *const)(v4 + 96),
        (const std::vector<std::shared_ptr<Item>>::value_type *)(v4 + 64));
    std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v4 + 64));
    __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator++(&__for_begin);
  }
  if ( std::vector<std::shared_ptr<Item>>::empty((const std::vector<std::shared_ptr<Item>> *const)(v4 + 96)) )
    v10 = 0;
  else
    v10 = PlayerItemComp::addItemBatch(
            this,
            (const std::vector<std::shared_ptr<Item>> *)(v4 + 96),
            reason,
            result_vec_ptr);
  std::vector<std::shared_ptr<Item>>::~vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 96));
  result = v10;
  if ( v18 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 4061: range 0000000017CDBFDE-0000000017CDC43E
bool __cdecl PlayerItemComp::addItemBatchWithStackLimit(std::vector<std::shared_ptr<Item>> const&,ActionReason const&,std::vector*<AddItemResult,std::allocator<std::vector*>>)::{lambda(std::shared_ptr<Item>)#1}::operator()(
        const PlayerItemComp::addItemBatchWithStackLimit::<lambda(ItemPtr)> *const __closure,
        ItemPtr *p_item_ptr)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r13
  common::milog::MiLogStream *p_player; // rdi
  PlayerItemComp *this; // rax
  bool v7; // r14
  std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  PlayerItemComp *v9; // r14
  std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  uint32_t ItemId; // eax
  std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  unsigned __int64 v13; // rdx
  unsigned int v14; // eax
  Material *v15; // rcx
  bool result; // al
  unsigned int cur_count; // [rsp+10h] [rbp-A0h]
  uint32_t total_count; // [rsp+14h] [rbp-9Ch]
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+18h] [rbp-98h]
  common::milog::MiLogStream v21; // [rsp+20h] [rbp-90h] BYREF
  char v22[112]; // [rsp+40h] [rbp-70h] BYREF

  v2 = (unsigned __int64)v22;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 16 17 material_ptr:4068";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::addItemBatchWithStackLimit(std::vector<std::shared_ptr<Item>> const&,ActionReason const&,std::vector*<AddItemResult,std::allocator<std::vector*>>)::{lambda(std::shared_ptr<Item>)#1}::operator();
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202178560;
  if ( std::operator==<Item>(0LL, p_item_ptr) )
  {
    common::milog::MiLogStream::create(
      &v21,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "operator()",
      4065);
    p_player = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
                 &v21,
                 (const char (*)[26])"item_ptr is null, player:");
    if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
    {
      p_player = (common::milog::MiLogStream *)__closure;
      __asan_report_load8();
    }
    this = __closure->__this;
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__this->player_ >> 3) + 0x7FFF8000) )
    {
      p_player = (common::milog::MiLogStream *)&__closure->__this->player_;
      __asan_report_load8();
    }
    operator<<(p_player, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v21);
    v7 = 0;
  }
  else
  {
    std::dynamic_pointer_cast<Material,Item>((const std::shared_ptr<Item> *)(v2 + 32));
    if ( std::operator==<Material>(0LL, (const std::shared_ptr<Material> *)(v2 + 32)) )
    {
      v7 = 1;
    }
    else
    {
      v8 = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 32));
      material_config_ptr = Material::getMaterialConfig(v8);
      if ( !material_config_ptr )
        goto LABEL_16;
      if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&material_config_ptr->stack_limit);
      }
      if ( material_config_ptr->stack_limit )
      {
        if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v9 = __closure->__this;
        v10 = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 32));
        ItemId = Item::getItemId(v10);
        cur_count = PlayerItemComp::getPackMaterialCount(v9, ItemId);
        if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&material_config_ptr->stack_limit);
        }
        if ( cur_count < material_config_ptr->stack_limit )
        {
          v12 = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 32));
          if ( *(_BYTE *)(((unsigned __int64)v12 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v13 = (unsigned __int64)(v12->_vptr_Item + 8);
          if ( *(_BYTE *)((v13 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v14 = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v13)(v12);
          total_count = SAFE_ADD<unsigned int,unsigned int>(cur_count, v14);
          if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(&material_config_ptr->stack_limit);
          }
          if ( total_count > material_config_ptr->stack_limit )
          {
            v15 = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 32));
            if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
              && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
            {
              __asan_report_load4(&material_config_ptr->stack_limit);
            }
            Material::setCount(v15, material_config_ptr->stack_limit - cur_count);
          }
          v7 = 1;
        }
        else
        {
          v7 = 0;
        }
      }
      else
      {
LABEL_16:
        v7 = 1;
      }
    }
    std::shared_ptr<Material>::~shared_ptr((std::shared_ptr<Material> *const)(v2 + 32));
  }
  result = v7;
  if ( v22 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 4112: range 0000000017CDC738-0000000017CDC9E6
int32_t __cdecl PlayerItemComp::addItemBatch(
        PlayerItemComp *const this,
        const std::vector<data::IdCountConfig> *item_vec,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  _DWORD *v6; // r12
  uint32_t *p_count; // rax
  int32_t v8; // r14d
  int32_t result; // eax
  std::vector<data::IdCountConfig>::const_iterator __for_begin; // [rsp+20h] [rbp-C0h] BYREF
  std::vector<data::IdCountConfig>::const_iterator __for_end; // [rsp+28h] [rbp-B8h] BYREF
  const std::vector<data::IdCountConfig> *__for_range; // [rsp+30h] [rbp-B0h]
  const data::IdCountConfig *config; // [rsp+38h] [rbp-A8h]
  std::vector<ItemParam>::value_type __x; // [rsp+40h] [rbp-A0h] BYREF
  char v17[144]; // [rsp+50h] [rbp-90h] BYREF

  v4 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(96LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 24 19 item_param_vec:4113";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addItemBatch;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -218103808;
  v6[536862722] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 32));
  __for_range = item_vec;
  __for_begin._M_current = std::vector<data::IdCountConfig>::begin(item_vec)._M_current;
  __for_end._M_current = std::vector<data::IdCountConfig>::end(item_vec)._M_current;
  while ( __gnu_cxx::operator!=<data::IdCountConfig const*,std::vector<data::IdCountConfig>>(&__for_begin, &__for_end) )
  {
    config = __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator*(&__for_begin);
    p_count = &config->count;
    if ( *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)p_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(p_count);
    }
    if ( config->count )
    {
      if ( *(_BYTE *)(((unsigned __int64)&config->id >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&config->id >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&config->id);
      }
      __x.item_id = config->id;
      __x.count = config->count;
      __x.level = 0;
      __x.promote_level = 0;
      std::vector<ItemParam>::push_back((std::vector<ItemParam> *const)(v4 + 32), &__x);
    }
    __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator++(&__for_begin);
  }
  v8 = PlayerItemComp::addItemBatch(this, (const std::vector<ItemParam> *)(v4 + 32), reason, result_vec_ptr);
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 32));
  result = v8;
  if ( v17 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 4125: range 0000000017CDC9E8-0000000017CDD356
int32_t __cdecl PlayerItemComp::addItemBatch(
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  ItemExcelConfigMgr *p_item_config_mgr; // rcx
  common::milog::MiLogStream *v8; // r14
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  uint32_t count; // edi
  uint32_t Now; // ecx
  AddItemResult *M_current; // r15
  AddItemResult *v14; // r14
  bool *p_is_by_overflow_transform; // rax
  __int64 v16; // rsi
  __int64 v17; // rdx
  AddItemResult *v18; // r15
  AddItemResult *v19; // r14
  int32_t v20; // eax
  unsigned int val; // [rsp+34h] [rbp-22Ch] BYREF
  std::vector<ItemParam>::iterator __for_begin; // [rsp+38h] [rbp-228h] BYREF
  std::vector<ItemParam>::iterator __for_end; // [rsp+40h] [rbp-220h] BYREF
  std::vector<ItemParam> *__for_range; // [rsp+48h] [rbp-218h]
  std::vector<AddItemResult> *__for_range_0; // [rsp+50h] [rbp-210h]
  std::vector<AddItemResult> *__for_range_1; // [rsp+58h] [rbp-208h]
  AddItemResult *result_0; // [rsp+60h] [rbp-200h]
  AddItemResult *result; // [rsp+68h] [rbp-1F8h]
  const ItemParam *item_param; // [rsp+70h] [rbp-1F0h]
  const data::ItemConfig *item_config_ptr; // [rsp+78h] [rbp-1E8h]
  std::shared_ptr<Config> v34; // [rsp+80h] [rbp-1E0h] BYREF
  std::vector<ItemParam> __x; // [rsp+90h] [rbp-1D0h] BYREF
  common::milog::MiLogStream v36; // [rsp+B0h] [rbp-1B0h] BYREF
  char v37[400]; // [rsp+D0h] [rbp-190h] BYREF

  v4 = (unsigned __int64)v37;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_3(352LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "5 32 24 23 cur_item_param_vec:4126 96 24 20 temp_result_vec:4127 160 24 30 item_param_vec_no_vir"
                        "tual:4130 224 24 15 result_vec:4150 288 24 11 id_vec:4152";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addItemBatch;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234881024;
  v6[536862722] = -218959118;
  v6[536862723] = -234881024;
  v6[536862724] = -218959118;
  v6[536862725] = -234881024;
  v6[536862726] = -218959118;
  v6[536862727] = -234881024;
  v6[536862728] = -218959118;
  v6[536862729] = -218103808;
  v6[536862730] = -202116109;
  PlayerItemComp::checkOutputLimitAndModifyItemParams<ItemParam>(
    (std::vector<ItemParam> *)(v4 + 32),
    this,
    item_param_vec,
    reason);
  std::vector<AddItemResult>::vector((std::vector<AddItemResult> *const)(v4 + 96));
  PlayerItemComp::autoUseItemBatch(
    &__x,
    this,
    (const std::vector<ItemParam> *)(v4 + 32),
    (std::vector<AddItemResult> *)(v4 + 96),
    reason);
  std::vector<ItemParam>::operator=((std::vector<ItemParam> *const)(v4 + 32), &__x);
  std::vector<ItemParam>::~vector(&__x);
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 160));
  __for_range = (std::vector<ItemParam> *)(v4 + 32);
  __for_begin._M_current = std::vector<ItemParam>::begin((std::vector<ItemParam> *const)(v4 + 32))._M_current;
  __for_end._M_current = std::vector<ItemParam>::end((std::vector<ItemParam> *const)(v4 + 32))._M_current;
  while ( __gnu_cxx::operator!=<ItemParam *,std::vector<ItemParam>>(&__for_begin, &__for_end) )
  {
    item_param = __gnu_cxx::__normal_iterator<ItemParam *,std::vector<ItemParam>>::operator*(&__for_begin);
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v34);
    p_item_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v34)->design_config.txt_config_mgr.item_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_param);
    }
    item_config_ptr = ItemExcelConfigMgr::findItemConfig(p_item_config_mgr, item_param->item_id);
    std::shared_ptr<Config>::~shared_ptr(&v34);
    if ( item_config_ptr )
    {
      if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                       + 0x7FFF8000) )
      {
        __asan_report_load4(&item_config_ptr->item_type);
      }
      if ( item_config_ptr->item_type == ITEM_VIRTUAL )
      {
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        count = item_param->count;
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          count = (unsigned int)item_param;
          __asan_report_load4(item_param);
        }
        PlayerItemComp::addVirtualItem(
          this,
          item_param->item_id,
          count,
          (ActionReason *)reason,
          (std::vector<AddItemResult> *)(v4 + 96));
      }
      else
      {
        std::vector<ItemParam>::emplace_back<ItemParam const&>(
          (std::vector<ItemParam> *const)(v4 + 160),
          item_param,
          item_param);
      }
    }
    else
    {
      common::milog::MiLogStream::create(
        &v36,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "addItemBatch",
        4136);
      v8 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
             &v36,
             (const char (*)[28])"findItemConfig failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, &val);
      v10 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v9, (const char (*)[10])" item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v36);
    }
    __gnu_cxx::__normal_iterator<ItemParam *,std::vector<ItemParam>>::operator++(&__for_begin);
  }
  PackItemStore::addItemBatch(
    (std::vector<AddItemResult> *)(v4 + 224),
    &this->pack_store_,
    (const std::vector<ItemParam> *)(v4 + 160),
    reason);
  std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v4 + 288));
  __for_range_0 = (std::vector<AddItemResult> *)(v4 + 224);
  __for_begin._M_current = (ItemParam *)std::vector<AddItemResult>::begin((std::vector<AddItemResult> *const)(v4 + 224))._M_current;
  __for_end._M_current = (ItemParam *)std::vector<AddItemResult>::end(__for_range_0)._M_current;
  while ( __gnu_cxx::operator!=<AddItemResult *,std::vector<AddItemResult>>(
            (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_begin,
            (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_end) )
  {
    result = __gnu_cxx::__normal_iterator<AddItemResult *,std::vector<AddItemResult>>::operator*((const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *const)&__for_begin);
    std::vector<unsigned int>::emplace_back<unsigned int &>(
      (std::vector<unsigned int> *const)(v4 + 288),
      &result->item_id,
      &result->item_id);
    __gnu_cxx::__normal_iterator<AddItemResult *,std::vector<AddItemResult>>::operator++((__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *const)&__for_begin);
  }
  Now = common::tools::TimeUtils::getNow();
  PlayerItemComp::checkMaterialDelete(this, Now, (const std::vector<unsigned int> *)(v4 + 288));
  M_current = std::vector<AddItemResult>::end((std::vector<AddItemResult> *const)(v4 + 96))._M_current;
  v14 = std::vector<AddItemResult>::begin((std::vector<AddItemResult> *const)(v4 + 96))._M_current;
  __for_begin._M_current = (ItemParam *)std::vector<AddItemResult>::end((std::vector<AddItemResult> *const)(v4 + 224))._M_current;
  __gnu_cxx::__normal_iterator<AddItemResult const*,std::vector<AddItemResult>>::__normal_iterator<AddItemResult*>(
    (__gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *const)&__for_end,
    (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_begin);
  std::vector<AddItemResult>::insert<__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult>>,void>(
    (std::vector<AddItemResult> *const)(v4 + 224),
    (std::vector<AddItemResult>::const_iterator)__for_end._M_current,
    (__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> >)v14,
    (__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> >)M_current);
  PlayerItemComp::processByAddItemResultVec(this, (const std::vector<AddItemResult> *)(v4 + 224));
  if ( *(_BYTE *)(((unsigned __int64)&reason->is_by_overflow_transform >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)reason + 21) & 7) >= *(_BYTE *)(((unsigned __int64)&reason->is_by_overflow_transform >> 3)
                                                        + 0x7FFF8000) )
  {
    __asan_report_load1(&reason->is_by_overflow_transform);
  }
  if ( reason->is_by_overflow_transform )
  {
    __for_range_1 = (std::vector<AddItemResult> *)(v4 + 224);
    __for_begin._M_current = (ItemParam *)std::vector<AddItemResult>::begin((std::vector<AddItemResult> *const)(v4 + 224))._M_current;
    __for_end._M_current = (ItemParam *)std::vector<AddItemResult>::end(__for_range_1)._M_current;
    while ( __gnu_cxx::operator!=<AddItemResult *,std::vector<AddItemResult>>(
              (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_begin,
              (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_end) )
    {
      result_0 = __gnu_cxx::__normal_iterator<AddItemResult *,std::vector<AddItemResult>>::operator*((const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *const)&__for_begin);
      p_is_by_overflow_transform = &result_0->is_by_overflow_transform;
      v16 = ((_BYTE)result_0 + 21) & 7;
      v17 = (*(_BYTE *)(((unsigned __int64)p_is_by_overflow_transform >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)v16 >= *(_BYTE *)(((unsigned __int64)p_is_by_overflow_transform >> 3) + 0x7FFF8000));
      if ( (_BYTE)v17 )
        __asan_report_store1(p_is_by_overflow_transform, v16, v17);
      result_0->is_by_overflow_transform = 1;
      __gnu_cxx::__normal_iterator<AddItemResult *,std::vector<AddItemResult>>::operator++((__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *const)&__for_begin);
    }
  }
  else
  {
    PlayerItemComp::triggerItemAddEvent(this, (const std::vector<AddItemResult> *)(v4 + 224), 1, reason);
  }
  if ( result_vec_ptr )
  {
    v18 = std::vector<AddItemResult>::end((std::vector<AddItemResult> *const)(v4 + 224))._M_current;
    v19 = std::vector<AddItemResult>::begin((std::vector<AddItemResult> *const)(v4 + 224))._M_current;
    __for_begin._M_current = (ItemParam *)std::vector<AddItemResult>::end(result_vec_ptr)._M_current;
    __gnu_cxx::__normal_iterator<AddItemResult const*,std::vector<AddItemResult>>::__normal_iterator<AddItemResult*>(
      (__gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *const)&__for_end,
      (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_begin);
    std::vector<AddItemResult>::insert<__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult>>,void>(
      result_vec_ptr,
      (std::vector<AddItemResult>::const_iterator)__for_end._M_current,
      (__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> >)v19,
      (__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> >)v18);
  }
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v4 + 288));
  std::vector<AddItemResult>::~vector((std::vector<AddItemResult> *const)(v4 + 224));
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 160));
  std::vector<AddItemResult>::~vector((std::vector<AddItemResult> *const)(v4 + 96));
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 32));
  v20 = 0;
  if ( v37 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8028) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8028) = -168430091;
  }
  return v20;
};

// Line 4186: range 0000000017CDD358-0000000017CDD59C
int32_t __cdecl PlayerItemComp::checkAddItem(
        PlayerItemComp *const this,
        ItemPtr *p_item_ptr,
        const ActionReason *reason)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  std::shared_ptr<Item> *i; // r13
  int32_t v7; // r13d
  int32_t result; // eax
  std::allocator<std::shared_ptr<Item> > __a; // [rsp+3Fh] [rbp-A1h] BYREF
  std::shared_ptr<Item> v11; // [rsp+40h] [rbp-A0h] BYREF
  char v12[144]; // [rsp+50h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v12;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 24 13 item_vec:4187";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkAddItem;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  std::shared_ptr<Item>::shared_ptr(&v11, p_item_ptr);
  std::allocator<std::shared_ptr<Item>>::allocator(&__a);
  std::vector<std::shared_ptr<Item>>::vector(
    (std::vector<std::shared_ptr<Item>> *const)(v3 + 32),
    (std::initializer_list<std::shared_ptr<Item> >)__PAIR128__(1LL, &v11),
    &__a);
  std::allocator<std::shared_ptr<Item>>::~allocator(&__a);
  for ( i = (std::shared_ptr<Item> *)v12; i != &v11; std::shared_ptr<Item>::~shared_ptr(i) )
    --i;
  v7 = PlayerItemComp::checkAddItemBatch(this, (const std::vector<std::shared_ptr<Item>> *)(v3 + 32), reason);
  std::vector<std::shared_ptr<Item>>::~vector((std::vector<std::shared_ptr<Item>> *const)(v3 + 32));
  result = v7;
  if ( v12 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 4192: range 0000000017CDD59E-0000000017CDDD7D
int32_t __cdecl PlayerItemComp::checkAddItemBatch(
        PlayerItemComp *const this,
        const std::vector<std::shared_ptr<Item>> *item_vec,
        const ActionReason *reason)
{
  unsigned __int64 v3; // r12
  __int64 v4; // rax
  _DWORD *v5; // r13
  common::milog::MiLogStream *v6; // rbx
  int32_t v7; // r14d
  common::milog::MiLogStream *v8; // r14
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rcx
  common::milog::MiLogStream *v11; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  __int64 Guid; // rax
  bool v14; // r14
  common::milog::MiLogStream *v15; // r14
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v21; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v22; // rax
  unsigned __int64 v23; // rdx
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v24; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v25; // rax
  unsigned __int64 v26; // rdx
  int32_t result; // eax
  unsigned int v29; // [rsp+28h] [rbp-108h] BYREF
  unsigned int Uid; // [rsp+2Ch] [rbp-104h] BYREF
  int32_t ret; // [rsp+30h] [rbp-100h]
  int32_t ret_0; // [rsp+34h] [rbp-FCh]
  std::vector<std::shared_ptr<Item>>::const_iterator __for_begin; // [rsp+38h] [rbp-F8h] BYREF
  std::vector<std::shared_ptr<Item>>::const_iterator __for_end; // [rsp+40h] [rbp-F0h] BYREF
  unsigned __int64 val; // [rsp+48h] [rbp-E8h] BYREF
  const std::vector<std::shared_ptr<Item>> *__for_range; // [rsp+50h] [rbp-E0h]
  const std::shared_ptr<Item> *item_ptr; // [rsp+58h] [rbp-D8h]
  common::milog::MiLogStream v38; // [rsp+60h] [rbp-D0h] BYREF
  char v39[176]; // [rsp+80h] [rbp-B0h] BYREF

  v3 = (unsigned __int64)v39;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(128LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "2 32 16 10 param:4224 64 24 24 item_vec_no_virtual:4206";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkAddItemBatch;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -219021312;
  v5[536862722] = -218103808;
  v5[536862723] = -202116109;
  if ( std::vector<std::shared_ptr<Item>>::size(item_vec) )
  {
    ret = PlayerItemComp::checkOutputLimitBeforeCheckAddItemBatch<std::shared_ptr<Item>>(this, item_vec, reason);
    if ( ret )
    {
      common::milog::MiLogStream::create(
        &v38,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddItemBatch",
        4202);
      v8 = common::milog::MiLogStream::operator<<<char [56],(char *[56])0>(
             &v38,
             (const char (*)[56])"checkOutputLimitBeforeCheckAddItemBatch fail, item_vec:");
      PlayerItemComp::getItemParamVec((std::vector<ItemParam> *)(v3 + 64), this, item_vec);
      v9 = common::milog::MiLogStream::operator<<<ItemParam>(v8, (const std::vector<ItemParam> *)(v3 + 64));
      v10 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v9, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v10, this->player_);
      std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 64));
      common::milog::MiLogStream::~MiLogStream(&v38);
      v7 = ret;
    }
    else
    {
      std::vector<std::shared_ptr<Item>>::vector((std::vector<std::shared_ptr<Item>> *const)(v3 + 64));
      __for_range = item_vec;
      __for_begin._M_current = std::vector<std::shared_ptr<Item>>::begin(item_vec)._M_current;
      __for_end._M_current = std::vector<std::shared_ptr<Item>>::end(item_vec)._M_current;
      while ( 1 )
      {
        if ( !__gnu_cxx::operator!=<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>(
                &__for_begin,
                &__for_end) )
        {
          v7 = PackItemStore::checkAddItemBatch(
                 &this->pack_store_,
                 (const std::vector<std::shared_ptr<Item>> *)(v3 + 64),
                 reason);
          goto LABEL_34;
        }
        item_ptr = __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator*(&__for_begin);
        if ( std::operator==<Item>(item_ptr, 0LL) )
        {
          common::milog::MiLogStream::create(
            &v38,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkAddItemBatch",
            4212);
          v11 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
                  &v38,
                  (const char (*)[26])"item_ptr is nullptr, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          Uid = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &Uid);
          common::milog::MiLogStream::~MiLogStream(&v38);
          v7 = -1;
          goto LABEL_34;
        }
        v12 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
        Guid = Item::getGuid(v12);
        ItemStore::findItem((ItemStore *const)(v3 + 32), (uint64_t)&this->pack_store_, Guid);
        v14 = std::operator!=<Item>((const std::shared_ptr<Item> *)(v3 + 32), 0LL);
        std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v3 + 32));
        if ( v14 )
          break;
        v22 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
        if ( *(_BYTE *)(((unsigned __int64)v22 >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v23 = (unsigned __int64)(v22->_vptr_Item + 9);
        if ( *(_BYTE *)((v23 >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        if ( (*(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v23)(v22) == 1 )
        {
          *(_QWORD *)(v3 + 32) = 0LL;
          *(_QWORD *)(v3 + 40) = 0LL;
          v24 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
          *(_DWORD *)(v3 + 32) = Item::getItemId(v24);
          v25 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
          if ( *(_BYTE *)(((unsigned __int64)v25 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v26 = (unsigned __int64)(v25->_vptr_Item + 8);
          if ( *(_BYTE *)((v26 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          *(_DWORD *)(v3 + 36) = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v26)(v25);
          ret_0 = PlayerItemComp::checkAddVirtualItem(this, (const ItemParam *)(v3 + 32), reason);
          if ( ret_0 )
          {
            v7 = ret_0;
            goto LABEL_34;
          }
        }
        else
        {
          std::vector<std::shared_ptr<Item>>::emplace_back<std::shared_ptr<Item> const&>(
            (std::vector<std::shared_ptr<Item>> *const)(v3 + 64),
            item_ptr,
            item_ptr);
        }
        __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator++(&__for_begin);
      }
      common::milog::MiLogStream::create(
        &v38,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddItemBatch",
        4218);
      v15 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
              &v38,
              (const char (*)[28])"item_ptr aleady exist, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v29 = Player::getUid(this->player_);
      v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, &v29);
      v17 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v16, (const char (*)[10])" item_id:");
      v18 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
      Uid = Item::getItemId(v18);
      v19 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, &Uid);
      v20 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v19, (const char (*)[7])" guid:");
      v21 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
      val = Item::getGuid(v21);
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v20, &val);
      common::milog::MiLogStream::~MiLogStream(&v38);
      v7 = -1;
LABEL_34:
      std::vector<std::shared_ptr<Item>>::~vector((std::vector<std::shared_ptr<Item>> *const)(v3 + 64));
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v38,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkAddItemBatch",
      4195);
    v6 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
           &v38,
           (const char (*)[24])"item_vec is empty, uid:");
    val = std::vector<std::shared_ptr<Item>>::size(item_vec);
    common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v6, &val);
    common::milog::MiLogStream::~MiLogStream(&v38);
    v7 = -1;
  }
  result = v7;
  if ( v39 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 4240: range 0000000017CDDD7E-0000000017CDDFCD
int32_t __cdecl PlayerItemComp::addItem(
        PlayerItemComp *const this,
        ItemPtr *p_item_ptr,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  _DWORD *v6; // r12
  std::shared_ptr<Item> *i; // r13
  int32_t v8; // r13d
  int32_t result; // eax
  std::allocator<std::shared_ptr<Item> > __a; // [rsp+3Fh] [rbp-A1h] BYREF
  std::shared_ptr<Item> v13; // [rsp+40h] [rbp-A0h] BYREF
  char v14[144]; // [rsp+50h] [rbp-90h] BYREF

  v4 = (unsigned __int64)v14;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(96LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 24 13 item_vec:4241";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addItem;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -218103808;
  v6[536862722] = -202116109;
  std::shared_ptr<Item>::shared_ptr(&v13, p_item_ptr);
  std::allocator<std::shared_ptr<Item>>::allocator(&__a);
  std::vector<std::shared_ptr<Item>>::vector(
    (std::vector<std::shared_ptr<Item>> *const)(v4 + 32),
    (std::initializer_list<std::shared_ptr<Item> >)__PAIR128__(1LL, &v13),
    &__a);
  std::allocator<std::shared_ptr<Item>>::~allocator(&__a);
  for ( i = (std::shared_ptr<Item> *)v14; i != &v13; std::shared_ptr<Item>::~shared_ptr(i) )
    --i;
  v8 = PlayerItemComp::addItemBatch(this, (const std::vector<std::shared_ptr<Item>> *)(v4 + 32), reason, result_vec_ptr);
  std::vector<std::shared_ptr<Item>>::~vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 32));
  result = v8;
  if ( v14 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 4246: range 0000000017CDDFCE-0000000017CDE9FC
int32_t __cdecl PlayerItemComp::addItemBatch(
        PlayerItemComp *const this,
        const std::vector<std::shared_ptr<Item>> *item_vec,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  common::milog::MiLogStream *v7; // r14
  ItemExcelConfigMgr *p_item_config_mgr; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  uint32_t ItemId; // eax
  common::milog::MiLogStream *v11; // r14
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v14; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v15; // rax
  unsigned __int64 v16; // rdx
  uint32_t v17; // r14d
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v18; // rax
  uint32_t v19; // esi
  uint32_t Now; // ecx
  AddItemResult *M_current; // r15
  AddItemResult *v22; // r14
  bool *p_is_by_overflow_transform; // rax
  __int64 v24; // rsi
  __int64 v25; // rdx
  AddItemResult *v26; // r15
  AddItemResult *v27; // r14
  int32_t v28; // eax
  unsigned int Uid; // [rsp+30h] [rbp-230h] BYREF
  unsigned int val; // [rsp+34h] [rbp-22Ch] BYREF
  std::vector<std::shared_ptr<Item>>::iterator __for_begin; // [rsp+38h] [rbp-228h] BYREF
  std::vector<std::shared_ptr<Item>>::iterator __for_end; // [rsp+40h] [rbp-220h] BYREF
  std::vector<std::shared_ptr<Item>> *__for_range; // [rsp+48h] [rbp-218h]
  std::vector<AddItemResult> *__for_range_0; // [rsp+50h] [rbp-210h]
  std::vector<AddItemResult> *__for_range_1; // [rsp+58h] [rbp-208h]
  AddItemResult *result_0; // [rsp+60h] [rbp-200h]
  AddItemResult *result; // [rsp+68h] [rbp-1F8h]
  const std::shared_ptr<Item> *item_ptr; // [rsp+70h] [rbp-1F0h]
  const data::ItemConfig *item_config_ptr; // [rsp+78h] [rbp-1E8h]
  std::shared_ptr<Config> v42; // [rsp+80h] [rbp-1E0h] BYREF
  std::vector<std::shared_ptr<Item>> __x; // [rsp+90h] [rbp-1D0h] BYREF
  common::milog::MiLogStream v44; // [rsp+B0h] [rbp-1B0h] BYREF
  char v45[400]; // [rsp+D0h] [rbp-190h] BYREF

  v4 = (unsigned __int64)v45;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_3(352LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "5 32 24 17 cur_item_vec:4247 96 24 20 temp_result_vec:4248 160 24 24 item_vec_no_virtual:4251 22"
                        "4 24 15 result_vec:4277 288 24 11 id_vec:4279";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addItemBatch;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234881024;
  v6[536862722] = -218959118;
  v6[536862723] = -234881024;
  v6[536862724] = -218959118;
  v6[536862725] = -234881024;
  v6[536862726] = -218959118;
  v6[536862727] = -234881024;
  v6[536862728] = -218959118;
  v6[536862729] = -218103808;
  v6[536862730] = -202116109;
  PlayerItemComp::checkOutputLimitAndModifyItemParams<std::shared_ptr<Item>>(
    (std::vector<std::shared_ptr<Item>> *)(v4 + 32),
    this,
    item_vec,
    reason);
  std::vector<AddItemResult>::vector((std::vector<AddItemResult> *const)(v4 + 96));
  PlayerItemComp::autoUseItemBatch(
    &__x,
    this,
    (const std::vector<std::shared_ptr<Item>> *)(v4 + 32),
    (std::vector<AddItemResult> *)(v4 + 96),
    reason);
  std::vector<std::shared_ptr<Item>>::operator=((std::vector<std::shared_ptr<Item>> *const)(v4 + 32), &__x);
  std::vector<std::shared_ptr<Item>>::~vector(&__x);
  std::vector<std::shared_ptr<Item>>::vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 160));
  __for_range = (std::vector<std::shared_ptr<Item>> *)(v4 + 32);
  __for_begin._M_current = std::vector<std::shared_ptr<Item>>::begin((std::vector<std::shared_ptr<Item>> *const)(v4 + 32))._M_current;
  __for_end._M_current = std::vector<std::shared_ptr<Item>>::end((std::vector<std::shared_ptr<Item>> *const)(v4 + 32))._M_current;
  while ( __gnu_cxx::operator!=<std::shared_ptr<Item> *,std::vector<std::shared_ptr<Item>>>(&__for_begin, &__for_end) )
  {
    item_ptr = __gnu_cxx::__normal_iterator<std::shared_ptr<Item> *,std::vector<std::shared_ptr<Item>>>::operator*(&__for_begin);
    if ( std::operator==<Item>(item_ptr, 0LL) )
    {
      common::milog::MiLogStream::create(
        &v44,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "addItemBatch",
        4256);
      v7 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
             &v44,
             (const char (*)[26])"item_ptr is nullptr, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &val);
      common::milog::MiLogStream::~MiLogStream(&v44);
    }
    else
    {
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v42);
      p_item_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v42)->design_config.txt_config_mgr.item_config_mgr;
      v9 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
      ItemId = Item::getItemId(v9);
      item_config_ptr = ItemExcelConfigMgr::findItemConfig(p_item_config_mgr, ItemId);
      std::shared_ptr<Config>::~shared_ptr(&v42);
      if ( item_config_ptr )
      {
        if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                         + 0x7FFF8000) )
        {
          __asan_report_load4(&item_config_ptr->item_type);
        }
        if ( item_config_ptr->item_type == ITEM_VIRTUAL )
        {
          v15 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
          if ( *(_BYTE *)(((unsigned __int64)v15 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v16 = (unsigned __int64)(v15->_vptr_Item + 8);
          if ( *(_BYTE *)((v16 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v17 = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v16)(v15);
          v18 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
          v19 = Item::getItemId(v18);
          PlayerItemComp::addVirtualItem(
            this,
            v19,
            v17,
            (ActionReason *)reason,
            (std::vector<AddItemResult> *)(v4 + 96));
        }
        else
        {
          std::vector<std::shared_ptr<Item>>::emplace_back<std::shared_ptr<Item> const&>(
            (std::vector<std::shared_ptr<Item>> *const)(v4 + 160),
            item_ptr,
            item_ptr);
        }
      }
      else
      {
        common::milog::MiLogStream::create(
          &v44,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addItemBatch",
          4263);
        v11 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
                &v44,
                (const char (*)[28])"findItemConfig failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Uid = Player::getUid(this->player_);
        v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &Uid);
        v13 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v12, (const char (*)[10])" item_id:");
        v14 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
        val = Item::getItemId(v14);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, &val);
        common::milog::MiLogStream::~MiLogStream(&v44);
      }
    }
    __gnu_cxx::__normal_iterator<std::shared_ptr<Item> *,std::vector<std::shared_ptr<Item>>>::operator++(&__for_begin);
  }
  PackItemStore::addItemBatch(
    (std::vector<AddItemResult> *)(v4 + 224),
    &this->pack_store_,
    (const std::vector<std::shared_ptr<Item>> *)(v4 + 160),
    reason);
  std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v4 + 288));
  __for_range_0 = (std::vector<AddItemResult> *)(v4 + 224);
  __for_begin._M_current = (std::shared_ptr<Item> *)std::vector<AddItemResult>::begin((std::vector<AddItemResult> *const)(v4 + 224))._M_current;
  __for_end._M_current = (std::shared_ptr<Item> *)std::vector<AddItemResult>::end(__for_range_0)._M_current;
  while ( __gnu_cxx::operator!=<AddItemResult *,std::vector<AddItemResult>>(
            (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_begin,
            (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_end) )
  {
    result = __gnu_cxx::__normal_iterator<AddItemResult *,std::vector<AddItemResult>>::operator*((const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *const)&__for_begin);
    std::vector<unsigned int>::emplace_back<unsigned int &>(
      (std::vector<unsigned int> *const)(v4 + 288),
      &result->item_id,
      &result->item_id);
    __gnu_cxx::__normal_iterator<AddItemResult *,std::vector<AddItemResult>>::operator++((__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *const)&__for_begin);
  }
  Now = common::tools::TimeUtils::getNow();
  PlayerItemComp::checkMaterialDelete(this, Now, (const std::vector<unsigned int> *)(v4 + 288));
  M_current = std::vector<AddItemResult>::end((std::vector<AddItemResult> *const)(v4 + 96))._M_current;
  v22 = std::vector<AddItemResult>::begin((std::vector<AddItemResult> *const)(v4 + 96))._M_current;
  __for_begin._M_current = (std::shared_ptr<Item> *)std::vector<AddItemResult>::end((std::vector<AddItemResult> *const)(v4 + 224))._M_current;
  __gnu_cxx::__normal_iterator<AddItemResult const*,std::vector<AddItemResult>>::__normal_iterator<AddItemResult*>(
    (__gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *const)&__for_end,
    (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_begin);
  std::vector<AddItemResult>::insert<__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult>>,void>(
    (std::vector<AddItemResult> *const)(v4 + 224),
    (std::vector<AddItemResult>::const_iterator)__for_end._M_current,
    (__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> >)v22,
    (__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> >)M_current);
  PlayerItemComp::processByAddItemResultVec(this, (const std::vector<AddItemResult> *)(v4 + 224));
  if ( *(_BYTE *)(((unsigned __int64)&reason->is_by_overflow_transform >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)reason + 21) & 7) >= *(_BYTE *)(((unsigned __int64)&reason->is_by_overflow_transform >> 3)
                                                        + 0x7FFF8000) )
  {
    __asan_report_load1(&reason->is_by_overflow_transform);
  }
  if ( reason->is_by_overflow_transform )
  {
    __for_range_1 = (std::vector<AddItemResult> *)(v4 + 224);
    __for_begin._M_current = (std::shared_ptr<Item> *)std::vector<AddItemResult>::begin((std::vector<AddItemResult> *const)(v4 + 224))._M_current;
    __for_end._M_current = (std::shared_ptr<Item> *)std::vector<AddItemResult>::end(__for_range_1)._M_current;
    while ( __gnu_cxx::operator!=<AddItemResult *,std::vector<AddItemResult>>(
              (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_begin,
              (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_end) )
    {
      result_0 = __gnu_cxx::__normal_iterator<AddItemResult *,std::vector<AddItemResult>>::operator*((const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *const)&__for_begin);
      p_is_by_overflow_transform = &result_0->is_by_overflow_transform;
      v24 = ((_BYTE)result_0 + 21) & 7;
      v25 = (*(_BYTE *)(((unsigned __int64)p_is_by_overflow_transform >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)v24 >= *(_BYTE *)(((unsigned __int64)p_is_by_overflow_transform >> 3) + 0x7FFF8000));
      if ( (_BYTE)v25 )
        __asan_report_store1(p_is_by_overflow_transform, v24, v25);
      result_0->is_by_overflow_transform = 1;
      __gnu_cxx::__normal_iterator<AddItemResult *,std::vector<AddItemResult>>::operator++((__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *const)&__for_begin);
    }
  }
  else
  {
    PlayerItemComp::triggerItemAddEvent(this, (const std::vector<AddItemResult> *)(v4 + 224), 1, reason);
  }
  if ( result_vec_ptr )
  {
    v26 = std::vector<AddItemResult>::end((std::vector<AddItemResult> *const)(v4 + 224))._M_current;
    v27 = std::vector<AddItemResult>::begin((std::vector<AddItemResult> *const)(v4 + 224))._M_current;
    __for_begin._M_current = (std::shared_ptr<Item> *)std::vector<AddItemResult>::end(result_vec_ptr)._M_current;
    __gnu_cxx::__normal_iterator<AddItemResult const*,std::vector<AddItemResult>>::__normal_iterator<AddItemResult*>(
      (__gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *const)&__for_end,
      (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_begin);
    std::vector<AddItemResult>::insert<__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult>>,void>(
      result_vec_ptr,
      (std::vector<AddItemResult>::const_iterator)__for_end._M_current,
      (__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> >)v27,
      (__gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> >)v26);
  }
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v4 + 288));
  std::vector<AddItemResult>::~vector((std::vector<AddItemResult> *const)(v4 + 224));
  std::vector<std::shared_ptr<Item>>::~vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 160));
  std::vector<AddItemResult>::~vector((std::vector<AddItemResult> *const)(v4 + 96));
  std::vector<std::shared_ptr<Item>>::~vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 32));
  v28 = 0;
  if ( v45 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8028) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8028) = -168430091;
  }
  return v28;
};

// Line 4312: range 0000000017CDE9FE-0000000017CDEC39
int32_t __cdecl PlayerItemComp::checkSubItem(PlayerItemComp *const this, const ItemParam *item_param)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  _DWORD *v4; // r12
  std::initializer_list<ItemParam>::size_type v5; // rdx
  int32_t v6; // r14d
  int32_t result; // eax
  std::allocator<ItemParam> __a; // [rsp+2Fh] [rbp-A1h] BYREF
  std::initializer_list<ItemParam> __l; // [rsp+30h] [rbp-A0h] BYREF
  char v10[144]; // [rsp+40h] [rbp-90h] BYREF

  v2 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(96LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 24 19 item_param_vec:4313";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkSubItem;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -218103808;
  v4[536862722] = -202116109;
  if ( ((unsigned __int8)item_param & 7) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000)
    && *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    || *(_BYTE *)((((unsigned __int64)&item_param->promote_level + 3) >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)item_param + 15) & 7) >= *(_BYTE *)((((unsigned __int64)&item_param->promote_level + 3) >> 3)
                                                            + 0x7FFF8000) )
  {
    __asan_report_load_n(item_param, 16LL);
  }
  v5 = *(_QWORD *)&item_param->level;
  __l._M_array = *(std::initializer_list<ItemParam>::iterator *)&item_param->item_id;
  __l._M_len = v5;
  std::allocator<ItemParam>::allocator(&__a);
  std::vector<ItemParam>::vector(
    (std::vector<ItemParam> *const)(v2 + 32),
    (std::initializer_list<ItemParam>)__PAIR128__(1LL, &__l),
    &__a);
  std::allocator<ItemParam>::~allocator(&__a);
  v6 = PlayerItemComp::checkSubItemBatch(this, (const std::vector<ItemParam> *)(v2 + 32));
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v2 + 32));
  result = v6;
  if ( v10 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 4318: range 0000000017CDEC3A-0000000017CDF0BF
int32_t __cdecl PlayerItemComp::checkSubItemBatch(
        PlayerItemComp *const this,
        const std::vector<data::IdCountConfig> *item_vec)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  _DWORD *v4; // r12
  common::milog::MiLogStream *v5; // rcx
  int32_t v6; // r14d
  uint32_t *p_count; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rcx
  int32_t result; // eax
  std::vector<data::IdCountConfig>::const_iterator __for_begin; // [rsp+10h] [rbp-E0h] BYREF
  std::vector<data::IdCountConfig>::const_iterator __for_end; // [rsp+18h] [rbp-D8h] BYREF
  const std::vector<data::IdCountConfig> *__for_range; // [rsp+20h] [rbp-D0h]
  const data::IdCountConfig *config; // [rsp+28h] [rbp-C8h]
  std::vector<ItemParam>::value_type __x; // [rsp+30h] [rbp-C0h] BYREF
  common::milog::MiLogStream v17; // [rsp+40h] [rbp-B0h] BYREF
  char v18[144]; // [rsp+60h] [rbp-90h] BYREF

  v2 = (unsigned __int64)v18;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(96LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 24 19 item_param_vec:4324";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkSubItemBatch;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -218103808;
  v4[536862722] = -202116109;
  if ( std::vector<data::IdCountConfig>::empty(item_vec) )
  {
    common::milog::MiLogStream::create(
      &v17,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkSubItemBatch",
      4321);
    v5 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
           &v17,
           (const char (*)[27])"item_vec is empty, player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v5, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v17);
    v6 = -1;
  }
  else
  {
    std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v2 + 32));
    __for_range = item_vec;
    __for_begin._M_current = std::vector<data::IdCountConfig>::begin(item_vec)._M_current;
    __for_end._M_current = std::vector<data::IdCountConfig>::end(item_vec)._M_current;
    while ( 1 )
    {
      if ( !__gnu_cxx::operator!=<data::IdCountConfig const*,std::vector<data::IdCountConfig>>(&__for_begin, &__for_end) )
      {
        v6 = PlayerItemComp::checkSubItemBatch(this, (const std::vector<ItemParam> *)(v2 + 32));
        goto LABEL_22;
      }
      config = __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator*(&__for_begin);
      p_count = &config->count;
      if ( *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)p_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(p_count);
      }
      if ( !config->count )
        break;
      if ( *(_BYTE *)(((unsigned __int64)&config->id >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&config->id >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&config->id);
      }
      __x.item_id = config->id;
      if ( *(_BYTE *)(((unsigned __int64)&config->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)config + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&config->count >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&config->count);
      }
      __x.count = config->count;
      __x.level = 0;
      __x.promote_level = 0;
      std::vector<ItemParam>::push_back((std::vector<ItemParam> *const)(v2 + 32), &__x);
      __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator++(&__for_begin);
    }
    common::milog::MiLogStream::create(
      &v17,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkSubItemBatch",
      4329);
    v8 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
           &v17,
           (const char (*)[26])"item_count is 0, item_id:");
    v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, &config->id);
    v10 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v9, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v10, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v17);
    v6 = -1;
LABEL_22:
    std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v2 + 32));
  }
  result = v6;
  if ( v18 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 4338: range 0000000017CDF0C0-0000000017CE4971
int32_t __cdecl PlayerItemComp::checkSubItemBatch(
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec)
{
  int32_t v2; // r12d
  unsigned __int64 v3; // r14
  __int64 v4; // rax
  _DWORD *v5; // r13
  common::milog::MiLogStream *v6; // rcx
  uint32_t *p_count; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rcx
  ItemExcelConfigMgr *p_item_config_mgr; // rcx
  common::milog::MiLogStream *v12; // r12
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // r12
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // r12
  common::milog::MiLogStream *v21; // r12
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // r12
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // r12
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // r12
  common::milog::MiLogStream *v31; // rax
  common::milog::MiLogStream *v32; // rax
  common::milog::MiLogStream *v33; // r12
  int v34; // r15d
  std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v35; // rcx
  common::milog::MiLogStream *v36; // r12
  common::milog::MiLogStream *v37; // r12
  int v38; // r15d
  std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v39; // rcx
  common::milog::MiLogStream *v40; // r12
  common::milog::MiLogStream *v41; // r12
  int v42; // r15d
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v43; // rcx
  common::milog::MiLogStream *v44; // r12
  common::milog::MiLogStream *v45; // r12
  int v46; // r15d
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v47; // rcx
  common::milog::MiLogStream *v48; // r12
  common::milog::MiLogStream *v49; // r12
  int v50; // r15d
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v51; // rcx
  common::milog::MiLogStream *v52; // r12
  common::milog::MiLogStream *v53; // r12
  int v54; // r15d
  std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v55; // rcx
  common::milog::MiLogStream *v56; // r12
  common::milog::MiLogStream *v57; // r12
  int v58; // r15d
  std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v59; // rcx
  common::milog::MiLogStream *v60; // r12
  common::milog::MiLogStream *v61; // rax
  PlayerMechanicusComp *MechanicusComp; // rcx
  common::milog::MiLogStream *v63; // rax
  common::milog::MiLogStream *v64; // rax
  common::milog::MiLogStream *v65; // r12
  common::milog::MiLogStream *v66; // r12
  int v67; // r15d
  std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v68; // rcx
  common::milog::MiLogStream *v69; // r12
  common::milog::MiLogStream *v70; // r12
  int v71; // r15d
  std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v72; // rcx
  common::milog::MiLogStream *v73; // r12
  common::milog::MiLogStream *v74; // r12
  int v75; // r15d
  std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v76; // rcx
  common::milog::MiLogStream *v77; // r12
  common::milog::MiLogStream *v78; // r12
  common::milog::MiLogStream *v79; // rax
  common::milog::MiLogStream *v80; // rax
  common::milog::MiLogStream *v81; // r12
  int v82; // r15d
  std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v83; // rcx
  common::milog::MiLogStream *v84; // r12
  common::milog::MiLogStream *v85; // r12
  int v86; // r15d
  std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v87; // rcx
  common::milog::MiLogStream *v88; // r12
  common::milog::MiLogStream *v89; // r12
  int v90; // r15d
  std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v91; // rcx
  common::milog::MiLogStream *v92; // r12
  common::milog::MiLogStream *v93; // r12
  int v94; // r15d
  std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v95; // rcx
  common::milog::MiLogStream *v96; // r12
  common::milog::MiLogStream *v97; // r12
  int v98; // r15d
  std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v99; // rcx
  common::milog::MiLogStream *v100; // r12
  common::milog::MiLogStream *v101; // r12
  int v102; // r15d
  std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v103; // rcx
  common::milog::MiLogStream *v104; // r12
  common::milog::MiLogStream *v105; // r12
  int v106; // r15d
  std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v107; // rcx
  common::milog::MiLogStream *v108; // r12
  common::milog::MiLogStream *v109; // r12
  int v110; // r15d
  std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v111; // rcx
  common::milog::MiLogStream *v112; // r12
  common::milog::MiLogStream *v113; // r12
  int v114; // r15d
  std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v115; // rcx
  common::milog::MiLogStream *v116; // r12
  common::milog::MiLogStream *v117; // r12
  int v118; // r15d
  std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v119; // rcx
  common::milog::MiLogStream *v120; // r12
  common::milog::MiLogStream *v121; // r12
  int v122; // r15d
  std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v123; // rcx
  common::milog::MiLogStream *v124; // r12
  common::milog::MiLogStream *v125; // r12
  int v126; // r15d
  std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v127; // rcx
  common::milog::MiLogStream *v128; // r12
  common::milog::MiLogStream *v129; // r12
  int v130; // r15d
  std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v131; // rcx
  common::milog::MiLogStream *v132; // r12
  common::milog::MiLogStream *v133; // r12
  int v134; // r15d
  std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v135; // rcx
  common::milog::MiLogStream *v136; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v137; // rax
  common::milog::MiLogStream *v138; // rax
  uint32_t ActivityComp; // eax
  std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v140; // rax
  common::milog::MiLogStream *v142; // r12
  int v143; // r15d
  std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v144; // rax
  unsigned __int64 v145; // rdx
  __int64 (__fastcall *v146)(std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, _QWORD, _QWORD); // r8
  common::milog::MiLogStream *v147; // r12
  common::milog::MiLogStream *v148; // rax
  int32_t result; // eax
  unsigned int val; // [rsp+2Ch] [rbp-1C4h] BYREF
  int32_t ret_15; // [rsp+30h] [rbp-1C0h]
  int32_t ret; // [rsp+34h] [rbp-1BCh]
  int32_t ret_1; // [rsp+38h] [rbp-1B8h]
  int32_t ret_0; // [rsp+3Ch] [rbp-1B4h]
  uint32_t activity_id; // [rsp+40h] [rbp-1B0h]
  int32_t ret_30; // [rsp+44h] [rbp-1ACh]
  proto::VirtualItem coin_type_7; // [rsp+48h] [rbp-1A8h]
  int32_t ret_29; // [rsp+4Ch] [rbp-1A4h]
  proto::VirtualItem coin_type_6; // [rsp+50h] [rbp-1A0h]
  int32_t ret_28; // [rsp+54h] [rbp-19Ch]
  proto::VirtualItem coin_type_5; // [rsp+58h] [rbp-198h]
  int32_t ret_27; // [rsp+5Ch] [rbp-194h]
  proto::VirtualItem coin_type_3; // [rsp+60h] [rbp-190h]
  int32_t ret_25; // [rsp+64h] [rbp-18Ch]
  proto::VirtualItem coin_type_4; // [rsp+68h] [rbp-188h]
  int32_t ret_26; // [rsp+6Ch] [rbp-184h]
  proto::VirtualItem coin_type_2; // [rsp+70h] [rbp-180h]
  int32_t ret_24; // [rsp+74h] [rbp-17Ch]
  proto::VirtualItem coin_type_1; // [rsp+78h] [rbp-178h]
  int32_t ret_23; // [rsp+7Ch] [rbp-174h]
  proto::VirtualItem coin_type_0; // [rsp+80h] [rbp-170h]
  int32_t ret_22; // [rsp+84h] [rbp-16Ch]
  int32_t ret_21; // [rsp+88h] [rbp-168h]
  proto::VirtualItem coin_type; // [rsp+8Ch] [rbp-164h]
  int32_t ret_20; // [rsp+90h] [rbp-160h]
  int32_t ret_19; // [rsp+94h] [rbp-15Ch]
  int32_t ret_18; // [rsp+98h] [rbp-158h]
  int32_t ret_17; // [rsp+9Ch] [rbp-154h]
  int32_t ret_16; // [rsp+A0h] [rbp-150h]
  int32_t ret_14; // [rsp+A4h] [rbp-14Ch]
  int32_t ret_13; // [rsp+A8h] [rbp-148h]
  int32_t ret_12; // [rsp+ACh] [rbp-144h]
  int32_t ret_11; // [rsp+B0h] [rbp-140h]
  int32_t ret_10; // [rsp+B4h] [rbp-13Ch]
  int32_t ret_9; // [rsp+B8h] [rbp-138h]
  int32_t ret_8; // [rsp+BCh] [rbp-134h]
  int32_t ret_7; // [rsp+C0h] [rbp-130h]
  int32_t ret_6; // [rsp+C4h] [rbp-12Ch]
  int32_t ret_5; // [rsp+C8h] [rbp-128h]
  int32_t ret_4; // [rsp+CCh] [rbp-124h]
  int32_t ret_3; // [rsp+D0h] [rbp-120h]
  int32_t ret_2; // [rsp+D4h] [rbp-11Ch]
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+D8h] [rbp-118h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+E0h] [rbp-110h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+E8h] [rbp-108h]
  const ItemParam *item_param; // [rsp+F0h] [rbp-100h]
  const data::ItemConfig *item_config_ptr; // [rsp+F8h] [rbp-F8h]
  common::milog::MiLogStream v198; // [rsp+100h] [rbp-F0h] BYREF
  char v199[208]; // [rsp+120h] [rbp-D0h] BYREF

  v3 = (unsigned __int64)v199;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(160LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "3 48 4 14 coin_type:4863 64 16 17 activity_ptr:4870 96 24 30 item_param_vec_no_virtual:4344";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkSubItemBatch;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -219021312;
  v5[536862723] = -218103808;
  v5[536862724] = -202116109;
  if ( std::vector<ItemParam>::empty(item_param_vec) )
  {
    common::milog::MiLogStream::create(
      &v198,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkSubItemBatch",
      4341);
    v6 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
           &v198,
           (const char (*)[33])"item_param_vec is empty, player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v6, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v198);
    v2 = -1;
  }
  else
  {
    std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v3 + 96));
    __for_range = item_param_vec;
    __for_begin._M_current = std::vector<ItemParam>::begin(item_param_vec)._M_current;
    __for_end._M_current = std::vector<ItemParam>::end(item_param_vec)._M_current;
    while ( 1 )
    {
      if ( !__gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
      {
        v2 = PackItemStore::checkSubItemBatch(&this->pack_store_, (const std::vector<ItemParam> *)(v3 + 96));
        goto LABEL_480;
      }
      item_param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
      p_count = &item_param->count;
      if ( *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)p_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(p_count);
      }
      if ( !item_param->count )
      {
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4349);
        v8 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
               &v198,
               (const char (*)[26])"item_count is 0, item_id:");
        v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, &item_param->item_id);
        v10 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v9, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v10, this->player_);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = -1;
        goto LABEL_480;
      }
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)(v3 + 64));
      p_item_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64))->design_config.txt_config_mgr.item_config_mgr;
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      item_config_ptr = ItemExcelConfigMgr::findItemConfig(p_item_config_mgr, item_param->item_id);
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 64));
      if ( !item_config_ptr )
      {
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4355);
        v12 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
                &v198,
                (const char (*)[28])"findItemConfig failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        v13 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v12, &val);
        v14 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v13, (const char (*)[10])" item_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &item_param->item_id);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = -1;
        goto LABEL_480;
      }
      if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                       + 0x7FFF8000) )
      {
        __asan_report_load4(&item_config_ptr->item_type);
      }
      if ( item_config_ptr->item_type == ITEM_VIRTUAL )
        break;
      std::vector<ItemParam>::emplace_back<ItemParam const&>(
        (std::vector<ItemParam> *const)(v3 + 96),
        item_param,
        item_param);
LABEL_478:
      __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
    }
    if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_param);
    }
    switch ( item_param->item_id )
    {
      case 0x65u:
      case 0x66u:
      case 0x69u:
      case 0x6Cu:
      case 0x79u:
      case 0x81u:
      case 0x83u:
      case 0x92u:
      case 0x13Au:
      case 0x13Bu:
      case 0x13Cu:
      case 0x13Du:
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4375);
        v15 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(&v198, (const char (*)[36])off_26391DE0);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, &item_param->item_id);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = -1;
        break;
      case 0x6Au:
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_2 = PlayerItemComp::checkSubResin(this, item_param->count);
        if ( !ret_2 )
          goto LABEL_478;
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4414);
        v27 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                &v198,
                (const char (*)[29])"resin sub failed, cur_resin:");
        val = PlayerItemComp::getResin(this);
        v28 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, &val);
        v29 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v28, (const char (*)[8])" count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v29, &item_param->count);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = ret_2;
        break;
      case 0x6Bu:
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_3 = PlayerItemComp::checkSubLegendaryKey(this, item_param->count);
        if ( !ret_3 )
          goto LABEL_478;
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4424);
        v30 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                &v198,
                (const char (*)[45])"legendary_key sub failed, cur_legendary_key:");
        val = PlayerItemComp::getLegendaryKey(this);
        v31 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v30, &val);
        v32 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v31, (const char (*)[8])" count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v32, &item_param->count);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = ret_3;
        break;
      case 0x6Du:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<AsterActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<AsterActivity>(0LL, (const std::shared_ptr<AsterActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4434);
          v33 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                  &v198,
                  (const char (*)[39])"[ASTER] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v33, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v34 = 0;
        }
        else
        {
          v35 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_4 = AsterActivity::checkSubAsterCredit(v35, item_param->count);
          if ( ret_4 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4440);
            v36 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                    &v198,
                    (const char (*)[42])"[ASTER] checkSubAsterCredit failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v36, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_4;
            v34 = 0;
          }
          else
          {
            v34 = 1;
          }
        }
        std::shared_ptr<AsterActivity>::~shared_ptr((std::shared_ptr<AsterActivity> *const)(v3 + 64));
        if ( v34 )
          goto LABEL_478;
        break;
      case 0x6Eu:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<AsterActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<AsterActivity>(0LL, (const std::shared_ptr<AsterActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4450);
          v37 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                  &v198,
                  (const char (*)[39])"[ASTER] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v37, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v38 = 0;
        }
        else
        {
          v39 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_5 = AsterActivity::checkSubAsterToken(v39, item_param->count);
          if ( ret_5 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4456);
            v40 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                    &v198,
                    (const char (*)[41])"[ASTER] checkSubAsterToken failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v40, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_5;
            v38 = 0;
          }
          else
          {
            v38 = 1;
          }
        }
        std::shared_ptr<AsterActivity>::~shared_ptr((std::shared_ptr<AsterActivity> *const)(v3 + 64));
        if ( v38 )
          goto LABEL_478;
        break;
      case 0x6Fu:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4466);
          v41 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                  &v198,
                  (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v41, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v42 = 0;
        }
        else
        {
          v43 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_6 = DragonSpineActivity::checkSubShimmeringEssence(v43, item_param->count);
          if ( ret_6 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4472);
            v44 = common::milog::MiLogStream::operator<<<char [55],(char *[55])0>(
                    &v198,
                    (const char (*)[55])"[DRAGON_SPINE] checkSubShimmeringEssence failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v44, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_6;
            v42 = 0;
          }
          else
          {
            v42 = 1;
          }
        }
        std::shared_ptr<DragonSpineActivity>::~shared_ptr((std::shared_ptr<DragonSpineActivity> *const)(v3 + 64));
        if ( v42 )
          goto LABEL_478;
        break;
      case 0x70u:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4482);
          v45 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                  &v198,
                  (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v45, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v46 = 0;
        }
        else
        {
          v47 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_7 = DragonSpineActivity::checkSubWarmEssence(v47, item_param->count);
          if ( ret_7 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4488);
            v48 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                    &v198,
                    (const char (*)[49])"[DRAGON_SPINE] checkSubWarmEssence failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v48, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_7;
            v46 = 0;
          }
          else
          {
            v46 = 1;
          }
        }
        std::shared_ptr<DragonSpineActivity>::~shared_ptr((std::shared_ptr<DragonSpineActivity> *const)(v3 + 64));
        if ( v46 )
          goto LABEL_478;
        break;
      case 0x71u:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4498);
          v49 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                  &v198,
                  (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v49, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v50 = 0;
        }
        else
        {
          v51 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_8 = DragonSpineActivity::checkSubWondrousEssence(v51, item_param->count);
          if ( ret_8 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4504);
            v52 = common::milog::MiLogStream::operator<<<char [53],(char *[53])0>(
                    &v198,
                    (const char (*)[53])"[DRAGON_SPINE] checkSubWondrousEssence failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v52, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_8;
            v50 = 0;
          }
          else
          {
            v50 = 1;
          }
        }
        std::shared_ptr<DragonSpineActivity>::~shared_ptr((std::shared_ptr<DragonSpineActivity> *const)(v3 + 64));
        if ( v50 )
          goto LABEL_478;
        break;
      case 0x72u:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<TreasureMapActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<TreasureMapActivity>(0LL, (const std::shared_ptr<TreasureMapActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4514);
          v53 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                  &v198,
                  (const char (*)[46])"[TREASURE_MAP] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v53, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v54 = 0;
        }
        else
        {
          v55 = std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_9 = TreasureMapActivity::checkSubToken(v55, item_param->count);
          if ( ret_9 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4520);
            v56 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                    &v198,
                    (const char (*)[43])"[TREASURE_MAP] checkSubToken failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v56, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_9;
            v54 = 0;
          }
          else
          {
            v54 = 1;
          }
        }
        std::shared_ptr<TreasureMapActivity>::~shared_ptr((std::shared_ptr<TreasureMapActivity> *const)(v3 + 64));
        if ( v54 )
          goto LABEL_478;
        break;
      case 0x73u:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<SeaLampActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<SeaLampActivity>(0LL, (const std::shared_ptr<SeaLampActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4530);
          v57 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                  &v198,
                  (const char (*)[29])"[SEA_LAMP] not opening, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v57, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v58 = 0;
        }
        else
        {
          v59 = std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_10 = SeaLampActivity::checkSubSeaLampCoin(v59, item_param->count);
          if ( ret_10 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4536);
            v60 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                    &v198,
                    (const char (*)[43])"[SEA_LAMP] checkSubSeaLampCoin fails, uid:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v60, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_10;
            v58 = 0;
          }
          else
          {
            v58 = 1;
          }
        }
        std::shared_ptr<SeaLampActivity>::~shared_ptr((std::shared_ptr<SeaLampActivity> *const)(v3 + 64));
        if ( v58 )
          goto LABEL_478;
        break;
      case 0x74u:
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4543);
        v61 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(&v198, (const char (*)[36])off_26391DE0);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v61, &item_param->item_id);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = -1;
        break;
      case 0x75u:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        MechanicusComp = Player::getMechanicusComp(this->player_);
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_11 = PlayerMechanicusComp::checkSubCoin(MechanicusComp, item_param->count);
        if ( !ret_11 )
          goto LABEL_478;
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4551);
        v63 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
                &v198,
                (const char (*)[22])"check sub mechanicus:");
        v64 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v63, &item_param->count);
        v65 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v64, (const char (*)[13])" fails, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v65, &val);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = ret_11;
        break;
      case 0x76u:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<FleurFairActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<FleurFairActivity>(0LL, (const std::shared_ptr<FleurFairActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4561);
          v66 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                  &v198,
                  (const char (*)[44])"[FLEUR_FAIR] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v66, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v67 = 0;
        }
        else
        {
          v68 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_12 = FleurFairActivity::checkSubCredit(v68, item_param->count);
          if ( ret_12 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4567);
            v69 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                    &v198,
                    (const char (*)[42])"[FLEUR_FAIR] checkSubCredit failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v69, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_12;
            v67 = 0;
          }
          else
          {
            v67 = 1;
          }
        }
        std::shared_ptr<FleurFairActivity>::~shared_ptr((std::shared_ptr<FleurFairActivity> *const)(v3 + 64));
        if ( v67 )
          goto LABEL_478;
        break;
      case 0x77u:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<FleurFairActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<FleurFairActivity>(0LL, (const std::shared_ptr<FleurFairActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4577);
          v70 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                  &v198,
                  (const char (*)[44])"[FLEUR_FAIR] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v70, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v71 = 0;
        }
        else
        {
          v72 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_13 = FleurFairActivity::checkSubToken(v72, item_param->count);
          if ( ret_13 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4583);
            v73 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                    &v198,
                    (const char (*)[41])"[FLEUR_FAIR] checkSubToken failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v73, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_13;
            v71 = 0;
          }
          else
          {
            v71 = 1;
          }
        }
        std::shared_ptr<FleurFairActivity>::~shared_ptr((std::shared_ptr<FleurFairActivity> *const)(v3 + 64));
        if ( v71 )
          goto LABEL_478;
        break;
      case 0x78u:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<WaterSpiritActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<WaterSpiritActivity>(0LL, (const std::shared_ptr<WaterSpiritActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4593);
          v74 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                  &v198,
                  (const char (*)[46])"[WATER_SPIRIT] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v74, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v75 = 0;
        }
        else
        {
          v76 = std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_14 = WaterSpiritActivity::checkSubSpiritCoin(v76, item_param->count);
          if ( ret_14 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4599);
            v77 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(
                    &v198,
                    (const char (*)[48])"[WATER_SPIRIT] checkSubSpiritCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v77, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_14;
            v75 = 0;
          }
          else
          {
            v75 = 1;
          }
        }
        std::shared_ptr<WaterSpiritActivity>::~shared_ptr((std::shared_ptr<WaterSpiritActivity> *const)(v3 + 64));
        if ( v75 )
          goto LABEL_478;
        break;
      case 0x7Au:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<ChannellerSlabActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<ChannellerSlabActivity>(0LL, (const std::shared_ptr<ChannellerSlabActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4619);
          v81 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                  &v198,
                  (const char (*)[49])"[CHANNELLER_SLAB] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v81, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v82 = 0;
        }
        else
        {
          v83 = std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_16 = ChannellerSlabActivity::checkSubToken(v83, item_param->count);
          if ( ret_16 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4625);
            v84 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                    &v198,
                    (const char (*)[46])"[CHANNELLER_SLAB] checkSubToken failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v84, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_16;
            v82 = 0;
          }
          else
          {
            v82 = 1;
          }
        }
        std::shared_ptr<ChannellerSlabActivity>::~shared_ptr((std::shared_ptr<ChannellerSlabActivity> *const)(v3 + 64));
        if ( v82 )
          goto LABEL_478;
        break;
      case 0x7Cu:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<SummerTimeActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<SummerTimeActivity>(0LL, (const std::shared_ptr<SummerTimeActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4635);
          v85 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                  &v198,
                  (const char (*)[45])"[SUMMER_TIME] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v85, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v86 = 0;
        }
        else
        {
          v87 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_17 = SummerTimeActivity::checkAddDraftWood(v87, item_param->count);
          if ( ret_17 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4641);
            v88 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                    &v198,
                    (const char (*)[46])"[SUMMER_TIME] checkAddDraftWood failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v88, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_17;
            v86 = 0;
          }
          else
          {
            v86 = 1;
          }
        }
        std::shared_ptr<SummerTimeActivity>::~shared_ptr((std::shared_ptr<SummerTimeActivity> *const)(v3 + 64));
        if ( v86 )
          goto LABEL_478;
        break;
      case 0x7Du:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<SummerTimeActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<SummerTimeActivity>(0LL, (const std::shared_ptr<SummerTimeActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4651);
          v89 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                  &v198,
                  (const char (*)[45])"[SUMMER_TIME] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v89, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v90 = 0;
        }
        else
        {
          v91 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_18 = SummerTimeActivity::checkAddMiniHarpastum(v91, item_param->count);
          if ( ret_18 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4657);
            v92 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
                    &v198,
                    (const char (*)[50])"[SUMMER_TIME] checkAddMiniHarpastum failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v92, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_18;
            v90 = 0;
          }
          else
          {
            v90 = 1;
          }
        }
        std::shared_ptr<SummerTimeActivity>::~shared_ptr((std::shared_ptr<SummerTimeActivity> *const)(v3 + 64));
        if ( v90 )
          goto LABEL_478;
        break;
      case 0x7Eu:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<BounceConjuringActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<BounceConjuringActivity>(0LL, (const std::shared_ptr<BounceConjuringActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4667);
          v93 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
                  &v198,
                  (const char (*)[50])"[BOUNCE_CONJURING] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v93, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v94 = 0;
        }
        else
        {
          v95 = std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_19 = BounceConjuringActivity::checkSubCoin(v95, item_param->count);
          if ( ret_19 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4673);
            v96 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                    &v198,
                    (const char (*)[46])"[BOUNCE_CONJURING] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v96, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_19;
            v94 = 0;
          }
          else
          {
            v94 = 1;
          }
        }
        std::shared_ptr<BounceConjuringActivity>::~shared_ptr((std::shared_ptr<BounceConjuringActivity> *const)(v3 + 64));
        if ( v94 )
          goto LABEL_478;
        break;
      case 0x7Fu:
      case 0x80u:
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type = item_param->item_id;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<BlitzRushActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<BlitzRushActivity>(0LL, (const std::shared_ptr<BlitzRushActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4685);
          v97 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                  &v198,
                  (const char (*)[44])"[BLITZ_RUSH] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v97, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v98 = 0;
        }
        else
        {
          v99 = std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_20 = BlitzRushActivity::checkSubActivityCoin(v99, coin_type, item_param->count);
          if ( ret_20 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4691);
            v100 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                     &v198,
                     (const char (*)[40])"[BLITZ_RUSH] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v100, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_20;
            v98 = 0;
          }
          else
          {
            v98 = 1;
          }
        }
        std::shared_ptr<BlitzRushActivity>::~shared_ptr((std::shared_ptr<BlitzRushActivity> *const)(v3 + 64));
        if ( v98 )
          goto LABEL_478;
        break;
      case 0x82u:
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<ChessActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<ChessActivity>(0LL, (const std::shared_ptr<ChessActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4701);
          v101 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                   &v198,
                   (const char (*)[39])"[CHESS] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v101, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v102 = 0;
        }
        else
        {
          v103 = std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_21 = ChessActivity::checkSubCoin(v103, item_param->count);
          if ( ret_21 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4707);
            v104 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                     &v198,
                     (const char (*)[35])"[CHESS] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v104, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_21;
            v102 = 0;
          }
          else
          {
            v102 = 1;
          }
        }
        std::shared_ptr<ChessActivity>::~shared_ptr((std::shared_ptr<ChessActivity> *const)(v3 + 64));
        if ( v102 )
          goto LABEL_478;
        break;
      case 0x84u:
      case 0x85u:
      case 0x86u:
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_0 = item_param->item_id;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<RoguelikeDungeonActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<RoguelikeDungeonActivity>(
               0LL,
               (const std::shared_ptr<RoguelikeDungeonActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4720);
          v105 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                   &v198,
                   (const char (*)[43])"[ROGUELIKE] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v105, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v106 = 0;
        }
        else
        {
          v107 = std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_22 = RoguelikeDungeonActivity::checkSubActivityCoin(v107, coin_type_0, item_param->count);
          if ( ret_22 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              1u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4726);
            v108 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                     &v198,
                     (const char (*)[39])"[ROGUELIKE] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v108, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_22;
            v106 = 0;
          }
          else
          {
            v106 = 1;
          }
        }
        std::shared_ptr<RoguelikeDungeonActivity>::~shared_ptr((std::shared_ptr<RoguelikeDungeonActivity> *const)(v3 + 64));
        if ( v106 )
          goto LABEL_478;
        break;
      case 0x87u:
      case 0x88u:
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_1 = item_param->item_id;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<WinterCampActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<WinterCampActivity>(0LL, (const std::shared_ptr<WinterCampActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4738);
          v109 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                   &v198,
                   (const char (*)[44])"[WinterCamp] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v109, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v110 = 0;
        }
        else
        {
          v111 = std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_23 = WinterCampActivity::checkSubActivityCoin(v111, coin_type_1, item_param->count);
          if ( ret_23 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4744);
            v112 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                     &v198,
                     (const char (*)[40])"[WinterCamp] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v112, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_23;
            v110 = 0;
          }
          else
          {
            v110 = 1;
          }
        }
        std::shared_ptr<WinterCampActivity>::~shared_ptr((std::shared_ptr<WinterCampActivity> *const)(v3 + 64));
        if ( v110 )
          goto LABEL_478;
        break;
      case 0x89u:
      case 0x8Au:
      case 0x8Bu:
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_2 = item_param->item_id;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<LanternRiteActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<LanternRiteActivity>(0LL, (const std::shared_ptr<LanternRiteActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4757);
          v113 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                   &v198,
                   (const char (*)[45])"[LanternRite] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v113, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v114 = 0;
        }
        else
        {
          v115 = std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_24 = LanternRiteActivity::checkSubActivityCoin(v115, coin_type_2, item_param->count);
          if ( ret_24 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4763);
            v116 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                     &v198,
                     (const char (*)[41])"[LanternRite] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v116, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_24;
            v114 = 0;
          }
          else
          {
            v114 = 1;
          }
        }
        std::shared_ptr<LanternRiteActivity>::~shared_ptr((std::shared_ptr<LanternRiteActivity> *const)(v3 + 64));
        if ( v114 )
          goto LABEL_478;
        break;
      case 0x8Cu:
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_4 = item_param->item_id;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<RogueDiaryActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<RogueDiaryActivity>(0LL, (const std::shared_ptr<RogueDiaryActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4791);
          v121 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                   &v198,
                   (const char (*)[44])"[RogueDiary] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v121, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v122 = 0;
        }
        else
        {
          v123 = std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_26 = RogueDiaryActivity::checkSubActivityCoin(v123, coin_type_4, item_param->count);
          if ( ret_26 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4797);
            v124 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                     &v198,
                     (const char (*)[40])"[RogueDiary] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v124, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_26;
            v122 = 0;
          }
          else
          {
            v122 = 1;
          }
        }
        std::shared_ptr<RogueDiaryActivity>::~shared_ptr((std::shared_ptr<RogueDiaryActivity> *const)(v3 + 64));
        if ( v122 )
          goto LABEL_478;
        break;
      case 0x8Du:
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_3 = item_param->item_id;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<SummerTimeV2Activity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<SummerTimeV2Activity>(0LL, (const std::shared_ptr<SummerTimeV2Activity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4774);
          v117 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(
                   &v198,
                   (const char (*)[48])"[SUMMER_TIME_V2] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v117, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v118 = 0;
        }
        else
        {
          v119 = std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_25 = SummerTimeV2Activity::checkSubActivityCoin(v119, coin_type_3, item_param->count);
          if ( ret_25 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4780);
            v120 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                     &v198,
                     (const char (*)[44])"[SUMMER_TIME_V2] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v120, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_25;
            v118 = 0;
          }
          else
          {
            v118 = 1;
          }
        }
        std::shared_ptr<SummerTimeV2Activity>::~shared_ptr((std::shared_ptr<SummerTimeV2Activity> *const)(v3 + 64));
        if ( v118 )
          goto LABEL_478;
        break;
      case 0x8Fu:
      case 0x90u:
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_5 = item_param->item_id;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<GravenInnocenceActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<GravenInnocenceActivity>(0LL, (const std::shared_ptr<GravenInnocenceActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4809);
          v125 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                   &v198,
                   (const char (*)[49])"[GravenInnocence] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v125, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v126 = 0;
        }
        else
        {
          v127 = std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_27 = GravenInnocenceActivity::checkSubActivityCoin(v127, coin_type_5, item_param->count);
          if ( ret_27 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4815);
            v128 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                     &v198,
                     (const char (*)[45])"[GravenInnocence] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v128, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_27;
            v126 = 0;
          }
          else
          {
            v126 = 1;
          }
        }
        std::shared_ptr<GravenInnocenceActivity>::~shared_ptr((std::shared_ptr<GravenInnocenceActivity> *const)(v3 + 64));
        if ( v126 )
          goto LABEL_478;
        break;
      case 0x91u:
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_6 = item_param->item_id;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<TreasureSeelieActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<TreasureSeelieActivity>(0LL, (const std::shared_ptr<TreasureSeelieActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4826);
          v129 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                   &v198,
                   (const char (*)[49])"[TREASURE SEELIE] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v129, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v130 = 0;
        }
        else
        {
          v131 = std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_28 = TreasureSeelieActivity::checkSubActivityCoin(v131, coin_type_6, item_param->count);
          if ( ret_28 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4832);
            v132 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                     &v198,
                     (const char (*)[45])"[TREASURE SEELIE] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v132, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_28;
            v130 = 0;
          }
          else
          {
            v130 = 1;
          }
        }
        std::shared_ptr<TreasureSeelieActivity>::~shared_ptr((std::shared_ptr<TreasureSeelieActivity> *const)(v3 + 64));
        if ( v130 )
          goto LABEL_478;
        break;
      case 0x93u:
      case 0x94u:
      case 0x95u:
      case 0x96u:
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_7 = item_param->item_id;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::getActivityComp(this->player_);
        PlayerActivityComp::findOpenningActivity<VintageActivity>((PlayerActivityComp *const)(v3 + 64));
        if ( std::operator==<VintageActivity>(0LL, (const std::shared_ptr<VintageActivity> *)(v3 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4846);
          v133 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                   &v198,
                   (const char (*)[41])"[Vintage] activity is not opening, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v133, &val);
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = 860;
          v134 = 0;
        }
        else
        {
          v135 = std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
          if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                     + 0x7FFF8000) )
          {
            __asan_report_load4(&item_param->count);
          }
          ret_29 = VintageActivity::checkSubActivityCoin(v135, coin_type_7, item_param->count);
          if ( ret_29 )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              1u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4852);
            v136 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                     &v198,
                     (const char (*)[37])"[Vintage] checkSubCoin failed, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v136, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = ret_29;
            v134 = 0;
          }
          else
          {
            v134 = 1;
          }
        }
        std::shared_ptr<VintageActivity>::~shared_ptr((std::shared_ptr<VintageActivity> *const)(v3 + 64));
        if ( v134 )
          goto LABEL_478;
        break;
      case 0x97u:
      case 0x98u:
      case 0x99u:
      case 0x9Au:
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        *(_DWORD *)(v3 + 48) = item_param->item_id;
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)(v3 + 64));
        v137 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
        activity_id = NewActivityExcelConfigMgr::findActivityIdByCoinType(
                        &v137->design_config.txt_config_mgr.new_activity_config_mgr,
                        *(proto::VirtualItem *)(v3 + 48));
        std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 64));
        if ( activity_id )
        {
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          ActivityComp = (unsigned int)Player::getActivityComp(this->player_);
          PlayerActivityComp::findBaseActivity((PlayerActivityComp *const)(v3 + 64), ActivityComp);
          if ( std::operator==<BaseActivity>(0LL, (const std::shared_ptr<BaseActivity> *)(v3 + 64))
            || (v140 = std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64)),
                !BaseActivity::isOpening(v140, 0)) )
          {
            common::milog::MiLogStream::create(
              &v198,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkSubItemBatch",
              4873);
            v142 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                     &v198,
                     (const char (*)[31])"activity is not opening, uid: ");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v142, &val);
            common::milog::MiLogStream::~MiLogStream(&v198);
            v2 = 860;
            v143 = 0;
          }
          else
          {
            v144 = std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
            if ( *(_BYTE *)(((unsigned __int64)v144 >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            v145 = (unsigned __int64)(v144->_vptr_DescribalBase + 13);
            if ( *(_BYTE *)((v145 >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            v146 = *(__int64 (__fastcall **)(std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, _QWORD, _QWORD))v145;
            if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                       + 0x7FFF8000) )
            {
              __asan_report_load4(&item_param->count);
            }
            ret_30 = v146(v144, *(unsigned int *)(v3 + 48), item_param->count);
            if ( ret_30 )
            {
              common::milog::MiLogStream::create(
                &v198,
                &common::milog::MiLogDefault::default_log_obj_,
                3u,
                "./src/player/item/player_item_comp.cpp",
                "checkSubItemBatch",
                4879);
              v147 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
                       &v198,
                       (const char (*)[27])"checkSubCoin failed, uid: ");
              if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                __asan_report_load8();
              val = Player::getUid(this->player_);
              common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v147, &val);
              common::milog::MiLogStream::~MiLogStream(&v198);
              v2 = ret_30;
              v143 = 0;
            }
            else
            {
              v143 = 1;
            }
          }
          std::shared_ptr<BaseActivity>::~shared_ptr((std::shared_ptr<BaseActivity> *const)(v3 + 64));
          if ( v143 )
            goto LABEL_478;
        }
        else
        {
          common::milog::MiLogStream::create(
            &v198,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkSubItemBatch",
            4867);
          v138 = common::milog::MiLogStream::operator<<<char [64],(char *[64])0>(
                   &v198,
                   (const char (*)[64])"virutal coin cannot find corresponding activity id, coin_type: ");
          common::milog::MiLogStream::operator<<<proto::VirtualItem,(proto::VirtualItem*)0>(
            v138,
            (const proto::VirtualItem *)(v3 + 48));
          common::milog::MiLogStream::~MiLogStream(&v198);
          v2 = -1;
        }
        break;
      case 0xC9u:
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_0 = PlayerItemComp::checkSubHcoin(this, item_param->count);
        if ( !ret_0 )
          goto LABEL_478;
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4394);
        v21 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                &v198,
                (const char (*)[29])"hcoin sub failed, cur_hcoin:");
        val = PlayerItemComp::getHcoin(this);
        v22 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, &val);
        v23 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v22, (const char (*)[8])" count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v23, &item_param->count);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = ret_0;
        break;
      case 0xCAu:
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_1 = PlayerItemComp::checkSubScoin(this, item_param->count);
        if ( !ret_1 )
          goto LABEL_478;
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4404);
        v24 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                &v198,
                (const char (*)[29])"scoin sub failed, cur_scoin:");
        val = PlayerItemComp::getScoin(this);
        v25 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, &val);
        v26 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v25, (const char (*)[8])" count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v26, &item_param->count);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = ret_1;
        break;
      case 0xCBu:
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret = PlayerItemComp::checkSubMcoin(this, item_param->count);
        if ( !ret )
          goto LABEL_478;
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4384);
        v16 = common::milog::MiLogStream::operator<<<char [32],(char *[32])0>(
                &v198,
                (const char (*)[32])"checkSubMcoin fails, cur_mcoin:");
        *(_DWORD *)(v3 + 48) = PlayerItemComp::getMcoin(this);
        v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v16,
                (const unsigned int *)(v3 + 48));
        v18 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v17, (const char (*)[8])" count:");
        v19 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, &item_param->count);
        v20 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v19, (const char (*)[6])" uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &val);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = ret;
        break;
      case 0xCCu:
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_15 = PlayerItemComp::checkSubHomeCoin(this, item_param->count);
        if ( !ret_15 )
          goto LABEL_478;
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4609);
        v78 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                &v198,
                (const char (*)[37])"home_coin sub failed, cur_home_coin:");
        val = PlayerItemComp::getHomeCoin(this);
        v79 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v78, &val);
        v80 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v79, (const char (*)[8])" count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v80, &item_param->count);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = ret_15;
        break;
      default:
        common::milog::MiLogStream::create(
          &v198,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkSubItemBatch",
          4886);
        v148 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                 &v198,
                 (const char (*)[30])"unkown virutal item, item_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v148, &item_param->item_id);
        common::milog::MiLogStream::~MiLogStream(&v198);
        v2 = -1;
        break;
    }
LABEL_480:
    std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 96));
  }
  result = v2;
  if ( v199 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 4901: range 0000000017CE4972-0000000017CE4BBB
int32_t __cdecl PlayerItemComp::subItem(
        PlayerItemComp *const this,
        const ItemParam *item_param,
        const SubItemReason *reason)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  std::initializer_list<ItemParam>::size_type v6; // rdx
  int32_t v7; // r14d
  int32_t result; // eax
  std::allocator<ItemParam> __a; // [rsp+2Fh] [rbp-A1h] BYREF
  std::initializer_list<ItemParam> __l; // [rsp+30h] [rbp-A0h] BYREF
  char v12[144]; // [rsp+40h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v12;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 24 19 item_param_vec:4902";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::subItem;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  if ( ((unsigned __int8)item_param & 7) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000)
    && *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    || *(_BYTE *)((((unsigned __int64)&item_param->promote_level + 3) >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)item_param + 15) & 7) >= *(_BYTE *)((((unsigned __int64)&item_param->promote_level + 3) >> 3)
                                                            + 0x7FFF8000) )
  {
    __asan_report_load_n(item_param, 16LL);
  }
  v6 = *(_QWORD *)&item_param->level;
  __l._M_array = *(std::initializer_list<ItemParam>::iterator *)&item_param->item_id;
  __l._M_len = v6;
  std::allocator<ItemParam>::allocator(&__a);
  std::vector<ItemParam>::vector(
    (std::vector<ItemParam> *const)(v3 + 32),
    (std::initializer_list<ItemParam>)__PAIR128__(1LL, &__l),
    &__a);
  std::allocator<ItemParam>::~allocator(&__a);
  v7 = PlayerItemComp::subItemBatch(this, (const std::vector<ItemParam> *)(v3 + 32), reason);
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 32));
  result = v7;
  if ( v12 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 4907: range 0000000017CE4BBC-0000000017CE4E5F
int32_t __cdecl PlayerItemComp::subItemBatch(
        PlayerItemComp *const this,
        const std::vector<data::IdCountConfig> *item_vec,
        const SubItemReason *reason)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  uint32_t *p_count; // rax
  int32_t v7; // r14d
  int32_t result; // eax
  std::vector<data::IdCountConfig>::const_iterator __for_begin; // [rsp+20h] [rbp-C0h] BYREF
  std::vector<data::IdCountConfig>::const_iterator __for_end; // [rsp+28h] [rbp-B8h] BYREF
  const std::vector<data::IdCountConfig> *__for_range; // [rsp+30h] [rbp-B0h]
  const data::IdCountConfig *config; // [rsp+38h] [rbp-A8h]
  std::vector<ItemParam>::value_type __x; // [rsp+40h] [rbp-A0h] BYREF
  char v15[144]; // [rsp+50h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v15;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 24 19 item_param_vec:4908";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::subItemBatch;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v3 + 32));
  __for_range = item_vec;
  __for_begin._M_current = std::vector<data::IdCountConfig>::begin(item_vec)._M_current;
  __for_end._M_current = std::vector<data::IdCountConfig>::end(item_vec)._M_current;
  while ( __gnu_cxx::operator!=<data::IdCountConfig const*,std::vector<data::IdCountConfig>>(&__for_begin, &__for_end) )
  {
    config = __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator*(&__for_begin);
    p_count = &config->count;
    if ( *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)p_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(p_count);
    }
    if ( config->count )
    {
      if ( *(_BYTE *)(((unsigned __int64)&config->id >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&config->id >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&config->id);
      }
      __x.item_id = config->id;
      __x.count = config->count;
      __x.level = 0;
      __x.promote_level = 0;
      std::vector<ItemParam>::push_back((std::vector<ItemParam> *const)(v3 + 32), &__x);
    }
    __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator++(&__for_begin);
  }
  v7 = PlayerItemComp::subItemBatch(this, (const std::vector<ItemParam> *)(v3 + 32), reason);
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 32));
  result = v7;
  if ( v15 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 4920: range 0000000017CE4E60-0000000017CEAF08
int32_t __cdecl PlayerItemComp::subItemBatch(
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec,
        const SubItemReason *reason)
{
  int32_t v3; // r12d
  unsigned __int64 v4; // r14
  __int64 v5; // rax
  _DWORD *v6; // r13
  ItemExcelConfigMgr *p_item_config_mgr; // rcx
  common::milog::MiLogStream *v8; // r12
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // r12
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // r12
  common::milog::MiLogStream *v17; // r12
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // r12
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // r12
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // r12
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // r12
  int v30; // r15d
  AsterActivity *p_count; // rdi
  common::milog::MiLogStream *v32; // r12
  std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v33; // rax
  common::milog::MiLogStream *v34; // r12
  int v35; // r15d
  AsterActivity *v36; // rdi
  common::milog::MiLogStream *v37; // r12
  std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v38; // rax
  common::milog::MiLogStream *v39; // r12
  int v40; // r15d
  DragonSpineActivity *v41; // rdi
  common::milog::MiLogStream *v42; // r12
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v43; // rax
  common::milog::MiLogStream *v44; // r12
  int v45; // r15d
  DragonSpineActivity *v46; // rdi
  common::milog::MiLogStream *v47; // r12
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v48; // rax
  common::milog::MiLogStream *v49; // r12
  int v50; // r15d
  DragonSpineActivity *v51; // rdi
  common::milog::MiLogStream *v52; // r12
  std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v53; // rax
  common::milog::MiLogStream *v54; // r12
  int v55; // r15d
  std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v56; // rcx
  common::milog::MiLogStream *v57; // r12
  std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v58; // rax
  common::milog::MiLogStream *v59; // r12
  int v60; // r15d
  SeaLampActivity *v61; // rcx
  common::milog::MiLogStream *v62; // r12
  std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v63; // rax
  common::milog::MiLogStream *v64; // rax
  PlayerMechanicusComp *MechanicusComp; // rcx
  common::milog::MiLogStream *v66; // rax
  common::milog::MiLogStream *v67; // rax
  common::milog::MiLogStream *v68; // r12
  PlayerMechanicusComp *v69; // rax
  common::milog::MiLogStream *v70; // r12
  int v71; // r15d
  FleurFairActivity *v72; // rdi
  common::milog::MiLogStream *v73; // r12
  std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v74; // rax
  common::milog::MiLogStream *v75; // r12
  int v76; // r15d
  FleurFairActivity *v77; // rdi
  common::milog::MiLogStream *v78; // r12
  std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v79; // rax
  common::milog::MiLogStream *v80; // r12
  int v81; // r15d
  WaterSpiritActivity *v82; // rdi
  common::milog::MiLogStream *v83; // r12
  std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v84; // rax
  common::milog::MiLogStream *v85; // r12
  common::milog::MiLogStream *v86; // rax
  common::milog::MiLogStream *v87; // rax
  common::milog::MiLogStream *v88; // r12
  int v89; // r15d
  ChannellerSlabActivity *v90; // rdi
  common::milog::MiLogStream *v91; // r12
  std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v92; // rax
  common::milog::MiLogStream *v93; // r12
  int v94; // r15d
  SummerTimeActivity *v95; // rdi
  common::milog::MiLogStream *v96; // r12
  std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v97; // rax
  common::milog::MiLogStream *v98; // r12
  int v99; // r15d
  SummerTimeActivity *v100; // rdi
  common::milog::MiLogStream *v101; // r12
  std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v102; // rax
  common::milog::MiLogStream *v103; // r12
  int v104; // r15d
  BounceConjuringActivity *v105; // rdi
  common::milog::MiLogStream *v106; // r12
  std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v107; // rax
  common::milog::MiLogStream *v108; // r12
  int v109; // r15d
  BlitzRushActivity *v110; // rdi
  common::milog::MiLogStream *v111; // r12
  std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v112; // rax
  common::milog::MiLogStream *v113; // r12
  int v114; // r15d
  ChessActivity *v115; // rdi
  common::milog::MiLogStream *v116; // r12
  std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v117; // rax
  common::milog::MiLogStream *v118; // r12
  int v119; // r15d
  RoguelikeDungeonActivity *v120; // rdi
  common::milog::MiLogStream *v121; // r12
  std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v122; // rax
  common::milog::MiLogStream *v123; // r12
  int v124; // r15d
  WinterCampActivity *v125; // rdi
  common::milog::MiLogStream *v126; // r12
  std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v127; // rax
  common::milog::MiLogStream *v128; // r12
  int v129; // r15d
  LanternRiteActivity *v130; // rdi
  common::milog::MiLogStream *v131; // r12
  std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v132; // rax
  common::milog::MiLogStream *v133; // r12
  int v134; // r15d
  SummerTimeV2Activity *v135; // rdi
  common::milog::MiLogStream *v136; // r12
  std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v137; // rax
  common::milog::MiLogStream *v138; // r12
  int v139; // r15d
  RogueDiaryActivity *v140; // rdi
  common::milog::MiLogStream *v141; // r12
  std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v142; // rax
  common::milog::MiLogStream *v143; // r12
  int v144; // r15d
  GravenInnocenceActivity *v145; // rdi
  common::milog::MiLogStream *v146; // r12
  std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v147; // rax
  common::milog::MiLogStream *v148; // r12
  int v149; // r15d
  TreasureSeelieActivity *v150; // rdi
  common::milog::MiLogStream *v151; // r12
  std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v152; // rax
  common::milog::MiLogStream *v153; // r12
  int v154; // r15d
  VintageActivity *v155; // rdi
  common::milog::MiLogStream *v156; // r12
  std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v157; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v158; // rax
  common::milog::MiLogStream *v159; // rax
  uint32_t ActivityComp; // eax
  std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v161; // rax
  common::milog::MiLogStream *v163; // r12
  int v164; // r15d
  BaseActivity *v165; // rdi
  common::milog::MiLogStream *v166; // r12
  std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v167; // rax
  common::milog::MiLogStream *v168; // rax
  SubItemResult *M_current; // r15
  SubItemResult *v170; // r12
  int32_t result; // eax
  unsigned int val; // [rsp+24h] [rbp-22Ch] BYREF
  uint32_t activity_id; // [rsp+28h] [rbp-228h]
  int32_t ret_24; // [rsp+2Ch] [rbp-224h]
  proto::VirtualItem coin_type_7; // [rsp+30h] [rbp-220h]
  int32_t ret_23; // [rsp+34h] [rbp-21Ch]
  proto::VirtualItem coin_type_6; // [rsp+38h] [rbp-218h]
  int32_t ret_22; // [rsp+3Ch] [rbp-214h]
  proto::VirtualItem coin_type_5; // [rsp+40h] [rbp-210h]
  int32_t ret_21; // [rsp+44h] [rbp-20Ch]
  proto::VirtualItem coin_type_3; // [rsp+48h] [rbp-208h]
  int32_t ret_19; // [rsp+4Ch] [rbp-204h]
  proto::VirtualItem coin_type_4; // [rsp+50h] [rbp-200h]
  int32_t ret_20; // [rsp+54h] [rbp-1FCh]
  proto::VirtualItem coin_type_2; // [rsp+58h] [rbp-1F8h]
  int32_t ret_18; // [rsp+5Ch] [rbp-1F4h]
  proto::VirtualItem coin_type_1; // [rsp+60h] [rbp-1F0h]
  int32_t ret_17; // [rsp+64h] [rbp-1ECh]
  proto::VirtualItem coin_type_0; // [rsp+68h] [rbp-1E8h]
  int32_t ret_16; // [rsp+6Ch] [rbp-1E4h]
  int32_t ret_15; // [rsp+70h] [rbp-1E0h]
  proto::VirtualItem coin_type; // [rsp+74h] [rbp-1DCh]
  int32_t ret_14; // [rsp+78h] [rbp-1D8h]
  int32_t ret_13; // [rsp+7Ch] [rbp-1D4h]
  int32_t ret_12; // [rsp+80h] [rbp-1D0h]
  int32_t ret_11; // [rsp+84h] [rbp-1CCh]
  int32_t ret_10; // [rsp+88h] [rbp-1C8h]
  int32_t ret_9; // [rsp+8Ch] [rbp-1C4h]
  int32_t ret_8; // [rsp+90h] [rbp-1C0h]
  int32_t ret_7; // [rsp+94h] [rbp-1BCh]
  int32_t ret_6; // [rsp+98h] [rbp-1B8h]
  int32_t ret_5; // [rsp+9Ch] [rbp-1B4h]
  int32_t ret_4; // [rsp+A0h] [rbp-1B0h]
  int32_t ret_3; // [rsp+A4h] [rbp-1ACh]
  int32_t ret_2; // [rsp+A8h] [rbp-1A8h]
  int32_t ret_1; // [rsp+ACh] [rbp-1A4h]
  int32_t ret_0; // [rsp+B0h] [rbp-1A0h]
  int32_t ret; // [rsp+B4h] [rbp-19Ch]
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+B8h] [rbp-198h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+C0h] [rbp-190h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+C8h] [rbp-188h]
  const ItemParam *item_param; // [rsp+D0h] [rbp-180h]
  const data::ItemConfig *item_config_ptr; // [rsp+D8h] [rbp-178h]
  common::milog::MiLogStream v216; // [rsp+E0h] [rbp-170h] BYREF
  char v217[336]; // [rsp+100h] [rbp-150h] BYREF

  v4 = (unsigned __int64)v217;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_3(288LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "5 48 4 14 coin_type:5505 64 16 17 activity_ptr:5512 96 24 30 item_param_vec_no_virtual:4921 160 "
                        "24 22 finanl_sub_result:4922 224 24 15 sub_result:5541";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::subItemBatch;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556943;
  v6[536862722] = -219021312;
  v6[536862723] = -234881024;
  v6[536862724] = -218959118;
  v6[536862725] = -234881024;
  v6[536862726] = -218959118;
  v6[536862727] = -218103808;
  v6[536862728] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 96));
  std::vector<SubItemResult>::vector((std::vector<SubItemResult> *const)(v4 + 160));
  __for_range = item_param_vec;
  __for_begin._M_current = std::vector<ItemParam>::begin(item_param_vec)._M_current;
  __for_end._M_current = std::vector<ItemParam>::end(item_param_vec)._M_current;
  while ( 1 )
  {
    if ( !__gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
    {
      PackItemStore::subItemBatch(
        (std::vector<SubItemResult> *)(v4 + 224),
        &this->pack_store_,
        (const std::vector<ItemParam> *)(v4 + 96),
        reason);
      M_current = std::vector<SubItemResult>::end((std::vector<SubItemResult> *const)(v4 + 224))._M_current;
      v170 = std::vector<SubItemResult>::begin((std::vector<SubItemResult> *const)(v4 + 224))._M_current;
      __for_begin._M_current = (const ItemParam *)std::vector<SubItemResult>::end((std::vector<SubItemResult> *const)(v4 + 160))._M_current;
      __gnu_cxx::__normal_iterator<SubItemResult const*,std::vector<SubItemResult>>::__normal_iterator<SubItemResult*>(
        (__gnu_cxx::__normal_iterator<const SubItemResult*,std::vector<SubItemResult> > *const)&__for_end,
        (const __gnu_cxx::__normal_iterator<SubItemResult*,std::vector<SubItemResult> > *)&__for_begin);
      std::vector<SubItemResult>::insert<__gnu_cxx::__normal_iterator<SubItemResult*,std::vector<SubItemResult>>,void>(
        (std::vector<SubItemResult> *const)(v4 + 160),
        (std::vector<SubItemResult>::const_iterator)__for_end._M_current,
        (__gnu_cxx::__normal_iterator<SubItemResult*,std::vector<SubItemResult> >)v170,
        (__gnu_cxx::__normal_iterator<SubItemResult*,std::vector<SubItemResult> >)M_current);
      PlayerItemComp::triggerItemSubEvent(this, (const std::vector<SubItemResult> *)(v4 + 160), reason);
      v3 = 0;
      std::vector<SubItemResult>::~vector((std::vector<SubItemResult> *const)(v4 + 224));
      goto LABEL_470;
    }
    item_param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v4 + 64));
    p_item_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64))->design_config.txt_config_mgr.item_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_param);
    }
    item_config_ptr = ItemExcelConfigMgr::findItemConfig(p_item_config_mgr, item_param->item_id);
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 64));
    if ( !item_config_ptr )
    {
      common::milog::MiLogStream::create(
        &v216,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "subItemBatch",
        4928);
      v8 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
             &v216,
             (const char (*)[28])"findItemConfig failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, &val);
      v10 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v9, (const char (*)[10])" item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v216);
      v3 = -1;
      goto LABEL_470;
    }
    if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                     + 0x7FFF8000) )
    {
      __asan_report_load4(&item_config_ptr->item_type);
    }
    if ( item_config_ptr->item_type == ITEM_VIRTUAL )
      break;
    std::vector<ItemParam>::emplace_back<ItemParam const&>(
      (std::vector<ItemParam> *const)(v4 + 96),
      item_param,
      item_param);
LABEL_468:
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
  }
  *(_QWORD *)(v4 + 224) = 0LL;
  *(_DWORD *)(v4 + 232) = 0;
  *(_DWORD *)(v4 + 236) = 0;
  *(_DWORD *)(v4 + 240) = 0;
  if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(item_param);
  }
  *(_DWORD *)(v4 + 232) = item_param->item_id;
  if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&item_param->count);
  }
  *(_DWORD *)(v4 + 236) = item_param->count;
  switch ( item_param->item_id )
  {
    case 0x65u:
    case 0x66u:
    case 0x69u:
    case 0x6Cu:
    case 0x79u:
    case 0x81u:
    case 0x83u:
    case 0x92u:
    case 0x13Au:
    case 0x13Bu:
    case 0x13Cu:
    case 0x13Du:
      common::milog::MiLogStream::create(
        &v216,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "subItemBatch",
        4951);
      v11 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(&v216, (const char (*)[36])off_26391DE0);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v216);
      goto LABEL_468;
    case 0x6Au:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      if ( PlayerItemComp::subResin(this, item_param->count, reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          4991);
        v23 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                &v216,
                (const char (*)[29])"resin sub failed, cur_resin:");
        val = PlayerItemComp::getResin(this);
        v24 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v23, &val);
        v25 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v24, (const char (*)[8])" count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v25, &item_param->count);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        goto LABEL_470;
      }
      *(_DWORD *)(v4 + 240) = PlayerItemComp::getResin(this);
      std::vector<SubItemResult>::emplace_back<SubItemResult&>(
        (std::vector<SubItemResult> *const)(v4 + 160),
        (SubItemResult *)(v4 + 224),
        (SubItemResult *)(v4 + 224));
      goto LABEL_468;
    case 0x6Bu:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      if ( PlayerItemComp::subLegendaryKey(this, item_param->count, reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5002);
        v26 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                &v216,
                (const char (*)[45])"legendary_key sub failed, cur_legendary_key:");
        val = PlayerItemComp::getLegendaryKey(this);
        v27 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v26, &val);
        v28 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v27, (const char (*)[8])" count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v28, &item_param->count);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        goto LABEL_470;
      }
      *(_DWORD *)(v4 + 240) = PlayerItemComp::getLegendaryKey(this);
      std::vector<SubItemResult>::emplace_back<SubItemResult&>(
        (std::vector<SubItemResult> *const)(v4 + 160),
        (SubItemResult *)(v4 + 224),
        (SubItemResult *)(v4 + 224));
      goto LABEL_468;
    case 0x6Du:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<AsterActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<AsterActivity>(0LL, (const std::shared_ptr<AsterActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5014);
        v29 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v216,
                (const char (*)[39])"[ASTER] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v29, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v30 = 0;
      }
      else
      {
        p_count = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          p_count = (AsterActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret = AsterActivity::subAsterCredit(p_count, item_param->count, reason, 1);
        if ( ret )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5021);
          v32 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                  &v216,
                  (const char (*)[36])"[ASTER] subAsterCredit failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v32, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret;
          v30 = 0;
        }
        else
        {
          v33 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = AsterActivity::getAsterCredit(v33);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v30 = 1;
        }
      }
      std::shared_ptr<AsterActivity>::~shared_ptr((std::shared_ptr<AsterActivity> *const)(v4 + 64));
      if ( v30 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x6Eu:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<AsterActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<AsterActivity>(0LL, (const std::shared_ptr<AsterActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5033);
        v34 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v216,
                (const char (*)[39])"[ASTER] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v34, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v35 = 0;
      }
      else
      {
        v36 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v36 = (AsterActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_0 = AsterActivity::subAsterToken(v36, item_param->count, reason, 1);
        if ( ret_0 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5040);
          v37 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                  &v216,
                  (const char (*)[35])"[ASTER] subAsterToken failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v37, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_0;
          v35 = 0;
        }
        else
        {
          v38 = std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AsterActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = AsterActivity::getAsterToken(v38);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v35 = 1;
        }
      }
      std::shared_ptr<AsterActivity>::~shared_ptr((std::shared_ptr<AsterActivity> *const)(v4 + 64));
      if ( v35 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x6Fu:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5052);
        v39 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v216,
                (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v39, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v40 = 0;
      }
      else
      {
        v41 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v41 = (DragonSpineActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_1 = DragonSpineActivity::subShimmeringEssence(v41, item_param->count, reason, 1);
        if ( ret_1 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5059);
          v42 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                  &v216,
                  (const char (*)[49])"[DRAGON_SPINE] subShimmeringEssence failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v42, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_1;
          v40 = 0;
        }
        else
        {
          v43 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = DragonSpineActivity::getShimmeringEssence(v43);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v40 = 1;
        }
      }
      std::shared_ptr<DragonSpineActivity>::~shared_ptr((std::shared_ptr<DragonSpineActivity> *const)(v4 + 64));
      if ( v40 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x70u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5071);
        v44 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v216,
                (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v44, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v45 = 0;
      }
      else
      {
        v46 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v46 = (DragonSpineActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_2 = DragonSpineActivity::subWarmEssence(v46, item_param->count, reason, 1);
        if ( ret_2 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5078);
          v47 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                  &v216,
                  (const char (*)[43])"[DRAGON_SPINE] subWarmEssence failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v47, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_2;
          v45 = 0;
        }
        else
        {
          v48 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = DragonSpineActivity::getWarmEssence(v48);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v45 = 1;
        }
      }
      std::shared_ptr<DragonSpineActivity>::~shared_ptr((std::shared_ptr<DragonSpineActivity> *const)(v4 + 64));
      if ( v45 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x71u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<DragonSpineActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<DragonSpineActivity>(0LL, (const std::shared_ptr<DragonSpineActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5090);
        v49 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v216,
                (const char (*)[46])"[DRAGON_SPINE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v49, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v50 = 0;
      }
      else
      {
        v51 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v51 = (DragonSpineActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_3 = DragonSpineActivity::subWondrousEssence(v51, item_param->count, reason, 1);
        if ( ret_3 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5097);
          v52 = common::milog::MiLogStream::operator<<<char [47],(char *[47])0>(
                  &v216,
                  (const char (*)[47])"[DRAGON_SPINE] subWondrousEssence failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v52, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_3;
          v50 = 0;
        }
        else
        {
          v53 = std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DragonSpineActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = DragonSpineActivity::getWondrousEssence(v53);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v50 = 1;
        }
      }
      std::shared_ptr<DragonSpineActivity>::~shared_ptr((std::shared_ptr<DragonSpineActivity> *const)(v4 + 64));
      if ( v50 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x72u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<TreasureMapActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<TreasureMapActivity>(0LL, (const std::shared_ptr<TreasureMapActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5109);
        v54 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v216,
                (const char (*)[46])"[TREASURE_MAP] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v54, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v55 = 0;
      }
      else
      {
        v56 = std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_4 = TreasureMapActivity::subToken(v56, item_param->count);
        if ( ret_4 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5116);
          v57 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                  &v216,
                  (const char (*)[37])"[TREASURE_MAP] subToken failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v57, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_4;
          v55 = 0;
        }
        else
        {
          v58 = std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureMapActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = TreasureMapActivity::getToken(v58);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v55 = 1;
        }
      }
      std::shared_ptr<TreasureMapActivity>::~shared_ptr((std::shared_ptr<TreasureMapActivity> *const)(v4 + 64));
      if ( v55 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x73u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SeaLampActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<SeaLampActivity>(0LL, (const std::shared_ptr<SeaLampActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5128);
        v59 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                &v216,
                (const char (*)[30])"[SEA_LAMP] not openning, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v59, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v60 = 0;
      }
      else
      {
        v61 = std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        ret_5 = SeaLampActivity::subSeaLampCoin(v61, item_param->count, reason);
        if ( ret_5 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5134);
          v62 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
                  &v216,
                  (const char (*)[38])"[SEA_LAMP] subSeaLampCoin fails, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v62, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_5;
          v60 = 0;
        }
        else
        {
          v63 = std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SeaLampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = SeaLampActivity::getSeaLampCoin(v63);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v60 = 1;
        }
      }
      std::shared_ptr<SeaLampActivity>::~shared_ptr((std::shared_ptr<SeaLampActivity> *const)(v4 + 64));
      if ( v60 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x74u:
      common::milog::MiLogStream::create(
        &v216,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "subItemBatch",
        5143);
      v64 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(&v216, (const char (*)[36])off_26391DE0);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v64, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v216);
      v3 = -1;
      goto LABEL_470;
    case 0x75u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      MechanicusComp = Player::getMechanicusComp(this->player_);
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      ret_6 = PlayerMechanicusComp::subCoin(MechanicusComp, item_param->count, reason);
      if ( ret_6 )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5151);
        v66 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(&v216, (const char (*)[16])off_263930C0);
        v67 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v66, &item_param->count);
        v68 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v67, (const char (*)[12])" fails,uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v68, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = ret_6;
        goto LABEL_470;
      }
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v69 = Player::getMechanicusComp(this->player_);
      *(_DWORD *)(v4 + 240) = PlayerMechanicusComp::getCoin(v69);
      std::vector<SubItemResult>::emplace_back<SubItemResult&>(
        (std::vector<SubItemResult> *const)(v4 + 160),
        (SubItemResult *)(v4 + 224),
        (SubItemResult *)(v4 + 224));
      goto LABEL_468;
    case 0x76u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<FleurFairActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<FleurFairActivity>(0LL, (const std::shared_ptr<FleurFairActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5163);
        v70 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                &v216,
                (const char (*)[44])"[FLEUR_FAIR] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v70, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v71 = 0;
      }
      else
      {
        v72 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v72 = (FleurFairActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_7 = FleurFairActivity::subCredit(v72, item_param->count, reason, 1);
        if ( ret_7 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5170);
          v73 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                  &v216,
                  (const char (*)[36])"[FLEUR_FAIR] subCredit failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v73, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_7;
          v71 = 0;
        }
        else
        {
          v74 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = FleurFairActivity::getCredit(v74);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v71 = 1;
        }
      }
      std::shared_ptr<FleurFairActivity>::~shared_ptr((std::shared_ptr<FleurFairActivity> *const)(v4 + 64));
      if ( v71 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x77u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<FleurFairActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<FleurFairActivity>(0LL, (const std::shared_ptr<FleurFairActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5182);
        v75 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                &v216,
                (const char (*)[44])"[FLEUR_FAIR] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v75, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v76 = 0;
      }
      else
      {
        v77 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v77 = (FleurFairActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_8 = FleurFairActivity::subToken(v77, item_param->count, reason, 1);
        if ( ret_8 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5189);
          v78 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                  &v216,
                  (const char (*)[35])"[FLEUR_FAIR] subToken failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v78, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_8;
          v76 = 0;
        }
        else
        {
          v79 = std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FleurFairActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = FleurFairActivity::getToken(v79);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v76 = 1;
        }
      }
      std::shared_ptr<FleurFairActivity>::~shared_ptr((std::shared_ptr<FleurFairActivity> *const)(v4 + 64));
      if ( v76 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x78u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<WaterSpiritActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<WaterSpiritActivity>(0LL, (const std::shared_ptr<WaterSpiritActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5201);
        v80 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
                &v216,
                (const char (*)[46])"[WATER_SPIRIT] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v80, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v81 = 0;
      }
      else
      {
        v82 = std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v82 = (WaterSpiritActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_9 = WaterSpiritActivity::subSpiritCoin(v82, item_param->count, reason, 1);
        if ( ret_9 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5208);
          v83 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                  &v216,
                  (const char (*)[42])"[WATER_SPIRIT] subSpiritCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v83, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_9;
          v81 = 0;
        }
        else
        {
          v84 = std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WaterSpiritActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = WaterSpiritActivity::getSpiritCoin(v84);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v81 = 1;
        }
      }
      std::shared_ptr<WaterSpiritActivity>::~shared_ptr((std::shared_ptr<WaterSpiritActivity> *const)(v4 + 64));
      if ( v81 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x7Au:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<ChannellerSlabActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<ChannellerSlabActivity>(0LL, (const std::shared_ptr<ChannellerSlabActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5231);
        v88 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                &v216,
                (const char (*)[49])"[CHANNELLER_SLAB] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v88, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v89 = 0;
      }
      else
      {
        v90 = std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v90 = (ChannellerSlabActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_10 = ChannellerSlabActivity::subToken(v90, item_param->count, reason, 1);
        if ( ret_10 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5237);
          v91 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                  &v216,
                  (const char (*)[41])"[CHANNELLER_SLAB] subToken failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v91, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_10;
          v89 = 0;
        }
        else
        {
          v92 = std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChannellerSlabActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = ChannellerSlabActivity::getToken(v92);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v89 = 1;
        }
      }
      std::shared_ptr<ChannellerSlabActivity>::~shared_ptr((std::shared_ptr<ChannellerSlabActivity> *const)(v4 + 64));
      if ( v89 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x7Cu:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SummerTimeActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<SummerTimeActivity>(0LL, (const std::shared_ptr<SummerTimeActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5249);
        v93 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                &v216,
                (const char (*)[45])"[SUMMER_TIME] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v93, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v94 = 0;
      }
      else
      {
        v95 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v95 = (SummerTimeActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_11 = SummerTimeActivity::subDraftWood(v95, item_param->count, reason, 1);
        if ( ret_11 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5255);
          v96 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                  &v216,
                  (const char (*)[41])"[SUMMER_TIME] subDraftWood failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v96, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_11;
          v94 = 0;
        }
        else
        {
          v97 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = SummerTimeActivity::getDraftWood(v97);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v94 = 1;
        }
      }
      std::shared_ptr<SummerTimeActivity>::~shared_ptr((std::shared_ptr<SummerTimeActivity> *const)(v4 + 64));
      if ( v94 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x7Du:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SummerTimeActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<SummerTimeActivity>(0LL, (const std::shared_ptr<SummerTimeActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5267);
        v98 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                &v216,
                (const char (*)[45])"[SUMMER_TIME] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v98, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v99 = 0;
      }
      else
      {
        v100 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v100 = (SummerTimeActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_12 = SummerTimeActivity::subMiniHarpastum(v100, item_param->count, reason, 1);
        if ( ret_12 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5273);
          v101 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                   &v216,
                   (const char (*)[45])"[SUMMER_TIME] subMiniHarpastum failed, uid: ");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v101, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_12;
          v99 = 0;
        }
        else
        {
          v102 = std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = SummerTimeActivity::getMiniHarpastum(v102);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v99 = 1;
        }
      }
      std::shared_ptr<SummerTimeActivity>::~shared_ptr((std::shared_ptr<SummerTimeActivity> *const)(v4 + 64));
      if ( v99 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x7Eu:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<BounceConjuringActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<BounceConjuringActivity>(0LL, (const std::shared_ptr<BounceConjuringActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5285);
        v103 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
                 &v216,
                 (const char (*)[50])"[BOUNCE_CONJURING] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v103, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v104 = 0;
      }
      else
      {
        v105 = std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v105 = (BounceConjuringActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_13 = BounceConjuringActivity::subCoin(v105, item_param->count, reason, 1);
        if ( ret_13 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5292);
          v106 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                   &v216,
                   (const char (*)[40])"[BOUNCE_CONJURING] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v106, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_13;
          v104 = 0;
        }
        else
        {
          v107 = std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BounceConjuringActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = BounceConjuringActivity::getCoin(v107);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v104 = 1;
        }
      }
      std::shared_ptr<BounceConjuringActivity>::~shared_ptr((std::shared_ptr<BounceConjuringActivity> *const)(v4 + 64));
      if ( v104 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x7Fu:
    case 0x80u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<BlitzRushActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<BlitzRushActivity>(0LL, (const std::shared_ptr<BlitzRushActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5305);
        v108 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v216,
                 (const char (*)[44])"[BLITZ_RUSH] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v108, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v109 = 0;
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type = item_param->item_id;
        v110 = std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v110 = (BlitzRushActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_14 = BlitzRushActivity::subActivityCoin(v110, coin_type, item_param->count, reason, 1);
        if ( ret_14 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5312);
          v111 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
                   &v216,
                   (const char (*)[34])"[BLITZ_RUSH] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v111, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_14;
          v109 = 0;
        }
        else
        {
          v112 = std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BlitzRushActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = BlitzRushActivity::getActivityCoin(v112, coin_type);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v109 = 1;
        }
      }
      std::shared_ptr<BlitzRushActivity>::~shared_ptr((std::shared_ptr<BlitzRushActivity> *const)(v4 + 64));
      if ( v109 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x82u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<ChessActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<ChessActivity>(0LL, (const std::shared_ptr<ChessActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5324);
        v113 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                 &v216,
                 (const char (*)[39])"[CHESS] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v113, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v114 = 0;
      }
      else
      {
        v115 = std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v115 = (ChessActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_15 = ChessActivity::subCoin(v115, item_param->count, reason, 1);
        if ( ret_15 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5331);
          v116 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                   &v216,
                   (const char (*)[29])"[CHESS] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v116, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_15;
          v114 = 0;
        }
        else
        {
          v117 = std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<ChessActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = ChessActivity::getCoin(v117);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v114 = 1;
        }
      }
      std::shared_ptr<ChessActivity>::~shared_ptr((std::shared_ptr<ChessActivity> *const)(v4 + 64));
      if ( v114 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x84u:
    case 0x85u:
    case 0x86u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<RoguelikeDungeonActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<RoguelikeDungeonActivity>(0LL, (const std::shared_ptr<RoguelikeDungeonActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5345);
        v118 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
                 &v216,
                 (const char (*)[43])"[ROGUELIKE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v118, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v119 = 0;
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_0 = item_param->item_id;
        v120 = std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v120 = (RoguelikeDungeonActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_16 = RoguelikeDungeonActivity::subActivityCoin(v120, coin_type_0, item_param->count, reason, 1);
        if ( ret_16 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5352);
          v121 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
                   &v216,
                   (const char (*)[33])"[ROGUELIKE] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v121, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_16;
          v119 = 0;
        }
        else
        {
          v122 = std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RoguelikeDungeonActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = RoguelikeDungeonActivity::getActivityCoin(v122, coin_type_0);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v119 = 1;
        }
      }
      std::shared_ptr<RoguelikeDungeonActivity>::~shared_ptr((std::shared_ptr<RoguelikeDungeonActivity> *const)(v4 + 64));
      if ( v119 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x87u:
    case 0x88u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<WinterCampActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<WinterCampActivity>(0LL, (const std::shared_ptr<WinterCampActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5365);
        v123 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v216,
                 (const char (*)[44])"[WinterCamp] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v123, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v124 = 0;
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_1 = item_param->item_id;
        v125 = std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v125 = (WinterCampActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_17 = WinterCampActivity::subActivityCoin(v125, coin_type_1, item_param->count, reason, 1);
        if ( ret_17 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5372);
          v126 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
                   &v216,
                   (const char (*)[34])"[WinterCamp] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v126, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_17;
          v124 = 0;
        }
        else
        {
          v127 = std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<WinterCampActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = WinterCampActivity::getActivityCoin(v127, coin_type_1);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v124 = 1;
        }
      }
      std::shared_ptr<WinterCampActivity>::~shared_ptr((std::shared_ptr<WinterCampActivity> *const)(v4 + 64));
      if ( v124 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x89u:
    case 0x8Au:
    case 0x8Bu:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<LanternRiteActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<LanternRiteActivity>(0LL, (const std::shared_ptr<LanternRiteActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5386);
        v128 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                 &v216,
                 (const char (*)[45])"[LanternRite] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v128, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v129 = 0;
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_2 = item_param->item_id;
        v130 = std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v130 = (LanternRiteActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_18 = LanternRiteActivity::subActivityCoin(v130, coin_type_2, item_param->count, reason, 1);
        if ( ret_18 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5393);
          v131 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                   &v216,
                   (const char (*)[35])"[LanternRite] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v131, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_18;
          v129 = 0;
        }
        else
        {
          v132 = std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<LanternRiteActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = LanternRiteActivity::getActivityCoin(v132, coin_type_2);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v129 = 1;
        }
      }
      std::shared_ptr<LanternRiteActivity>::~shared_ptr((std::shared_ptr<LanternRiteActivity> *const)(v4 + 64));
      if ( v129 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x8Cu:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<RogueDiaryActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<RogueDiaryActivity>(0LL, (const std::shared_ptr<RogueDiaryActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5424);
        v138 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                 &v216,
                 (const char (*)[44])"[RogueDiary] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v138, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = 860;
        v139 = 0;
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_4 = item_param->item_id;
        v140 = std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v140 = (RogueDiaryActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_20 = RogueDiaryActivity::subActivityCoin(v140, coin_type_4, item_param->count, reason);
        if ( ret_20 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5431);
          v141 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
                   &v216,
                   (const char (*)[34])"[RogueDiary] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v141, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_20;
          v139 = 0;
        }
        else
        {
          v142 = std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<RogueDiaryActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = RogueDiaryActivity::getActivityCoin(v142, coin_type_4);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v139 = 1;
        }
      }
      std::shared_ptr<RogueDiaryActivity>::~shared_ptr((std::shared_ptr<RogueDiaryActivity> *const)(v4 + 64));
      if ( v139 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x8Du:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<SummerTimeV2Activity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<SummerTimeV2Activity>(0LL, (const std::shared_ptr<SummerTimeV2Activity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5405);
        v133 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(
                 &v216,
                 (const char (*)[48])"[SUMMER_TIME_V2] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v133, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v134 = 0;
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_3 = item_param->item_id;
        v135 = std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v135 = (SummerTimeV2Activity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_19 = SummerTimeV2Activity::subActivityCoin(v135, coin_type_3, item_param->count, reason, 1);
        if ( ret_19 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5412);
          v136 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
                   &v216,
                   (const char (*)[38])"[SUMMER_TIME_V2] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v136, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_19;
          v134 = 0;
        }
        else
        {
          v137 = std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SummerTimeV2Activity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = SummerTimeV2Activity::getActivityCoin(v137, coin_type_3);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v134 = 1;
        }
      }
      std::shared_ptr<SummerTimeV2Activity>::~shared_ptr((std::shared_ptr<SummerTimeV2Activity> *const)(v4 + 64));
      if ( v134 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x8Fu:
    case 0x90u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<GravenInnocenceActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<GravenInnocenceActivity>(0LL, (const std::shared_ptr<GravenInnocenceActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5444);
        v143 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                 &v216,
                 (const char (*)[49])"[GravenInnocence] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v143, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v144 = 0;
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_5 = item_param->item_id;
        v145 = std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v145 = (GravenInnocenceActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_21 = GravenInnocenceActivity::subActivityCoin(v145, coin_type_5, item_param->count, reason, 1);
        if ( ret_21 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5451);
          v146 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                   &v216,
                   (const char (*)[39])"[GravenInnocence] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v146, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_21;
          v144 = 0;
        }
        else
        {
          v147 = std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<GravenInnocenceActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = GravenInnocenceActivity::getActivityCoin(v147, coin_type_5);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v144 = 1;
        }
      }
      std::shared_ptr<GravenInnocenceActivity>::~shared_ptr((std::shared_ptr<GravenInnocenceActivity> *const)(v4 + 64));
      if ( v144 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x91u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<TreasureSeelieActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<TreasureSeelieActivity>(0LL, (const std::shared_ptr<TreasureSeelieActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5463);
        v148 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
                 &v216,
                 (const char (*)[49])"[TREASURE SEELIE] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v148, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v149 = 0;
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_6 = item_param->item_id;
        v150 = std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v150 = (TreasureSeelieActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_22 = TreasureSeelieActivity::subActivityCoin(v150, coin_type_6, item_param->count, reason, 1);
        if ( ret_22 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5470);
          v151 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                   &v216,
                   (const char (*)[39])"[TREASURE SEELIE] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v151, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_22;
          v149 = 0;
        }
        else
        {
          v152 = std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<TreasureSeelieActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = TreasureSeelieActivity::getActivityCoin(v152, coin_type_6);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v149 = 1;
        }
      }
      std::shared_ptr<TreasureSeelieActivity>::~shared_ptr((std::shared_ptr<TreasureSeelieActivity> *const)(v4 + 64));
      if ( v149 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x93u:
    case 0x94u:
    case 0x95u:
    case 0x96u:
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getActivityComp(this->player_);
      PlayerActivityComp::findOpenningActivity<VintageActivity>((PlayerActivityComp *const)(v4 + 64));
      if ( std::operator==<VintageActivity>(0LL, (const std::shared_ptr<VintageActivity> *)(v4 + 64)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5485);
        v153 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                 &v216,
                 (const char (*)[41])"[Vintage] activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v153, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        v154 = 0;
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        coin_type_7 = item_param->item_id;
        v155 = std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v155 = (VintageActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_23 = VintageActivity::subActivityCoin(v155, coin_type_7, item_param->count, reason, 1);
        if ( ret_23 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5492);
          v156 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                   &v216,
                   (const char (*)[31])"[Vintage] subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v156, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_23;
          v154 = 0;
        }
        else
        {
          v157 = std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<VintageActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = VintageActivity::getActivityCoin(v157, coin_type_7);
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v154 = 1;
        }
      }
      std::shared_ptr<VintageActivity>::~shared_ptr((std::shared_ptr<VintageActivity> *const)(v4 + 64));
      if ( v154 )
        goto LABEL_468;
      goto LABEL_470;
    case 0x97u:
    case 0x98u:
    case 0x99u:
    case 0x9Au:
      if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_param);
      }
      *(_DWORD *)(v4 + 48) = item_param->item_id;
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)(v4 + 64));
      v158 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
      activity_id = NewActivityExcelConfigMgr::findActivityIdByCoinType(
                      &v158->design_config.txt_config_mgr.new_activity_config_mgr,
                      *(proto::VirtualItem *)(v4 + 48));
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 64));
      if ( !activity_id )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5509);
        v159 = common::milog::MiLogStream::operator<<<char [64],(char *[64])0>(
                 &v216,
                 (const char (*)[64])"virutal coin cannot find corresponding activity id, coin_type: ");
        common::milog::MiLogStream::operator<<<proto::VirtualItem,(proto::VirtualItem*)0>(
          v159,
          (const proto::VirtualItem *)(v4 + 48));
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        goto LABEL_470;
      }
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      ActivityComp = (unsigned int)Player::getActivityComp(this->player_);
      PlayerActivityComp::findBaseActivity((PlayerActivityComp *const)(v4 + 64), ActivityComp);
      if ( std::operator==<BaseActivity>(0LL, (const std::shared_ptr<BaseActivity> *)(v4 + 64))
        || (v161 = std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64)),
            !BaseActivity::isOpening(v161, 0)) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5515);
        v163 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                 &v216,
                 (const char (*)[31])"activity is not opening, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v163, &val);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = 860;
        v164 = 0;
      }
      else
      {
        v165 = std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          v165 = (BaseActivity *)&item_param->count;
          __asan_report_load4(&item_param->count);
        }
        ret_24 = BaseActivity::subActivityGeneralCoin(
                   v165,
                   *(proto::VirtualItem *)(v4 + 48),
                   item_param->count,
                   reason,
                   1);
        if ( ret_24 )
        {
          common::milog::MiLogStream::create(
            &v216,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "subItemBatch",
            5521);
          v166 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
                   &v216,
                   (const char (*)[21])"subCoin failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v166, &val);
          common::milog::MiLogStream::~MiLogStream(&v216);
          v3 = ret_24;
          v164 = 0;
        }
        else
        {
          v167 = std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<BaseActivity,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
          *(_DWORD *)(v4 + 240) = BaseActivity::getActivityGeneralCoin(v167, *(proto::VirtualItem *)(v4 + 48));
          std::vector<SubItemResult>::emplace_back<SubItemResult&>(
            (std::vector<SubItemResult> *const)(v4 + 160),
            (SubItemResult *)(v4 + 224),
            (SubItemResult *)(v4 + 224));
          v164 = 1;
        }
      }
      std::shared_ptr<BaseActivity>::~shared_ptr((std::shared_ptr<BaseActivity> *const)(v4 + 64));
      if ( !v164 )
        goto LABEL_470;
      goto LABEL_468;
    case 0xC9u:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      if ( PlayerItemComp::subHcoin(this, item_param->count, reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          4969);
        v17 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                &v216,
                (const char (*)[29])"hcoin sub failed, cur_hcoin:");
        val = PlayerItemComp::getHcoin(this);
        v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, &val);
        v19 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v18, (const char (*)[8])" count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v19, &item_param->count);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        goto LABEL_470;
      }
      *(_DWORD *)(v4 + 240) = PlayerItemComp::getHcoin(this);
      std::vector<SubItemResult>::emplace_back<SubItemResult&>(
        (std::vector<SubItemResult> *const)(v4 + 160),
        (SubItemResult *)(v4 + 224),
        (SubItemResult *)(v4 + 224));
      goto LABEL_468;
    case 0xCAu:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      if ( PlayerItemComp::subScoin(this, item_param->count, reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          4980);
        v20 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                &v216,
                (const char (*)[29])"scoin sub failed, cur_scoin:");
        val = PlayerItemComp::getScoin(this);
        v21 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &val);
        v22 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v21, (const char (*)[8])" count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, &item_param->count);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        goto LABEL_470;
      }
      *(_DWORD *)(v4 + 240) = PlayerItemComp::getScoin(this);
      std::vector<SubItemResult>::emplace_back<SubItemResult&>(
        (std::vector<SubItemResult> *const)(v4 + 160),
        (SubItemResult *)(v4 + 224),
        (SubItemResult *)(v4 + 224));
      goto LABEL_468;
    case 0xCBu:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      if ( !PlayerItemComp::subMcoin(this, item_param->count, reason, 1) )
      {
        *(_DWORD *)(v4 + 240) = PlayerItemComp::getMcoin(this);
        std::vector<SubItemResult>::emplace_back<SubItemResult&>(
          (std::vector<SubItemResult> *const)(v4 + 160),
          (SubItemResult *)(v4 + 224),
          (SubItemResult *)(v4 + 224));
        goto LABEL_468;
      }
      common::milog::MiLogStream::create(
        &v216,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "subItemBatch",
        4958);
      v12 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
              &v216,
              (const char (*)[28])"mcoin sub fails, cur_mcoin:");
      *(_DWORD *)(v4 + 48) = PlayerItemComp::getMcoin(this);
      v13 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v12, (const unsigned int *)(v4 + 48));
      v14 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v13, (const char (*)[8])" count:");
      v15 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &item_param->count);
      v16 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v15, (const char (*)[6])" uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, &val);
      common::milog::MiLogStream::~MiLogStream(&v216);
      v3 = -1;
LABEL_470:
      std::vector<SubItemResult>::~vector((std::vector<SubItemResult> *const)(v4 + 160));
      std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 96));
      result = v3;
      if ( v217 == (char *)v4 )
      {
        *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
        *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
        *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
        *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
        *(_DWORD *)((v4 >> 3) + 0x7FFF8020) = 0;
      }
      else
      {
        *(_QWORD *)v4 = 1172321806LL;
        *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
        *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
        *(_DWORD *)((v4 >> 3) + 0x7FFF8020) = -168430091;
      }
      return result;
    case 0xCCu:
      if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                 + 0x7FFF8000) )
      {
        __asan_report_load4(&item_param->count);
      }
      if ( PlayerItemComp::subHomeCoin(this, item_param->count, reason, 1) )
      {
        common::milog::MiLogStream::create(
          &v216,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "subItemBatch",
          5219);
        v85 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                &v216,
                (const char (*)[37])"home_coin sub failed, cur_home_coin:");
        val = PlayerItemComp::getHomeCoin(this);
        v86 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v85, &val);
        v87 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v86, (const char (*)[8])" count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v87, &item_param->count);
        common::milog::MiLogStream::~MiLogStream(&v216);
        v3 = -1;
        goto LABEL_470;
      }
      *(_DWORD *)(v4 + 240) = PlayerItemComp::getHomeCoin(this);
      std::vector<SubItemResult>::emplace_back<SubItemResult&>(
        (std::vector<SubItemResult> *const)(v4 + 160),
        (SubItemResult *)(v4 + 224),
        (SubItemResult *)(v4 + 224));
      goto LABEL_468;
    default:
      common::milog::MiLogStream::create(
        &v216,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "subItemBatch",
        5530);
      v168 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
               &v216,
               (const char (*)[30])"unkown virutal item, item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v168, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v216);
      v3 = -1;
      goto LABEL_470;
  }
};

// Line 5550: range 0000000017CEAF0A-0000000017CEB0C9
int32_t __cdecl PlayerItemComp::checkSubItem(PlayerItemComp *const this, uint64_t guid)
{
  unsigned __int64 p_M_len; // rbx
  __int64 v3; // rax
  _DWORD *v4; // r12
  int32_t v5; // r14d
  int32_t result; // eax
  std::allocator<long unsigned int> __a; // [rsp+27h] [rbp-99h] BYREF
  std::initializer_list<long unsigned int> __l; // [rsp+28h] [rbp-98h] BYREF

  p_M_len = (unsigned __int64)&__l._M_len;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(96LL);
    if ( v3 )
      p_M_len = v3;
  }
  *(_QWORD *)p_M_len = 1102416563LL;
  *(_QWORD *)(p_M_len + 8) = "1 32 24 13 guid_vec:5551";
  *(_QWORD *)(p_M_len + 16) = PlayerItemComp::checkSubItem;
  v4 = (_DWORD *)(p_M_len >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -218103808;
  v4[536862722] = -202116109;
  __l._M_array = (std::initializer_list<long unsigned int>::iterator)guid;
  std::allocator<unsigned long>::allocator(&__a);
  std::vector<unsigned long>::vector(
    (std::vector<long unsigned int> *const)(p_M_len + 32),
    (std::initializer_list<long unsigned int>)__PAIR128__(1LL, &__l),
    &__a);
  std::allocator<unsigned long>::~allocator(&__a);
  v5 = PlayerItemComp::checkSubItemBatch(this, (const std::vector<long unsigned int> *)(p_M_len + 32));
  std::vector<unsigned long>::~vector((std::vector<long unsigned int> *const)(p_M_len + 32));
  result = v5;
  if ( &__l._M_len == (std::initializer_list<long unsigned int>::size_type *)p_M_len )
  {
    *(_QWORD *)((p_M_len >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((p_M_len >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)p_M_len = 1172321806LL;
    *(_QWORD *)((p_M_len >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((p_M_len >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 5556: range 0000000017CEB0CA-0000000017CEB0F2
int32_t __cdecl PlayerItemComp::checkSubItemBatch(
        PlayerItemComp *const this,
        const std::vector<long unsigned int> *guid_vec)
{
  return PackItemStore::checkSubItemBatch(&this->pack_store_, guid_vec);
};

// Line 5561: range 0000000017CEB0F4-0000000017CEB2C1
int32_t __cdecl PlayerItemComp::subItem(PlayerItemComp *const this, uint64_t guid, const SubItemReason *reason)
{
  unsigned __int64 p_M_len; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  int32_t v6; // r14d
  int32_t result; // eax
  std::allocator<long unsigned int> __a; // [rsp+27h] [rbp-99h] BYREF
  std::initializer_list<long unsigned int> __l; // [rsp+28h] [rbp-98h] BYREF

  p_M_len = (unsigned __int64)&__l._M_len;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      p_M_len = v4;
  }
  *(_QWORD *)p_M_len = 1102416563LL;
  *(_QWORD *)(p_M_len + 8) = "1 32 24 13 guid_vec:5562";
  *(_QWORD *)(p_M_len + 16) = PlayerItemComp::subItem;
  v5 = (_DWORD *)(p_M_len >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  __l._M_array = (std::initializer_list<long unsigned int>::iterator)guid;
  std::allocator<unsigned long>::allocator(&__a);
  std::vector<unsigned long>::vector(
    (std::vector<long unsigned int> *const)(p_M_len + 32),
    (std::initializer_list<long unsigned int>)__PAIR128__(1LL, &__l),
    &__a);
  std::allocator<unsigned long>::~allocator(&__a);
  v6 = PlayerItemComp::subItemBatch(this, (const std::vector<long unsigned int> *)(p_M_len + 32), reason);
  std::vector<unsigned long>::~vector((std::vector<long unsigned int> *const)(p_M_len + 32));
  result = v6;
  if ( &__l._M_len == (std::initializer_list<long unsigned int>::size_type *)p_M_len )
  {
    *(_QWORD *)((p_M_len >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((p_M_len >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)p_M_len = 1172321806LL;
    *(_QWORD *)((p_M_len >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((p_M_len >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 5567: range 0000000017CEB2C2-0000000017CEB42C
int32_t __cdecl PlayerItemComp::subItemBatch(
        PlayerItemComp *const this,
        const std::vector<long unsigned int> *guid_vec,
        const SubItemReason *reason)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  int32_t result; // eax
  char v8[144]; // [rsp+20h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v8;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 24 15 sub_result:5568";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::subItemBatch;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  PackItemStore::subItemBatch((std::vector<SubItemResult> *)(v3 + 32), &this->pack_store_, guid_vec, reason);
  PlayerItemComp::triggerItemSubEvent(this, (const std::vector<SubItemResult> *)(v3 + 32), reason);
  std::vector<SubItemResult>::~vector((std::vector<SubItemResult> *const)(v3 + 32));
  result = 0;
  if ( v8 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 5576: range 0000000017CEB42E-0000000017CEB652
// local variable allocation has failed, the output may be wrong!
ItemPtr __cdecl PlayerItemComp::forceAddEquipByAddAvatar(
        PlayerItemComp *const this,
        uint32_t item_id,
        const ActionReason *reason)
{
  const ActionReason *v3; // rcx
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  _DWORD *v6; // r12
  std::vector<AddItemResult>::reference v7; // rax
  __int64 guid; // rdx
  ItemPtr result; // rax
  const ActionReason *reasona; // [rsp+0h] [rbp-B0h]
  uint32_t item_ida; // [rsp+Ch] [rbp-A4h]
  char v12[144]; // [rsp+20h] [rbp-90h] BYREF

  item_ida = (unsigned int)reason;
  reasona = v3;
  v4 = (unsigned __int64)v12;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(96LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 24 15 result_vec:5577";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::forceAddEquipByAddAvatar;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -218103808;
  v6[536862722] = -202116109;
  ItemStore::forceAddEquipByAddAvatar(
    (std::vector<AddItemResult> *)(v4 + 32),
    (ItemStore *const)(*(_QWORD *)&item_id + 32LL),
    item_ida,
    reasona);
  PlayerItemComp::processByAddItemResultVec(
    *(PlayerItemComp *const *)&item_id,
    (const std::vector<AddItemResult> *)(v4 + 32));
  PlayerItemComp::triggerItemAddEvent(
    *(PlayerItemComp *const *)&item_id,
    (const std::vector<AddItemResult> *)(v4 + 32),
    0,
    reasona);
  if ( std::vector<AddItemResult>::empty((const std::vector<AddItemResult> *const)(v4 + 32)) )
  {
    std::shared_ptr<Item>::shared_ptr((std::shared_ptr<Item> *const)this, 0LL);
  }
  else
  {
    v7 = std::vector<AddItemResult>::operator[]((std::vector<AddItemResult> *const)(v4 + 32), 0LL);
    if ( *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    guid = v7->guid;
    if ( *(_WORD *)(((unsigned __int64)this >> 3) + 0x7FFF8000) )
      __asan_report_store16(this);
    ItemStore::findItem((ItemStore *const)this, *(_QWORD *)&item_id + 32LL, guid);
  }
  std::vector<AddItemResult>::~vector((std::vector<AddItemResult> *const)(v4 + 32));
  if ( v12 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = -168430091;
  }
  result._M_ptr = (std::__shared_ptr<Item,(__gnu_cxx::_Lock_policy)2>::element_type *)this;
  return result;
};

// Line 5596: range 0000000017CEB654-0000000017CEBA4E
uint32_t __fastcall PlayerItemComp::getPackMaterialCount(PlayerItemComp *const this, uint32_t item_id)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r13
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  common::milog::MiLogStream *v6; // r14
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  uint32_t result; // eax
  unsigned int v10; // eax
  unsigned int val; // [rsp+14h] [rbp-ACh] BYREF
  const data::ItemConfig *item_config_ptr; // [rsp+18h] [rbp-A8h]
  std::shared_ptr<Config> v13; // [rsp+20h] [rbp-A0h] BYREF
  common::milog::MiLogStream v14; // [rsp+30h] [rbp-90h] BYREF
  char v15[112]; // [rsp+50h] [rbp-70h] BYREF

  v2 = (unsigned __int64)v15;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 12 item_id:5595";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::getPackMaterialCount;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = item_id;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v13);
  v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v13);
  item_config_ptr = ItemExcelConfigMgr::findItemConfig(
                      &v5->design_config.txt_config_mgr.item_config_mgr,
                      *(_DWORD *)(v2 + 32));
  std::shared_ptr<Config>::~shared_ptr(&v13);
  if ( !item_config_ptr )
  {
    common::milog::MiLogStream::create(
      &v14,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "getPackMaterialCount",
      5600);
    v6 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
           &v14,
           (const char (*)[28])"findItemConfig failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, &val);
    v8 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v7, (const char (*)[10])" item_id:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, (const unsigned int *)(v2 + 32));
    common::milog::MiLogStream::~MiLogStream(&v14);
    result = 0;
    goto LABEL_29;
  }
  if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                   + 0x7FFF8000) )
  {
    __asan_report_load4(&item_config_ptr->item_type);
  }
  if ( item_config_ptr->item_type != ITEM_VIRTUAL )
  {
    result = ItemStore::getMaterialCount(&this->pack_store_, *(_DWORD *)(v2 + 32));
    goto LABEL_29;
  }
  v10 = *(_DWORD *)(v2 + 32);
  if ( v10 == 204 )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->home_coin_);
    }
    result = this->home_coin_;
  }
  else
  {
    if ( v10 > 0xCC )
    {
LABEL_27:
      result = 0;
      goto LABEL_29;
    }
    switch ( v10 )
    {
      case 0xCBu:
        result = PlayerItemComp::getMcoin(this);
        break;
      case 0xC9u:
        if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(&this->hcoin_);
        }
        result = this->hcoin_;
        break;
      case 0xCAu:
        if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&this->scoin_);
        }
        result = this->scoin_;
        break;
      default:
        goto LABEL_27;
    }
  }
LABEL_29:
  if ( v15 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 5627: range 0000000017CEBA50-0000000017CEBA75
uint32_t __cdecl PlayerItemComp::getPackMaterialCountWithSubtype(PlayerItemComp *const this, uint32_t material_type)
{
  return ItemStore::getMaterialCountWithMaterialType(&this->pack_store_, material_type);
};

// Line 5632: range 0000000017CEBA76-0000000017CED0C6
int32_t __cdecl PlayerItemComp::triggerItemAddEvent(
        PlayerItemComp *const this,
        const std::vector<AddItemResult> *result_vec,
        bool is_show_hint,
        const ActionReason *reason)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  const unsigned int *v7; // r9
  PlayerEventComp *EventComp; // r14
  PlayerEventComp *v9; // r14
  DungeonScene *p_item_id; // rdi
  uint32_t v11; // edx
  std::pair<std::_Rb_tree_const_iterator<unsigned int>,bool> v12; // rax
  PlayerWatcherComp *WatcherComp; // rcx
  MaterialExcelConfigMgr *p_material_config_mgr; // rcx
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v17; // rax
  proto::ItemHint *v18; // rax
  std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v19; // rax
  proto::ItemHint *v20; // rax
  std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v21; // rax
  google::protobuf::uint32 v22; // ecx
  unsigned int add_count; // r14d
  unsigned int v24; // eax
  google::protobuf::uint32 v25; // eax
  std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v26; // rax
  proto::ItemHint *v27; // rax
  std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v28; // rax
  const google::protobuf::RepeatedPtrField<proto::ItemHint> *v29; // rax
  std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v30; // rcx
  std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v31; // rcx
  std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v32; // rcx
  std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v33; // rcx
  Player *player; // r14
  unsigned int v35; // r14d
  std::map<unsigned int,unsigned int>::mapped_type *v36; // rax
  unsigned int *v37; // rdx
  SelectType v38; // r14d
  uint32_t *v39; // rsi
  std::map<unsigned int,unsigned int>::mapped_type *v40; // rax
  SelectType *v41; // rdx
  char v42; // cl
  common::milog::MiLogStream *v43; // r14
  std::__shared_ptr_access<proto::GadgetAutoPickDropInfoNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v44; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v45; // rax
  unsigned __int64 v46; // rdx
  proto::Material *v47; // rcx
  std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int> >::reference v48; // rax
  std::pair<unsigned int const,unsigned int> *v49; // rdx
  std::__shared_ptr_access<proto::GadgetAutoPickDropInfoNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v50; // rax
  proto::Material *v51; // rcx
  Player *v52; // r14
  int32_t result; // eax
  const ActionReason *reasona; // [rsp+0h] [rbp-250h]
  const proto::ActionReasonType *v55; // [rsp+8h] [rbp-248h]
  bool is_force_get_hint; // [rsp+29h] [rbp-227h]
  bool is_merged; // [rsp+2Ah] [rbp-226h]
  bool is_new; // [rsp+2Bh] [rbp-225h]
  unsigned int val; // [rsp+2Ch] [rbp-224h] BYREF
  std::vector<AddItemResult>::iterator __for_begin_0; // [rsp+30h] [rbp-220h] BYREF
  std::map<unsigned int,unsigned int>::iterator __for_begin_1; // [rsp+38h] [rbp-218h] BYREF
  std::map<unsigned int,unsigned int>::iterator __for_end_0; // [rsp+40h] [rbp-210h] BYREF
  const std::vector<AddItemResult> *__for_range; // [rsp+48h] [rbp-208h]
  std::vector<AddItemResult> *__for_range_0; // [rsp+50h] [rbp-200h]
  const std::vector<AddItemResult> *__for_range_2; // [rsp+58h] [rbp-1F8h]
  std::map<unsigned int,unsigned int> *__for_range_3; // [rsp+60h] [rbp-1F0h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *item_id; // [rsp+68h] [rbp-1E8h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *count; // [rsp+70h] [rbp-1E0h]
  proto::Item *proto_item_0; // [rsp+78h] [rbp-1D8h]
  const AddItemResult *add_result_1; // [rsp+80h] [rbp-1D0h]
  proto::Item *proto_item; // [rsp+88h] [rbp-1C8h]
  const AddItemResult *add_result_0; // [rsp+90h] [rbp-1C0h]
  google::protobuf::RepeatedPtrField<proto::ItemHint> *__for_range_1; // [rsp+98h] [rbp-1B8h]
  proto::ItemHint *proto_item_param; // [rsp+A0h] [rbp-1B0h]
  const AddItemResult *add_result; // [rsp+A8h] [rbp-1A8h]
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+B0h] [rbp-1A0h]
  std::pair<unsigned int const,unsigned int> __for_end; // [rsp+B8h] [rbp-198h] BYREF
  common::milog::MiLogStream v79; // [rsp+C0h] [rbp-190h] BYREF
  char v80[368]; // [rsp+E0h] [rbp-170h] BYREF

  reasona = reason;
  BYTE4(v55) = is_show_hint;
  v4 = (unsigned __int64)v80;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_3(320LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "6 48 16 15 notify_ptr:5633 80 16 42 gadget_auto_pick_drop_info_notify_ptr:5733 112 16 13 item_pt"
                        "r:5743 144 16 22 dungeon_scene_ptr:5664 176 24 34 overflow_transform_result_vec:5635 240 48 27 v"
                        "irtual_item_count_map:5734";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::triggerItemAddEvent;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = 61937;
  v6[536862722] = 62194;
  v6[536862723] = 62194;
  v6[536862724] = 62194;
  v6[536862725] = 62194;
  v6[536862726] = -218959360;
  v6[536862727] = 62194;
  v6[536862729] = -202116109;
  common::tools::perf::make_shared<proto::ItemAddHintNotify>();
  std::vector<AddItemResult>::vector((std::vector<AddItemResult> *const)(v4 + 176));
  __for_range = result_vec;
  __for_end_0._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int> >::_Base_ptr)std::vector<AddItemResult>::begin(result_vec)._M_current;
  __for_end = (std::pair<unsigned int const,unsigned int>)std::vector<AddItemResult>::end(result_vec)._M_current;
  while ( __gnu_cxx::operator!=<AddItemResult const*,std::vector<AddItemResult>>(
            (const __gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *)&__for_end_0,
            (const __gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *)&__for_end) )
  {
    add_result = __gnu_cxx::__normal_iterator<AddItemResult const*,std::vector<AddItemResult>>::operator*((const __gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *const)&__for_end_0);
    if ( *(_BYTE *)(((unsigned __int64)&add_result->item_id >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&add_result->item_id >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&add_result->item_id);
    }
    if ( add_result->item_id == 204 )
    {
      common::tools::perf::make_shared<HomeCoinEvent,unsigned int const&>(
        (const unsigned int *)(v4 + 112),
        &add_result->add_count);
      std::shared_ptr<BaseEvent>::shared_ptr<HomeCoinEvent,void>(
        (std::shared_ptr<BaseEvent> *const)(v4 + 80),
        (std::shared_ptr<HomeCoinEvent> *)(v4 + 112));
      std::shared_ptr<HomeCoinEvent>::~shared_ptr((std::shared_ptr<HomeCoinEvent> *const)(v4 + 112));
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      EventComp = Player::getEventComp(this->player_);
      std::shared_ptr<BaseEvent>::shared_ptr(
        (std::shared_ptr<BaseEvent> *const)(v4 + 144),
        (const std::shared_ptr<BaseEvent> *)(v4 + 80));
      PlayerEventComp::notifyEvent(EventComp, (BaseEventPtr *)(v4 + 144));
      std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)(v4 + 144));
      std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)(v4 + 80));
    }
    if ( *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)reasona & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona);
    }
    if ( reasona->reason_type != ACTION_REASON_FORGE_RETURN
      && reasona->reason_type != ACTION_REASON_FURNITURE_MAKE_CANCEL )
    {
      common::tools::perf::make_shared<ObtainItemEvent,unsigned int const&,unsigned int const&,unsigned long const&,proto::ActionReasonType const&>(
        (const unsigned int *)(v4 + 144),
        &add_result->item_id,
        (const unsigned __int64 *)&add_result->add_count,
        (const proto::ActionReasonType *)add_result,
        (const unsigned int *)reasona,
        v7,
        (const unsigned __int64 *)reasona,
        v55);
      std::shared_ptr<BaseEvent>::shared_ptr<ObtainItemEvent,void>(
        (std::shared_ptr<BaseEvent> *const)(v4 + 112),
        (std::shared_ptr<ObtainItemEvent> *)(v4 + 144));
      std::shared_ptr<ObtainItemEvent>::~shared_ptr((std::shared_ptr<ObtainItemEvent> *const)(v4 + 144));
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v9 = Player::getEventComp(this->player_);
      std::shared_ptr<BaseEvent>::shared_ptr(
        (std::shared_ptr<BaseEvent> *const)(v4 + 144),
        (const std::shared_ptr<BaseEvent> *)(v4 + 112));
      PlayerEventComp::notifyEvent(v9, (BaseEventPtr *)(v4 + 144));
      std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)(v4 + 144));
      std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)(v4 + 112));
    }
    if ( *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)reasona & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona);
    }
    if ( reasona->reason_type != ACTION_REASON_ADD_AVATAR )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::getSceneComp(this->player_);
      PlayerSceneComp::getCurScene<DungeonScene>((PlayerSceneComp *const)(v4 + 144));
      if ( std::operator!=<DungeonScene>(0LL, (const std::shared_ptr<DungeonScene> *)(v4 + 144)) )
      {
        p_item_id = std::__shared_ptr_access<DungeonScene,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<DungeonScene,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 144));
        if ( *(_BYTE *)(((unsigned __int64)&add_result->item_id >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&add_result->item_id >> 3) + 0x7FFF8000) <= 3 )
        {
          p_item_id = (DungeonScene *)&add_result->item_id;
          __asan_report_load4(&add_result->item_id);
        }
        v11 = add_result->item_id;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        {
          p_item_id = (DungeonScene *)&this->player_;
          __asan_report_load8();
        }
        DungeonScene::onItemAdd(p_item_id, this->player_, v11);
      }
      std::shared_ptr<DungeonScene>::~shared_ptr((std::shared_ptr<DungeonScene> *const)(v4 + 144));
    }
    v12 = std::set<unsigned int>::insert(&this->history_item_set_, &add_result->item_id);
    is_new = v12.second;
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    WatcherComp = Player::getWatcherComp(this->player_);
    if ( *(_BYTE *)(((unsigned __int64)&add_result->item_id >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&add_result->item_id >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&add_result->item_id);
    }
    PlayerWatcherComp::triggerCollectSetOfReadings(WatcherComp, add_result->item_id);
    is_force_get_hint = 0;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v4 + 144));
    p_material_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 144))->design_config.txt_config_mgr.material_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)&add_result->item_id >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&add_result->item_id >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&add_result->item_id);
    }
    material_config_ptr = data::MaterialExcelConfigMgrBase::findMaterialExcelConfig(
                            p_material_config_mgr,
                            add_result->item_id);
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 144));
    if ( material_config_ptr )
    {
      if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->is_force_get_hint >> 3) + 0x7FFF8000) != 0
        && (((unsigned __int8)material_config_ptr - 36) & 7) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->is_force_get_hint >> 3)
                                                                         + 0x7FFF8000) )
      {
        __asan_report_load1(&material_config_ptr->is_force_get_hint);
      }
      if ( material_config_ptr->is_force_get_hint )
      {
        is_force_get_hint = 1;
        common::milog::MiLogStream::create(
          &v79,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "triggerItemAddEvent",
          5680);
        v15 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(&v79, (const char (*)[7])" item:");
        v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, &add_result->item_id);
        common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v16, (const char (*)[17])" force get hint.");
        common::milog::MiLogStream::~MiLogStream(&v79);
      }
    }
    if ( *(_BYTE *)(((unsigned __int64)&add_result->is_auto_used >> 3) + 0x7FFF8000) != 0
      && (((unsigned __int8)add_result + 20) & 7) >= *(_BYTE *)(((unsigned __int64)&add_result->is_auto_used >> 3)
                                                              + 0x7FFF8000) )
    {
      __asan_report_load1(&add_result->is_auto_used);
    }
    if ( (!add_result->is_auto_used || is_force_get_hint) && BYTE4(v55) == 1 )
    {
      if ( *(_BYTE *)(((unsigned __int64)&add_result->is_by_overflow_transform >> 3) + 0x7FFF8000) != 0
        && (((unsigned __int8)add_result + 21) & 7) >= *(_BYTE *)(((unsigned __int64)&add_result->is_by_overflow_transform >> 3)
                                                                + 0x7FFF8000) )
      {
        __asan_report_load1(&add_result->is_by_overflow_transform);
      }
      if ( add_result->is_by_overflow_transform )
      {
        std::vector<AddItemResult>::push_back((std::vector<AddItemResult> *const)(v4 + 176), add_result);
      }
      else
      {
        v17 = std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 48));
        v18 = proto::ItemAddHintNotify::add_item_list(v17);
        AddItemResult::toProtoItemHint(add_result, v18, is_new);
      }
    }
    __gnu_cxx::__normal_iterator<AddItemResult const*,std::vector<AddItemResult>>::operator++((__gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *const)&__for_end_0);
  }
  __for_range_0 = (std::vector<AddItemResult> *)(v4 + 176);
  __for_begin_0._M_current = std::vector<AddItemResult>::begin((std::vector<AddItemResult> *const)(v4 + 176))._M_current;
  __for_begin_1._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int> >::_Base_ptr)std::vector<AddItemResult>::end(__for_range_0)._M_current;
  while ( __gnu_cxx::operator!=<AddItemResult *,std::vector<AddItemResult>>(
            &__for_begin_0,
            (const __gnu_cxx::__normal_iterator<AddItemResult*,std::vector<AddItemResult> > *)&__for_begin_1) )
  {
    add_result_0 = __gnu_cxx::__normal_iterator<AddItemResult *,std::vector<AddItemResult>>::operator*(&__for_begin_0);
    v19 = std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 48));
    v20 = proto::ItemAddHintNotify::add_overflow_transformed_item_list(v19);
    AddItemResult::toProtoItemHint(add_result_0, v20, 0);
    is_merged = 0;
    v21 = std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 48));
    __for_range_1 = proto::ItemAddHintNotify::mutable_item_list(v21);
    __for_end_0._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int> >::_Base_ptr)google::protobuf::RepeatedPtrField<proto::ItemHint>::begin(__for_range_1).it_;
    __for_end = (std::pair<unsigned int const,unsigned int>)google::protobuf::RepeatedPtrField<proto::ItemHint>::end(__for_range_1).it_;
    while ( google::protobuf::internal::RepeatedPtrIterator<proto::ItemHint>::operator!=(
              (const google::protobuf::internal::RepeatedPtrIterator<proto::ItemHint> *const)&__for_end_0,
              (const google::protobuf::internal::RepeatedPtrIterator<proto::ItemHint>::iterator *)&__for_end) )
    {
      proto_item_param = google::protobuf::internal::RepeatedPtrIterator<proto::ItemHint>::operator*((const google::protobuf::internal::RepeatedPtrIterator<proto::ItemHint> *const)&__for_end_0);
      v22 = proto::ItemHint::item_id(proto_item_param);
      if ( *(_BYTE *)(((unsigned __int64)&add_result_0->item_id >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&add_result_0->item_id >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&add_result_0->item_id);
      }
      if ( v22 == add_result_0->item_id )
      {
        if ( *(_BYTE *)(((unsigned __int64)&add_result_0->add_count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)add_result_0 + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&add_result_0->add_count >> 3)
                                                                      + 0x7FFF8000) )
        {
          __asan_report_load4(&add_result_0->add_count);
        }
        add_count = add_result_0->add_count;
        v24 = proto::ItemHint::count(proto_item_param);
        v25 = SAFE_ADD<unsigned int,unsigned int>(v24, add_count);
        proto::ItemHint::set_count(proto_item_param, v25);
        is_merged = 1;
        break;
      }
      google::protobuf::internal::RepeatedPtrIterator<proto::ItemHint>::operator++((google::protobuf::internal::RepeatedPtrIterator<proto::ItemHint> *const)&__for_end_0);
    }
    if ( !is_merged )
    {
      v26 = std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 48));
      v27 = proto::ItemAddHintNotify::add_item_list(v26);
      AddItemResult::toProtoItemHint(add_result_0, v27, 0);
    }
    __gnu_cxx::__normal_iterator<AddItemResult *,std::vector<AddItemResult>>::operator++(&__for_begin_0);
  }
  v28 = std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 48));
  v29 = proto::ItemAddHintNotify::item_list(v28);
  if ( !google::protobuf::RepeatedPtrField<proto::ItemHint>::empty(v29) )
  {
    v30 = std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 48));
    if ( *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)reasona & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona);
    }
    proto::ItemAddHintNotify::set_reason(v30, reasona->reason_type);
    v31 = std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 48));
    if ( *(_BYTE *)(((unsigned __int64)&reasona->quest_id >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reasona + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reasona->quest_id >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&reasona->quest_id);
    }
    proto::ItemAddHintNotify::set_quest_id(v31, reasona->quest_id);
    v32 = std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 48));
    if ( *(_BYTE *)(((unsigned __int64)&reasona->is_transfered_from_avatar_card >> 3) + 0x7FFF8000) != 0
      && (((unsigned __int8)reasona + 12) & 7) >= *(_BYTE *)(((unsigned __int64)&reasona->is_transfered_from_avatar_card >> 3)
                                                           + 0x7FFF8000) )
    {
      __asan_report_load1(&reasona->is_transfered_from_avatar_card);
    }
    proto::ItemAddHintNotify::set_is_transfered_from_avatar_card(v32, reasona->is_transfered_from_avatar_card);
    v33 = std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemAddHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 48));
    if ( *(_BYTE *)(((unsigned __int64)&reasona->is_general_reward_hiden >> 3) + 0x7FFF8000) != 0
      && (((unsigned __int8)reasona + 20) & 7) >= *(_BYTE *)(((unsigned __int64)&reasona->is_general_reward_hiden >> 3)
                                                           + 0x7FFF8000) )
    {
      __asan_report_load1(&reasona->is_general_reward_hiden);
    }
    proto::ItemAddHintNotify::set_is_general_reward_hiden(v33, reasona->is_general_reward_hiden);
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    player = this->player_;
    std::dynamic_pointer_cast<google::protobuf::Message const,proto::ItemAddHintNotify>((const std::shared_ptr<proto::ItemAddHintNotify> *)(v4 + 144));
    Player::sendMessage(player, (common::minet::ConstMessagePtr *)(v4 + 144), 0LL);
    std::shared_ptr<google::protobuf::Message const>::~shared_ptr((std::shared_ptr<const google::protobuf::Message> *const)(v4 + 144));
  }
  if ( *(_BYTE *)(((unsigned __int64)&reasona->is_show_gadget_auto_pick_drop_info_notify >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)reasona + 13) & 7) >= *(_BYTE *)(((unsigned __int64)&reasona->is_show_gadget_auto_pick_drop_info_notify >> 3)
                                                         + 0x7FFF8000) )
  {
    __asan_report_load1(&reasona->is_show_gadget_auto_pick_drop_info_notify);
  }
  if ( reasona->is_show_gadget_auto_pick_drop_info_notify )
  {
    common::tools::perf::make_shared<proto::GadgetAutoPickDropInfoNotify>();
    std::map<unsigned int,unsigned int>::map((std::map<unsigned int,unsigned int> *const)(v4 + 240));
    __for_range_2 = result_vec;
    __for_end_0._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int> >::_Base_ptr)std::vector<AddItemResult>::begin(result_vec)._M_current;
    __for_end = (std::pair<unsigned int const,unsigned int>)std::vector<AddItemResult>::end(__for_range_2)._M_current;
    while ( __gnu_cxx::operator!=<AddItemResult const*,std::vector<AddItemResult>>(
              (const __gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *)&__for_end_0,
              (const __gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *)&__for_end) )
    {
      add_result_1 = __gnu_cxx::__normal_iterator<AddItemResult const*,std::vector<AddItemResult>>::operator*((const __gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *const)&__for_end_0);
      if ( *(_BYTE *)(((unsigned __int64)add_result_1 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      if ( add_result_1->guid )
      {
        if ( *(_BYTE *)(((unsigned __int64)add_result_1 >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        PlayerItemComp::findItemInPack((PlayerItemComp *const)(v4 + 112), (uint64_t)this);
        if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v4 + 112), 0LL) )
        {
          common::milog::MiLogStream::create(
            &v79,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "triggerItemAddEvent",
            5746);
          v43 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
                  &v79,
                  (const char (*)[26])"item_ptr is nullptr, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v43, &val);
          common::milog::MiLogStream::~MiLogStream(&v79);
        }
        else
        {
          v44 = std::__shared_ptr_access<proto::GadgetAutoPickDropInfoNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::GadgetAutoPickDropInfoNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 80));
          proto_item = proto::GadgetAutoPickDropInfoNotify::add_item_list(v44);
          v45 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 112));
          if ( *(_BYTE *)(((unsigned __int64)v45 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v46 = (unsigned __int64)(v45->_vptr_Item + 4);
          if ( *(_BYTE *)((v46 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          (*(void (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, proto::Item *))v46)(
            v45,
            proto_item);
          std::dynamic_pointer_cast<Material,Item>((const std::shared_ptr<Item> *)(v4 + 144));
          if ( std::operator!=<Material>((const std::shared_ptr<Material> *)(v4 + 144), 0LL) )
          {
            v47 = proto::Item::mutable_material(proto_item);
            if ( *(_BYTE *)(((unsigned __int64)&add_result_1->add_count >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)add_result_1 + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&add_result_1->add_count >> 3)
                                                                          + 0x7FFF8000) )
            {
              __asan_report_load4(&add_result_1->add_count);
            }
            proto::Material::set_count(v47, add_result_1->add_count);
          }
          std::shared_ptr<Material>::~shared_ptr((std::shared_ptr<Material> *const)(v4 + 144));
        }
        std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v4 + 112));
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&add_result_1->add_count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)add_result_1 + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&add_result_1->add_count >> 3)
                                                                      + 0x7FFF8000) )
        {
          __asan_report_load4(&add_result_1->add_count);
        }
        v35 = add_result_1->add_count;
        v36 = std::map<unsigned int,unsigned int>::operator[](
                (std::map<unsigned int,unsigned int> *const)(v4 + 240),
                &add_result_1->item_id);
        v37 = v36;
        if ( *(_BYTE *)(((unsigned __int64)v36 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v36 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v36 >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(v36);
        }
        v38 = SAFE_ADD<unsigned int,unsigned int>(*v37, v35);
        v39 = &add_result_1->item_id;
        v40 = std::map<unsigned int,unsigned int>::operator[](
                (std::map<unsigned int,unsigned int> *const)(v4 + 240),
                &add_result_1->item_id);
        v41 = v40;
        v42 = *(_BYTE *)(((unsigned __int64)v40 >> 3) + 0x7FFF8000);
        if ( v42 != 0 && (char)(((unsigned __int8)v40 & 7) + 3) >= v42 )
        {
          LOBYTE(v39) = v42 != 0;
          __asan_report_store4(v40, v39, v40);
        }
        *v41 = v38;
      }
      __gnu_cxx::__normal_iterator<AddItemResult const*,std::vector<AddItemResult>>::operator++((__gnu_cxx::__normal_iterator<const AddItemResult*,std::vector<AddItemResult> > *const)&__for_end_0);
    }
    __for_range_3 = (std::map<unsigned int,unsigned int> *)(v4 + 240);
    __for_begin_1._M_node = std::map<unsigned int,unsigned int>::begin((std::map<unsigned int,unsigned int> *const)(v4 + 240))._M_node;
    __for_end_0._M_node = std::map<unsigned int,unsigned int>::end(__for_range_3)._M_node;
    while ( std::operator!=(&__for_begin_1, &__for_end_0) )
    {
      v48 = std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int>>::operator*(&__for_begin_1);
      v49 = v48;
      if ( ((unsigned __int8)v48 & 7) >= *(_BYTE *)(((unsigned __int64)v48 >> 3) + 0x7FFF8000)
        && *(_BYTE *)(((unsigned __int64)v48 >> 3) + 0x7FFF8000) != 0
        || *(_BYTE *)((((unsigned __int64)&v48->second + 3) >> 3) + 0x7FFF8000) != 0
        && (((unsigned __int8)v48 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v48->second + 3) >> 3) + 0x7FFF8000) )
      {
        __asan_report_load_n(v48, 8LL);
      }
      __for_end = *v49;
      item_id = std::get<0ul,unsigned int const,unsigned int>(&__for_end);
      count = std::get<1ul,unsigned int const,unsigned int>(&__for_end);
      v50 = std::__shared_ptr_access<proto::GadgetAutoPickDropInfoNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::GadgetAutoPickDropInfoNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 80));
      proto_item_0 = proto::GadgetAutoPickDropInfoNotify::add_item_list(v50);
      if ( *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_id);
      }
      proto::Item::set_item_id(proto_item_0, *item_id);
      v51 = proto::Item::mutable_material(proto_item_0);
      if ( *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(count);
      }
      proto::Material::set_count(v51, *count);
      std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int>>::operator++(&__for_begin_1);
    }
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v52 = this->player_;
    std::dynamic_pointer_cast<google::protobuf::Message const,proto::GadgetAutoPickDropInfoNotify>((const std::shared_ptr<proto::GadgetAutoPickDropInfoNotify> *)(v4 + 144));
    Player::sendMessage(v52, (common::minet::ConstMessagePtr *)(v4 + 144), 0LL);
    std::shared_ptr<google::protobuf::Message const>::~shared_ptr((std::shared_ptr<const google::protobuf::Message> *const)(v4 + 144));
    std::map<unsigned int,unsigned int>::~map((std::map<unsigned int,unsigned int> *const)(v4 + 240));
    std::shared_ptr<proto::GadgetAutoPickDropInfoNotify>::~shared_ptr((std::shared_ptr<proto::GadgetAutoPickDropInfoNotify> *const)(v4 + 80));
  }
  std::vector<AddItemResult>::~vector((std::vector<AddItemResult> *const)(v4 + 176));
  std::shared_ptr<proto::ItemAddHintNotify>::~shared_ptr((std::shared_ptr<proto::ItemAddHintNotify> *const)(v4 + 48));
  result = 0;
  if ( v80 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8024) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 5771: range 0000000017CED0C8-0000000017CED377
int32_t __cdecl PlayerItemComp::triggerItemSubEvent(
        PlayerItemComp *const this,
        const std::vector<SubItemResult> *result_vec,
        const SubItemReason *reason)
{
  std::shared_ptr<BaseEvent> *v3; // rbx
  __int64 v4; // rax
  unsigned __int64 v5; // r12
  int32_t result; // eax
  PlayerEventComp *EventComp; // r14
  std::vector<SubItemResult>::const_iterator __for_begin; // [rsp+20h] [rbp-A0h] BYREF
  std::vector<SubItemResult>::const_iterator __for_end; // [rsp+28h] [rbp-98h] BYREF
  const std::vector<SubItemResult> *__for_range; // [rsp+30h] [rbp-90h]
  const SubItemResult *sub_result; // [rsp+38h] [rbp-88h]
  std::shared_ptr<LoseItemEvent> __r; // [rsp+40h] [rbp-80h] BYREF
  char v14[112]; // [rsp+50h] [rbp-70h] BYREF

  v3 = (std::shared_ptr<BaseEvent> *)v14;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_0(64LL);
    if ( v4 )
      v3 = (std::shared_ptr<BaseEvent> *)v4;
  }
  v3->_M_ptr = (std::__shared_ptr<BaseEvent,(__gnu_cxx::_Lock_policy)2>::element_type *)1102416563;
  v3->_M_refcount._M_pi = (std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2> *)"1 32 16 14 event_ptr:5780";
  v3[1]._M_ptr = (std::__shared_ptr<BaseEvent,(__gnu_cxx::_Lock_policy)2>::element_type *)PlayerItemComp::triggerItemSubEvent;
  v5 = (unsigned __int64)v3 >> 3;
  *(_DWORD *)(v5 + 2147450880) = -235802127;
  *(_DWORD *)(v5 + 2147450884) = -202178560;
  if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(reason);
  }
  if ( reason->reason_type == ACTION_REASON_FORGE_COST || reason->reason_type == ACTION_REASON_FURNITURE_MAKE_START )
  {
    result = 0;
  }
  else
  {
    __for_range = result_vec;
    __for_begin._M_current = std::vector<SubItemResult>::begin(result_vec)._M_current;
    __for_end._M_current = std::vector<SubItemResult>::end(result_vec)._M_current;
    while ( __gnu_cxx::operator!=<SubItemResult const*,std::vector<SubItemResult>>(&__for_begin, &__for_end) )
    {
      sub_result = __gnu_cxx::__normal_iterator<SubItemResult const*,std::vector<SubItemResult>>::operator*(&__for_begin);
      common::tools::perf::make_shared<LoseItemEvent,unsigned int const&,unsigned int const&>(
        (const unsigned int *)&__r,
        &sub_result->item_id,
        &sub_result->sub_count,
        &sub_result->item_id);
      std::shared_ptr<BaseEvent>::shared_ptr<LoseItemEvent,void>(v3 + 2, &__r);
      std::shared_ptr<LoseItemEvent>::~shared_ptr(&__r);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      EventComp = Player::getEventComp(this->player_);
      std::shared_ptr<BaseEvent>::shared_ptr((std::shared_ptr<BaseEvent> *const)&__r, v3 + 2);
      PlayerEventComp::notifyEvent(EventComp, (BaseEventPtr *)&__r);
      std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)&__r);
      std::shared_ptr<BaseEvent>::~shared_ptr(v3 + 2);
      __gnu_cxx::__normal_iterator<SubItemResult const*,std::vector<SubItemResult>>::operator++(&__for_begin);
    }
    result = 0;
  }
  if ( v14 == (char *)v3 )
  {
    *(_QWORD *)(((unsigned __int64)v3 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    v3->_M_ptr = (std::__shared_ptr<BaseEvent,(__gnu_cxx::_Lock_policy)2>::element_type *)1172321806;
    *(_QWORD *)(((unsigned __int64)v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 5789: range 0000000017CED378-0000000017CED3D6
int32_t __cdecl PlayerItemComp::checkAddMcoin(
        PlayerItemComp *const this,
        uint32_t add_mcoin,
        const ActionReason *reason)
{
  uint32_t PlatformType; // ecx

  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  PlatformType = Player::getPlatformType(this->player_);
  return PlayerItemComp::checkAddMcoin(this, add_mcoin, reason, PlatformType);
};

// Line 5794: range 0000000017CED3D8-0000000017CED7F8
__int64 __fastcall PlayerItemComp::checkAddMcoin(
        PlayerItemComp *const this,
        uint32_t add_mcoin,
        const ActionReason *reason,
        uint32_t platform_type)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r13
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rcx
  unsigned int v12; // r14d
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  __int64 result; // rax
  std::allocator<ItemParam> __a; // [rsp+2Bh] [rbp-E5h] BYREF
  int32_t ret; // [rsp+2Ch] [rbp-E4h]
  std::initializer_list<ItemParam> __l; // [rsp+30h] [rbp-E0h] BYREF
  common::milog::MiLogStream v22; // [rsp+40h] [rbp-D0h] BYREF
  char v23[176]; // [rsp+60h] [rbp-B0h] BYREF

  v4 = (unsigned __int64)v23;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 4 10 mcoin:5802 48 4 14 add_mcoin:5793 64 24 19 item_param_vec:5795";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkAddMcoin;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556924;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  *(_DWORD *)(v4 + 48) = add_mcoin;
  LODWORD(__l._M_array) = 203;
  HIDWORD(__l._M_array) = *(_DWORD *)(v4 + 48);
  __l._M_len = 0LL;
  std::allocator<ItemParam>::allocator(&__a);
  std::vector<ItemParam>::vector(
    (std::vector<ItemParam> *const)(v4 + 64),
    (std::initializer_list<ItemParam>)__PAIR128__(1LL, &__l),
    &__a);
  std::allocator<ItemParam>::~allocator(&__a);
  ret = PlayerItemComp::checkOutputLimitBeforeCheckAddItemBatch<ItemParam>(
          this,
          (const std::vector<ItemParam> *)(v4 + 64),
          reason);
  if ( ret )
  {
    common::milog::MiLogStream::create(
      &v22,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkAddMcoin",
      5799);
    v7 = common::milog::MiLogStream::operator<<<char [62],(char *[62])0>(
           &v22,
           (const char (*)[62])"checkOutputLimitBeforeCheckAddItemBatch fail, item_param_vec:");
    v8 = common::milog::MiLogStream::operator<<<ItemParam>(v7, (const std::vector<ItemParam> *)(v4 + 64));
    v9 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v8, (const char (*)[9])" reason:");
    v10 = operator<<(v9, reason);
    v11 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v10, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v11, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v22);
    v12 = ret;
  }
  else
  {
    *(_DWORD *)(v4 + 32) = PlayerItemComp::getMcoin(this, platform_type);
    if ( (!*(_DWORD *)(v4 + 48)
       || !*(_DWORD *)(v4 + 32)
       || (unsigned int)(*(_DWORD *)(v4 + 32) + *(_DWORD *)(v4 + 48)) >= *(_DWORD *)(v4 + 48))
      && (*(_DWORD *)(v4 + 48)
       || *(_DWORD *)(v4 + 32)
       || (unsigned int)(*(_DWORD *)(v4 + 32) + *(_DWORD *)(v4 + 48)) <= *(_DWORD *)(v4 + 48)) )
    {
      v12 = 0;
    }
    else
    {
      common::milog::MiLogStream::create(
        &v22,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAddMcoin",
        5805);
      v13 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
              &v22,
              (const char (*)[31])"mcoin add overflow, cur_mcoin:");
      v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v4 + 32));
      v15 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v14, (const char (*)[12])" add_mcoin:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, (const unsigned int *)(v4 + 48));
      common::milog::MiLogStream::~MiLogStream(&v22);
      v12 = 627;
    }
  }
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 64));
  result = v12;
  if ( v23 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 5812: range 0000000017CED7FA-0000000017CED864
int32_t __cdecl PlayerItemComp::addMcoin(
        PlayerItemComp *const this,
        uint32_t add_mcoin,
        const ActionReason *reason,
        bool is_notify)
{
  uint32_t PlatformType; // edi

  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  PlatformType = Player::getPlatformType(this->player_);
  return PlayerItemComp::addMcoin(this, add_mcoin, reason, is_notify, PlatformType);
};

// Line 5817: range 0000000017CED866-0000000017CEE2CA
__int64 __fastcall PlayerItemComp::addMcoin(
        PlayerItemComp *const this,
        uint32_t add_mcoin,
        const ActionReason *reason,
        bool is_notify,
        uint32_t platform_type)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rcx
  unsigned int v13; // r14d
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  PlayerBasicComp *BasicComp; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  uint32_t Mcoin; // eax
  uint32_t WaitSubMcoin; // eax
  proto::PropValue *i; // r14
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  data::ItemLimitType limit_type; // r14d
  uint32_t reason_type; // r15d
  int64_t AllPlatRealLeftMcoin; // rax
  __int64 result; // rax
  std::string v30; // [rsp+0h] [rbp-1F0h]
  common::milog::MiLogStream *__l; // [rsp+10h] [rbp-1E0h]
  std::allocator<ItemParam> __a; // [rsp+43h] [rbp-1ADh] BYREF
  unsigned int val; // [rsp+44h] [rbp-1ACh] BYREF
  int64_t old_mcoin; // [rsp+48h] [rbp-1A8h]
  int v38[4]; // [rsp+50h] [rbp-1A0h] BYREF
  common::milog::MiLogStream v39; // [rsp+60h] [rbp-190h] BYREF
  proto::PropValue v40; // [rsp+80h] [rbp-170h] BYREF
  proto::PropValue v41; // [rsp+B0h] [rbp-140h] BYREF
  char v42[272]; // [rsp+E0h] [rbp-110h] BYREF

  v5 = (unsigned __int64)v42;
  v30._M_string_length = (std::string::size_type)v42;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(224LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "6 32 1 23 log_context_holder:5834 48 4 10 mcoin:5826 64 4 19 wait_sub_mcoin:5827 80 4 14 add_mco"
                        "in:5816 96 24 19 item_param_vec:5818 160 24 13 prop_vec:5856";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::addMcoin;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556927;
  v7[536862722] = -234556924;
  v7[536862723] = -234881024;
  v7[536862724] = -218959118;
  v7[536862725] = -218103808;
  v7[536862726] = -202116109;
  *(_DWORD *)(v5 + 80) = add_mcoin;
  v38[0] = 203;
  v38[1] = *(_DWORD *)(v5 + 80);
  v38[2] = 0;
  v38[3] = 0;
  v30._anon_0._M_allocated_capacity = (std::string::size_type)v38;
  *(&v30._anon_0._M_allocated_capacity + 1) = 1LL;
  std::allocator<ItemParam>::allocator(&__a);
  std::vector<ItemParam>::vector(
    (std::vector<ItemParam> *const)(v5 + 96),
    (std::initializer_list<ItemParam>)v30._anon_0,
    &__a);
  std::allocator<ItemParam>::~allocator(&__a);
  PlayerItemComp::checkOutputLimitAndModifyItemParams<ItemParam>(
    (std::vector<ItemParam> *)(v5 + 160),
    this,
    (const std::vector<ItemParam> *)(v5 + 96),
    reason);
  std::vector<ItemParam>::operator=((std::vector<ItemParam> *const)(v5 + 96), (std::vector<ItemParam> *)(v5 + 160));
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v5 + 160));
  if ( std::vector<ItemParam>::empty((const std::vector<ItemParam> *const)(v5 + 96)) )
  {
    common::milog::MiLogStream::create(
      &v39,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "addMcoin",
      5822);
    v8 = common::milog::MiLogStream::operator<<<char [53],(char *[53])0>(
           &v39,
           (const char (*)[53])"checkOutputLimitAndModifyItemParams fail, add_mcoin:");
    v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, (const unsigned int *)(v5 + 80));
    v10 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v9, (const char (*)[9])" reason:");
    v11 = operator<<(v10, reason);
    v12 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v11, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v12, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v39);
    v13 = -1;
  }
  else
  {
    *(_DWORD *)(v5 + 48) = PlayerItemComp::getMcoin(this, platform_type);
    *(_DWORD *)(v5 + 64) = PlayerItemComp::getWaitSubMcoin(this, platform_type);
    if ( (!*(_DWORD *)(v5 + 80)
       || !*(_DWORD *)(v5 + 48)
       || (unsigned int)(*(_DWORD *)(v5 + 48) + *(_DWORD *)(v5 + 80)) >= *(_DWORD *)(v5 + 80))
      && (*(_DWORD *)(v5 + 80)
       || *(_DWORD *)(v5 + 48)
       || (unsigned int)(*(_DWORD *)(v5 + 48) + *(_DWORD *)(v5 + 80)) <= *(_DWORD *)(v5 + 80)) )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      BasicComp = Player::getBasicComp(this->player_);
      PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v39, BasicComp);
      StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 32), 0x67u, v30);
      std::string::~string(&v39);
      old_mcoin = PlayerItemComp::getAllPlatRealLeftMcoin(this);
      if ( *(_DWORD *)(v5 + 80) <= *(_DWORD *)(v5 + 64) )
      {
        *(_DWORD *)(v5 + 64) -= *(_DWORD *)(v5 + 80);
      }
      else
      {
        *(_DWORD *)(v5 + 48) = SAFE_ADD<unsigned int,unsigned int>(
                                 *(_DWORD *)(v5 + 48),
                                 *(_DWORD *)(v5 + 80) - *(_DWORD *)(v5 + 64));
        *(_DWORD *)(v5 + 64) = 0;
      }
      if ( *(_DWORD *)(v5 + 48) && *(_DWORD *)(v5 + 64) )
      {
        common::milog::MiLogStream::create(
          &v39,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addMcoin",
          5848);
        __l = common::milog::MiLogStream::operator<<<char [5],(char *[5])0>(&v39, (const char (*)[5])"uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(__l, &val);
        v19 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v18, (const char (*)[8])" mcoin:");
        v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v19,
                (const unsigned int *)(v5 + 48));
        v21 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                v20,
                (const char (*)[17])" wait_sub_mcoin:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, (const unsigned int *)(v5 + 64));
        common::milog::MiLogStream::~MiLogStream(&v39);
      }
      PlayerItemComp::setMcoin(this, *(_DWORD *)(v5 + 48), platform_type);
      PlayerItemComp::setWaitSubMcoin(this, *(_DWORD *)(v5 + 64), platform_type);
      if ( is_notify )
      {
        Mcoin = PlayerItemComp::getMcoin(this);
        buildIntProp(&v40, 0x2729u, Mcoin);
        WaitSubMcoin = PlayerItemComp::getWaitSubMcoin(this);
        buildIntProp(&v41, 0x272Au, WaitSubMcoin);
        std::allocator<proto::PropValue>::allocator((std::allocator<proto::PropValue> *const)&__a);
        std::vector<proto::PropValue>::vector(
          (std::vector<proto::PropValue> *const)(v5 + 160),
          (std::initializer_list<proto::PropValue>)__PAIR128__(2LL, &v40),
          (const std::vector<proto::PropValue>::allocator_type *)&__a);
        std::allocator<proto::PropValue>::~allocator((std::allocator<proto::PropValue> *const)&__a);
        for ( i = (proto::PropValue *)v42; i != &v40; (*vptr_MessageLite)(i) )
        {
          if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
          if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
            __asan_report_load8();
        }
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::notifyPlayerPropList(this->player_, (const std::vector<proto::PropValue> *)(v5 + 160));
        std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v5 + 160));
      }
      if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&reason->limit_type);
      }
      limit_type = reason->limit_type;
      if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(reason);
      }
      reason_type = reason->reason_type;
      AllPlatRealLeftMcoin = PlayerItemComp::getAllPlatRealLeftMcoin(this);
      PlayerItemComp::logPlayerAddCoin(
        this,
        ITEM_VIRTUAL_MCOIN,
        old_mcoin,
        AllPlatRealLeftMcoin,
        reason_type,
        limit_type,
        1,
        1,
        platform_type);
      v13 = 0;
      StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 32));
    }
    else
    {
      common::milog::MiLogStream::create(
        &v39,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "addMcoin",
        5830);
      v14 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
              &v39,
              (const char (*)[31])"mcoin add overflow, cur_mcoin:");
      v15 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, (const unsigned int *)(v5 + 48));
      v16 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v15, (const char (*)[12])" add_mcoin:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, (const unsigned int *)(v5 + 80));
      common::milog::MiLogStream::~MiLogStream(&v39);
      v13 = -1;
    }
  }
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v5 + 96));
  result = v13;
  if ( v30._M_string_length == v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8018) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8018) = -168430091;
  }
  return result;
};

// Line 5868: range 0000000017CEE2CC-0000000017CEE324
int32_t __cdecl PlayerItemComp::checkSubMcoin(PlayerItemComp *const this, uint32_t sub_mcoin)
{
  uint32_t PlatformType; // edx

  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  PlatformType = Player::getPlatformType(this->player_);
  return PlayerItemComp::checkSubMcoin(this, sub_mcoin, PlatformType);
};

// Line 5873: range 0000000017CEE326-0000000017CEE380
int32_t __cdecl PlayerItemComp::checkSubMcoin(PlayerItemComp *const this, uint32_t sub_mcoin, uint32_t platform_type)
{
  if ( PlayerItemComp::getWaitSubMcoin(this, platform_type) || sub_mcoin > PlayerItemComp::getMcoin(this, platform_type) )
    return 655;
  else
    return 0;
};

// Line 5882: range 0000000017CEE382-0000000017CEE3EC
int32_t __cdecl PlayerItemComp::subMcoin(
        PlayerItemComp *const this,
        uint32_t sub_mcoin,
        const SubItemReason *reason,
        bool is_notify)
{
  uint32_t PlatformType; // edi

  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  PlatformType = Player::getPlatformType(this->player_);
  return PlayerItemComp::subMcoin(this, sub_mcoin, reason, is_notify, PlatformType);
};

// Line 5887: range 0000000017CEE3EE-0000000017CEEA53
__int64 __fastcall PlayerItemComp::subMcoin(
        PlayerItemComp *const this,
        uint32_t sub_mcoin,
        const SubItemReason *reason,
        bool is_notify,
        __int32 platform_type)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rbx
  unsigned int v15; // r14d
  PlayerBasicComp *BasicComp; // rax
  uint32_t Mcoin; // eax
  uint32_t WaitSubMcoin; // eax
  proto::PropValue *i; // r14
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  uint32_t v21; // r14d
  int64_t AllPlatRealLeftMcoin; // rax
  __int64 result; // rax
  std::string v24; // [rsp+0h] [rbp-190h]
  std::allocator<proto::PropValue> __a; // [rsp+33h] [rbp-15Dh] BYREF
  unsigned int val; // [rsp+34h] [rbp-15Ch] BYREF
  int64_t old_mcoin; // [rsp+38h] [rbp-158h]
  common::milog::MiLogStream v29; // [rsp+40h] [rbp-150h] BYREF
  proto::PropValue v30; // [rsp+60h] [rbp-130h] BYREF
  proto::PropValue v31; // [rsp+90h] [rbp-100h] BYREF
  char v32[208]; // [rsp+C0h] [rbp-D0h] BYREF

  *(&v24._anon_0._M_allocated_capacity + 1) = (std::string::size_type)reason;
  HIDWORD(v24._anon_0._M_allocated_capacity) = platform_type;
  v5 = (unsigned __int64)v32;
  v24._M_string_length = (std::string::size_type)v32;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(160LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "5 32 1 23 log_context_holder:5897 48 4 10 mcoin:5888 64 4 19 wait_sub_mcoin:5889 80 4 14 sub_mco"
                        "in:5886 96 24 13 prop_vec:5904";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::subMcoin;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556927;
  v7[536862722] = -234556924;
  v7[536862723] = -218103808;
  v7[536862724] = -202116109;
  *(_DWORD *)(v5 + 80) = sub_mcoin;
  *(_DWORD *)(v5 + 48) = PlayerItemComp::getMcoin(this, HIDWORD(v24._anon_0._M_allocated_capacity));
  *(_DWORD *)(v5 + 64) = PlayerItemComp::getWaitSubMcoin(this, HIDWORD(v24._anon_0._M_allocated_capacity));
  if ( *(_DWORD *)(v5 + 64) || *(_DWORD *)(v5 + 48) < *(_DWORD *)(v5 + 80) )
  {
    common::milog::MiLogStream::create(
      &v29,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "subMcoin",
      5893);
    v8 = common::milog::MiLogStream::operator<<<char [11],(char *[11])0>(&v29, (const char (*)[11])"cur_mcoin:");
    v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, (const unsigned int *)(v5 + 48));
    v10 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v9, (const char (*)[17])" wait_sub_mcoin:");
    v11 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, (const unsigned int *)(v5 + 64));
    v12 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v11, (const char (*)[12])" sub_mcoin:");
    v13 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v12, (const unsigned int *)(v5 + 80));
    v14 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v13, (const char (*)[13])" fails, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &val);
    common::milog::MiLogStream::~MiLogStream(&v29);
    v15 = -1;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v29, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 32), 0x67u, v24);
    std::string::~string(&v29);
    old_mcoin = PlayerItemComp::getAllPlatRealLeftMcoin(this);
    *(_DWORD *)(v5 + 48) -= *(_DWORD *)(v5 + 80);
    PlayerItemComp::setMcoin(this, *(_DWORD *)(v5 + 48), HIDWORD(v24._anon_0._M_allocated_capacity));
    if ( is_notify )
    {
      Mcoin = PlayerItemComp::getMcoin(this);
      buildIntProp(&v30, 0x2729u, Mcoin);
      WaitSubMcoin = PlayerItemComp::getWaitSubMcoin(this);
      buildIntProp(&v31, 0x272Au, WaitSubMcoin);
      std::allocator<proto::PropValue>::allocator(&__a);
      std::vector<proto::PropValue>::vector(
        (std::vector<proto::PropValue> *const)(v5 + 96),
        (std::initializer_list<proto::PropValue>)__PAIR128__(2LL, &v30),
        &__a);
      std::allocator<proto::PropValue>::~allocator(&__a);
      for ( i = (proto::PropValue *)v32; i != &v30; (*vptr_MessageLite)(i) )
      {
        if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
        if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
          __asan_report_load8();
      }
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::notifyPlayerPropList(this->player_, (const std::vector<proto::PropValue> *)(v5 + 96));
      std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v5 + 96));
    }
    if ( *(_BYTE *)((*(&v24._anon_0._M_allocated_capacity + 1) >> 3) + 0x7FFF8000) != 0
      && (char)((v24._anon_0._M_local_buf[8] & 7) + 3) >= *(_BYTE *)((*(&v24._anon_0._M_allocated_capacity + 1) >> 3)
                                                                   + 0x7FFF8000) )
    {
      __asan_report_load4(*(&v24._anon_0._M_allocated_capacity + 1));
    }
    v21 = **((_DWORD **)&v24._anon_0._M_allocated_capacity + 1);
    AllPlatRealLeftMcoin = PlayerItemComp::getAllPlatRealLeftMcoin(this);
    PlayerItemComp::logPlayerAddCoin(
      this,
      ITEM_VIRTUAL_MCOIN,
      old_mcoin,
      AllPlatRealLeftMcoin,
      v21,
      ITEM_LIMIT_NONE,
      1,
      1,
      HIDWORD(v24._anon_0._M_allocated_capacity));
    v15 = 0;
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 32));
  }
  result = v15;
  if ( v24._M_string_length == v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 5916: range 0000000017CEEA54-0000000017CEF2A7
__int64 __fastcall PlayerItemComp::exchangeMcoinPlatform(
        PlayerItemComp *const this,
        uint32_t exchange_num,
        unsigned int exchange_type,
        const ActionReason *reason)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r13
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  common::milog::MiLogStream *v9; // r14
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rbx
  common::milog::MiLogStream *v14; // r14
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  __int32 v18; // r14d
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rbx
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // r14
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rbx
  unsigned int Mcoin; // [rsp+2Ch] [rbp-C4h] BYREF
  unsigned int val; // [rsp+30h] [rbp-C0h] BYREF
  int32_t retcode; // [rsp+34h] [rbp-BCh]
  SubItemReason v37; // [rsp+38h] [rbp-B8h] BYREF
  common::milog::MiLogStream v38; // [rsp+40h] [rbp-B0h] BYREF
  char v39[144]; // [rsp+60h] [rbp-90h] BYREF

  v4 = (unsigned __int64)v39;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(96LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 4 25 source_platform_type:5919 48 4 25 target_platform_type:5920 64 4 17 exchange_num:5915";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::exchangeMcoinPlatform;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556924;
  v6[536862722] = -202116348;
  *(_DWORD *)(v4 + 64) = exchange_num;
  retcode = 0;
  *(_DWORD *)(v4 + 32) = 0;
  *(_DWORD *)(v4 + 48) = 0;
  if ( exchange_type == 1 )
  {
    *(_DWORD *)(v4 + 32) = TxtConfigMgr::getPCMPlatformType();
    *(_DWORD *)(v4 + 48) = TxtConfigMgr::getPsnPlatformType();
  }
  else
  {
    if ( exchange_type != 2 )
    {
      common::milog::MiLogStream::create(
        &v38,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "exchangeMcoinPlatform",
        5938);
      v7 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(
             &v38,
             (const char (*)[25])"no expect exchange_type:");
      val = exchange_type;
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &val);
      common::milog::MiLogStream::~MiLogStream(&v38);
      result = 0xFFFFFFFFLL;
      goto LABEL_28;
    }
    *(_DWORD *)(v4 + 32) = TxtConfigMgr::getPsnPlatformType();
    *(_DWORD *)(v4 + 48) = TxtConfigMgr::getPCMPlatformType();
  }
  retcode = PlayerItemComp::checkSubMcoin(this, *(_DWORD *)(v4 + 64), *(_DWORD *)(v4 + 32));
  if ( retcode )
  {
    common::milog::MiLogStream::create(
      &v38,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "exchangeMcoinPlatform",
      5947);
    v9 = common::milog::MiLogStream::operator<<<char [32],(char *[32])0>(
           &v38,
           (const char (*)[32])"checkSubMcoin fails, cur_mcoin:");
    Mcoin = PlayerItemComp::getMcoin(this, *(_DWORD *)(v4 + 32));
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &Mcoin);
    v11 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v10, (const char (*)[8])" count:");
    v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v4 + 64));
    v13 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v12, (const char (*)[6])" uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
LABEL_12:
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, &val);
    common::milog::MiLogStream::~MiLogStream(&v38);
    result = (unsigned int)retcode;
    goto LABEL_28;
  }
  retcode = PlayerItemComp::checkAddMcoin(this, *(_DWORD *)(v4 + 64), reason, *(_DWORD *)(v4 + 48));
  if ( retcode )
  {
    common::milog::MiLogStream::create(
      &v38,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "exchangeMcoinPlatform",
      5953);
    v14 = common::milog::MiLogStream::operator<<<char [32],(char *[32])0>(
            &v38,
            (const char (*)[32])"checkAddMcoin fails, cur_mcoin:");
    Mcoin = PlayerItemComp::getMcoin(this, *(_DWORD *)(v4 + 48));
    v15 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &Mcoin);
    v16 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v15, (const char (*)[8])" count:");
    v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, (const unsigned int *)(v4 + 64));
    v13 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v17, (const char (*)[6])" uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    goto LABEL_12;
  }
  v18 = *(_DWORD *)(v4 + 32);
  SubItemReason::SubItemReason(&v37, reason);
  retcode = PlayerItemComp::subMcoin(this, *(_DWORD *)(v4 + 64), &v37, 1, v18);
  if ( retcode )
  {
    common::milog::MiLogStream::create(
      &v38,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "exchangeMcoinPlatform",
      5960);
    v19 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
            &v38,
            (const char (*)[28])"subMcoin fails, mcoin_cost:");
    v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v19, (const unsigned int *)(v4 + 64));
    v21 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v20, (const char (*)[6])" uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, &val);
    common::milog::MiLogStream::~MiLogStream(&v38);
    result = (unsigned int)retcode;
  }
  else
  {
    retcode = PlayerItemComp::addMcoin(this, *(_DWORD *)(v4 + 64), reason, 1, *(_DWORD *)(v4 + 48));
    if ( retcode )
    {
      common::milog::MiLogStream::create(
        &v38,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "exchangeMcoinPlatform",
        5966);
      v22 = common::milog::MiLogStream::operator<<<char [23],(char *[23])0>(
              &v38,
              (const char (*)[23])"addMcoin fails, mcoin:");
      v23 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, (const unsigned int *)(v4 + 64));
      v24 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v23, (const char (*)[6])" uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, &val);
      common::milog::MiLogStream::~MiLogStream(&v38);
    }
    common::milog::MiLogStream::create(
      &v38,
      &common::milog::MiLogDefault::default_log_obj_,
      2u,
      "./src/player/item/player_item_comp.cpp",
      "exchangeMcoinPlatform",
      5969);
    v25 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
            &v38,
            (const char (*)[40])"exchange success, source_platform_type:");
    v26 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v25, (const unsigned int *)(v4 + 32));
    v27 = common::milog::MiLogStream::operator<<<char [23],(char *[23])0>(
            v26,
            (const char (*)[23])" target_platform_type:");
    v28 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, (const unsigned int *)(v4 + 48));
    v29 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v28, (const char (*)[15])" exchange_num:");
    v30 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v29, (const unsigned int *)(v4 + 64));
    v31 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v30, (const char (*)[6])" uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v31, &val);
    common::milog::MiLogStream::~MiLogStream(&v38);
    result = (unsigned int)retcode;
  }
LABEL_28:
  if ( v39 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 5976: range 0000000017CEF2A8-0000000017CEFDE7
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall PlayerItemComp::mcoinExchangeHcoin(
        PlayerItemComp *const this,
        uint32_t mcoin_cost,
        uint32_t hcoin_expected)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  unsigned int v9; // r14d
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  PlayerBasicComp *BasicComp; // rax
  __int32 PlatformType; // eax
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // r14
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // r14
  std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v32; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v33; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v34; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v35; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v36; // rax
  Player *v37; // r14
  __int64 result; // rax
  std::string v39; // [rsp+0h] [rbp-190h] OVERLAPPED BYREF
  std::shared_ptr<google::protobuf::Message> p_body_ptr; // [rsp+20h] [rbp-170h] BYREF
  std::shared_ptr<google::protobuf::Message> v41; // [rsp+30h] [rbp-160h] BYREF
  common::milog::MiLogStream v42; // [rsp+40h] [rbp-150h] BYREF
  char v43[304]; // [rsp+60h] [rbp-130h] BYREF

  v39._M_string_length = (std::string::size_type)this;
  v39._M_dataplus._M_p = (std::string::pointer)__PAIR64__(mcoin_cost, hcoin_expected);
  v3 = (unsigned __int64)v43;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(256LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "8 48 1 11 holder:6009 64 4 10 ratio:5982 80 4 10 hcoin:5988 96 4 15 mcoin_cost:5975 112 4 19 hco"
                        "in_expected:5975 128 8 15 sub_reason:6014 160 16 12 log_ptr:6029 192 24 15 add_reason:6022";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::mcoinExchangeHcoin;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234753551;
  v5[536862722] = -234556924;
  v5[536862723] = -234556924;
  v5[536862724] = -218959360;
  v5[536862725] = -219021312;
  v5[536862726] = -218103808;
  v5[536862727] = -202116109;
  *(_DWORD *)(v3 + 96) = HIDWORD(v39._M_dataplus._M_p);
  *(_DWORD *)(v3 + 112) = v39._M_dataplus._M_p;
  if ( *(_DWORD *)(v3 + 96) && *(_DWORD *)(v3 + 112) )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v41);
    v10 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v41);
    *(_DWORD *)(v3 + 64) = ConstValueExcelConfigMgr::getMcoinExchangeHcoinRatio(&v10->design_config.txt_config_mgr.const_value_config_mgr);
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)&v41);
    if ( *(_DWORD *)(v3 + 96)
      && *(_DWORD *)(v3 + 64)
      && (unsigned int)(*(_DWORD *)(v3 + 96) * *(_DWORD *)(v3 + 64)) / *(_DWORD *)(v3 + 96) != *(_DWORD *)(v3 + 64) )
    {
      common::milog::MiLogStream::create(
        &v42,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "mcoinExchangeHcoin",
        5985);
      v11 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(&v42, (const char (*)[12])"mcoin_cost:");
      v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v3 + 96));
      v13 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v12, (const char (*)[10])" * ratio:");
      v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v3 + 64));
      common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v14, (const char (*)[10])" overflow");
      common::milog::MiLogStream::~MiLogStream(&v42);
      v9 = -1;
    }
    else
    {
      *(_DWORD *)(v3 + 80) = SAFE_MULTIPLY<unsigned int,unsigned int>(*(_DWORD *)(v3 + 96), *(_DWORD *)(v3 + 64));
      if ( *(_DWORD *)(v3 + 80) == *(_DWORD *)(v3 + 112) )
      {
        *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2) = PlayerItemComp::checkSubMcoin(
                                                                (PlayerItemComp *const)v39._M_string_length,
                                                                *(_DWORD *)(v3 + 96));
        if ( *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2) )
        {
          common::milog::MiLogStream::create(
            &v42,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "mcoinExchangeHcoin",
            5999);
          v22 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
                  &v42,
                  (const char (*)[33])"checkSubMcoin fails, mcoin_cost:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, (const unsigned int *)(v3 + 96));
          common::milog::MiLogStream::~MiLogStream(&v42);
          v9 = *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2);
        }
        else
        {
          *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2) = PlayerItemComp::checkAddHcoin(
                                                                  (PlayerItemComp *const)v39._M_string_length,
                                                                  *(_DWORD *)(v3 + 112));
          if ( *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2) )
          {
            common::milog::MiLogStream::create(
              &v42,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "mcoinExchangeHcoin",
              6005);
            v23 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                    &v42,
                    (const char (*)[37])"checkAddHcoin fails, hcoin_expected:");
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
              v23,
              (const unsigned int *)(v3 + 112));
            common::milog::MiLogStream::~MiLogStream(&v42);
            v9 = *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2);
          }
          else
          {
            if ( *(_BYTE *)(((v39._M_string_length + 24) >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            BasicComp = Player::getBasicComp(*(Player *const *)(v39._M_string_length + 24));
            PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v42, BasicComp);
            StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v3 + 48), 0x45Fu, v39);
            std::string::~string(&v42);
            *((_DWORD *)&v39._anon_0._M_allocated_capacity + 3) = 71;
            SubItemReason::SubItemReason((SubItemReason *const)(v3 + 128), ACTION_REASON_MCOIN_EXCHANGE_HCOIN);
            if ( *(_BYTE *)(((v39._M_string_length + 24) >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            PlatformType = Player::getPlatformType(*(const Player *const *)(v39._M_string_length + 24));
            *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2) = PlayerItemComp::subMcoin(
                                                                    (PlayerItemComp *const)v39._M_string_length,
                                                                    *(_DWORD *)(v3 + 96),
                                                                    (const SubItemReason *)(v3 + 128),
                                                                    1,
                                                                    PlatformType);
            if ( *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2) )
            {
              common::milog::MiLogStream::create(
                &v42,
                &common::milog::MiLogDefault::default_log_obj_,
                4u,
                "./src/player/item/player_item_comp.cpp",
                "mcoinExchangeHcoin",
                6018);
              v26 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
                      &v42,
                      (const char (*)[28])"subMcoin fails, mcoin_cost:");
              v27 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                      v26,
                      (const unsigned int *)(v3 + 96));
              v28 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v27, (const char (*)[6])" uid:");
              if ( *(_BYTE *)(((v39._M_string_length + 24) >> 3) + 0x7FFF8000) )
                __asan_report_load8();
              HIDWORD(v39._anon_0._M_allocated_capacity) = Player::getUid(*(const Player *const *)(v39._M_string_length
                                                                                                 + 24));
              common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v28,
                (const unsigned int *)&v39._anon_0._M_allocated_capacity + 1);
              common::milog::MiLogStream::~MiLogStream(&v42);
              v9 = *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2);
            }
            else
            {
              ActionReason::ActionReason(
                (ActionReason *const)(v3 + 192),
                *((proto::ActionReasonType *)&v39._anon_0._M_allocated_capacity + 3),
                ITEM_LIMIT_UNLIMITED);
              *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2) = PlayerItemComp::addHcoin(
                                                                      (PlayerItemComp *const)v39._M_string_length,
                                                                      *(_DWORD *)(v3 + 112),
                                                                      (const ActionReason *)(v3 + 192),
                                                                      1);
              if ( *((_DWORD *)&v39._anon_0._M_allocated_capacity + 2) )
              {
                common::milog::MiLogStream::create(
                  &v42,
                  &common::milog::MiLogDefault::default_log_obj_,
                  4u,
                  "./src/player/item/player_item_comp.cpp",
                  "mcoinExchangeHcoin",
                  6026);
                v29 = common::milog::MiLogStream::operator<<<char [32],(char *[32])0>(
                        &v42,
                        (const char (*)[32])"addHcoin fails, hcoin_expected:");
                v30 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                        v29,
                        (const unsigned int *)(v3 + 112));
                v31 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v30, (const char (*)[6])" uid:");
                if ( *(_BYTE *)(((v39._M_string_length + 24) >> 3) + 0x7FFF8000) )
                  __asan_report_load8();
                HIDWORD(v39._anon_0._M_allocated_capacity) = Player::getUid(*(const Player *const *)(v39._M_string_length + 24));
                common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v31,
                  (const unsigned int *)&v39._anon_0._M_allocated_capacity + 1);
                common::milog::MiLogStream::~MiLogStream(&v42);
              }
              common::tools::perf::make_shared<proto_log::PlayerLogBodyExchangeCoin>();
              v32 = std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 160));
              proto_log::PlayerLogBodyExchangeCoin::set_cost_coin_id(v32, 0xCBu);
              v33 = std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 160));
              proto_log::PlayerLogBodyExchangeCoin::set_cost_coin_num(v33, *(_DWORD *)(v3 + 96));
              v34 = std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 160));
              proto_log::PlayerLogBodyExchangeCoin::set_add_coin_id(v34, 0xC9u);
              v35 = std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 160));
              proto_log::PlayerLogBodyExchangeCoin::set_add_coin_num(v35, *(_DWORD *)(v3 + 112));
              v36 = std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExchangeCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 160));
              proto_log::PlayerLogBodyExchangeCoin::set_reason(
                v36,
                *((google::protobuf::uint32 *)&v39._anon_0._M_allocated_capacity + 3));
              if ( *(_BYTE *)(((v39._M_string_length + 24) >> 3) + 0x7FFF8000) )
                __asan_report_load8();
              v37 = *(Player **)(v39._M_string_length + 24);
              std::shared_ptr<google::protobuf::Message>::shared_ptr(&v41, 0LL);
              std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodyExchangeCoin,void>(
                &p_body_ptr,
                (const std::shared_ptr<proto_log::PlayerLogBodyExchangeCoin> *)(v3 + 160));
              Player::printStatLog(v37, &p_body_ptr, &v41, 0xEu);
              std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ptr);
              std::shared_ptr<google::protobuf::Message>::~shared_ptr(&v41);
              v9 = 0;
              std::shared_ptr<proto_log::PlayerLogBodyExchangeCoin>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodyExchangeCoin> *const)(v3 + 160));
            }
            StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v3 + 48));
          }
        }
      }
      else
      {
        common::milog::MiLogStream::create(
          &v42,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "mcoinExchangeHcoin",
          5991);
        v15 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(&v42, (const char (*)[12])"mcoin_cost:");
        v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v15,
                (const unsigned int *)(v3 + 96));
        v17 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                v16,
                (const char (*)[17])" hcoin_expected:");
        v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v17,
                (const unsigned int *)(v3 + 112));
        v19 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(
                v18,
                (const char (*)[18])" but final hcoin:");
        v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v19,
                (const unsigned int *)(v3 + 80));
        v21 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v20, (const char (*)[8])" ratio:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, (const unsigned int *)(v3 + 64));
        common::milog::MiLogStream::~MiLogStream(&v42);
        v9 = -1;
      }
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v42,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "mcoinExchangeHcoin",
      5979);
    v6 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(&v42, (const char (*)[12])"mcoin_cost:");
    v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, (const unsigned int *)(v3 + 96));
    v8 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v7, (const char (*)[17])" hcoin_expected:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, (const unsigned int *)(v3 + 112));
    common::milog::MiLogStream::~MiLogStream(&v42);
    v9 = -1;
  }
  result = v9;
  if ( v43 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8018) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6042: range 0000000017CEFDE8-0000000017CF005B
__int64 __fastcall PlayerItemComp::checkAddHcoin(PlayerItemComp *const this, uint32_t add_hcoin)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r13
  common::milog::MiLogStream *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  common::milog::MiLogStream v9; // [rsp+10h] [rbp-80h] BYREF
  char v10[96]; // [rsp+30h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 14 add_hcoin:6041";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkAddHcoin;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = add_hcoin;
  if ( *(_DWORD *)(v2 + 32) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->hcoin_);
    }
    if ( this->hcoin_ && *(_DWORD *)(v2 + 32) + this->hcoin_ < *(_DWORD *)(v2 + 32) )
      goto LABEL_14;
  }
  if ( *(_DWORD *)(v2 + 32) )
    goto LABEL_15;
  if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->hcoin_);
  }
  if ( this->hcoin_ || *(_DWORD *)(v2 + 32) + this->hcoin_ <= *(_DWORD *)(v2 + 32) )
  {
LABEL_15:
    result = 0LL;
  }
  else
  {
LABEL_14:
    common::milog::MiLogStream::create(
      &v9,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkAddHcoin",
      6045);
    v5 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
           &v9,
           (const char (*)[31])"hcoin add overflow, cur_hcoin:");
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &this->hcoin_);
    v7 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v6, (const char (*)[12])" add_hcoin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v2 + 32));
    common::milog::MiLogStream::~MiLogStream(&v9);
    result = 626LL;
  }
  if ( v10 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6053: range 0000000017CF005C-0000000017CF0ADD
__int64 __fastcall PlayerItemComp::addHcoin(
        PlayerItemComp *const this,
        uint32_t add_hcoin,
        const ActionReason *reason,
        bool is_notify)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r14
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  unsigned int v10; // r13d
  PlayerBasicComp *BasicComp; // rax
  unsigned int v12; // ecx
  uint32_t v13; // ecx
  char v14; // dl
  __int64 v15; // rsi
  __int64 v16; // rdx
  __int64 v17; // rdx
  common::milog::MiLogStream *v18; // r13
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  proto::PropValue *i; // r13
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  data::ItemLimitType v25; // r13d
  int64_t RealLeftHcoin; // rax
  __int64 result; // rax
  std::string __l; // [rsp+0h] [rbp-170h]
  std::initializer_list<proto::PropValue> __la; // [rsp+0h] [rbp-170h]
  uint32_t __lb; // [rsp+0h] [rbp-170h]
  uint32_t *reasona; // [rsp+18h] [rbp-158h]
  std::allocator<proto::PropValue> __a; // [rsp+33h] [rbp-13Dh] BYREF
  unsigned int val; // [rsp+34h] [rbp-13Ch] BYREF
  int64_t old_hcoin; // [rsp+38h] [rbp-138h]
  common::milog::MiLogStream v36; // [rsp+40h] [rbp-130h] BYREF
  proto::PropValue v37; // [rsp+60h] [rbp-110h] BYREF
  proto::PropValue v38; // [rsp+90h] [rbp-E0h] BYREF
  char v39[176]; // [rsp+C0h] [rbp-B0h] BYREF

  *(&__l._anon_0._M_allocated_capacity + 1) = (std::string::size_type)reason;
  v4 = (unsigned __int64)v39;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 1 23 log_context_holder:6060 48 4 14 add_hcoin:6052 64 24 13 prop_vec:6079";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addHcoin;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556927;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  *(_DWORD *)(v4 + 48) = add_hcoin;
  if ( *(_DWORD *)(v4 + 48) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->hcoin_);
    }
    if ( this->hcoin_ && *(_DWORD *)(v4 + 48) + this->hcoin_ < *(_DWORD *)(v4 + 48) )
      goto LABEL_14;
  }
  if ( *(_DWORD *)(v4 + 48) )
    goto LABEL_64;
  if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->hcoin_);
  }
  if ( this->hcoin_ || *(_DWORD *)(v4 + 48) + this->hcoin_ <= *(_DWORD *)(v4 + 48) )
  {
LABEL_64:
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v36, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32), 0x67u, __l);
    std::string::~string(&v36);
    old_hcoin = PlayerItemComp::getRealLeftHcoin(this);
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->wait_sub_hcoin_);
    }
    if ( this->wait_sub_hcoin_ >= *(_DWORD *)(v4 + 48) )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3)
                                                            + 0x7FFF8000) )
      {
        __asan_report_load4(&this->wait_sub_hcoin_);
      }
      this->wait_sub_hcoin_ -= *(_DWORD *)(v4 + 48);
    }
    else
    {
      v12 = *(_DWORD *)(v4 + 48) - this->wait_sub_hcoin_;
      if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&this->hcoin_);
      }
      v15 = v12;
      v13 = SAFE_ADD<unsigned int,unsigned int>(this->hcoin_, v12);
      v14 = *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000);
      LOBYTE(v15) = v14 != 0;
      v16 = (v14 != 0) & (unsigned __int8)((char)((((_BYTE)this - 28) & 7) + 3) >= v14);
      if ( (_BYTE)v16 )
        __asan_report_store4(&this->hcoin_, v15, v16);
      this->hcoin_ = v13;
      v17 = (*(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000));
      if ( (_BYTE)v17 )
        __asan_report_store4(&this->wait_sub_hcoin_, (((_BYTE)this - 12) & 7u) + 3, v17);
      this->wait_sub_hcoin_ = 0;
    }
    if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->hcoin_);
    }
    if ( this->hcoin_ )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3)
                                                            + 0x7FFF8000) )
      {
        __asan_report_load4(&this->wait_sub_hcoin_);
      }
      if ( this->wait_sub_hcoin_ )
      {
        common::milog::MiLogStream::create(
          &v36,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addHcoin",
          6074);
        v18 = common::milog::MiLogStream::operator<<<char [5],(char *[5])0>(&v36, (const char (*)[5])"uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        v19 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, &val);
        v20 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v19, (const char (*)[9])" hcoin_:");
        v21 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &this->hcoin_);
        v22 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(
                v21,
                (const char (*)[18])" wait_sub_hcoin_:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, &this->wait_sub_hcoin_);
        common::milog::MiLogStream::~MiLogStream(&v36);
      }
    }
    if ( is_notify )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&this->hcoin_);
      }
      buildIntProp(&v37, 0x271Fu, this->hcoin_);
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3)
                                                            + 0x7FFF8000) )
      {
        __asan_report_load4(&this->wait_sub_hcoin_);
      }
      buildIntProp(&v38, 0x2726u, this->wait_sub_hcoin_);
      __la._M_array = &v37;
      __la._M_len = 2LL;
      std::allocator<proto::PropValue>::allocator(&__a);
      std::vector<proto::PropValue>::vector((std::vector<proto::PropValue> *const)(v4 + 64), __la, &__a);
      std::allocator<proto::PropValue>::~allocator(&__a);
      for ( i = (proto::PropValue *)v39; i != &v37; (*vptr_MessageLite)(i) )
      {
        if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
        if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
          __asan_report_load8();
      }
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::notifyPlayerPropList(this->player_, (const std::vector<proto::PropValue> *)(v4 + 64));
      std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v4 + 64));
    }
    if ( *(_BYTE *)(((unsigned __int64)(reasona + 1) >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reasona + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)(reasona + 1) >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona + 1);
    }
    v25 = reasona[1];
    if ( *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)reasona & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona);
    }
    __lb = *reasona;
    RealLeftHcoin = PlayerItemComp::getRealLeftHcoin(this);
    PlayerItemComp::logPlayerAddCoin(this, ITEM_VIRTUAL_HCOIN, old_hcoin, RealLeftHcoin, __lb, v25, 0);
    v10 = 0;
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32));
  }
  else
  {
LABEL_14:
    common::milog::MiLogStream::create(
      &v36,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "addHcoin",
      6056);
    v7 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
           &v36,
           (const char (*)[31])"hcoin add overflow, cur_hcoin:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->hcoin_);
    v9 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v8, (const char (*)[12])" add_hcoin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 48));
    common::milog::MiLogStream::~MiLogStream(&v36);
    v10 = -1;
  }
  result = v10;
  if ( v39 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6091: range 0000000017CF0ADE-0000000017CF0CFF
__int64 __fastcall PlayerItemComp::checkSubHcoin(PlayerItemComp *const this, uint32_t sub_hcoin)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  common::milog::MiLogStream *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  common::milog::MiLogStream v9; // [rsp+10h] [rbp-80h] BYREF
  char v10[96]; // [rsp+30h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 14 sub_hcoin:6090";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkSubHcoin;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = sub_hcoin;
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->wait_sub_hcoin_);
  }
  if ( this->wait_sub_hcoin_ )
    goto LABEL_10;
  if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->hcoin_);
  }
  if ( this->hcoin_ < *(_DWORD *)(v2 + 32) )
  {
LABEL_10:
    common::milog::MiLogStream::create(
      &v9,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkSubHcoin",
      6094);
    v5 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
           &v9,
           (const char (*)[35])"hcoin check sub failed, cur_hcoin:");
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &this->hcoin_);
    v7 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v6, (const char (*)[12])" sub_hcoin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v2 + 32));
    common::milog::MiLogStream::~MiLogStream(&v9);
    result = 624LL;
  }
  else
  {
    result = 0LL;
  }
  if ( v10 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6102: range 0000000017CF0D00-0000000017CF13B4
__int64 __fastcall PlayerItemComp::subHcoin(
        PlayerItemComp *const this,
        uint32_t sub_hcoin,
        const SubItemReason *reason,
        bool is_notify)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r14
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  unsigned int v12; // r13d
  PlayerBasicComp *BasicComp; // rax
  proto::PropValue *i; // r13
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  uint32_t reason_type; // r13d
  int64_t RealLeftHcoin; // rax
  __int64 result; // rax
  std::string __l; // [rsp+0h] [rbp-170h]
  std::initializer_list<proto::PropValue> __la; // [rsp+0h] [rbp-170h]
  const SubItemReason *reasona; // [rsp+18h] [rbp-158h]
  std::allocator<proto::PropValue> __a; // [rsp+37h] [rbp-139h] BYREF
  int64_t old_hcoin; // [rsp+38h] [rbp-138h]
  common::milog::MiLogStream v25; // [rsp+40h] [rbp-130h] BYREF
  proto::PropValue v26; // [rsp+60h] [rbp-110h] BYREF
  proto::PropValue v27; // [rsp+90h] [rbp-E0h] BYREF
  char v28[176]; // [rsp+C0h] [rbp-B0h] BYREF

  *(&__l._anon_0._M_allocated_capacity + 1) = (std::string::size_type)reason;
  v4 = (unsigned __int64)v28;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 1 23 log_context_holder:6109 48 4 14 sub_hcoin:6101 64 24 13 prop_vec:6115";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::subHcoin;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556927;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  *(_DWORD *)(v4 + 48) = sub_hcoin;
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->wait_sub_hcoin_);
  }
  if ( this->wait_sub_hcoin_ )
    goto LABEL_10;
  if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->hcoin_);
  }
  if ( this->hcoin_ < *(_DWORD *)(v4 + 48) )
  {
LABEL_10:
    common::milog::MiLogStream::create(
      &v25,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "subHcoin",
      6105);
    v7 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
           &v25,
           (const char (*)[35])"hcoin check sub failed, cur_hcoin:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->hcoin_);
    v9 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(v8, (const char (*)[18])" wait_sub_hcoin_:");
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &this->wait_sub_hcoin_);
    v11 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v10, (const char (*)[12])" sub_hcoin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v4 + 48));
    common::milog::MiLogStream::~MiLogStream(&v25);
    v12 = -1;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v25, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32), 0x67u, __l);
    std::string::~string(&v25);
    old_hcoin = PlayerItemComp::getRealLeftHcoin(this);
    if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->hcoin_);
    }
    this->hcoin_ -= *(_DWORD *)(v4 + 48);
    if ( is_notify )
    {
      buildIntProp(&v26, 0x271Fu, this->hcoin_);
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3)
                                                            + 0x7FFF8000) )
      {
        __asan_report_load4(&this->wait_sub_hcoin_);
      }
      buildIntProp(&v27, 0x2726u, this->wait_sub_hcoin_);
      __la._M_array = &v26;
      __la._M_len = 2LL;
      std::allocator<proto::PropValue>::allocator(&__a);
      std::vector<proto::PropValue>::vector((std::vector<proto::PropValue> *const)(v4 + 64), __la, &__a);
      std::allocator<proto::PropValue>::~allocator(&__a);
      for ( i = (proto::PropValue *)v28; i != &v26; (*vptr_MessageLite)(i) )
      {
        if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
        if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
          __asan_report_load8();
      }
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::notifyPlayerPropList(this->player_, (const std::vector<proto::PropValue> *)(v4 + 64));
      std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v4 + 64));
    }
    if ( *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)reasona & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona);
    }
    reason_type = reasona->reason_type;
    RealLeftHcoin = PlayerItemComp::getRealLeftHcoin(this);
    PlayerItemComp::logPlayerAddCoin(
      this,
      ITEM_VIRTUAL_HCOIN,
      old_hcoin,
      RealLeftHcoin,
      reason_type,
      ITEM_LIMIT_NONE,
      0);
    v12 = 0;
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32));
  }
  result = v12;
  if ( v28 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6127: range 0000000017CF13B6-0000000017CF1615
__int64 __fastcall PlayerItemComp::checkAddScoin(PlayerItemComp *const this, uint32_t add_scoin)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r13
  common::milog::MiLogStream *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  common::milog::MiLogStream v9; // [rsp+10h] [rbp-80h] BYREF
  char v10[96]; // [rsp+30h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 14 add_scoin:6126";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkAddScoin;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = add_scoin;
  if ( *(_DWORD *)(v2 + 32) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->scoin_);
    }
    if ( this->scoin_ && *(_DWORD *)(v2 + 32) + this->scoin_ < *(_DWORD *)(v2 + 32) )
      goto LABEL_14;
  }
  if ( *(_DWORD *)(v2 + 32) )
    goto LABEL_15;
  if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->scoin_);
  }
  if ( this->scoin_ || *(_DWORD *)(v2 + 32) + this->scoin_ <= *(_DWORD *)(v2 + 32) )
  {
LABEL_15:
    result = 0LL;
  }
  else
  {
LABEL_14:
    common::milog::MiLogStream::create(
      &v9,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkAddScoin",
      6130);
    v5 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
           &v9,
           (const char (*)[31])"scoin add overflow, cur_scoin:");
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &this->scoin_);
    v7 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v6, (const char (*)[12])" add_scoin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v2 + 32));
    common::milog::MiLogStream::~MiLogStream(&v9);
    result = 627LL;
  }
  if ( v10 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6138: range 0000000017CF1616-0000000017CF203F
__int64 __fastcall PlayerItemComp::addScoin(
        PlayerItemComp *const this,
        uint32_t add_scoin,
        const ActionReason *reason,
        bool is_notify)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r14
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  unsigned int v10; // r13d
  PlayerBasicComp *BasicComp; // rax
  unsigned int v12; // ecx
  __int64 v13; // rdx
  char v14; // al
  __int64 v15; // rsi
  common::milog::MiLogStream *v16; // r13
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  proto::PropValue *i; // r13
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  data::ItemLimitType v23; // r13d
  int64_t RealLeftScoin; // rax
  __int64 result; // rax
  std::string __l; // [rsp+0h] [rbp-170h]
  std::initializer_list<proto::PropValue> __la; // [rsp+0h] [rbp-170h]
  uint32_t __lb; // [rsp+0h] [rbp-170h]
  uint32_t *reasona; // [rsp+18h] [rbp-158h]
  std::allocator<proto::PropValue> __a; // [rsp+33h] [rbp-13Dh] BYREF
  unsigned int val; // [rsp+34h] [rbp-13Ch] BYREF
  int64_t old_scoin; // [rsp+38h] [rbp-138h]
  common::milog::MiLogStream v34; // [rsp+40h] [rbp-130h] BYREF
  proto::PropValue v35; // [rsp+60h] [rbp-110h] BYREF
  proto::PropValue v36; // [rsp+90h] [rbp-E0h] BYREF
  char v37[176]; // [rsp+C0h] [rbp-B0h] BYREF

  *(&__l._anon_0._M_allocated_capacity + 1) = (std::string::size_type)reason;
  v4 = (unsigned __int64)v37;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 1 23 log_context_holder:6145 48 4 14 add_scoin:6137 64 24 13 prop_vec:6164";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addScoin;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556927;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  *(_DWORD *)(v4 + 48) = add_scoin;
  if ( *(_DWORD *)(v4 + 48) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->scoin_);
    }
    if ( this->scoin_ && *(_DWORD *)(v4 + 48) + this->scoin_ < *(_DWORD *)(v4 + 48) )
      goto LABEL_14;
  }
  if ( *(_DWORD *)(v4 + 48) )
    goto LABEL_64;
  if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->scoin_);
  }
  if ( this->scoin_ || *(_DWORD *)(v4 + 48) + this->scoin_ <= *(_DWORD *)(v4 + 48) )
  {
LABEL_64:
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v34, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32), 0x67u, __l);
    std::string::~string(&v34);
    old_scoin = PlayerItemComp::getRealLeftScoin(this);
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->wait_sub_scoin_);
    }
    if ( this->wait_sub_scoin_ >= *(_DWORD *)(v4 + 48) )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&this->wait_sub_scoin_);
      }
      this->wait_sub_scoin_ -= *(_DWORD *)(v4 + 48);
    }
    else
    {
      v12 = *(_DWORD *)(v4 + 48) - this->wait_sub_scoin_;
      if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&this->scoin_);
      }
      v15 = v12;
      v13 = SAFE_ADD<unsigned int,unsigned int>(this->scoin_, v12);
      v14 = *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000);
      LOBYTE(v15) = v14 != 0;
      if ( v14 != 0 && v14 <= 3 )
        __asan_report_store4(&this->scoin_, v15, v13);
      this->scoin_ = v13;
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_store4(&this->wait_sub_scoin_, v15, &this->wait_sub_scoin_);
      }
      this->wait_sub_scoin_ = 0;
    }
    if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->scoin_);
    }
    if ( this->scoin_ )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&this->wait_sub_scoin_);
      }
      if ( this->wait_sub_scoin_ )
      {
        common::milog::MiLogStream::create(
          &v34,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addScoin",
          6159);
        v16 = common::milog::MiLogStream::operator<<<char [5],(char *[5])0>(&v34, (const char (*)[5])"uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, &val);
        v18 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v17, (const char (*)[9])" scoin_:");
        v19 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, &this->scoin_);
        v20 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(
                v19,
                (const char (*)[18])" wait_sub_scoin_:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &this->wait_sub_scoin_);
        common::milog::MiLogStream::~MiLogStream(&v34);
      }
    }
    if ( is_notify )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&this->scoin_);
      }
      buildIntProp(&v35, 0x2720u, this->scoin_);
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&this->wait_sub_scoin_);
      }
      buildIntProp(&v36, 0x2727u, this->wait_sub_scoin_);
      __la._M_array = &v35;
      __la._M_len = 2LL;
      std::allocator<proto::PropValue>::allocator(&__a);
      std::vector<proto::PropValue>::vector((std::vector<proto::PropValue> *const)(v4 + 64), __la, &__a);
      std::allocator<proto::PropValue>::~allocator(&__a);
      for ( i = (proto::PropValue *)v37; i != &v35; (*vptr_MessageLite)(i) )
      {
        if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
        if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
          __asan_report_load8();
      }
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::notifyPlayerPropList(this->player_, (const std::vector<proto::PropValue> *)(v4 + 64));
      std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v4 + 64));
    }
    if ( *(_BYTE *)(((unsigned __int64)(reasona + 1) >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reasona + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)(reasona + 1) >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona + 1);
    }
    v23 = reasona[1];
    if ( *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)reasona & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona);
    }
    __lb = *reasona;
    RealLeftScoin = PlayerItemComp::getRealLeftScoin(this);
    PlayerItemComp::logPlayerAddCoin(this, ITEM_VIRTUAL_SCOIN, old_scoin, RealLeftScoin, __lb, v23, 0);
    v10 = 0;
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32));
  }
  else
  {
LABEL_14:
    common::milog::MiLogStream::create(
      &v34,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "addScoin",
      6141);
    v7 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
           &v34,
           (const char (*)[31])"scoin add overflow, cur_scoin:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->scoin_);
    v9 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v8, (const char (*)[12])" add_scoin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 48));
    common::milog::MiLogStream::~MiLogStream(&v34);
    v10 = -1;
  }
  result = v10;
  if ( v37 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6175: range 0000000017CF2040-0000000017CF2251
__int64 __fastcall PlayerItemComp::checkSubScoin(PlayerItemComp *const this, uint32_t sub_scoin)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  common::milog::MiLogStream *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  common::milog::MiLogStream v9; // [rsp+10h] [rbp-80h] BYREF
  char v10[96]; // [rsp+30h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 14 sub_scoin:6174";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkSubScoin;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = sub_scoin;
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->wait_sub_scoin_);
  }
  if ( this->wait_sub_scoin_ )
    goto LABEL_10;
  if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->scoin_);
  }
  if ( this->scoin_ < *(_DWORD *)(v2 + 32) )
  {
LABEL_10:
    common::milog::MiLogStream::create(
      &v9,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkSubScoin",
      6178);
    v5 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
           &v9,
           (const char (*)[35])"scoin check sub failed, cur_scoin:");
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &this->scoin_);
    v7 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v6, (const char (*)[12])" sub_scoin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v2 + 32));
    common::milog::MiLogStream::~MiLogStream(&v9);
    result = 625LL;
  }
  else
  {
    result = 0LL;
  }
  if ( v10 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6186: range 0000000017CF2252-0000000017CF28E6
__int64 __fastcall PlayerItemComp::subScoin(
        PlayerItemComp *const this,
        uint32_t sub_scoin,
        const SubItemReason *reason,
        bool is_notify)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r14
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  unsigned int v12; // r13d
  PlayerBasicComp *BasicComp; // rax
  proto::PropValue *i; // r13
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  uint32_t reason_type; // r13d
  int64_t RealLeftScoin; // rax
  __int64 result; // rax
  std::string __l; // [rsp+0h] [rbp-170h]
  std::initializer_list<proto::PropValue> __la; // [rsp+0h] [rbp-170h]
  const SubItemReason *reasona; // [rsp+18h] [rbp-158h]
  std::allocator<proto::PropValue> __a; // [rsp+37h] [rbp-139h] BYREF
  int64_t old_scoin; // [rsp+38h] [rbp-138h]
  common::milog::MiLogStream v25; // [rsp+40h] [rbp-130h] BYREF
  proto::PropValue v26; // [rsp+60h] [rbp-110h] BYREF
  proto::PropValue v27; // [rsp+90h] [rbp-E0h] BYREF
  char v28[176]; // [rsp+C0h] [rbp-B0h] BYREF

  *(&__l._anon_0._M_allocated_capacity + 1) = (std::string::size_type)reason;
  v4 = (unsigned __int64)v28;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 1 23 log_context_holder:6193 48 4 14 sub_scoin:6185 64 24 13 prop_vec:6199";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::subScoin;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556927;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  *(_DWORD *)(v4 + 48) = sub_scoin;
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->wait_sub_scoin_);
  }
  if ( this->wait_sub_scoin_ )
    goto LABEL_10;
  if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->scoin_);
  }
  if ( this->scoin_ < *(_DWORD *)(v4 + 48) )
  {
LABEL_10:
    common::milog::MiLogStream::create(
      &v25,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "subScoin",
      6189);
    v7 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
           &v25,
           (const char (*)[35])"scoin check sub failed, cur_scoin:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->scoin_);
    v9 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(v8, (const char (*)[18])" wait_sub_scoin_:");
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &this->wait_sub_scoin_);
    v11 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v10, (const char (*)[12])" sub_scoin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v4 + 48));
    common::milog::MiLogStream::~MiLogStream(&v25);
    v12 = -1;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v25, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32), 0x67u, __l);
    std::string::~string(&v25);
    old_scoin = PlayerItemComp::getRealLeftScoin(this);
    if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->scoin_);
    }
    this->scoin_ -= *(_DWORD *)(v4 + 48);
    if ( is_notify )
    {
      buildIntProp(&v26, 0x2720u, this->scoin_);
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&this->wait_sub_scoin_);
      }
      buildIntProp(&v27, 0x2727u, this->wait_sub_scoin_);
      __la._M_array = &v26;
      __la._M_len = 2LL;
      std::allocator<proto::PropValue>::allocator(&__a);
      std::vector<proto::PropValue>::vector((std::vector<proto::PropValue> *const)(v4 + 64), __la, &__a);
      std::allocator<proto::PropValue>::~allocator(&__a);
      for ( i = (proto::PropValue *)v28; i != &v26; (*vptr_MessageLite)(i) )
      {
        if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
        if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
          __asan_report_load8();
      }
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::notifyPlayerPropList(this->player_, (const std::vector<proto::PropValue> *)(v4 + 64));
      std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v4 + 64));
    }
    if ( *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)reasona & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona);
    }
    reason_type = reasona->reason_type;
    RealLeftScoin = PlayerItemComp::getRealLeftScoin(this);
    PlayerItemComp::logPlayerAddCoin(
      this,
      ITEM_VIRTUAL_SCOIN,
      old_scoin,
      RealLeftScoin,
      reason_type,
      ITEM_LIMIT_NONE,
      0);
    v12 = 0;
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32));
  }
  result = v12;
  if ( v28 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6210: range 0000000017CF28E8-0000000017CF2B5B
__int64 __fastcall PlayerItemComp::checkAddHomeCoin(PlayerItemComp *const this, uint32_t add_home_coin)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r13
  common::milog::MiLogStream *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  common::milog::MiLogStream v9; // [rsp+10h] [rbp-80h] BYREF
  char v10[96]; // [rsp+30h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 18 add_home_coin:6209";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkAddHomeCoin;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = add_home_coin;
  if ( *(_DWORD *)(v2 + 32) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->home_coin_);
    }
    if ( this->home_coin_ && *(_DWORD *)(v2 + 32) + this->home_coin_ < *(_DWORD *)(v2 + 32) )
      goto LABEL_14;
  }
  if ( *(_DWORD *)(v2 + 32) )
    goto LABEL_15;
  if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->home_coin_);
  }
  if ( this->home_coin_ || *(_DWORD *)(v2 + 32) + this->home_coin_ <= *(_DWORD *)(v2 + 32) )
  {
LABEL_15:
    result = 0LL;
  }
  else
  {
LABEL_14:
    common::milog::MiLogStream::create(
      &v9,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkAddHomeCoin",
      6213);
    v5 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
           &v9,
           (const char (*)[39])"home_coin add overflow, cur_home_coin:");
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &this->home_coin_);
    v7 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v6, (const char (*)[16])" add_home_coin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v2 + 32));
    common::milog::MiLogStream::~MiLogStream(&v9);
    result = 9724LL;
  }
  if ( v10 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6221: range 0000000017CF2B5C-0000000017CF35DD
__int64 __fastcall PlayerItemComp::addHomeCoin(
        PlayerItemComp *const this,
        uint32_t add_home_coin,
        const ActionReason *reason,
        bool is_notify)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r14
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  unsigned int v10; // r13d
  PlayerBasicComp *BasicComp; // rax
  unsigned int v12; // ecx
  uint32_t v13; // ecx
  char v14; // dl
  __int64 v15; // rsi
  __int64 v16; // rdx
  __int64 v17; // rdx
  common::milog::MiLogStream *v18; // r13
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  proto::PropValue *i; // r13
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  data::ItemLimitType v25; // r13d
  int64_t RealLeftHomeCoin; // rax
  __int64 result; // rax
  std::string __l; // [rsp+0h] [rbp-170h]
  std::initializer_list<proto::PropValue> __la; // [rsp+0h] [rbp-170h]
  uint32_t __lb; // [rsp+0h] [rbp-170h]
  uint32_t *reasona; // [rsp+18h] [rbp-158h]
  std::allocator<proto::PropValue> __a; // [rsp+33h] [rbp-13Dh] BYREF
  unsigned int val; // [rsp+34h] [rbp-13Ch] BYREF
  int64_t old_home_coin; // [rsp+38h] [rbp-138h]
  common::milog::MiLogStream v36; // [rsp+40h] [rbp-130h] BYREF
  proto::PropValue v37; // [rsp+60h] [rbp-110h] BYREF
  proto::PropValue v38; // [rsp+90h] [rbp-E0h] BYREF
  char v39[176]; // [rsp+C0h] [rbp-B0h] BYREF

  *(&__l._anon_0._M_allocated_capacity + 1) = (std::string::size_type)reason;
  v4 = (unsigned __int64)v39;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 1 23 log_context_holder:6228 48 4 18 add_home_coin:6220 64 24 13 prop_vec:6247";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addHomeCoin;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556927;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  *(_DWORD *)(v4 + 48) = add_home_coin;
  if ( *(_DWORD *)(v4 + 48) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->home_coin_);
    }
    if ( this->home_coin_ && *(_DWORD *)(v4 + 48) + this->home_coin_ < *(_DWORD *)(v4 + 48) )
      goto LABEL_14;
  }
  if ( *(_DWORD *)(v4 + 48) )
    goto LABEL_64;
  if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->home_coin_);
  }
  if ( this->home_coin_ || *(_DWORD *)(v4 + 48) + this->home_coin_ <= *(_DWORD *)(v4 + 48) )
  {
LABEL_64:
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v36, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32), 0x67u, __l);
    std::string::~string(&v36);
    old_home_coin = PlayerItemComp::getRealLeftHomeCoin(this);
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3)
                                                         + 0x7FFF8000) )
    {
      __asan_report_load4(&this->wait_sub_home_coin_);
    }
    if ( this->wait_sub_home_coin_ >= *(_DWORD *)(v4 + 48) )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3)
                                                           + 0x7FFF8000) )
      {
        __asan_report_load4(&this->wait_sub_home_coin_);
      }
      this->wait_sub_home_coin_ -= *(_DWORD *)(v4 + 48);
    }
    else
    {
      v12 = *(_DWORD *)(v4 + 48) - this->wait_sub_home_coin_;
      if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&this->home_coin_);
      }
      v15 = v12;
      v13 = SAFE_ADD<unsigned int,unsigned int>(this->home_coin_, v12);
      v14 = *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000);
      LOBYTE(v15) = v14 != 0;
      v16 = (v14 != 0) & (unsigned __int8)((char)((((_BYTE)this - 20) & 7) + 3) >= v14);
      if ( (_BYTE)v16 )
        __asan_report_store4(&this->home_coin_, v15, v16);
      this->home_coin_ = v13;
      v17 = (*(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000));
      if ( (_BYTE)v17 )
        __asan_report_store4(&this->wait_sub_home_coin_, (((_BYTE)this + 4) & 7u) + 3, v17);
      this->wait_sub_home_coin_ = 0;
    }
    if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->home_coin_);
    }
    if ( this->home_coin_ )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3)
                                                           + 0x7FFF8000) )
      {
        __asan_report_load4(&this->wait_sub_home_coin_);
      }
      if ( this->wait_sub_home_coin_ )
      {
        common::milog::MiLogStream::create(
          &v36,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "addHomeCoin",
          6242);
        v18 = common::milog::MiLogStream::operator<<<char [5],(char *[5])0>(&v36, (const char (*)[5])"uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        v19 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, &val);
        v20 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v19, (const char (*)[13])" home_coin_:");
        v21 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &this->home_coin_);
        v22 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
                v21,
                (const char (*)[22])" wait_sub_home_coin_:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, &this->wait_sub_home_coin_);
        common::milog::MiLogStream::~MiLogStream(&v36);
      }
    }
    if ( is_notify )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&this->home_coin_);
      }
      buildIntProp(&v37, 0x273Au, this->home_coin_);
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3)
                                                           + 0x7FFF8000) )
      {
        __asan_report_load4(&this->wait_sub_home_coin_);
      }
      buildIntProp(&v38, 0x273Bu, this->wait_sub_home_coin_);
      __la._M_array = &v37;
      __la._M_len = 2LL;
      std::allocator<proto::PropValue>::allocator(&__a);
      std::vector<proto::PropValue>::vector((std::vector<proto::PropValue> *const)(v4 + 64), __la, &__a);
      std::allocator<proto::PropValue>::~allocator(&__a);
      for ( i = (proto::PropValue *)v39; i != &v37; (*vptr_MessageLite)(i) )
      {
        if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
        if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
          __asan_report_load8();
      }
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::notifyPlayerPropList(this->player_, (const std::vector<proto::PropValue> *)(v4 + 64));
      std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v4 + 64));
    }
    if ( *(_BYTE *)(((unsigned __int64)(reasona + 1) >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reasona + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)(reasona + 1) >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona + 1);
    }
    v25 = reasona[1];
    if ( *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)reasona & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona);
    }
    __lb = *reasona;
    RealLeftHomeCoin = PlayerItemComp::getRealLeftHomeCoin(this);
    PlayerItemComp::logPlayerAddCoin(this, ITEM_VIRTUAL_HOME_COIN, old_home_coin, RealLeftHomeCoin, __lb, v25, 0);
    v10 = 0;
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32));
  }
  else
  {
LABEL_14:
    common::milog::MiLogStream::create(
      &v36,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "addHomeCoin",
      6224);
    v7 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
           &v36,
           (const char (*)[39])"home_coin add overflow, cur_home_coin:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->home_coin_);
    v9 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v8, (const char (*)[16])" add_home_coin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 48));
    common::milog::MiLogStream::~MiLogStream(&v36);
    v10 = -1;
  }
  result = v10;
  if ( v39 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6258: range 0000000017CF35DE-0000000017CF37FF
__int64 __fastcall PlayerItemComp::checkSubHomeCoin(PlayerItemComp *const this, uint32_t sub_home_coin)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  common::milog::MiLogStream *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  common::milog::MiLogStream v9; // [rsp+10h] [rbp-80h] BYREF
  char v10[96]; // [rsp+30h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 18 sub_home_coin:6257";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkSubHomeCoin;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = sub_home_coin;
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->wait_sub_home_coin_);
  }
  if ( this->wait_sub_home_coin_ )
    goto LABEL_10;
  if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->home_coin_);
  }
  if ( this->home_coin_ < *(_DWORD *)(v2 + 32) )
  {
LABEL_10:
    common::milog::MiLogStream::create(
      &v9,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkSubHomeCoin",
      6261);
    v5 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
           &v9,
           (const char (*)[43])"home_coin check sub failed, cur_home_coin:");
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &this->home_coin_);
    v7 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v6, (const char (*)[16])" sub_home_coin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v2 + 32));
    common::milog::MiLogStream::~MiLogStream(&v9);
    result = 9725LL;
  }
  else
  {
    result = 0LL;
  }
  if ( v10 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6269: range 0000000017CF3800-0000000017CF3EB4
__int64 __fastcall PlayerItemComp::subHomeCoin(
        PlayerItemComp *const this,
        uint32_t sub_home_coin,
        const SubItemReason *reason,
        bool is_notify)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r14
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  unsigned int v12; // r13d
  PlayerBasicComp *BasicComp; // rax
  proto::PropValue *i; // r13
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  uint32_t reason_type; // r13d
  int64_t RealLeftHomeCoin; // rax
  __int64 result; // rax
  std::string __l; // [rsp+0h] [rbp-170h]
  std::initializer_list<proto::PropValue> __la; // [rsp+0h] [rbp-170h]
  const SubItemReason *reasona; // [rsp+18h] [rbp-158h]
  std::allocator<proto::PropValue> __a; // [rsp+37h] [rbp-139h] BYREF
  int64_t old_home_coin; // [rsp+38h] [rbp-138h]
  common::milog::MiLogStream v25; // [rsp+40h] [rbp-130h] BYREF
  proto::PropValue v26; // [rsp+60h] [rbp-110h] BYREF
  proto::PropValue v27; // [rsp+90h] [rbp-E0h] BYREF
  char v28[176]; // [rsp+C0h] [rbp-B0h] BYREF

  *(&__l._anon_0._M_allocated_capacity + 1) = (std::string::size_type)reason;
  v4 = (unsigned __int64)v28;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 1 23 log_context_holder:6276 48 4 18 sub_home_coin:6268 64 24 13 prop_vec:6282";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::subHomeCoin;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556927;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  *(_DWORD *)(v4 + 48) = sub_home_coin;
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->wait_sub_home_coin_);
  }
  if ( this->wait_sub_home_coin_ )
    goto LABEL_10;
  if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->home_coin_);
  }
  if ( this->home_coin_ < *(_DWORD *)(v4 + 48) )
  {
LABEL_10:
    common::milog::MiLogStream::create(
      &v25,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "subHomeCoin",
      6272);
    v7 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
           &v25,
           (const char (*)[43])"home_coin check sub failed, cur_home_coin:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->home_coin_);
    v9 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
           v8,
           (const char (*)[22])" wait_sub_home_coin_:");
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &this->wait_sub_home_coin_);
    v11 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v10, (const char (*)[16])" sub_home_coin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v4 + 48));
    common::milog::MiLogStream::~MiLogStream(&v25);
    v12 = -1;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v25, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32), 0x67u, __l);
    std::string::~string(&v25);
    old_home_coin = PlayerItemComp::getRealLeftHomeCoin(this);
    if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->home_coin_);
    }
    this->home_coin_ -= *(_DWORD *)(v4 + 48);
    if ( is_notify )
    {
      buildIntProp(&v26, 0x273Au, this->home_coin_);
      if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3)
                                                           + 0x7FFF8000) )
      {
        __asan_report_load4(&this->wait_sub_home_coin_);
      }
      buildIntProp(&v27, 0x273Bu, this->wait_sub_home_coin_);
      __la._M_array = &v26;
      __la._M_len = 2LL;
      std::allocator<proto::PropValue>::allocator(&__a);
      std::vector<proto::PropValue>::vector((std::vector<proto::PropValue> *const)(v4 + 64), __la, &__a);
      std::allocator<proto::PropValue>::~allocator(&__a);
      for ( i = (proto::PropValue *)v28; i != &v26; (*vptr_MessageLite)(i) )
      {
        if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
        if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
          __asan_report_load8();
      }
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::notifyPlayerPropList(this->player_, (const std::vector<proto::PropValue> *)(v4 + 64));
      std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v4 + 64));
    }
    if ( *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)reasona & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reasona >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reasona);
    }
    reason_type = reasona->reason_type;
    RealLeftHomeCoin = PlayerItemComp::getRealLeftHomeCoin(this);
    PlayerItemComp::logPlayerAddCoin(
      this,
      ITEM_VIRTUAL_HOME_COIN,
      old_home_coin,
      RealLeftHomeCoin,
      reason_type,
      ITEM_LIMIT_NONE,
      0);
    v12 = 0;
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32));
  }
  result = v12;
  if ( v28 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6294: range 0000000017CF3EB6-0000000017CF4527
__int64 __fastcall PlayerItemComp::subMcoinNegative(
        PlayerItemComp *const this,
        __int32 sub_mcoin,
        __int32 platform_type)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  common::milog::MiLogStream *v6; // r14
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  unsigned int v12; // r14d
  PlayerBasicComp *BasicComp; // rax
  uint32_t v14; // eax
  uint32_t WaitSubMcoin; // eax
  proto::PropValue *i; // r14
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  int64_t AllPlatRealLeftMcoin; // rax
  __int64 result; // rax
  std::string v20; // [rsp+0h] [rbp-190h]
  std::allocator<proto::PropValue> __a; // [rsp+2Fh] [rbp-161h] BYREF
  unsigned int val; // [rsp+30h] [rbp-160h] BYREF
  uint32_t mcoin; // [rsp+34h] [rbp-15Ch]
  int64_t old_mcoin; // [rsp+38h] [rbp-158h]
  common::milog::MiLogStream v25; // [rsp+40h] [rbp-150h] BYREF
  proto::PropValue v26; // [rsp+60h] [rbp-130h] BYREF
  proto::PropValue v27; // [rsp+90h] [rbp-100h] BYREF
  char v28[208]; // [rsp+C0h] [rbp-D0h] BYREF

  *(&v20._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  HIDWORD(v20._anon_0._M_allocated_capacity) = sub_mcoin;
  *(_DWORD *)v20._anon_0._M_local_buf = platform_type;
  v3 = (unsigned __int64)v28;
  v20._M_string_length = (std::string::size_type)v28;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(160LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "4 48 1 23 log_context_holder:6304 64 4 19 wait_sub_mcoin:6296 80 4 14 sub_mcoin:6293 96 24 13 prop_vec:6319";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::subMcoinNegative;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234753551;
  v5[536862722] = -234556924;
  v5[536862723] = -218103808;
  v5[536862724] = -202116109;
  *(_DWORD *)(v3 + 80) = sub_mcoin;
  mcoin = PlayerItemComp::getMcoin(this, v20._anon_0._M_allocated_capacity);
  *(_DWORD *)(v3 + 64) = PlayerItemComp::getWaitSubMcoin(this, v20._anon_0._M_allocated_capacity);
  if ( (!*(_DWORD *)(v3 + 64)
     || !*(_DWORD *)(v3 + 80)
     || (unsigned int)(*(_DWORD *)(v3 + 80) + *(_DWORD *)(v3 + 64)) >= *(_DWORD *)(v3 + 64))
    && (*(_DWORD *)(v3 + 64)
     || *(_DWORD *)(v3 + 80)
     || (unsigned int)(*(_DWORD *)(v3 + 80) + *(_DWORD *)(v3 + 64)) <= *(_DWORD *)(v3 + 64)) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v25, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v3 + 48), 0x67u, v20);
    std::string::~string(&v25);
    old_mcoin = PlayerItemComp::getAllPlatRealLeftMcoin(*((const PlayerItemComp *const *)&v20._anon_0._M_allocated_capacity
                                                        + 1));
    if ( mcoin < *(_DWORD *)(v3 + 80) )
    {
      *(_DWORD *)(v3 + 64) = SAFE_ADD<unsigned int,unsigned int>(*(_DWORD *)(v3 + 64), *(_DWORD *)(v3 + 80) - mcoin);
      mcoin = 0;
    }
    else
    {
      mcoin -= *(_DWORD *)(v3 + 80);
    }
    PlayerItemComp::setMcoin(
      *((PlayerItemComp *const *)&v20._anon_0._M_allocated_capacity + 1),
      mcoin,
      v20._anon_0._M_allocated_capacity);
    PlayerItemComp::setWaitSubMcoin(
      *((PlayerItemComp *const *)&v20._anon_0._M_allocated_capacity + 1),
      *(_DWORD *)(v3 + 64),
      v20._anon_0._M_allocated_capacity);
    v14 = PlayerItemComp::getMcoin(*((const PlayerItemComp *const *)&v20._anon_0._M_allocated_capacity + 1));
    buildIntProp(&v26, 0x2729u, v14);
    WaitSubMcoin = PlayerItemComp::getWaitSubMcoin(*((const PlayerItemComp *const *)&v20._anon_0._M_allocated_capacity
                                                   + 1));
    buildIntProp(&v27, 0x272Au, WaitSubMcoin);
    std::allocator<proto::PropValue>::allocator(&__a);
    std::vector<proto::PropValue>::vector(
      (std::vector<proto::PropValue> *const)(v3 + 96),
      (std::initializer_list<proto::PropValue>)__PAIR128__(2LL, &v26),
      &__a);
    std::allocator<proto::PropValue>::~allocator(&__a);
    for ( i = (proto::PropValue *)v28; i != &v26; (*vptr_MessageLite)(i) )
    {
      if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
      if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    if ( *(_BYTE *)(((*(&v20._anon_0._M_allocated_capacity + 1) + 24) >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    Player::notifyPlayerPropList(
      *(Player *const *)(*(&v20._anon_0._M_allocated_capacity + 1) + 24),
      (const std::vector<proto::PropValue> *)(v3 + 96));
    AllPlatRealLeftMcoin = PlayerItemComp::getAllPlatRealLeftMcoin(*((const PlayerItemComp *const *)&v20._anon_0._M_allocated_capacity
                                                                   + 1));
    PlayerItemComp::logPlayerAddCoin(
      *((PlayerItemComp *const *)&v20._anon_0._M_allocated_capacity + 1),
      ITEM_VIRTUAL_MCOIN,
      old_mcoin,
      AllPlatRealLeftMcoin,
      0x412u,
      ITEM_LIMIT_NONE,
      1,
      1,
      v20._anon_0._M_allocated_capacity);
    v12 = 0;
    std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v3 + 96));
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v3 + 48));
  }
  else
  {
    common::milog::MiLogStream::create(
      &v25,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "subMcoinNegative",
      6300);
    v6 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(&v25, (const char (*)[6])"uid: ");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, &val);
    v8 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v7, (const char (*)[17])" wait_sub_mcoin:");
    v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, (const unsigned int *)(v3 + 64));
    v10 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v9, (const char (*)[12])" sub_mcoin:");
    v11 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, (const unsigned int *)(v3 + 80));
    common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v11, (const char (*)[10])" overflow");
    common::milog::MiLogStream::~MiLogStream(&v25);
    v12 = -1;
  }
  result = v12;
  if ( v20._M_string_length == v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 6330: range 0000000017CF4528-0000000017CF4DC8
__int64 __fastcall PlayerItemComp::subHcoinNegative(PlayerItemComp *const this, __int32 sub_hcoin)
{
  unsigned __int64 v2; // r12
  __int64 v3; // rax
  _DWORD *v4; // r14
  common::milog::MiLogStream *v5; // r13
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  unsigned int v11; // r13d
  PlayerBasicComp *BasicComp; // rax
  int v13; // ecx
  unsigned int v14; // ecx
  SelectType v15; // ecx
  char v16; // dl
  __int64 v17; // rsi
  __int64 v18; // rdx
  __int64 v19; // rdx
  proto::PropValue *i; // r13
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  int64_t RealLeftHcoin; // rax
  __int64 result; // rax
  std::string __l; // [rsp+0h] [rbp-160h]
  std::initializer_list<proto::PropValue> __la; // [rsp+0h] [rbp-160h]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-148h]
  std::allocator<proto::PropValue> __a; // [rsp+23h] [rbp-13Dh] BYREF
  unsigned int val; // [rsp+24h] [rbp-13Ch] BYREF
  int64_t old_hcoin; // [rsp+28h] [rbp-138h]
  common::milog::MiLogStream v30; // [rsp+30h] [rbp-130h] BYREF
  proto::PropValue v31; // [rsp+50h] [rbp-110h] BYREF
  proto::PropValue v32; // [rsp+80h] [rbp-E0h] BYREF
  char v33[176]; // [rsp+B0h] [rbp-B0h] BYREF

  *(&__l._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  HIDWORD(__l._anon_0._M_allocated_capacity) = sub_hcoin;
  v2 = (unsigned __int64)v33;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(128LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "3 32 1 23 log_context_holder:6337 48 4 14 sub_hcoin:6329 64 24 13 prop_vec:6349";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::subHcoinNegative;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234556927;
  v4[536862722] = -218103808;
  v4[536862723] = -202116109;
  *(_DWORD *)(v2 + 48) = sub_hcoin;
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->wait_sub_hcoin_);
  }
  if ( this->wait_sub_hcoin_
    && *(_DWORD *)(v2 + 48)
    && *(_DWORD *)(v2 + 48) + this->wait_sub_hcoin_ < this->wait_sub_hcoin_ )
  {
    goto LABEL_14;
  }
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_hcoin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->wait_sub_hcoin_);
  }
  if ( this->wait_sub_hcoin_
    || *(_DWORD *)(v2 + 48)
    || *(_DWORD *)(v2 + 48) + this->wait_sub_hcoin_ <= this->wait_sub_hcoin_ )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v30, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v2 + 32), 0x67u, __l);
    std::string::~string(&v30);
    old_hcoin = PlayerItemComp::getRealLeftHcoin(thisa);
    if ( *(_BYTE *)(((unsigned __int64)&thisa->hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)thisa - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&thisa->hcoin_);
    }
    if ( thisa->hcoin_ < *(_DWORD *)(v2 + 48) )
    {
      v13 = *(_DWORD *)(v2 + 48);
      if ( *(_BYTE *)(((unsigned __int64)&thisa->hcoin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)thisa - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->hcoin_ >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&thisa->hcoin_);
      }
      v14 = v13 - thisa->hcoin_;
      if ( *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)thisa - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_hcoin_ >> 3)
                                                             + 0x7FFF8000) )
      {
        __asan_report_load4(&thisa->wait_sub_hcoin_);
      }
      v17 = v14;
      v15 = SAFE_ADD<unsigned int,unsigned int>(thisa->wait_sub_hcoin_, v14);
      v16 = *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_hcoin_ >> 3) + 0x7FFF8000);
      LOBYTE(v17) = v16 != 0;
      v18 = (v16 != 0) & (unsigned __int8)((char)((((_BYTE)thisa - 12) & 7) + 3) >= v16);
      if ( (_BYTE)v18 )
        __asan_report_store4(&thisa->wait_sub_hcoin_, v17, v18);
      thisa->wait_sub_hcoin_ = v15;
      v19 = (*(_BYTE *)(((unsigned __int64)&thisa->hcoin_ >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)thisa - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->hcoin_ >> 3) + 0x7FFF8000));
      if ( (_BYTE)v19 )
        __asan_report_store4(&thisa->hcoin_, (((_BYTE)thisa - 28) & 7u) + 3, v19);
      thisa->hcoin_ = 0;
    }
    else
    {
      thisa->hcoin_ -= *(_DWORD *)(v2 + 48);
    }
    if ( *(_BYTE *)(((unsigned __int64)&thisa->hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)thisa - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->hcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&thisa->hcoin_);
    }
    buildIntProp(&v31, 0x271Fu, thisa->hcoin_);
    if ( *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_hcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)thisa - 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_hcoin_ >> 3)
                                                           + 0x7FFF8000) )
    {
      __asan_report_load4(&thisa->wait_sub_hcoin_);
    }
    buildIntProp(&v32, 0x2726u, thisa->wait_sub_hcoin_);
    __la._M_array = &v31;
    __la._M_len = 2LL;
    std::allocator<proto::PropValue>::allocator(&__a);
    std::vector<proto::PropValue>::vector((std::vector<proto::PropValue> *const)(v2 + 64), __la, &__a);
    std::allocator<proto::PropValue>::~allocator(&__a);
    for ( i = (proto::PropValue *)v33; i != &v31; (*vptr_MessageLite)(i) )
    {
      if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
      if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    Player::notifyPlayerPropList(thisa->player_, (const std::vector<proto::PropValue> *)(v2 + 64));
    RealLeftHcoin = PlayerItemComp::getRealLeftHcoin(thisa);
    PlayerItemComp::logPlayerAddCoin(thisa, ITEM_VIRTUAL_HCOIN, old_hcoin, RealLeftHcoin, 0x412u, ITEM_LIMIT_NONE, 0);
    v11 = 0;
    std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v2 + 64));
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v2 + 32));
  }
  else
  {
LABEL_14:
    common::milog::MiLogStream::create(
      &v30,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "subHcoinNegative",
      6333);
    v5 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(&v30, (const char (*)[6])"uid: ");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &val);
    v7 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(v6, (const char (*)[18])" wait_sub_hcoin_:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->wait_sub_hcoin_);
    v9 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v8, (const char (*)[12])" sub_hcoin:");
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v2 + 48));
    common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v10, (const char (*)[10])" overflow");
    common::milog::MiLogStream::~MiLogStream(&v30);
    v11 = -1;
  }
  result = v11;
  if ( v33 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6360: range 0000000017CF4DCA-0000000017CF561E
__int64 __fastcall PlayerItemComp::subScoinNegative(PlayerItemComp *const this, __int32 sub_scoin)
{
  unsigned __int64 v2; // r12
  __int64 v3; // rax
  _DWORD *v4; // r14
  common::milog::MiLogStream *v5; // r13
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  unsigned int v11; // r13d
  PlayerBasicComp *BasicComp; // rax
  int v13; // ecx
  unsigned int v14; // ecx
  __int64 v15; // rdx
  char v16; // al
  __int64 v17; // rsi
  proto::PropValue *i; // r13
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  int64_t RealLeftScoin; // rax
  __int64 result; // rax
  std::string __l; // [rsp+0h] [rbp-160h]
  std::initializer_list<proto::PropValue> __la; // [rsp+0h] [rbp-160h]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-148h]
  std::allocator<proto::PropValue> __a; // [rsp+23h] [rbp-13Dh] BYREF
  unsigned int val; // [rsp+24h] [rbp-13Ch] BYREF
  int64_t old_scoin; // [rsp+28h] [rbp-138h]
  common::milog::MiLogStream v28; // [rsp+30h] [rbp-130h] BYREF
  proto::PropValue v29; // [rsp+50h] [rbp-110h] BYREF
  proto::PropValue v30; // [rsp+80h] [rbp-E0h] BYREF
  char v31[176]; // [rsp+B0h] [rbp-B0h] BYREF

  *(&__l._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  HIDWORD(__l._anon_0._M_allocated_capacity) = sub_scoin;
  v2 = (unsigned __int64)v31;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(128LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "3 32 1 23 log_context_holder:6367 48 4 14 sub_scoin:6359 64 24 13 prop_vec:6379";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::subScoinNegative;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234556927;
  v4[536862722] = -218103808;
  v4[536862723] = -202116109;
  *(_DWORD *)(v2 + 48) = sub_scoin;
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->wait_sub_scoin_);
  }
  if ( this->wait_sub_scoin_
    && *(_DWORD *)(v2 + 48)
    && *(_DWORD *)(v2 + 48) + this->wait_sub_scoin_ < this->wait_sub_scoin_ )
  {
    goto LABEL_14;
  }
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->wait_sub_scoin_);
  }
  if ( this->wait_sub_scoin_
    || *(_DWORD *)(v2 + 48)
    || *(_DWORD *)(v2 + 48) + this->wait_sub_scoin_ <= this->wait_sub_scoin_ )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v28, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v2 + 32), 0x67u, __l);
    std::string::~string(&v28);
    old_scoin = PlayerItemComp::getRealLeftScoin(thisa);
    if ( *(_BYTE *)(((unsigned __int64)&thisa->scoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&thisa->scoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&thisa->scoin_);
    }
    if ( thisa->scoin_ < *(_DWORD *)(v2 + 48) )
    {
      v13 = *(_DWORD *)(v2 + 48);
      if ( *(_BYTE *)(((unsigned __int64)&thisa->scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&thisa->scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&thisa->scoin_);
      }
      v14 = v13 - thisa->scoin_;
      if ( *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&thisa->wait_sub_scoin_);
      }
      v17 = v14;
      v15 = SAFE_ADD<unsigned int,unsigned int>(thisa->wait_sub_scoin_, v14);
      v16 = *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_scoin_ >> 3) + 0x7FFF8000);
      LOBYTE(v17) = v16 != 0;
      if ( v16 != 0 && v16 <= 3 )
        __asan_report_store4(&thisa->wait_sub_scoin_, v17, v15);
      thisa->wait_sub_scoin_ = v15;
      if ( *(_BYTE *)(((unsigned __int64)&thisa->scoin_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&thisa->scoin_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_store4(&thisa->scoin_, v17, &thisa->scoin_);
      }
      thisa->scoin_ = 0;
    }
    else
    {
      thisa->scoin_ -= *(_DWORD *)(v2 + 48);
    }
    if ( *(_BYTE *)(((unsigned __int64)&thisa->scoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&thisa->scoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&thisa->scoin_);
    }
    buildIntProp(&v29, 0x2720u, thisa->scoin_);
    if ( *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_scoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_scoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&thisa->wait_sub_scoin_);
    }
    buildIntProp(&v30, 0x2727u, thisa->wait_sub_scoin_);
    __la._M_array = &v29;
    __la._M_len = 2LL;
    std::allocator<proto::PropValue>::allocator(&__a);
    std::vector<proto::PropValue>::vector((std::vector<proto::PropValue> *const)(v2 + 64), __la, &__a);
    std::allocator<proto::PropValue>::~allocator(&__a);
    for ( i = (proto::PropValue *)v31; i != &v29; (*vptr_MessageLite)(i) )
    {
      if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
      if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    Player::notifyPlayerPropList(thisa->player_, (const std::vector<proto::PropValue> *)(v2 + 64));
    RealLeftScoin = PlayerItemComp::getRealLeftScoin(thisa);
    PlayerItemComp::logPlayerAddCoin(thisa, ITEM_VIRTUAL_SCOIN, old_scoin, RealLeftScoin, 0x412u, ITEM_LIMIT_NONE, 0);
    v11 = 0;
    std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v2 + 64));
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v2 + 32));
  }
  else
  {
LABEL_14:
    common::milog::MiLogStream::create(
      &v28,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "subScoinNegative",
      6363);
    v5 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(&v28, (const char (*)[6])"uid: ");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &val);
    v7 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(v6, (const char (*)[18])" wait_sub_scoin_:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->wait_sub_scoin_);
    v9 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v8, (const char (*)[12])" sub_scoin:");
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v2 + 48));
    common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v10, (const char (*)[10])" overflow");
    common::milog::MiLogStream::~MiLogStream(&v28);
    v11 = -1;
  }
  result = v11;
  if ( v31 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6390: range 0000000017CF5620-0000000017CF5EC0
__int64 __fastcall PlayerItemComp::subHomeCoinNegative(PlayerItemComp *const this, __int32 sub_home_coin)
{
  unsigned __int64 v2; // r12
  __int64 v3; // rax
  _DWORD *v4; // r14
  common::milog::MiLogStream *v5; // r13
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  unsigned int v11; // r13d
  PlayerBasicComp *BasicComp; // rax
  int v13; // ecx
  unsigned int v14; // ecx
  SelectType v15; // ecx
  char v16; // dl
  __int64 v17; // rsi
  __int64 v18; // rdx
  __int64 v19; // rdx
  proto::PropValue *i; // r13
  void (__fastcall **vptr_MessageLite)(proto::PropValue *); // rax
  int64_t RealLeftHomeCoin; // rax
  __int64 result; // rax
  std::string __l; // [rsp+0h] [rbp-160h]
  std::initializer_list<proto::PropValue> __la; // [rsp+0h] [rbp-160h]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-148h]
  std::allocator<proto::PropValue> __a; // [rsp+23h] [rbp-13Dh] BYREF
  unsigned int val; // [rsp+24h] [rbp-13Ch] BYREF
  int64_t old_home_coin; // [rsp+28h] [rbp-138h]
  common::milog::MiLogStream v30; // [rsp+30h] [rbp-130h] BYREF
  proto::PropValue v31; // [rsp+50h] [rbp-110h] BYREF
  proto::PropValue v32; // [rsp+80h] [rbp-E0h] BYREF
  char v33[176]; // [rsp+B0h] [rbp-B0h] BYREF

  *(&__l._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  HIDWORD(__l._anon_0._M_allocated_capacity) = sub_home_coin;
  v2 = (unsigned __int64)v33;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(128LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "3 32 1 23 log_context_holder:6397 48 4 18 sub_home_coin:6389 64 24 13 prop_vec:6409";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::subHomeCoinNegative;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234556927;
  v4[536862722] = -218103808;
  v4[536862723] = -202116109;
  *(_DWORD *)(v2 + 48) = sub_home_coin;
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->wait_sub_home_coin_);
  }
  if ( this->wait_sub_home_coin_
    && *(_DWORD *)(v2 + 48)
    && *(_DWORD *)(v2 + 48) + this->wait_sub_home_coin_ < this->wait_sub_home_coin_ )
  {
    goto LABEL_14;
  }
  if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_home_coin_ >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->wait_sub_home_coin_);
  }
  if ( this->wait_sub_home_coin_
    || *(_DWORD *)(v2 + 48)
    || *(_DWORD *)(v2 + 48) + this->wait_sub_home_coin_ <= this->wait_sub_home_coin_ )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11]((std::string *)&v30, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v2 + 32), 0x67u, __l);
    std::string::~string(&v30);
    old_home_coin = PlayerItemComp::getRealLeftHomeCoin(thisa);
    if ( *(_BYTE *)(((unsigned __int64)&thisa->home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)thisa - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->home_coin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&thisa->home_coin_);
    }
    if ( thisa->home_coin_ < *(_DWORD *)(v2 + 48) )
    {
      v13 = *(_DWORD *)(v2 + 48);
      if ( *(_BYTE *)(((unsigned __int64)&thisa->home_coin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)thisa - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->home_coin_ >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&thisa->home_coin_);
      }
      v14 = v13 - thisa->home_coin_;
      if ( *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)thisa + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_home_coin_ >> 3)
                                                            + 0x7FFF8000) )
      {
        __asan_report_load4(&thisa->wait_sub_home_coin_);
      }
      v17 = v14;
      v15 = SAFE_ADD<unsigned int,unsigned int>(thisa->wait_sub_home_coin_, v14);
      v16 = *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_home_coin_ >> 3) + 0x7FFF8000);
      LOBYTE(v17) = v16 != 0;
      v18 = (v16 != 0) & (unsigned __int8)((char)((((_BYTE)thisa + 4) & 7) + 3) >= v16);
      if ( (_BYTE)v18 )
        __asan_report_store4(&thisa->wait_sub_home_coin_, v17, v18);
      thisa->wait_sub_home_coin_ = v15;
      v19 = (*(_BYTE *)(((unsigned __int64)&thisa->home_coin_ >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)thisa - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->home_coin_ >> 3) + 0x7FFF8000));
      if ( (_BYTE)v19 )
        __asan_report_store4(&thisa->home_coin_, (((_BYTE)thisa - 20) & 7u) + 3, v19);
      thisa->home_coin_ = 0;
    }
    else
    {
      thisa->home_coin_ -= *(_DWORD *)(v2 + 48);
    }
    if ( *(_BYTE *)(((unsigned __int64)&thisa->home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)thisa - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->home_coin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&thisa->home_coin_);
    }
    buildIntProp(&v31, 0x273Au, thisa->home_coin_);
    if ( *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_home_coin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)thisa + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&thisa->wait_sub_home_coin_ >> 3)
                                                          + 0x7FFF8000) )
    {
      __asan_report_load4(&thisa->wait_sub_home_coin_);
    }
    buildIntProp(&v32, 0x273Bu, thisa->wait_sub_home_coin_);
    __la._M_array = &v31;
    __la._M_len = 2LL;
    std::allocator<proto::PropValue>::allocator(&__a);
    std::vector<proto::PropValue>::vector((std::vector<proto::PropValue> *const)(v2 + 64), __la, &__a);
    std::allocator<proto::PropValue>::~allocator(&__a);
    for ( i = (proto::PropValue *)v33; i != &v31; (*vptr_MessageLite)(i) )
    {
      if ( *(_BYTE *)(((unsigned __int64)--i >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      vptr_MessageLite = (void (__fastcall **)(proto::PropValue *))i->_vptr_MessageLite;
      if ( *(_BYTE *)(((unsigned __int64)i->_vptr_MessageLite >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    Player::notifyPlayerPropList(thisa->player_, (const std::vector<proto::PropValue> *)(v2 + 64));
    RealLeftHomeCoin = PlayerItemComp::getRealLeftHomeCoin(thisa);
    PlayerItemComp::logPlayerAddCoin(
      thisa,
      ITEM_VIRTUAL_HOME_COIN,
      old_home_coin,
      RealLeftHomeCoin,
      0x412u,
      ITEM_LIMIT_NONE,
      0);
    v11 = 0;
    std::vector<proto::PropValue>::~vector((std::vector<proto::PropValue> *const)(v2 + 64));
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v2 + 32));
  }
  else
  {
LABEL_14:
    common::milog::MiLogStream::create(
      &v30,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "subHomeCoinNegative",
      6393);
    v5 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(&v30, (const char (*)[6])"uid: ");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &val);
    v7 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
           v6,
           (const char (*)[22])" wait_sub_home_coin_:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->wait_sub_home_coin_);
    v9 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v8, (const char (*)[16])" sub_home_coin:");
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v2 + 48));
    common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v10, (const char (*)[10])" overflow");
    common::milog::MiLogStream::~MiLogStream(&v30);
    v11 = -1;
  }
  result = v11;
  if ( v33 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6420: range 0000000017CF5EC2-0000000017CF6503
void __cdecl PlayerItemComp::checkAndModifyMcoin(PlayerItemComp *const this)
{
  uint32_t *p_wait_sub_psn_mcoin; // rsi
  uint32_t RegPlatform; // eax
  char v3; // al
  common::milog::MiLogStream *v4; // rax
  common::milog::MiLogStream *v5; // rax
  common::milog::MiLogStream *v6; // rax
  __int64 v7; // rsi
  uint32_t mcoin; // ecx
  char v9; // al
  __int64 v10; // rsi
  uint32_t wait_sub_mcoin; // ecx
  char v12; // al
  common::milog::MiLogStream *v13; // rbx
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rbx
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  unsigned int val; // [rsp+1Ch] [rbp-34h] BYREF
  common::milog::MiLogStream v28; // [rsp+20h] [rbp-30h] BYREF

  if ( *(char *)(((unsigned __int64)&this->is_psn_version_modify_ >> 3) + 0x7FFF8000) < 0 )
    __asan_report_load1(&this->is_psn_version_modify_);
  if ( this->is_psn_version_modify_ )
  {
    common::milog::MiLogStream::create(
      &v28,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkAndModifyMcoin",
      6424);
    p_wait_sub_psn_mcoin = (uint32_t *)"[MCOIN] psn mcoin try more times!";
    common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
      &v28,
      (const char (*)[34])"[MCOIN] psn mcoin try more times!");
    common::milog::MiLogStream::~MiLogStream(&v28);
  }
  if ( *(char *)(((unsigned __int64)&this->is_psn_version_modify_ >> 3) + 0x7FFF8000) < 0 )
    __asan_report_load1(&this->is_psn_version_modify_);
  if ( this->is_psn_version_modify_ )
    goto LABEL_12;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  RegPlatform = Player::getRegPlatform(this->player_);
  if ( TxtConfigMgr::isPsnPlatform(RegPlatform) )
    v3 = 1;
  else
LABEL_12:
    v3 = 0;
  if ( v3 )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->psn_mcoin_);
    }
    if ( this->psn_mcoin_ )
      goto LABEL_20;
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->wait_sub_psn_mcoin_);
    }
    if ( this->wait_sub_psn_mcoin_ )
    {
LABEL_20:
      common::milog::MiLogStream::create(
        &v28,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "checkAndModifyMcoin",
        6431);
      v4 = common::milog::MiLogStream::operator<<<char [56],(char *[56])0>(
             &v28,
             (const char (*)[56])"[MCOIN] fix mcoin but psn mcoin is not zero psn_mcoin_:");
      v5 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v4, &this->psn_mcoin_);
      v6 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
             v5,
             (const char (*)[22])" wait_sub_psn_mcoin_:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, &this->wait_sub_psn_mcoin_);
      common::milog::MiLogStream::~MiLogStream(&v28);
    }
    v7 = (((_BYTE)this - 36) & 7u) + 3;
    if ( *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 36) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->mcoin_);
    }
    mcoin = this->mcoin_;
    v9 = *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000);
    if ( v9 != 0 && v9 <= 3 )
    {
      LOBYTE(v7) = v9 != 0;
      __asan_report_store4(&this->psn_mcoin_, v7, &this->psn_mcoin_);
    }
    this->psn_mcoin_ = mcoin;
    this->mcoin_ = 0;
    v10 = (((_BYTE)this - 4) & 7u) + 3;
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->wait_sub_mcoin_);
    }
    wait_sub_mcoin = this->wait_sub_mcoin_;
    v12 = *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000);
    if ( v12 != 0 && v12 <= 3 )
    {
      LOBYTE(v10) = v12 != 0;
      __asan_report_store4(&this->wait_sub_psn_mcoin_, v10, &this->wait_sub_psn_mcoin_);
    }
    this->wait_sub_psn_mcoin_ = wait_sub_mcoin;
    this->wait_sub_mcoin_ = 0;
    common::milog::MiLogStream::create(
      &v28,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkAndModifyMcoin",
      6440);
    v13 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
            &v28,
            (const char (*)[43])"[MCOIN] fix user mcoin_ to psn_mcoin_ uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, &val);
    v15 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v14, (const char (*)[13])" psn_mcoin_:");
    v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, &this->psn_mcoin_);
    v17 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
            v16,
            (const char (*)[22])" wait_sub_psn_mcoin_:");
    p_wait_sub_psn_mcoin = &this->wait_sub_psn_mcoin_;
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, &this->wait_sub_psn_mcoin_);
    common::milog::MiLogStream::~MiLogStream(&v28);
  }
  if ( *(char *)(((unsigned __int64)&this->is_psn_version_modify_ >> 3) + 0x7FFF8000) < 0 )
    __asan_report_store1(&this->is_psn_version_modify_, p_wait_sub_psn_mcoin, &this->is_psn_version_modify_);
  this->is_psn_version_modify_ = 1;
  common::milog::MiLogStream::create(
    &v28,
    &common::milog::MiLogDefault::default_log_obj_,
    2u,
    "./src/player/item/player_item_comp.cpp",
    "checkAndModifyMcoin",
    6444);
  v18 = common::milog::MiLogStream::operator<<<char [23],(char *[23])0>(
          &v28,
          (const char (*)[23])"[MCOIN] user reg_plat:");
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  val = Player::getRegPlatform(this->player_);
  v19 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, &val);
  v20 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v19, (const char (*)[8])" mcoin:");
  v21 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &this->mcoin_);
  v22 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v21, (const char (*)[13])" psn_mcoin_:");
  v23 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, &this->psn_mcoin_);
  v24 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(v23, (const char (*)[18])" wait_sub_mcoin_:");
  v25 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, &this->wait_sub_mcoin_);
  v26 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
          v25,
          (const char (*)[22])" wait_sub_psn_mcoin_:");
  common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v26, &this->wait_sub_psn_mcoin_);
  common::milog::MiLogStream::~MiLogStream(&v28);
};

// Line 6450: range 0000000017CF6504-0000000017CF65D2
uint32_t __cdecl PlayerItemComp::getMcoin(const PlayerItemComp *const this)
{
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  if ( Player::isPsnPlatform(this->player_) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->psn_mcoin_);
    }
    return this->psn_mcoin_;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 36) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->mcoin_);
    }
    return this->mcoin_;
  }
};

// Line 6460: range 0000000017CF65D4-0000000017CF667A
uint32_t __cdecl PlayerItemComp::getMcoin(const PlayerItemComp *const this, uint32_t platform_type)
{
  if ( TxtConfigMgr::isPsnPlatform(platform_type) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->psn_mcoin_);
    }
    return this->psn_mcoin_;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 36) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->mcoin_);
    }
    return this->mcoin_;
  }
};

// Line 6470: range 0000000017CF667C-0000000017CF6754
// local variable allocation has failed, the output may be wrong!
void __cdecl PlayerItemComp::setMcoin(PlayerItemComp *const this, uint32_t mcoin)
{
  __int64 v2; // rdx

  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  if ( Player::isPsnPlatform(this->player_) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_store4(&this->psn_mcoin_, *(_QWORD *)&mcoin, &this->psn_mcoin_);
    }
    this->psn_mcoin_ = mcoin;
  }
  else
  {
    v2 = (*(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)this - 36) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000));
    if ( (_BYTE)v2 )
      __asan_report_store4(&this->mcoin_, (((_BYTE)this - 36) & 7u) + 3, v2);
    this->mcoin_ = mcoin;
  }
};

// Line 6482: range 0000000017CF6756-0000000017CF6806
// local variable allocation has failed, the output may be wrong!
void __cdecl PlayerItemComp::setMcoin(PlayerItemComp *const this, uint32_t mcoin, uint32_t platform_type)
{
  __int64 v3; // rdx

  if ( TxtConfigMgr::isPsnPlatform(platform_type) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_store4(&this->psn_mcoin_, *(_QWORD *)&mcoin, &this->psn_mcoin_);
    }
    this->psn_mcoin_ = mcoin;
  }
  else
  {
    v3 = (*(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)this - 36) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->mcoin_ >> 3) + 0x7FFF8000));
    if ( (_BYTE)v3 )
      __asan_report_store4(&this->mcoin_, (((_BYTE)this - 36) & 7u) + 3, v3);
    this->mcoin_ = mcoin;
  }
};

// Line 6494: range 0000000017CF6808-0000000017CF68D6
uint32_t __cdecl PlayerItemComp::getWaitSubMcoin(const PlayerItemComp *const this)
{
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  if ( Player::isPsnPlatform(this->player_) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->wait_sub_psn_mcoin_);
    }
    return this->wait_sub_psn_mcoin_;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->wait_sub_mcoin_);
    }
    return this->wait_sub_mcoin_;
  }
};

// Line 6504: range 0000000017CF68D8-0000000017CF697E
uint32_t __cdecl PlayerItemComp::getWaitSubMcoin(const PlayerItemComp *const this, uint32_t platform_type)
{
  if ( TxtConfigMgr::isPsnPlatform(platform_type) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->wait_sub_psn_mcoin_);
    }
    return this->wait_sub_psn_mcoin_;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)this - 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&this->wait_sub_mcoin_);
    }
    return this->wait_sub_mcoin_;
  }
};

// Line 6514: range 0000000017CF6980-0000000017CF6A58
// local variable allocation has failed, the output may be wrong!
void __cdecl PlayerItemComp::setWaitSubMcoin(PlayerItemComp *const this, uint32_t wait_sub_mcoin)
{
  __int64 v2; // rdx

  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  if ( Player::isPsnPlatform(this->player_) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_store4(&this->wait_sub_psn_mcoin_, *(_QWORD *)&wait_sub_mcoin, &this->wait_sub_psn_mcoin_);
    }
    this->wait_sub_psn_mcoin_ = wait_sub_mcoin;
  }
  else
  {
    v2 = (*(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)this - 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000));
    if ( (_BYTE)v2 )
      __asan_report_store4(&this->wait_sub_mcoin_, (((_BYTE)this - 4) & 7u) + 3, v2);
    this->wait_sub_mcoin_ = wait_sub_mcoin;
  }
};

// Line 6526: range 0000000017CF6A5A-0000000017CF6B0A
// local variable allocation has failed, the output may be wrong!
void __cdecl PlayerItemComp::setWaitSubMcoin(
        PlayerItemComp *const this,
        uint32_t wait_sub_mcoin,
        uint32_t platform_type)
{
  __int64 v3; // rdx

  if ( TxtConfigMgr::isPsnPlatform(platform_type) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->wait_sub_psn_mcoin_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_store4(&this->wait_sub_psn_mcoin_, *(_QWORD *)&wait_sub_mcoin, &this->wait_sub_psn_mcoin_);
    }
    this->wait_sub_psn_mcoin_ = wait_sub_mcoin;
  }
  else
  {
    v3 = (*(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)this - 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->wait_sub_mcoin_ >> 3) + 0x7FFF8000));
    if ( (_BYTE)v3 )
      __asan_report_store4(&this->wait_sub_mcoin_, (((_BYTE)this - 4) & 7u) + 3, v3);
    this->wait_sub_mcoin_ = wait_sub_mcoin;
  }
};

// Line 6538: range 0000000017CF6B0C-0000000017CF6B54
uint32_t __cdecl PlayerItemComp::getAllPlatWaitSubMcoin(const PlayerItemComp *const this)
{
  uint32_t PsnPlatformType; // edx
  unsigned int WaitSubMcoin; // ebx
  uint32_t PCMPlatformType; // edx
  unsigned int v4; // eax

  PsnPlatformType = TxtConfigMgr::getPsnPlatformType();
  WaitSubMcoin = PlayerItemComp::getWaitSubMcoin(this, PsnPlatformType);
  PCMPlatformType = TxtConfigMgr::getPCMPlatformType();
  v4 = PlayerItemComp::getWaitSubMcoin(this, PCMPlatformType);
  return SAFE_ADD<unsigned int,unsigned int>(v4, WaitSubMcoin);
};

// Line 6543: range 0000000017CF6B56-0000000017CF6B8B
int64_t __cdecl PlayerItemComp::getRealLeftMcoin(const PlayerItemComp *const this)
{
  __int64 Mcoin; // rbx

  Mcoin = PlayerItemComp::getMcoin(this);
  return Mcoin - PlayerItemComp::getWaitSubMcoin(this);
};

// Line 6548: range 0000000017CF6B8C-0000000017CF6BCE
int64_t __cdecl PlayerItemComp::getRealLeftMcoin(const PlayerItemComp *const this, uint32_t platform_type)
{
  __int64 Mcoin; // rbx

  Mcoin = PlayerItemComp::getMcoin(this, platform_type);
  return Mcoin - PlayerItemComp::getWaitSubMcoin(this, platform_type);
};

// Line 6553: range 0000000017CF6BD0-0000000017CF6C1B
int64_t __cdecl PlayerItemComp::getAllPlatRealLeftMcoin(const PlayerItemComp *const this)
{
  uint32_t PsnPlatformType; // edx
  __int64 RealLeftMcoin; // rbx
  uint32_t PCMPlatformType; // edx
  __int64 v4; // rax

  PsnPlatformType = TxtConfigMgr::getPsnPlatformType();
  RealLeftMcoin = PlayerItemComp::getRealLeftMcoin(this, PsnPlatformType);
  PCMPlatformType = TxtConfigMgr::getPCMPlatformType();
  v4 = PlayerItemComp::getRealLeftMcoin(this, PCMPlatformType);
  return SAFE_ADD<long,long>(v4, RealLeftMcoin);
};

// Line 6559: range 0000000017CF6C1C-0000000017CF6DD8
__int64 __fastcall PlayerItemComp::checkSubResin(PlayerItemComp *const this, uint32_t sub_resin)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  common::milog::MiLogStream *v5; // r14
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  unsigned int val; // [rsp+1Ch] [rbp-94h] BYREF
  common::milog::MiLogStream v10; // [rsp+20h] [rbp-90h] BYREF
  char v11[112]; // [rsp+40h] [rbp-70h] BYREF

  v2 = (unsigned __int64)v11;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 14 sub_resin:6558";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkSubResin;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = sub_resin;
  if ( PlayerItemComp::getResin(this) >= *(_DWORD *)(v2 + 32) )
  {
    result = 0LL;
  }
  else
  {
    common::milog::MiLogStream::create(
      &v10,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkSubResin",
      6562);
    v5 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
           &v10,
           (const char (*)[44])"[RESIN] resin check sub failed, cur_resin: ");
    val = PlayerItemComp::getResin(this);
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &val);
    v7 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v6, (const char (*)[12])"sub_resin: ");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v2 + 32));
    common::milog::MiLogStream::~MiLogStream(&v10);
    result = 660LL;
  }
  if ( v11 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6570: range 0000000017CF6DDA-0000000017CF701C
int32_t __cdecl PlayerItemComp::subResin(
        PlayerItemComp *const this,
        uint32_t sub_resin,
        const SubItemReason *reason,
        bool is_notify)
{
  AutoRecoverItemProxy *v5; // rax
  Player *player; // rbx
  uint32_t Resin; // eax
  common::milog::MiLogStream v10; // [rsp+20h] [rbp-60h] BYREF
  proto::PropValue prop_value; // [rsp+40h] [rbp-40h] BYREF

  if ( std::operator==<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
  {
    common::milog::MiLogStream::create(
      &v10,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "subResin",
      6573);
    common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v10, (const char (*)[18])"resin ptr is null");
    common::milog::MiLogStream::~MiLogStream(&v10);
    return -1;
  }
  else
  {
    v5 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    if ( (unsigned int)AutoRecoverItemProxy::onSubValue(v5, sub_resin) )
    {
      common::milog::MiLogStream::create(
        &v10,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "subResin",
        6579);
      common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(&v10, (const char (*)[17])off_263956A0);
      common::milog::MiLogStream::~MiLogStream(&v10);
      return -1;
    }
    else
    {
      if ( is_notify )
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        player = this->player_;
        Resin = PlayerItemComp::getResin(this);
        buildIntProp(&prop_value, 0x2724u, Resin);
        Player::notifyPlayerProp(player, &prop_value);
        proto::PropValue::~PropValue(&prop_value);
        PlayerItemComp::onResinChange(this);
      }
      if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(reason);
      }
      PlayerItemComp::logResinChange(this, -sub_resin, -sub_resin, reason->reason_type, ITEM_LIMIT_NONE);
      return 0;
    }
  }
};

// Line 6595: range 0000000017CF701E-0000000017CF7331
__int64 __fastcall PlayerItemComp::checkAddResin(PlayerItemComp *const this, uint32_t add_resin)
{
  unsigned __int64 v2; // r12
  __int64 v3; // rax
  _DWORD *v4; // r13
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  common::milog::MiLogStream *v7; // r14
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  __int64 result; // rax
  unsigned int *v11; // [rsp+0h] [rbp-100h]
  PlayerItemComp *thisa; // [rsp+8h] [rbp-F8h]
  unsigned int *v13; // [rsp+10h] [rbp-F0h]
  unsigned int val; // [rsp+1Ch] [rbp-E4h] BYREF
  std::shared_ptr<Config> v15; // [rsp+20h] [rbp-E0h] BYREF
  common::milog::MiLogStream v16; // [rsp+30h] [rbp-D0h] BYREF
  char v17[176]; // [rsp+50h] [rbp-B0h] BYREF

  HIDWORD(v11) = add_resin;
  v2 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(128LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "5 32 4 21 recover_interval:6596 48 4 14 max_limit:6596 64 4 22 max_recover_limit:6596 80 4 19 nu"
                        "m_per_bought:6596 96 4 14 add_resin:6594";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkAddResin;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234556924;
  v4[536862722] = -234556924;
  v4[536862723] = -202116348;
  *(_DWORD *)(v2 + 96) = add_resin;
  *(_DWORD *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 48) = 0;
  *(_DWORD *)(v2 + 64) = 0;
  *(_DWORD *)(v2 + 80) = 0;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v15);
  v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v15);
  ConstValueExcelConfigMgr::findConstValue<unsigned int,unsigned int &,unsigned int &,unsigned int &>(
    &v5->design_config.txt_config_mgr.const_value_config_mgr,
    CONST_VALUE_RESIN_PARAM,
    (unsigned int *)(v2 + 48),
    (unsigned int *)(v2 + 64),
    (unsigned int *)(v2 + 32),
    (unsigned int *)(v2 + 80),
    v11,
    (unsigned int *)this,
    v13);
  std::shared_ptr<Config>::~shared_ptr(&v15);
  if ( *(_DWORD *)(v2 + 96)
    && PlayerItemComp::getResin(thisa)
    && PlayerItemComp::getResin(thisa) + *(_DWORD *)(v2 + 96) < *(_DWORD *)(v2 + 96)
    || !*(_DWORD *)(v2 + 96)
    && !PlayerItemComp::getResin(thisa)
    && PlayerItemComp::getResin(thisa) + *(_DWORD *)(v2 + 96) > *(_DWORD *)(v2 + 96)
    || PlayerItemComp::getResin(thisa) + *(_DWORD *)(v2 + 96) > *(_DWORD *)(v2 + 48) )
  {
    common::milog::MiLogStream::create(
      &v16,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkAddResin",
      6599);
    v7 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
           &v16,
           (const char (*)[27])"resin add overflow, resin:");
    val = PlayerItemComp::getResin(thisa);
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &val);
    v9 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v8, (const char (*)[12])" add_resin:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v2 + 96));
    common::milog::MiLogStream::~MiLogStream(&v16);
    result = 661LL;
  }
  else
  {
    result = 0LL;
  }
  if ( v17 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6607: range 0000000017CF7332-0000000017CF7616
__int64 __fastcall PlayerItemComp::addResin(
        PlayerItemComp *const this,
        uint32_t add_resin,
        unsigned __int64 reason,
        bool is_notify)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  unsigned __int64 v6; // r13
  __int64 result; // rax
  AutoRecoverItemProxy *v8; // rax
  common::milog::MiLogStream *v9; // rax
  data::ItemLimitType v10; // ecx
  common::milog::MiLogStream v13; // [rsp+20h] [rbp-80h] BYREF
  char v14[96]; // [rsp+40h] [rbp-60h] BYREF

  v4 = (unsigned __int64)v14;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_0(64LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 4 14 add_resin:6606";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addResin;
  v6 = v4 >> 3;
  *(_DWORD *)(v6 + 2147450880) = -235802127;
  *(_DWORD *)(v6 + 2147450884) = -202116348;
  *(_DWORD *)(v4 + 32) = add_resin;
  if ( std::operator==<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
  {
    common::milog::MiLogStream::create(
      &v13,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "addResin",
      6610);
    common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v13, (const char (*)[18])"resin ptr is null");
    common::milog::MiLogStream::~MiLogStream(&v13);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v8 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    if ( (unsigned int)AutoRecoverItemProxy::onAddValue(v8, *(_DWORD *)(v4 + 32)) )
    {
      common::milog::MiLogStream::create(
        &v13,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "addResin",
        6616);
      v9 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(&v13, (const char (*)[17])off_263958A0);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 32));
      common::milog::MiLogStream::~MiLogStream(&v13);
      result = 0xFFFFFFFFLL;
    }
    else
    {
      if ( is_notify )
        PlayerItemComp::onResinChange(this);
      if ( *(_BYTE *)(((reason + 4) >> 3) + 0x7FFF8000) != 0
        && (char)(((reason + 4) & 7) + 3) >= *(_BYTE *)(((reason + 4) >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(reason + 4);
      }
      v10 = *(_DWORD *)(reason + 4);
      if ( *(_BYTE *)((reason >> 3) + 0x7FFF8000) != 0
        && (char)((reason & 7) + 3) >= *(_BYTE *)((reason >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(reason);
      }
      PlayerItemComp::logResinChange(this, *(_DWORD *)(v4 + 32), *(_DWORD *)(v4 + 32), *(_DWORD *)reason, v10);
      result = 0LL;
    }
  }
  if ( v14 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6631: range 0000000017CF7618-0000000017CF7661
uint32_t __cdecl PlayerItemComp::getResin(PlayerItemComp *const this)
{
  std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v2; // rax

  if ( std::operator==<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
    return 0;
  v2 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
  return AutoRecoverItemProxy::getValue(v2);
};

// Line 6641: range 0000000017CF7662-0000000017CF7AF9
int32_t __cdecl PlayerItemComp::onResinChange(PlayerItemComp *const this)
{
  unsigned __int64 v1; // rbx
  __int64 v2; // rax
  _DWORD *v3; // r13
  int32_t v4; // r14d
  Player *player; // r14
  uint32_t Resin; // eax
  proto::ResinChangeNotify *v7; // r14
  std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  uint32_t NextRefreshTime; // eax
  proto::ResinChangeNotify *v10; // r14
  uint32_t v11; // eax
  AutoRecoverItemProxy *v12; // rax
  proto::ResinChangeNotify *v13; // rax
  common::milog::MiLogStream *v14; // r14
  std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // r14
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // r14
  Player *v20; // r14
  int32_t result; // eax
  unsigned int val; // [rsp+10h] [rbp-100h] BYREF
  unsigned int v23; // [rsp+14h] [rbp-FCh] BYREF
  __int64 Now; // [rsp+18h] [rbp-F8h] BYREF
  std::shared_ptr<proto::ResinChangeNotify> __r; // [rsp+20h] [rbp-F0h] BYREF
  common::milog::MiLogStream v26; // [rsp+30h] [rbp-E0h] BYREF
  proto::PropValue prop_value; // [rsp+50h] [rbp-C0h] BYREF
  char v28[144]; // [rsp+80h] [rbp-90h] BYREF

  v1 = (unsigned __int64)v28;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v2 = __asan_stack_malloc_1(96LL);
    if ( v2 )
      v1 = v2;
  }
  *(_QWORD *)v1 = 1102416563LL;
  *(_QWORD *)(v1 + 8) = "2 48 4 18 cur_buy_count:6653 64 16 15 notify_ptr:6649";
  *(_QWORD *)(v1 + 16) = PlayerItemComp::onResinChange;
  v3 = (_DWORD *)(v1 >> 3);
  v3[536862720] = -235802127;
  v3[536862721] = -234556943;
  v3[536862722] = -202178560;
  if ( std::operator==<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
  {
    v4 = -1;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    player = this->player_;
    Resin = PlayerItemComp::getResin(this);
    buildIntProp(&prop_value, 0x2724u, Resin);
    Player::notifyPlayerProp(player, &prop_value);
    proto::PropValue::~PropValue(&prop_value);
    common::tools::perf::make_shared<proto::ResinChangeNotify>();
    v7 = std::__shared_ptr_access<proto::ResinChangeNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ResinChangeNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v1 + 64));
    v8 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    NextRefreshTime = AutoRecoverItemProxy::getNextRefreshTime(v8);
    proto::ResinChangeNotify::set_next_add_timestamp(v7, NextRefreshTime);
    v10 = std::__shared_ptr_access<proto::ResinChangeNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ResinChangeNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v1 + 64));
    v11 = PlayerItemComp::getResin(this);
    proto::ResinChangeNotify::set_cur_value(v10, v11);
    v12 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    if ( AutoRecoverItemProxy::getCurBuyCount(v12, (uint32_t *)(v1 + 48)) )
    {
      common::milog::MiLogStream::create(
        &v26,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "onResinChange",
        6656);
      common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(&v26, (const char (*)[22])"getCurBuyCount failed");
      common::milog::MiLogStream::~MiLogStream(&v26);
      v4 = -1;
    }
    else
    {
      v13 = std::__shared_ptr_access<proto::ResinChangeNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ResinChangeNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v1 + 64));
      proto::ResinChangeNotify::set_cur_buy_count(v13, *(_DWORD *)(v1 + 48));
      common::milog::MiLogStream::create(
        &v26,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "onResinChange",
        6662);
      v14 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
              &v26,
              (const char (*)[26])"[RECOVER] onResinChange: ");
      v15 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
      val = AutoRecoverItemProxy::getNextRefreshTime(v15);
      v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &val);
      v17 = common::milog::MiLogStream::operator<<<char [3],(char *[3])0>(v16, (const char (*)[3])", ");
      Now = common::tools::TimeUtils::getNow();
      v18 = common::milog::MiLogStream::operator<<<long,(long *)0>(v17, &Now);
      v19 = common::milog::MiLogStream::operator<<<char [3],(char *[3])0>(v18, (const char (*)[3])", ");
      v23 = PlayerItemComp::getResin(this);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v19, &v23);
      common::milog::MiLogStream::~MiLogStream(&v26);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v20 = this->player_;
      std::dynamic_pointer_cast<google::protobuf::Message const,proto::ResinChangeNotify>(&__r);
      Player::sendMessage(v20, (common::minet::ConstMessagePtr *)&__r, 0LL);
      std::shared_ptr<google::protobuf::Message const>::~shared_ptr((std::shared_ptr<const google::protobuf::Message> *const)&__r);
      v4 = 0;
    }
    std::shared_ptr<proto::ResinChangeNotify>::~shared_ptr((std::shared_ptr<proto::ResinChangeNotify> *const)(v1 + 64));
  }
  result = v4;
  if ( v28 == (char *)v1 )
  {
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v1 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v1 = 1172321806LL;
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v1 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 6668: range 0000000017CF7AFA-0000000017CF7D70
int32_t __cdecl PlayerItemComp::buyResin(PlayerItemComp *const this)
{
  unsigned __int64 v1; // rbx
  __int64 v2; // rax
  unsigned __int64 v3; // r12
  PlayerBasicComp *BasicComp; // rax
  int32_t v5; // r14d
  AutoRecoverItemProxy *v6; // rax
  int32_t result; // eax
  std::string v8; // [rsp+0h] [rbp-B0h]
  PlayerItemComp *thisa; // [rsp+8h] [rbp-A8h]
  int32_t ret; // [rsp+1Ch] [rbp-94h]
  std::string v11; // [rsp+20h] [rbp-90h] BYREF
  char v12[112]; // [rsp+40h] [rbp-70h] BYREF

  v8._M_string_length = (std::string::size_type)this;
  v1 = (unsigned __int64)v12;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v2 = __asan_stack_malloc_0(64LL);
    if ( v2 )
      v1 = v2;
  }
  *(_QWORD *)v1 = 1102416563LL;
  *(_QWORD *)(v1 + 8) = "1 32 1 11 holder:6669";
  *(_QWORD *)(v1 + 16) = PlayerItemComp::buyResin;
  v3 = v1 >> 3;
  *(_DWORD *)(v3 + 2147450880) = -235802127;
  *(_DWORD *)(v3 + 2147450884) = -202116351;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&v11, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v1 + 32), 0x9C5u, v8);
  std::string::~string(&v11);
  if ( std::operator==<AutoRecoverItemProxy>(0LL, &thisa->resin_proxy_ptr_) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v11,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "buyResin",
      6673);
    common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(
      (common::milog::MiLogStream *const)&v11,
      (const char (*)[18])"resin ptr is null");
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v11);
    v5 = -1;
  }
  else
  {
    v6 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&thisa->resin_proxy_ptr_);
    ret = AutoRecoverItemProxy::buyOnce(v6);
    if ( ret )
    {
      if ( ret == 668 )
      {
        v5 = 662;
      }
      else if ( ret == 669 )
      {
        v5 = 663;
      }
      else
      {
        v5 = ret;
      }
    }
    else
    {
      v5 = 0;
    }
  }
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v1 + 32));
  result = v5;
  if ( v12 == (char *)v1 )
  {
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v1 = 1172321806LL;
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6695: range 0000000017CF7D72-0000000017CF7E31
void __cdecl PlayerItemComp::onGmResetResinBoughtCount(PlayerItemComp *const this)
{
  AutoRecoverItemProxy *v1; // rax
  common::milog::MiLogStream v2; // [rsp+10h] [rbp-30h] BYREF

  if ( std::operator==<AutoRecoverItemProxy>(0LL, &this->resin_proxy_ptr_) )
  {
    common::milog::MiLogStream::create(
      &v2,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "onGmResetResinBoughtCount",
      6698);
    common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v2, (const char (*)[18])"resin ptr is null");
    common::milog::MiLogStream::~MiLogStream(&v2);
  }
  else
  {
    v1 = std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<AutoRecoverItemProxy,(__gnu_cxx::_Lock_policy)2,false,false> *const)&this->resin_proxy_ptr_);
    AutoRecoverItemProxy::resetBoughtCount(v1);
    PlayerItemComp::onResinChange(this);
  }
};

// Line 6707: range 0000000017CF7E32-0000000017CF7E64
int32_t __cdecl PlayerItemComp::checkSubLegendaryKey(PlayerItemComp *const this, uint32_t sub_legendary_key)
{
  if ( sub_legendary_key <= PlayerItemComp::getLegendaryKey(this) )
    return 0;
  else
    return 8001;
};

// Line 6717: range 0000000017CF7E66-0000000017CF81F7
__int64 __fastcall PlayerItemComp::subLegendaryKey(
        PlayerItemComp *const this,
        uint32_t sub_legendary_key,
        unsigned __int64 reason,
        bool is_notify)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  unsigned __int64 v6; // r13
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  __int64 result; // rax
  Player *player; // r14
  uint32_t v12; // esi
  uint32_t v13; // ecx
  common::milog::MiLogStream v16; // [rsp+20h] [rbp-C0h] BYREF
  proto::PropValue prop_value; // [rsp+40h] [rbp-A0h] BYREF
  char v18[112]; // [rsp+70h] [rbp-70h] BYREF

  v4 = (unsigned __int64)v18;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_0(64LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 4 22 sub_legendary_key:6716";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::subLegendaryKey;
  v6 = v4 >> 3;
  *(_DWORD *)(v6 + 2147450880) = -235802127;
  *(_DWORD *)(v6 + 2147450884) = -202116348;
  *(_DWORD *)(v4 + 32) = sub_legendary_key;
  if ( *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->legendary_key_);
  }
  if ( this->legendary_key_ >= *(_DWORD *)(v4 + 32) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->legendary_key_);
    }
    this->legendary_key_ -= *(_DWORD *)(v4 + 32);
    if ( is_notify )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      player = this->player_;
      buildIntProp(&prop_value, 0x272Bu, this->legendary_key_);
      Player::notifyPlayerProp(player, &prop_value);
      proto::PropValue::~PropValue(&prop_value);
    }
    if ( *(_BYTE *)(((reason + 4) >> 3) + 0x7FFF8000) != 0
      && (char)(((reason + 4) & 7) + 3) >= *(_BYTE *)(((reason + 4) >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reason + 4);
    }
    v12 = *(_DWORD *)(reason + 4);
    v13 = *(_DWORD *)(v4 + 32);
    if ( *(_BYTE *)((reason >> 3) + 0x7FFF8000) != 0
      && (char)((reason & 7) + 3) >= *(_BYTE *)((reason >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reason);
    }
    PlayerItemComp::logLegendaryKeyChange(this, 1u, *(proto::ActionReasonType *)reason, v13, v12);
    result = 0LL;
  }
  else
  {
    common::milog::MiLogStream::create(
      &v16,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "subLegendaryKey",
      6720);
    v7 = common::milog::MiLogStream::operator<<<char [51],(char *[51])0>(
           &v16,
           (const char (*)[51])"legendary_key check sub failed, cur_legendary_key:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->legendary_key_);
    v9 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(v8, (const char (*)[20])" sub_legendary_key:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 32));
    common::milog::MiLogStream::~MiLogStream(&v16);
    result = 0xFFFFFFFFLL;
  }
  if ( v18 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6734: range 0000000017CF81F8-0000000017CF8361
int32_t __cdecl PlayerItemComp::checkAddLegendaryKey(PlayerItemComp *const this, uint32_t add_legendary_key)
{
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v2; // rax
  uint32_t legendary_key_limit; // [rsp+1Ch] [rbp-14h]
  std::shared_ptr<Config> v5; // [rsp+20h] [rbp-10h] BYREF

  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v5);
  v2 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v5);
  legendary_key_limit = ConstValueExcelConfigMgr::getLegendaryKeyLimit(&v2->design_config.txt_config_mgr.const_value_config_mgr);
  std::shared_ptr<Config>::~shared_ptr(&v5);
  if ( add_legendary_key )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->legendary_key_);
    }
    if ( this->legendary_key_ && add_legendary_key > this->legendary_key_ + add_legendary_key )
      return 8002;
  }
  if ( !add_legendary_key
    && *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->legendary_key_);
  }
  if ( *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->legendary_key_);
  }
  if ( legendary_key_limit < this->legendary_key_ + add_legendary_key )
    return 8002;
  else
    return 0;
};

// Line 6745: range 0000000017CF8362-0000000017CF8779
__int64 __fastcall PlayerItemComp::addLegendaryKey(
        PlayerItemComp *const this,
        uint32_t add_legendary_key,
        unsigned __int64 reason,
        bool is_notify)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  unsigned __int64 v6; // r13
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  __int64 result; // rax
  unsigned int v11; // edx
  __int64 v12; // rsi
  __int64 v13; // rdx
  char v14; // al
  Player *player; // r14
  uint32_t v16; // ecx
  common::milog::MiLogStream v19; // [rsp+20h] [rbp-C0h] BYREF
  proto::PropValue prop_value; // [rsp+40h] [rbp-A0h] BYREF
  char v21[112]; // [rsp+70h] [rbp-70h] BYREF

  v4 = (unsigned __int64)v21;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_0(64LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 4 22 add_legendary_key:6744";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addLegendaryKey;
  v6 = v4 >> 3;
  *(_DWORD *)(v6 + 2147450880) = -235802127;
  *(_DWORD *)(v6 + 2147450884) = -202116348;
  *(_DWORD *)(v4 + 32) = add_legendary_key;
  if ( *(_DWORD *)(v4 + 32) )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->legendary_key_);
    }
    if ( this->legendary_key_ && *(_DWORD *)(v4 + 32) + this->legendary_key_ < *(_DWORD *)(v4 + 32) )
      goto LABEL_14;
  }
  if ( *(_DWORD *)(v4 + 32) )
    goto LABEL_15;
  if ( *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->legendary_key_);
  }
  if ( this->legendary_key_ || *(_DWORD *)(v4 + 32) + this->legendary_key_ <= *(_DWORD *)(v4 + 32) )
  {
LABEL_15:
    v11 = *(_DWORD *)(v4 + 32);
    if ( *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&this->legendary_key_);
    }
    v12 = v11;
    v13 = SAFE_ADD<unsigned int,unsigned int>(this->legendary_key_, v11);
    v14 = *(_BYTE *)(((unsigned __int64)&this->legendary_key_ >> 3) + 0x7FFF8000);
    if ( v14 != 0 && v14 <= 3 )
    {
      LOBYTE(v12) = v14 != 0;
      __asan_report_store4(&this->legendary_key_, v12, v13);
    }
    this->legendary_key_ = v13;
    if ( is_notify )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      player = this->player_;
      buildIntProp(&prop_value, 0x272Bu, this->legendary_key_);
      Player::notifyPlayerProp(player, &prop_value);
      proto::PropValue::~PropValue(&prop_value);
    }
    v16 = *(_DWORD *)(v4 + 32);
    if ( *(_BYTE *)((reason >> 3) + 0x7FFF8000) != 0
      && (char)((reason & 7) + 3) >= *(_BYTE *)((reason >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(reason);
    }
    PlayerItemComp::logLegendaryKeyChange(this, 0, *(proto::ActionReasonType *)reason, v16, 0);
    result = 0LL;
  }
  else
  {
LABEL_14:
    common::milog::MiLogStream::create(
      &v19,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "addLegendaryKey",
      6748);
    v7 = common::milog::MiLogStream::operator<<<char [47],(char *[47])0>(
           &v19,
           (const char (*)[47])"legendary_key add overflow, cur_legendary_key:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &this->legendary_key_);
    v9 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(v8, (const char (*)[20])" add_legendary_key:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 32));
    common::milog::MiLogStream::~MiLogStream(&v19);
    result = 0xFFFFFFFFLL;
  }
  if ( v21 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6762: range 0000000017CF877A-0000000017CF8AC4
void __cdecl PlayerItemComp::logLegendaryKeyChange(
        PlayerItemComp *const this,
        uint32_t change_type,
        proto::ActionReasonType reason_type,
        uint32_t delta_value,
        uint32_t detail_id)
{
  unsigned __int64 v5; // r12
  __int64 v6; // rax
  _DWORD *v7; // r13
  PlayerBasicComp *BasicComp; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // r14
  uint32_t LegendaryKey; // eax
  std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v13; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v14; // rax
  Player *player; // r14
  std::string v16; // [rsp+0h] [rbp-F0h]
  google::protobuf::uint32 detail_ida; // [rsp+8h] [rbp-E8h]
  google::protobuf::uint32 delta_valuea; // [rsp+Ch] [rbp-E4h]
  google::protobuf::uint32 reason_typea; // [rsp+10h] [rbp-E0h]
  google::protobuf::uint32 change_typea; // [rsp+14h] [rbp-DCh]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-D8h]
  std::shared_ptr<google::protobuf::Message> p_body_ptr; // [rsp+20h] [rbp-D0h] BYREF
  std::shared_ptr<google::protobuf::Message> p_body_ext_ptr; // [rsp+30h] [rbp-C0h] BYREF
  std::string v24; // [rsp+40h] [rbp-B0h] BYREF
  char v25[144]; // [rsp+60h] [rbp-90h] BYREF

  *(&v16._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  HIDWORD(v16._anon_0._M_allocated_capacity) = change_type;
  *(_DWORD *)v16._anon_0._M_local_buf = reason_type;
  HIDWORD(v16._M_string_length) = delta_value;
  LODWORD(v16._M_string_length) = detail_id;
  v5 = (unsigned __int64)v25;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_1(96LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "2 48 1 11 holder:6763 64 16 12 log_ptr:6765";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::logLegendaryKeyChange;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234753551;
  v7[536862722] = -202178560;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&v24, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 48), 0x4B7u, v16);
  std::string::~string(&v24);
  common::tools::perf::make_shared<proto_log::PlayerLogBodyChangeLegendaryKey>();
  v9 = std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  proto_log::PlayerLogBodyChangeLegendaryKey::set_change_type(v9, change_typea);
  v10 = std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  LegendaryKey = PlayerItemComp::getLegendaryKey(thisa);
  proto_log::PlayerLogBodyChangeLegendaryKey::set_cur_value(v10, LegendaryKey);
  v12 = std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  proto_log::PlayerLogBodyChangeLegendaryKey::set_reason_type(v12, reason_typea);
  v13 = std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  proto_log::PlayerLogBodyChangeLegendaryKey::set_delta_value(v13, delta_valuea);
  v14 = std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyChangeLegendaryKey,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  proto_log::PlayerLogBodyChangeLegendaryKey::set_detail_id(v14, detail_ida);
  if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  player = thisa->player_;
  std::shared_ptr<google::protobuf::Message>::shared_ptr(&p_body_ext_ptr, 0LL);
  std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodyChangeLegendaryKey,void>(
    &p_body_ptr,
    (const std::shared_ptr<proto_log::PlayerLogBodyChangeLegendaryKey> *)(v5 + 64));
  Player::printStatLog(player, &p_body_ptr, &p_body_ext_ptr, 0xEu);
  std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ptr);
  std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ext_ptr);
  std::shared_ptr<proto_log::PlayerLogBodyChangeLegendaryKey>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodyChangeLegendaryKey> *const)(v5 + 64));
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 48));
  if ( v25 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 6777: range 0000000017CF8AC6-0000000017CF8E14
int32_t __cdecl PlayerItemComp::getItemParamVecByRewardIdVec(
        const PlayerItemComp *const this,
        const std::vector<unsigned int> *reward_id_vec,
        std::vector<ItemParam> *item_param_vec)
{
  unsigned __int64 v3; // r12
  __int64 v4; // rax
  _DWORD *v5; // r13
  RewardExcelConfigMgr *p_reward_config_mgr; // rcx
  common::milog::MiLogStream *v7; // rcx
  int32_t v8; // r14d
  int32_t result; // eax
  int32_t ret; // [rsp+2Ch] [rbp-F4h]
  std::vector<proto::ItemParamBin>::iterator __for_begin; // [rsp+30h] [rbp-F0h] BYREF
  std::vector<proto::ItemParamBin>::iterator __for_end; // [rsp+38h] [rbp-E8h] BYREF
  std::vector<proto::ItemParamBin> *__for_range; // [rsp+40h] [rbp-E0h]
  const proto::ItemParamBin *item_param_bin; // [rsp+48h] [rbp-D8h]
  common::milog::MiLogStream v16; // [rsp+50h] [rbp-D0h] BYREF
  char v17[176]; // [rsp+70h] [rbp-B0h] BYREF

  v3 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(128LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "2 32 16 15 item_param:6790 64 24 23 item_param_bin_vec:6780";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::getItemParamVecByRewardIdVec;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -219021312;
  v5[536862722] = -218103808;
  v5[536862723] = -202116109;
  std::vector<ItemParam>::clear(item_param_vec);
  std::vector<proto::ItemParamBin>::vector((std::vector<proto::ItemParamBin> *const)(v3 + 64));
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)(v3 + 32));
  p_reward_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 32))->design_config.txt_config_mgr.reward_config_mgr;
  ret = RewardExcelConfigMgr::getItemParamsByRewardIds(
          p_reward_config_mgr,
          reward_id_vec,
          (std::vector<proto::ItemParamBin> *)(v3 + 64));
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 32));
  if ( ret )
  {
    common::milog::MiLogStream::create(
      &v16,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "getItemParamVecByRewardIdVec",
      6784);
    v7 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
           &v16,
           (const char (*)[39])"getItemParamsByRewardIds fail, player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v7, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v16);
    v8 = ret;
  }
  else
  {
    __for_range = (std::vector<proto::ItemParamBin> *)(v3 + 64);
    __for_begin._M_current = std::vector<proto::ItemParamBin>::begin((std::vector<proto::ItemParamBin> *const)(v3 + 64))._M_current;
    __for_end._M_current = std::vector<proto::ItemParamBin>::end((std::vector<proto::ItemParamBin> *const)(v3 + 64))._M_current;
    while ( __gnu_cxx::operator!=<proto::ItemParamBin *,std::vector<proto::ItemParamBin>>(&__for_begin, &__for_end) )
    {
      item_param_bin = __gnu_cxx::__normal_iterator<proto::ItemParamBin *,std::vector<proto::ItemParamBin>>::operator*(&__for_begin);
      *(_DWORD *)(v3 + 32) = 0;
      *(_DWORD *)(v3 + 36) = 0;
      *(_DWORD *)(v3 + 40) = 0;
      *(_DWORD *)(v3 + 44) = 0;
      ItemParam::fromBin((ItemParam *const)(v3 + 32), item_param_bin);
      std::vector<ItemParam>::push_back(item_param_vec, (const std::vector<ItemParam>::value_type *)(v3 + 32));
      __gnu_cxx::__normal_iterator<proto::ItemParamBin *,std::vector<proto::ItemParamBin>>::operator++(&__for_begin);
    }
    v8 = 0;
  }
  std::vector<proto::ItemParamBin>::~vector((std::vector<proto::ItemParamBin> *const)(v3 + 64));
  result = v8;
  if ( v17 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6799: range 0000000017CF8E16-0000000017CF936E
std::vector<ItemParam> *__cdecl PlayerItemComp::getMergedItemParamVec(
        std::vector<ItemParam> *retstr,
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  MaterialExcelConfigMgr *p_material_config_mgr; // rcx
  bool v7; // r14
  std::map<unsigned int,unsigned int>::mapped_type *v8; // rax
  std::map<unsigned int,unsigned int>::mapped_type v9; // esi
  std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int> >::reference v10; // rax
  std::pair<unsigned int const,unsigned int> *v11; // rdx
  ItemParam *v12; // rdx
  std::map<unsigned int,unsigned int>::iterator __for_begin_0; // [rsp+20h] [rbp-110h] BYREF
  std::map<unsigned int,unsigned int>::iterator __for_end_0; // [rsp+28h] [rbp-108h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+30h] [rbp-100h]
  std::map<unsigned int,unsigned int> *__for_range_0; // [rsp+38h] [rbp-F8h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *item_id; // [rsp+40h] [rbp-F0h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *count; // [rsp+48h] [rbp-E8h]
  const ItemParam *param; // [rsp+50h] [rbp-E0h]
  std::pair<unsigned int const,unsigned int> __for_end; // [rsp+58h] [rbp-D8h] BYREF
  char v23[208]; // [rsp+60h] [rbp-D0h] BYREF

  v3 = (unsigned __int64)v23;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(160LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "2 48 16 15 item_param:6814 80 48 19 item_count_map:6801";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::getMergedItemParamVec;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = 61937;
  v5[536862722] = 62194;
  v5[536862724] = -202116109;
  std::vector<ItemParam>::vector(retstr);
  std::map<unsigned int,unsigned int>::map((std::map<unsigned int,unsigned int> *const)(v3 + 80));
  __for_range = item_param_vec;
  __for_end_0._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int> >::_Base_ptr)std::vector<ItemParam>::begin(item_param_vec)._M_current;
  __for_end = (std::pair<unsigned int const,unsigned int>)std::vector<ItemParam>::end(item_param_vec)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(
            (const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *)&__for_end_0,
            (const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *)&__for_end) )
  {
    param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*((const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *const)&__for_end_0);
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v3 + 48));
    p_material_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 48))->design_config.txt_config_mgr.material_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(param);
    }
    v7 = data::MaterialExcelConfigMgrBase::findMaterialExcelConfig(p_material_config_mgr, param->item_id) != 0LL;
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 48));
    if ( v7 )
    {
      v8 = std::map<unsigned int,unsigned int>::operator[](
             (std::map<unsigned int,unsigned int> *const)(v3 + 80),
             &param->item_id);
      if ( *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v8 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v8);
      }
      v9 = *v8;
      if ( *(_BYTE *)(((unsigned __int64)&param->count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&param->count >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&param->count);
      }
      *v8 = v9 + param->count;
    }
    else
    {
      std::vector<ItemParam>::emplace_back<ItemParam const&>(retstr, param, param);
    }
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++((__gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *const)&__for_end_0);
  }
  __for_range_0 = (std::map<unsigned int,unsigned int> *)(v3 + 80);
  __for_begin_0._M_node = std::map<unsigned int,unsigned int>::begin((std::map<unsigned int,unsigned int> *const)(v3 + 80))._M_node;
  __for_end_0._M_node = std::map<unsigned int,unsigned int>::end(__for_range_0)._M_node;
  while ( std::operator!=(&__for_begin_0, &__for_end_0) )
  {
    v10 = std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int>>::operator*(&__for_begin_0);
    v11 = v10;
    if ( ((unsigned __int8)v10 & 7) >= *(_BYTE *)(((unsigned __int64)v10 >> 3) + 0x7FFF8000)
      && *(_BYTE *)(((unsigned __int64)v10 >> 3) + 0x7FFF8000) != 0
      || *(_BYTE *)((((unsigned __int64)&v10->second + 3) >> 3) + 0x7FFF8000) != 0
      && (((unsigned __int8)v10 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v10->second + 3) >> 3) + 0x7FFF8000) )
    {
      __asan_report_load_n(v10, 8LL);
    }
    __for_end = *v11;
    item_id = std::get<0ul,unsigned int const,unsigned int>(&__for_end);
    count = std::get<1ul,unsigned int const,unsigned int>(&__for_end);
    *(_DWORD *)(v3 + 48) = 0;
    *(_DWORD *)(v3 + 52) = 0;
    *(_DWORD *)(v3 + 56) = 0;
    *(_DWORD *)(v3 + 60) = 0;
    if ( *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_id);
    }
    *(_DWORD *)(v3 + 48) = *item_id;
    if ( *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(count);
    }
    *(_DWORD *)(v3 + 52) = *count;
    v12 = std::move<ItemParam &>((ItemParam *)(v3 + 48));
    std::vector<ItemParam>::emplace_back<ItemParam>(retstr, v12, v12);
    std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int>>::operator++(&__for_begin_0);
  }
  std::map<unsigned int,unsigned int>::~map((std::map<unsigned int,unsigned int> *const)(v3 + 80));
  if ( v23 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8010) = -168430091;
  }
  return retstr;
};

// Line 6824: range 0000000017CF9370-0000000017CF9438
int32_t __cdecl PlayerItemComp::checkGrantReward(
        PlayerItemComp *const this,
        uint32_t reward_id,
        const ActionReason *reason)
{
  int32_t v3; // ebx
  std::allocator<unsigned int> __a; // [rsp+2Bh] [rbp-45h] BYREF
  std::initializer_list<unsigned int> __l; // [rsp+2Ch] [rbp-44h] BYREF

  LODWORD(__l._M_array) = reward_id;
  std::allocator<unsigned int>::allocator(&__a);
  std::vector<unsigned int>::vector(
    (std::vector<unsigned int> *const)((char *)&__l._M_array + 4),
    (std::initializer_list<unsigned int>)__PAIR128__(1LL, &__l),
    &__a);
  v3 = PlayerItemComp::checkGrantRewards(this, (const std::vector<unsigned int> *)((char *)&__l._M_array + 4), reason);
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)((char *)&__l._M_array + 4));
  std::allocator<unsigned int>::~allocator(&__a);
  return v3;
};

// Line 6829: range 0000000017CF943A-0000000017CF9687
int32_t __cdecl PlayerItemComp::checkGrantRewards(
        PlayerItemComp *const this,
        const std::vector<unsigned int> *reward_id_vec,
        const ActionReason *reason)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  common::milog::MiLogStream *v6; // rdx
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rcx
  int32_t v9; // r14d
  int32_t result; // eax
  common::milog::MiLogStream v12; // [rsp+20h] [rbp-B0h] BYREF
  char v13[144]; // [rsp+40h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v13;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 24 19 item_param_vec:6830";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkGrantRewards;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v3 + 32));
  if ( PlayerItemComp::getItemParamVecByRewardIdVec(this, reward_id_vec, (std::vector<ItemParam> *)(v3 + 32)) )
  {
    common::milog::MiLogStream::create(
      &v12,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkGrantRewards",
      6833);
    v6 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
           &v12,
           (const char (*)[50])"getItemParamVecByRewardIdVec fail, reward_id_vec:");
    v7 = common::milog::MiLogStream::operator<<<unsigned int>(v6, reward_id_vec);
    v8 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v7, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v8, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v12);
    v9 = -1;
  }
  else
  {
    v9 = PlayerItemComp::checkAddItemBatch(this, (const std::vector<ItemParam> *)(v3 + 32), reason);
  }
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 32));
  result = v9;
  if ( v13 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 6841: range 0000000017CF9688-0000000017CF9755
int32_t __cdecl PlayerItemComp::grantReward(
        PlayerItemComp *const this,
        uint32_t reward_id,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  int32_t v4; // ebx
  std::allocator<unsigned int> __a; // [rsp+2Bh] [rbp-45h] BYREF
  std::initializer_list<unsigned int> __l; // [rsp+2Ch] [rbp-44h] BYREF

  LODWORD(__l._M_array) = reward_id;
  std::allocator<unsigned int>::allocator(&__a);
  std::vector<unsigned int>::vector(
    (std::vector<unsigned int> *const)((char *)&__l._M_array + 4),
    (std::initializer_list<unsigned int>)__PAIR128__(1LL, &__l),
    &__a);
  v4 = PlayerItemComp::grantRewards(
         this,
         (const std::vector<unsigned int> *)((char *)&__l._M_array + 4),
         reason,
         result_vec_ptr);
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)((char *)&__l._M_array + 4));
  std::allocator<unsigned int>::~allocator(&__a);
  return v4;
};

// Line 6847: range 0000000017CF9756-0000000017CF9E8A
int32_t __cdecl PlayerItemComp::grantRewards(
        PlayerItemComp *const this,
        const std::vector<unsigned int> *temp_reward_id_vec,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rdx
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rcx
  int32_t v12; // r14d
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rcx
  int32_t result; // eax
  std::vector<ItemParam>::iterator __for_begin; // [rsp+20h] [rbp-1F0h] BYREF
  std::vector<ItemParam>::iterator __for_end; // [rsp+28h] [rbp-1E8h] BYREF
  std::vector<ItemParam> *__for_range; // [rsp+30h] [rbp-1E0h]
  const ItemParam *item_param; // [rsp+38h] [rbp-1D8h]
  common::milog::MiLogStream v23; // [rsp+40h] [rbp-1D0h] BYREF
  char v24[432]; // [rsp+60h] [rbp-1B0h] BYREF

  v4 = (unsigned __int64)v24;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_3(384LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "5 48 24 18 reward_id_vec:6848 112 24 19 item_param_vec:6855 176 24 14 param_vec:6862 240 24 17 i"
                        "tem_ptr_vec:6873 304 40 16 equip_param:6865";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::grantRewards;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = 61937;
  v6[536862722] = -218959360;
  v6[536862723] = 62194;
  v6[536862724] = -218959360;
  v6[536862725] = 62194;
  v6[536862726] = -218959360;
  v6[536862727] = 62194;
  v6[536862728] = -218959360;
  v6[536862729] = 62194;
  v6[536862730] = -218103808;
  v6[536862731] = -202116109;
  std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v4 + 48), temp_reward_id_vec);
  if ( PlayerItemComp::checkAndRecordBeforeReward(this, (std::vector<unsigned int> *)(v4 + 48), reason) )
  {
    common::milog::MiLogStream::create(
      &v23,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "grantRewards",
      6851);
    v7 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(
           &v23,
           (const char (*)[48])"checkAndRecordBeforeReward fail, reward_id_vec:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int>(v7, (const std::vector<unsigned int> *)(v4 + 48));
    v9 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v8, (const char (*)[9])" reason:");
    v10 = operator<<(v9, reason);
    v11 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v10, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v11, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v23);
    v12 = -1;
  }
  else
  {
    std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 112));
    if ( PlayerItemComp::getItemParamVecByRewardIdVec(
           this,
           (const std::vector<unsigned int> *)(v4 + 48),
           (std::vector<ItemParam> *)(v4 + 112)) )
    {
      common::milog::MiLogStream::create(
        &v23,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "grantRewards",
        6858);
      v13 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
              &v23,
              (const char (*)[50])"getItemParamVecByRewardIdVec fail, reward_id_vec:");
      v14 = common::milog::MiLogStream::operator<<<unsigned int>(v13, (const std::vector<unsigned int> *)(v4 + 48));
      v15 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v14, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v15, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v23);
      v12 = -1;
    }
    else
    {
      std::vector<proto::EquipParam>::vector((std::vector<proto::EquipParam> *const)(v4 + 176));
      __for_range = (std::vector<ItemParam> *)(v4 + 112);
      __for_begin._M_current = std::vector<ItemParam>::begin((std::vector<ItemParam> *const)(v4 + 112))._M_current;
      __for_end._M_current = std::vector<ItemParam>::end((std::vector<ItemParam> *const)(v4 + 112))._M_current;
      while ( __gnu_cxx::operator!=<ItemParam *,std::vector<ItemParam>>(&__for_begin, &__for_end) )
      {
        item_param = __gnu_cxx::__normal_iterator<ItemParam *,std::vector<ItemParam>>::operator*(&__for_begin);
        proto::EquipParam::EquipParam((proto::EquipParam *const)(v4 + 304));
        if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_param);
        }
        proto::EquipParam::set_item_id((proto::EquipParam *const)(v4 + 304), item_param->item_id);
        if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->count);
        }
        proto::EquipParam::set_item_num((proto::EquipParam *const)(v4 + 304), item_param->count);
        if ( *(_BYTE *)(((unsigned __int64)&item_param->level >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->level >> 3)
                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->level);
        }
        proto::EquipParam::set_item_level((proto::EquipParam *const)(v4 + 304), item_param->level);
        if ( *(_BYTE *)(((unsigned __int64)&item_param->promote_level >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_param + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->promote_level >> 3)
                                                                    + 0x7FFF8000) )
        {
          __asan_report_load4(&item_param->promote_level);
        }
        proto::EquipParam::set_promote_level((proto::EquipParam *const)(v4 + 304), item_param->promote_level);
        std::vector<proto::EquipParam>::push_back(
          (std::vector<proto::EquipParam> *const)(v4 + 176),
          (const std::vector<proto::EquipParam>::value_type *)(v4 + 304));
        proto::EquipParam::~EquipParam((proto::EquipParam *const)(v4 + 304));
        __gnu_cxx::__normal_iterator<ItemParam *,std::vector<ItemParam>>::operator++(&__for_begin);
      }
      PlayerItemComp::createItemBatch(
        (std::vector<std::shared_ptr<Item>> *)(v4 + 240),
        this,
        (const std::vector<proto::EquipParam> *)(v4 + 176));
      v12 = PlayerItemComp::addItemBatch(
              this,
              (const std::vector<std::shared_ptr<Item>> *)(v4 + 240),
              reason,
              result_vec_ptr);
      std::vector<std::shared_ptr<Item>>::~vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 240));
      std::vector<proto::EquipParam>::~vector((std::vector<proto::EquipParam> *const)(v4 + 176));
    }
    std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 112));
  }
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v4 + 48));
  result = v12;
  if ( v24 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8028) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8028) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6879: range 0000000017CF9E8C-0000000017CF9F57
int32_t __cdecl PlayerItemComp::grantRewardOrSendMail(
        PlayerItemComp *const this,
        uint32_t reward_id,
        uint32_t id,
        const ActionReason *reason)
{
  int32_t v4; // ebx
  std::allocator<unsigned int> __a; // [rsp+2Bh] [rbp-45h] BYREF
  std::initializer_list<unsigned int> __l; // [rsp+2Ch] [rbp-44h] BYREF

  LODWORD(__l._M_array) = reward_id;
  std::allocator<unsigned int>::allocator(&__a);
  std::vector<unsigned int>::vector(
    (std::vector<unsigned int> *const)((char *)&__l._M_array + 4),
    (std::initializer_list<unsigned int>)__PAIR128__(1LL, &__l),
    &__a);
  v4 = PlayerItemComp::grantRewardsOrSendMail(
         this,
         (const std::vector<unsigned int> *)((char *)&__l._M_array + 4),
         id,
         reason);
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)((char *)&__l._M_array + 4));
  std::allocator<unsigned int>::~allocator(&__a);
  return v4;
};

// Line 6885: range 0000000017CF9F58-0000000017CFA510
int32_t __cdecl PlayerItemComp::grantRewardsOrSendMail(
        PlayerItemComp *const this,
        const std::vector<unsigned int> *temp_reward_id_vec,
        uint32_t id,
        const ActionReason *reason)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rdx
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rcx
  int32_t v12; // r14d
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rcx
  __int64 v16; // rdx
  PlayerMailComp *MailComp; // rax
  int32_t result; // eax
  common::milog::MiLogStream v21; // [rsp+20h] [rbp-170h] BYREF
  char v22[336]; // [rsp+40h] [rbp-150h] BYREF

  v4 = (unsigned __int64)v22;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_3(288LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "4 32 24 18 reward_id_vec:6886 96 24 19 item_param_vec:6893 160 24 16 temp_reason:6901 224 24 17 "
                        "argument_vec:6908";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::grantRewardsOrSendMail;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234881024;
  v6[536862722] = -218959118;
  v6[536862723] = -234881024;
  v6[536862724] = -218959118;
  v6[536862725] = -234881024;
  v6[536862726] = -218959118;
  v6[536862727] = -218103808;
  v6[536862728] = -202116109;
  std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v4 + 32), temp_reward_id_vec);
  if ( PlayerItemComp::checkAndRecordBeforeReward(this, (std::vector<unsigned int> *)(v4 + 32), reason) )
  {
    common::milog::MiLogStream::create(
      &v21,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "grantRewardsOrSendMail",
      6889);
    v7 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(
           &v21,
           (const char (*)[48])"checkAndRecordBeforeReward fail, reward_id_vec:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int>(v7, (const std::vector<unsigned int> *)(v4 + 32));
    v9 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v8, (const char (*)[9])" reason:");
    v10 = operator<<(v9, reason);
    v11 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v10, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v11, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v21);
    v12 = -1;
  }
  else
  {
    std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 96));
    if ( PlayerItemComp::getItemParamVecByRewardIdVec(
           this,
           (const std::vector<unsigned int> *)(v4 + 32),
           (std::vector<ItemParam> *)(v4 + 96)) )
    {
      common::milog::MiLogStream::create(
        &v21,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "grantRewardsOrSendMail",
        6896);
      v13 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
              &v21,
              (const char (*)[50])"getItemParamVecByRewardIdVec fail, reward_id_vec:");
      v14 = common::milog::MiLogStream::operator<<<unsigned int>(v13, (const std::vector<unsigned int> *)(v4 + 32));
      v15 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v14, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v15, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v21);
      v12 = -1;
    }
    else
    {
      if ( ((unsigned __int8)reason & 7) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000)
        && *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
        || *(_BYTE *)(((unsigned __int64)(&reason->is_by_overflow_transform + 2) >> 3) + 0x7FFF8000) != 0
        && (((unsigned __int8)reason + 23) & 7) >= *(_BYTE *)(((unsigned __int64)(&reason->is_by_overflow_transform + 2) >> 3)
                                                            + 0x7FFF8000) )
      {
        __asan_report_load_n(reason, 24LL);
      }
      v16 = *(_QWORD *)&reason->quest_id;
      *(_QWORD *)(v4 + 160) = *(_QWORD *)&reason->reason_type;
      *(_QWORD *)(v4 + 168) = v16;
      *(_QWORD *)(v4 + 176) = *(_QWORD *)&reason->item_exceed_msg_type;
      *(_BYTE *)(v4 + 174) = 0;
      if ( PlayerItemComp::checkAddItemBatch(
             this,
             (const std::vector<ItemParam> *)(v4 + 96),
             (const ActionReason *)(v4 + 160)) )
      {
        std::vector<std::string>::vector((std::vector<std::string> *const)(v4 + 224));
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        MailComp = Player::getMailComp(this->player_);
        v12 = PlayerMailComp::addMailById(
                MailComp,
                id,
                4u,
                (const std::vector<ItemParam> *)(v4 + 96),
                (const std::vector<std::string> *)(v4 + 224),
                reason);
        std::vector<std::string>::~vector((std::vector<std::string> *const)(v4 + 224));
      }
      else
      {
        v12 = PlayerItemComp::addItemBatch(this, (const std::vector<ItemParam> *)(v4 + 96), reason, 0LL);
      }
    }
    std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 96));
  }
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v4 + 32));
  result = v12;
  if ( v22 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8020) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8020) = -168430091;
  }
  return result;
};

// Line 6914: range 0000000017CFA512-0000000017CFA5DF
int32_t __cdecl PlayerItemComp::grantRewardWithStackLimit(
        PlayerItemComp *const this,
        uint32_t reward_id,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  int32_t v4; // ebx
  std::allocator<unsigned int> __a; // [rsp+2Bh] [rbp-45h] BYREF
  std::initializer_list<unsigned int> __l; // [rsp+2Ch] [rbp-44h] BYREF

  LODWORD(__l._M_array) = reward_id;
  std::allocator<unsigned int>::allocator(&__a);
  std::vector<unsigned int>::vector(
    (std::vector<unsigned int> *const)((char *)&__l._M_array + 4),
    (std::initializer_list<unsigned int>)__PAIR128__(1LL, &__l),
    &__a);
  v4 = PlayerItemComp::grantRewardsWithStackLimit(
         this,
         (const std::vector<unsigned int> *)((char *)&__l._M_array + 4),
         reason,
         result_vec_ptr);
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)((char *)&__l._M_array + 4));
  std::allocator<unsigned int>::~allocator(&__a);
  return v4;
};

// Line 6919: range 0000000017CFA5E0-0000000017CFA9CA
int32_t __cdecl PlayerItemComp::grantRewardsWithStackLimit(
        PlayerItemComp *const this,
        const std::vector<unsigned int> *temp_reward_id_vec,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rdx
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rcx
  int32_t v12; // r14d
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rcx
  int32_t result; // eax
  common::milog::MiLogStream v19; // [rsp+20h] [rbp-F0h] BYREF
  char v20[208]; // [rsp+40h] [rbp-D0h] BYREF

  v4 = (unsigned __int64)v20;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(160LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "2 32 24 18 reward_id_vec:6920 96 24 19 item_param_vec:6926";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::grantRewardsWithStackLimit;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234881024;
  v6[536862722] = -218959118;
  v6[536862723] = -218103808;
  v6[536862724] = -202116109;
  std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v4 + 32), temp_reward_id_vec);
  if ( PlayerItemComp::checkAndRecordBeforeReward(this, (std::vector<unsigned int> *)(v4 + 32), reason) )
  {
    common::milog::MiLogStream::create(
      &v19,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "grantRewardsWithStackLimit",
      6923);
    v7 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(
           &v19,
           (const char (*)[48])"checkAndRecordBeforeReward fail, reward_id_vec:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int>(v7, (const std::vector<unsigned int> *)(v4 + 32));
    v9 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v8, (const char (*)[9])" reason:");
    v10 = operator<<(v9, reason);
    v11 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v10, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v11, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v19);
    v12 = -1;
  }
  else
  {
    std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 96));
    if ( PlayerItemComp::getItemParamVecByRewardIdVec(
           this,
           (const std::vector<unsigned int> *)(v4 + 32),
           (std::vector<ItemParam> *)(v4 + 96)) )
    {
      common::milog::MiLogStream::create(
        &v19,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "grantRewardsWithStackLimit",
        6929);
      v13 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
              &v19,
              (const char (*)[50])"getItemParamVecByRewardIdVec fail, reward_id_vec:");
      v14 = common::milog::MiLogStream::operator<<<unsigned int>(v13, (const std::vector<unsigned int> *)(v4 + 32));
      v15 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v14, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v15, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v19);
      v12 = -1;
    }
    else
    {
      v12 = PlayerItemComp::addItemBatchWithStackLimit(
              this,
              (std::vector<ItemParam> *)(v4 + 96),
              reason,
              result_vec_ptr);
    }
    std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 96));
  }
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v4 + 32));
  result = v12;
  if ( v20 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 6937: range 0000000017CFA9CC-0000000017CFAF4F
__int64 __fastcall PlayerItemComp::checkGrantDropItems(
        PlayerItemComp *const this,
        uint32_t drop_id,
        uint32_t drop_count,
        const ActionReason *reason)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  unsigned int v8; // r14d
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rbx
  std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::vector<data::IdCountConfig> >,false,false>::pointer v12; // rax
  std::vector<data::IdCountConfig>::size_type v13; // rax
  uint32_t *p_count; // rax
  __int64 result; // rax
  unsigned int val; // [rsp+28h] [rbp-148h] BYREF
  uint32_t item_count; // [rsp+2Ch] [rbp-144h]
  std::vector<data::IdCountConfig>::const_iterator __for_begin; // [rsp+30h] [rbp-140h] BYREF
  std::vector<data::IdCountConfig>::const_iterator __for_end; // [rsp+38h] [rbp-138h] BYREF
  const data::ItemConfig *item_config_ptr; // [rsp+40h] [rbp-130h]
  const std::unordered_map<unsigned int,std::vector<data::IdCountConfig>> *max_drop_item_map; // [rsp+48h] [rbp-128h]
  const std::vector<data::IdCountConfig> *__for_range; // [rsp+50h] [rbp-120h]
  const data::IdCountConfig *id_count_config; // [rsp+58h] [rbp-118h]
  common::milog::MiLogStream v26; // [rsp+60h] [rbp-110h] BYREF
  char v27[240]; // [rsp+80h] [rbp-F0h] BYREF

  v4 = (unsigned __int64)v27;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(192LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "4 48 4 12 drop_id:6936 64 8 9 iter:6946 96 16 15 item_param:6941 128 24 13 item_vec:6953";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkGrantDropItems;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556943;
  v6[536862722] = -218959360;
  v6[536862723] = -219021312;
  v6[536862724] = -218103808;
  v6[536862725] = -202116109;
  *(_DWORD *)(v4 + 48) = drop_id;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)(v4 + 96));
  v7 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
  item_config_ptr = ItemExcelConfigMgr::findItemConfig(
                      &v7->design_config.txt_config_mgr.item_config_mgr,
                      *(_DWORD *)(v4 + 48));
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 96));
  if ( item_config_ptr )
  {
    *(_QWORD *)(v4 + 96) = 0LL;
    *(_QWORD *)(v4 + 104) = 0LL;
    *(_DWORD *)(v4 + 96) = *(_DWORD *)(v4 + 48);
    *(_DWORD *)(v4 + 100) = drop_count;
    v8 = PlayerItemComp::checkAddItem(this, (const ItemParam *)(v4 + 96), reason);
  }
  else
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v4 + 96));
    max_drop_item_map = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96))->design_config.txt_config_mgr.drop_config_mgr.max_drop_item_map;
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v4 + 96));
    *(std::unordered_map<unsigned int,std::vector<data::IdCountConfig>>::const_iterator *)(v4 + 64) = std::unordered_map<unsigned int,std::vector<data::IdCountConfig>>::find(max_drop_item_map, (const std::unordered_map<unsigned int,std::vector<data::IdCountConfig>>::key_type *)(v4 + 48));
    __for_end._M_current = (const data::IdCountConfig *)std::unordered_map<unsigned int,std::vector<data::IdCountConfig>>::end(max_drop_item_map)._M_cur;
    if ( std::__detail::operator==<std::pair<unsigned int const,std::vector<data::IdCountConfig>>,false>(
           (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,std::vector<data::IdCountConfig> >,false> *)(v4 + 64),
           (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,std::vector<data::IdCountConfig> >,false> *)&__for_end) )
    {
      common::milog::MiLogStream::create(
        &v26,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkGrantDropItems",
        6949);
      v9 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(&v26, (const char (*)[17])"invalid drop_id:");
      v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 48));
      v11 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v10, (const char (*)[6])" uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &val);
      common::milog::MiLogStream::~MiLogStream(&v26);
      v8 = 5;
    }
    else
    {
      std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 128));
      v12 = std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::vector<data::IdCountConfig>>,false,false>::operator->((const std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::vector<data::IdCountConfig> >,false,false> *const)(v4 + 64));
      v13 = std::vector<data::IdCountConfig>::size(&v12->second);
      std::vector<ItemParam>::reserve((std::vector<ItemParam> *const)(v4 + 128), v13);
      __for_range = &std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::vector<data::IdCountConfig>>,false,false>::operator->((const std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::vector<data::IdCountConfig> >,false,false> *const)(v4 + 64))->second;
      __for_begin._M_current = std::vector<data::IdCountConfig>::begin(__for_range)._M_current;
      __for_end._M_current = std::vector<data::IdCountConfig>::end(__for_range)._M_current;
      while ( __gnu_cxx::operator!=<data::IdCountConfig const*,std::vector<data::IdCountConfig>>(
                &__for_begin,
                &__for_end) )
      {
        id_count_config = __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator*(&__for_begin);
        p_count = &id_count_config->count;
        if ( *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)p_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(p_count);
        }
        item_count = SAFE_MULTIPLY<unsigned int,unsigned int>(id_count_config->count, drop_count);
        if ( *(_BYTE *)(((unsigned __int64)&id_count_config->id >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&id_count_config->id >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&id_count_config->id);
        }
        *(_DWORD *)(v4 + 96) = id_count_config->id;
        *(_DWORD *)(v4 + 100) = item_count;
        *(_DWORD *)(v4 + 104) = 0;
        *(_DWORD *)(v4 + 108) = 0;
        std::vector<ItemParam>::push_back(
          (std::vector<ItemParam> *const)(v4 + 128),
          (std::vector<ItemParam>::value_type *)(v4 + 96));
        __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator++(&__for_begin);
      }
      v8 = PlayerItemComp::checkAddItemBatch(this, (const std::vector<ItemParam> *)(v4 + 128), reason);
      std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 128));
    }
  }
  result = v8;
  if ( v27 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 6966: range 0000000017CFAF50-0000000017CFB3A5
__int64 __fastcall PlayerItemComp::grantDropItems(
        PlayerItemComp *const this,
        uint32_t drop_id,
        uint32_t drop_count,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  uint32_t v8; // edx
  uint32_t v9; // esi
  uint32_t LogLevel; // eax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // r14
  unsigned int v16; // r14d
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // r14
  __int64 result; // rax
  unsigned int val; // [rsp+2Ch] [rbp-F4h] BYREF
  common::milog::MiLogStream v27; // [rsp+30h] [rbp-F0h] BYREF
  char v28[208]; // [rsp+50h] [rbp-D0h] BYREF

  v5 = (unsigned __int64)v28;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(160LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "4 32 4 12 drop_id:6965 48 4 15 drop_count:6965 64 8 18 output_result:6968 96 24 13 item_vec:6967";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::grantDropItems;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556924;
  v7[536862722] = -218959360;
  v7[536862723] = -218103808;
  v7[536862724] = -202116109;
  *(_DWORD *)(v5 + 32) = drop_id;
  *(_DWORD *)(v5 + 48) = drop_count;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v5 + 96));
  v8 = *(_DWORD *)(v5 + 48);
  v9 = *(_DWORD *)(v5 + 32);
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  *(OutputResult *)(v5 + 64) = DropUtils::dropItems(this->player_, v9, v8, reason, (std::vector<ItemParam> *)(v5 + 96));
  if ( *(_DWORD *)(v5 + 64) )
  {
    LogLevel = OutputResult::getLogLevel((const OutputResult *const)(v5 + 64));
    common::milog::MiLogStream::create(
      &v27,
      &common::milog::MiLogDefault::default_log_obj_,
      LogLevel,
      "./src/player/item/player_item_comp.cpp",
      "grantDropItems",
      6971);
    v11 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(
            &v27,
            (const char (*)[25])"dropItems fail drop_id: ");
    v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v5 + 32));
    v13 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v12, (const char (*)[14])" drop_count: ");
    v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v5 + 48));
    v15 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v14, (const char (*)[7])" uid: ");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, &val);
    common::milog::MiLogStream::~MiLogStream(&v27);
    v16 = *(_DWORD *)(v5 + 64);
  }
  else if ( std::vector<ItemParam>::empty((const std::vector<ItemParam> *const)(v5 + 96)) )
  {
    v16 = 0;
  }
  else if ( PlayerItemComp::addItemBatch(this, (const std::vector<ItemParam> *)(v5 + 96), reason, result_vec_ptr) )
  {
    common::milog::MiLogStream::create(
      &v27,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "grantDropItems",
      6981);
    v17 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
            &v27,
            (const char (*)[28])"addItemBatch fail drop_id: ");
    v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, (const unsigned int *)(v5 + 32));
    v19 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v18, (const char (*)[14])" drop_count: ");
    v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v19, (const unsigned int *)(v5 + 48));
    v21 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v20, (const char (*)[7])" uid: ");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, &val);
    common::milog::MiLogStream::~MiLogStream(&v27);
    v16 = -1;
  }
  else
  {
    v16 = 0;
  }
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v5 + 96));
  result = v16;
  if ( v28 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 6989: range 0000000017CFB3A6-0000000017CFB7FB
__int64 __fastcall PlayerItemComp::grantDropItemsWithStackLimit(
        PlayerItemComp *const this,
        uint32_t drop_id,
        uint32_t drop_count,
        const ActionReason *reason,
        std::vector<AddItemResult> *result_vec_ptr)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  uint32_t v8; // edx
  uint32_t v9; // esi
  uint32_t LogLevel; // eax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // r14
  unsigned int v16; // r14d
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // r14
  __int64 result; // rax
  unsigned int val; // [rsp+2Ch] [rbp-F4h] BYREF
  common::milog::MiLogStream v27; // [rsp+30h] [rbp-F0h] BYREF
  char v28[208]; // [rsp+50h] [rbp-D0h] BYREF

  v5 = (unsigned __int64)v28;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(160LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "4 32 4 12 drop_id:6988 48 4 15 drop_count:6988 64 8 18 output_result:6991 96 24 13 item_vec:6990";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::grantDropItemsWithStackLimit;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556924;
  v7[536862722] = -218959360;
  v7[536862723] = -218103808;
  v7[536862724] = -202116109;
  *(_DWORD *)(v5 + 32) = drop_id;
  *(_DWORD *)(v5 + 48) = drop_count;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v5 + 96));
  v8 = *(_DWORD *)(v5 + 48);
  v9 = *(_DWORD *)(v5 + 32);
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  *(OutputResult *)(v5 + 64) = DropUtils::dropItems(this->player_, v9, v8, reason, (std::vector<ItemParam> *)(v5 + 96));
  if ( *(_DWORD *)(v5 + 64) )
  {
    LogLevel = OutputResult::getLogLevel((const OutputResult *const)(v5 + 64));
    common::milog::MiLogStream::create(
      &v27,
      &common::milog::MiLogDefault::default_log_obj_,
      LogLevel,
      "./src/player/item/player_item_comp.cpp",
      "grantDropItemsWithStackLimit",
      6994);
    v11 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(
            &v27,
            (const char (*)[25])"dropItems fail drop_id: ");
    v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v5 + 32));
    v13 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v12, (const char (*)[14])" drop_count: ");
    v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v5 + 48));
    v15 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v14, (const char (*)[7])" uid: ");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, &val);
    common::milog::MiLogStream::~MiLogStream(&v27);
    v16 = *(_DWORD *)(v5 + 64);
  }
  else if ( std::vector<ItemParam>::empty((const std::vector<ItemParam> *const)(v5 + 96)) )
  {
    v16 = 0;
  }
  else if ( PlayerItemComp::addItemBatchWithStackLimit(
              this,
              (std::vector<ItemParam> *)(v5 + 96),
              reason,
              result_vec_ptr) )
  {
    common::milog::MiLogStream::create(
      &v27,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "grantDropItemsWithStackLimit",
      7004);
    v17 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
            &v27,
            (const char (*)[42])"addItemBatchWithStackLimit fail drop_id: ");
    v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, (const unsigned int *)(v5 + 32));
    v19 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v18, (const char (*)[14])" drop_count: ");
    v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v19, (const unsigned int *)(v5 + 48));
    v21 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v20, (const char (*)[7])" uid: ");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, &val);
    common::milog::MiLogStream::~MiLogStream(&v27);
    v16 = -1;
  }
  else
  {
    v16 = 0;
  }
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v5 + 96));
  result = v16;
  if ( v28 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 7012: range 0000000017CFB7FC-0000000017CFC3EF
int32_t __cdecl PlayerItemComp::checkFrontLooseAddItemBatch(
        PlayerItemComp *const this,
        const std::vector<unsigned int> *item_id_vec,
        const ActionReason *reason,
        FrontLooseCheckResult *check_result_ptr)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  __gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int> >::reference v11; // rax
  _DWORD *v12; // rdx
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v13; // rax
  common::milog::MiLogStream *v14; // r14
  const data::MaterialExcelConfig *v15; // rax
  const data::HomeWorldFurnitureExcelConfig *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  int32_t v19; // r14d
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  std::set<unsigned int> *v24; // rdx
  std::set<unsigned int> *v25; // rax
  int32_t result; // eax
  bool is_material_ge_limit; // [rsp+20h] [rbp-190h]
  bool is_weapon_ge_limit; // [rsp+21h] [rbp-18Fh]
  bool is_reliquary_ge_limit; // [rsp+22h] [rbp-18Eh]
  bool is_furniture_ge_limit; // [rsp+23h] [rbp-18Dh]
  unsigned int val; // [rsp+24h] [rbp-18Ch] BYREF
  uint32_t material_item_limit; // [rsp+28h] [rbp-188h]
  uint32_t weapon_item_limit; // [rsp+2Ch] [rbp-184h]
  uint32_t reliquary_item_limit; // [rsp+30h] [rbp-180h]
  uint32_t furniture_item_limit; // [rsp+34h] [rbp-17Ch]
  uint32_t count_0; // [rsp+38h] [rbp-178h]
  uint32_t count; // [rsp+3Ch] [rbp-174h]
  std::vector<unsigned int>::const_iterator __for_begin; // [rsp+40h] [rbp-170h] BYREF
  std::vector<unsigned int>::const_iterator __for_end; // [rsp+48h] [rbp-168h] BYREF
  const std::vector<unsigned int> *__for_range; // [rsp+50h] [rbp-160h]
  const data::ItemConfig *item_config_ptr; // [rsp+58h] [rbp-158h]
  const data::HomeWorldFurnitureExcelConfig *furniture_config_ptr; // [rsp+60h] [rbp-150h]
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+68h] [rbp-148h]
  std::shared_ptr<Config> v46; // [rsp+70h] [rbp-140h] BYREF
  common::milog::MiLogStream v47; // [rsp+80h] [rbp-130h] BYREF
  char v48[272]; // [rsp+A0h] [rbp-110h] BYREF

  v4 = (unsigned __int64)v48;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(224LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 48 4 12 item_id:7026 64 48 22 exceeded_item_set:7023 144 48 27 exceeded_item_type_set:7024";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkFrontLooseAddItemBatch;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556943;
  v6[536862723] = -219021312;
  v6[536862724] = 62194;
  v6[536862726] = -202116109;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v46);
  v7 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v46);
  material_item_limit = ConstValueExcelConfigMgr::getMaterialItemLimit(&v7->design_config.txt_config_mgr.const_value_config_mgr);
  std::shared_ptr<Config>::~shared_ptr(&v46);
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v46);
  v8 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v46);
  weapon_item_limit = ConstValueExcelConfigMgr::getWeaponItemLimit(&v8->design_config.txt_config_mgr.const_value_config_mgr);
  std::shared_ptr<Config>::~shared_ptr(&v46);
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v46);
  v9 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v46);
  reliquary_item_limit = ConstValueExcelConfigMgr::getReliquaryItemLimit(&v9->design_config.txt_config_mgr.const_value_config_mgr);
  std::shared_ptr<Config>::~shared_ptr(&v46);
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v46);
  v10 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v46);
  furniture_item_limit = ConstValueExcelConfigMgr::getFurnitureItemLimit(&v10->design_config.txt_config_mgr.const_value_config_mgr);
  std::shared_ptr<Config>::~shared_ptr(&v46);
  is_material_ge_limit = material_item_limit <= PlayerItemComp::getTotalMaterialNum(this);
  is_weapon_ge_limit = weapon_item_limit <= PlayerItemComp::getTotalWeaponNum(this);
  is_reliquary_ge_limit = reliquary_item_limit <= PlayerItemComp::getTotalReliquaryNum(this);
  is_furniture_ge_limit = furniture_item_limit <= PlayerItemComp::getTotalFurnitureNum(this);
  std::set<unsigned int>::set((std::set<unsigned int> *const)(v4 + 64));
  std::set<unsigned int>::set((std::set<unsigned int> *const)(v4 + 144));
  __for_range = item_id_vec;
  __for_begin._M_current = std::vector<unsigned int>::begin(item_id_vec)._M_current;
  __for_end._M_current = std::vector<unsigned int>::end(item_id_vec)._M_current;
  while ( 2 )
  {
    if ( !__gnu_cxx::operator!=<unsigned int const*,std::vector<unsigned int>>(&__for_begin, &__for_end) )
    {
      if ( !std::set<unsigned int>::empty((const std::set<unsigned int> *const)(v4 + 64))
        || !std::set<unsigned int>::empty((const std::set<unsigned int> *const)(v4 + 144)) )
      {
        PlayerItemComp::tryNotifyCheckAddItemExceedLimitNotify(
          this,
          reason,
          1,
          (const std::set<unsigned int> *)(v4 + 64),
          (const std::set<unsigned int> *)(v4 + 144));
        if ( check_result_ptr )
        {
          v24 = std::move<std::set<unsigned int> &>((std::set<unsigned int> *)(v4 + 64));
          std::set<unsigned int>::operator=(&check_result_ptr->exceeded_item_set, v24);
          v25 = std::move<std::set<unsigned int> &>((std::set<unsigned int> *)(v4 + 144));
          std::set<unsigned int>::operator=(&check_result_ptr->exceeded_item_type_set, v25);
        }
        v19 = 617;
      }
      else
      {
        v19 = 0;
      }
      goto LABEL_58;
    }
    v11 = __gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int>>::operator*(&__for_begin);
    v12 = v11;
    if ( *(_BYTE *)(((unsigned __int64)v11 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v11 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v11 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v11);
    }
    *(_DWORD *)(v4 + 48) = *v12;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v46);
    v13 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v46);
    item_config_ptr = ItemExcelConfigMgr::findItemConfig(
                        &v13->design_config.txt_config_mgr.item_config_mgr,
                        *(_DWORD *)(v4 + 48));
    std::shared_ptr<Config>::~shared_ptr(&v46);
    if ( !item_config_ptr )
    {
      common::milog::MiLogStream::create(
        &v47,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkFrontLooseAddItemBatch",
        7031);
      v14 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
              &v47,
              (const char (*)[28])"findItemConfig failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_35;
    }
    if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                     + 0x7FFF8000) )
    {
      __asan_report_load4(&item_config_ptr->item_type);
    }
    switch ( item_config_ptr->item_type )
    {
      case ITEM_VIRTUAL:
        goto LABEL_48;
      case ITEM_MATERIAL:
        if ( item_config_ptr )
          v15 = (const data::MaterialExcelConfig *)__dynamic_cast(
                                                     item_config_ptr,
                                                     (const struct __class_type_info *)&`typeinfo for'data::ItemConfig,
                                                     (const struct __class_type_info *)&`typeinfo for'data::MaterialExcelConfig,
                                                     0LL);
        else
          v15 = 0LL;
        material_config_ptr = v15;
        if ( !v15 )
        {
          common::milog::MiLogStream::create(
            &v47,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkFrontLooseAddItemBatch",
            7042);
          v14 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
                  &v47,
                  (const char (*)[34])"dynamic_pointer_cast failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          goto LABEL_35;
        }
        count = ItemStore::getMaterialCount(&this->pack_store_, *(_DWORD *)(v4 + 48));
        if ( !count && is_material_ge_limit )
        {
          val = 2;
          std::set<unsigned int>::insert((std::set<unsigned int> *const)(v4 + 144), &val);
          goto LABEL_48;
        }
        if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&material_config_ptr->stack_limit >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&material_config_ptr->stack_limit);
        }
        if ( count >= material_config_ptr->stack_limit )
          goto LABEL_28;
        goto LABEL_48;
      case ITEM_RELIQUARY:
        if ( is_reliquary_ge_limit )
        {
          val = 3;
          std::set<unsigned int>::insert((std::set<unsigned int> *const)(v4 + 144), &val);
        }
        goto LABEL_48;
      case ITEM_WEAPON:
        if ( is_weapon_ge_limit )
        {
          val = 4;
          std::set<unsigned int>::insert((std::set<unsigned int> *const)(v4 + 144), &val);
        }
        goto LABEL_48;
      case ITEM_FURNITURE:
        if ( item_config_ptr )
          v16 = (const data::HomeWorldFurnitureExcelConfig *)__dynamic_cast(
                                                               item_config_ptr,
                                                               (const struct __class_type_info *)&`typeinfo for'data::ItemConfig,
                                                               (const struct __class_type_info *)&`typeinfo for'data::HomeWorldFurnitureExcelConfig,
                                                               0LL);
        else
          v16 = 0LL;
        furniture_config_ptr = v16;
        if ( v16 )
        {
          count_0 = ItemStore::getItemCount(&this->pack_store_, *(_DWORD *)(v4 + 48));
          if ( count_0 || !is_furniture_ge_limit )
          {
            if ( *(_BYTE *)(((unsigned __int64)&furniture_config_ptr->stack_limit >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)furniture_config_ptr - 108) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&furniture_config_ptr->stack_limit >> 3)
                                                                                   + 0x7FFF8000) )
            {
              __asan_report_load4(&furniture_config_ptr->stack_limit);
            }
            if ( count_0 >= furniture_config_ptr->stack_limit )
LABEL_28:
              std::set<unsigned int>::insert(
                (std::set<unsigned int> *const)(v4 + 64),
                (const std::set<unsigned int>::value_type *)(v4 + 48));
          }
          else
          {
            val = 6;
            std::set<unsigned int>::insert((std::set<unsigned int> *const)(v4 + 144), &val);
          }
LABEL_48:
          __gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int>>::operator++(&__for_begin);
          continue;
        }
        common::milog::MiLogStream::create(
          &v47,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkFrontLooseAddItemBatch",
          7064);
        v14 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
                &v47,
                (const char (*)[34])"dynamic_pointer_cast failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
LABEL_35:
        val = Player::getUid(this->player_);
        v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &val);
        v18 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v17, (const char (*)[10])" item_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, (const unsigned int *)(v4 + 48));
        common::milog::MiLogStream::~MiLogStream(&v47);
        v19 = -1;
LABEL_58:
        std::set<unsigned int>::~set((std::set<unsigned int> *const)(v4 + 144));
        std::set<unsigned int>::~set((std::set<unsigned int> *const)(v4 + 64));
        result = v19;
        if ( v48 == (char *)v4 )
        {
          *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF800C) = 0LL;
          *(_DWORD *)((v4 >> 3) + 0x7FFF8018) = 0;
        }
        else
        {
          *(_QWORD *)v4 = 1172321806LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
          *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
          *(_DWORD *)((v4 >> 3) + 0x7FFF8018) = -168430091;
        }
        return result;
      default:
        common::milog::MiLogStream::create(
          &v47,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkFrontLooseAddItemBatch",
          7106);
        v20 = common::milog::MiLogStream::operator<<<char [32],(char *[32])0>(
                &v47,
                (const char (*)[32])"unsupported item type, item_id:");
        v21 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v20,
                (const unsigned int *)(v4 + 48));
        v22 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v21, (const char (*)[12])" item_type:");
        common::milog::MiLogStream::operator<<<data::ItemType,(data::ItemType*)0>(v22, &item_config_ptr->item_type);
        common::milog::MiLogStream::~MiLogStream(&v47);
        v19 = -1;
        goto LABEL_58;
    }
  }
};

// Line 7129: range 0000000017CFC3F0-0000000017CFC7EE
__int64 __fastcall PlayerItemComp::checkFrontLooseGrantDropItems(
        PlayerItemComp *const this,
        uint32_t drop_id,
        uint32_t drop_count,
        const ActionReason *reason,
        FrontLooseCheckResult *check_result_ptr)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rbx
  unsigned int v11; // r14d
  std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::vector<data::IdCountConfig> >,false,false>::pointer v12; // rax
  std::vector<unsigned int>::size_type v13; // rax
  __int64 result; // rax
  unsigned int val; // [rsp+24h] [rbp-12Ch] BYREF
  std::vector<data::IdCountConfig>::const_iterator __for_begin; // [rsp+28h] [rbp-128h] BYREF
  std::vector<data::IdCountConfig>::const_iterator __for_end; // [rsp+30h] [rbp-120h] BYREF
  const std::unordered_map<unsigned int,std::vector<data::IdCountConfig>> *max_drop_item_map; // [rsp+38h] [rbp-118h]
  const std::vector<data::IdCountConfig> *__for_range; // [rsp+40h] [rbp-110h]
  const data::IdCountConfig *id_count_config; // [rsp+48h] [rbp-108h]
  std::shared_ptr<Config> v23; // [rsp+50h] [rbp-100h] BYREF
  common::milog::MiLogStream v24; // [rsp+60h] [rbp-F0h] BYREF
  char v25[208]; // [rsp+80h] [rbp-D0h] BYREF

  v5 = (unsigned __int64)v25;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(160LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "3 48 4 12 drop_id:7128 64 8 9 iter:7131 96 24 16 item_id_vec:7137";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::checkFrontLooseGrantDropItems;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556943;
  v7[536862722] = -218959360;
  v7[536862723] = -218103808;
  v7[536862724] = -202116109;
  *(_DWORD *)(v5 + 48) = drop_id;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v23);
  max_drop_item_map = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v23)->design_config.txt_config_mgr.drop_config_mgr.max_drop_item_map;
  std::shared_ptr<Config>::~shared_ptr(&v23);
  *(std::unordered_map<unsigned int,std::vector<data::IdCountConfig>>::const_iterator *)(v5 + 64) = std::unordered_map<unsigned int,std::vector<data::IdCountConfig>>::find(max_drop_item_map, (const std::unordered_map<unsigned int,std::vector<data::IdCountConfig>>::key_type *)(v5 + 48));
  __for_end._M_current = (const data::IdCountConfig *)std::unordered_map<unsigned int,std::vector<data::IdCountConfig>>::end(max_drop_item_map)._M_cur;
  if ( std::__detail::operator==<std::pair<unsigned int const,std::vector<data::IdCountConfig>>,false>(
         (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,std::vector<data::IdCountConfig> >,false> *)(v5 + 64),
         (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,std::vector<data::IdCountConfig> >,false> *)&__for_end) )
  {
    common::milog::MiLogStream::create(
      &v24,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkFrontLooseGrantDropItems",
      7134);
    v8 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(&v24, (const char (*)[17])"invalid drop_id:");
    v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, (const unsigned int *)(v5 + 48));
    v10 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v9, (const char (*)[6])" uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, &val);
    common::milog::MiLogStream::~MiLogStream(&v24);
    v11 = 5;
  }
  else
  {
    std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v5 + 96));
    v12 = std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::vector<data::IdCountConfig>>,false,false>::operator->((const std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::vector<data::IdCountConfig> >,false,false> *const)(v5 + 64));
    v13 = std::vector<data::IdCountConfig>::size(&v12->second);
    std::vector<unsigned int>::reserve((std::vector<unsigned int> *const)(v5 + 96), v13);
    __for_range = &std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::vector<data::IdCountConfig>>,false,false>::operator->((const std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::vector<data::IdCountConfig> >,false,false> *const)(v5 + 64))->second;
    __for_begin._M_current = std::vector<data::IdCountConfig>::begin(__for_range)._M_current;
    __for_end._M_current = std::vector<data::IdCountConfig>::end(__for_range)._M_current;
    while ( __gnu_cxx::operator!=<data::IdCountConfig const*,std::vector<data::IdCountConfig>>(&__for_begin, &__for_end) )
    {
      id_count_config = __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator*(&__for_begin);
      std::vector<unsigned int>::push_back((std::vector<unsigned int> *const)(v5 + 96), &id_count_config->id);
      __gnu_cxx::__normal_iterator<data::IdCountConfig const*,std::vector<data::IdCountConfig>>::operator++(&__for_begin);
    }
    v11 = PlayerItemComp::checkFrontLooseAddItemBatch(
            this,
            (const std::vector<unsigned int> *)(v5 + 96),
            reason,
            check_result_ptr);
    std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v5 + 96));
  }
  result = v11;
  if ( v25 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 7148: range 0000000017CFC7F0-0000000017CFCBD3
int32_t __cdecl PlayerItemComp::checkFrontLooseGrantRewards(
        PlayerItemComp *const this,
        const std::vector<unsigned int> *reward_id_vec,
        const ActionReason *reason,
        FrontLooseCheckResult *check_result_ptr)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  RewardExcelConfigMgr *p_reward_config_mgr; // rcx
  common::milog::MiLogStream *v8; // rdx
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rcx
  int32_t v11; // r14d
  std::vector<unsigned int>::size_type v12; // rax
  int32_t result; // eax
  std::vector<unsigned int>::value_type __x; // [rsp+28h] [rbp-128h] BYREF
  int32_t ret; // [rsp+2Ch] [rbp-124h]
  std::vector<proto::ItemParamBin>::iterator __for_begin; // [rsp+30h] [rbp-120h] BYREF
  std::vector<proto::ItemParamBin>::iterator __for_end; // [rsp+38h] [rbp-118h] BYREF
  std::vector<proto::ItemParamBin> *__for_range; // [rsp+40h] [rbp-110h]
  const proto::ItemParamBin *item_param_bin; // [rsp+48h] [rbp-108h]
  std::shared_ptr<Config> v22; // [rsp+50h] [rbp-100h] BYREF
  common::milog::MiLogStream v23; // [rsp+60h] [rbp-F0h] BYREF
  char v24[208]; // [rsp+80h] [rbp-D0h] BYREF

  v4 = (unsigned __int64)v24;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(160LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "2 32 24 23 item_param_bin_vec:7149 96 24 16 item_id_vec:7156";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkFrontLooseGrantRewards;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234881024;
  v6[536862722] = -218959118;
  v6[536862723] = -218103808;
  v6[536862724] = -202116109;
  std::vector<proto::ItemParamBin>::vector((std::vector<proto::ItemParamBin> *const)(v4 + 32));
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v22);
  p_reward_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v22)->design_config.txt_config_mgr.reward_config_mgr;
  ret = RewardExcelConfigMgr::getItemParamsByRewardIds(
          p_reward_config_mgr,
          reward_id_vec,
          (std::vector<proto::ItemParamBin> *)(v4 + 32));
  std::shared_ptr<Config>::~shared_ptr(&v22);
  if ( ret )
  {
    common::milog::MiLogStream::create(
      &v23,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkFrontLooseGrantRewards",
      7153);
    v8 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
           &v23,
           (const char (*)[46])"getItemParamsByRewardIds fail, reward_id_vec:");
    v9 = common::milog::MiLogStream::operator<<<unsigned int>(v8, reward_id_vec);
    v10 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v9, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v10, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v23);
    v11 = ret;
  }
  else
  {
    std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v4 + 96));
    v12 = std::vector<proto::ItemParamBin>::size((const std::vector<proto::ItemParamBin> *const)(v4 + 32));
    std::vector<unsigned int>::reserve((std::vector<unsigned int> *const)(v4 + 96), v12);
    __for_range = (std::vector<proto::ItemParamBin> *)(v4 + 32);
    __for_begin._M_current = std::vector<proto::ItemParamBin>::begin((std::vector<proto::ItemParamBin> *const)(v4 + 32))._M_current;
    __for_end._M_current = std::vector<proto::ItemParamBin>::end((std::vector<proto::ItemParamBin> *const)(v4 + 32))._M_current;
    while ( __gnu_cxx::operator!=<proto::ItemParamBin *,std::vector<proto::ItemParamBin>>(&__for_begin, &__for_end) )
    {
      item_param_bin = __gnu_cxx::__normal_iterator<proto::ItemParamBin *,std::vector<proto::ItemParamBin>>::operator*(&__for_begin);
      __x = proto::ItemParamBin::item_id(item_param_bin);
      std::vector<unsigned int>::push_back((std::vector<unsigned int> *const)(v4 + 96), &__x);
      __gnu_cxx::__normal_iterator<proto::ItemParamBin *,std::vector<proto::ItemParamBin>>::operator++(&__for_begin);
    }
    v11 = PlayerItemComp::checkFrontLooseAddItemBatch(
            this,
            (const std::vector<unsigned int> *)(v4 + 96),
            reason,
            check_result_ptr);
    std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v4 + 96));
  }
  std::vector<proto::ItemParamBin>::~vector((std::vector<proto::ItemParamBin> *const)(v4 + 32));
  result = v11;
  if ( v24 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 7167: range 0000000017CFCBD4-0000000017CFCF13
void __cdecl PlayerItemComp::processByAddItemResultVec(
        PlayerItemComp *const this,
        const std::vector<AddItemResult> *rlt_vec)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r13
  common::milog::MiLogStream *v5; // rax
  common::milog::MiLogStream *v6; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  unsigned __int64 v8; // rdx
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  uint32_t ItemId; // edx
  std::vector<AddItemResult>::const_iterator __for_begin; // [rsp+10h] [rbp-B0h] BYREF
  std::vector<AddItemResult>::const_iterator __for_end; // [rsp+18h] [rbp-A8h] BYREF
  const std::vector<AddItemResult> *__for_range; // [rsp+20h] [rbp-A0h]
  const AddItemResult *rlt; // [rsp+28h] [rbp-98h]
  common::milog::MiLogStream v15; // [rsp+30h] [rbp-90h] BYREF
  char v16[112]; // [rsp+50h] [rbp-70h] BYREF

  v2 = (unsigned __int64)v16;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 16 13 item_ptr:7172";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::processByAddItemResultVec;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202178560;
  __for_range = rlt_vec;
  __for_begin._M_current = std::vector<AddItemResult>::begin(rlt_vec)._M_current;
  __for_end._M_current = std::vector<AddItemResult>::end(rlt_vec)._M_current;
  while ( __gnu_cxx::operator!=<AddItemResult const*,std::vector<AddItemResult>>(&__for_begin, &__for_end) )
  {
    rlt = __gnu_cxx::__normal_iterator<AddItemResult const*,std::vector<AddItemResult>>::operator*(&__for_begin);
    if ( *(_BYTE *)(((unsigned __int64)rlt >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    if ( rlt->guid )
    {
      if ( *(_BYTE *)(((unsigned __int64)rlt >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      PlayerItemComp::findItemInPack((PlayerItemComp *const)(v2 + 32), (uint64_t)this);
      if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v2 + 32), 0LL) )
      {
        common::milog::MiLogStream::create(
          &v15,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "processByAddItemResultVec",
          7175);
        v5 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(&v15, (const char (*)[8])byte_26396740);
        v6 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v5, &rlt->guid);
        common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(v6, (const char (*)[43])byte_26396780);
        common::milog::MiLogStream::~MiLogStream(&v15);
      }
      else
      {
        v7 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 32));
        if ( *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v8 = (unsigned __int64)(v7->_vptr_Item + 9);
        if ( *(_BYTE *)((v8 >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        if ( (*(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v8)(v7) == 3 )
        {
          v9 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 32));
          ItemId = Item::getItemId(v9);
          PlayerItemComp::recordReliquarySuit(this, ItemId);
        }
      }
      std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v2 + 32));
    }
    __gnu_cxx::__normal_iterator<AddItemResult const*,std::vector<AddItemResult>>::operator++(&__for_begin);
  }
  if ( v16 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 7192: range 0000000017CFCF14-0000000017CFD1C5
void __fastcall PlayerItemComp::recordReliquarySuit(PlayerItemComp *const this, uint32_t reliquary_id)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  std::set<data::EquipType> *v9; // rax
  const data::ReliquaryExcelConfig *reliquary_conf_ptr; // [rsp+10h] [rbp-A0h]
  std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int> >,std::equal_to<std::pair<unsigned int,unsigned int> >,std::allocator<std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> > > >::key_type __k; // [rsp+18h] [rbp-98h] BYREF
  std::shared_ptr<Config> v12; // [rsp+20h] [rbp-90h] BYREF
  common::milog::MiLogStream v13; // [rsp+30h] [rbp-80h] BYREF
  char v14[96]; // [rsp+50h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v14;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 17 reliquary_id:7191";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::recordReliquarySuit;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = reliquary_id;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v12);
  v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v12);
  reliquary_conf_ptr = data::ReliquaryExcelConfigMgrBase::findReliquaryExcelConfig(
                         &v5->design_config.txt_config_mgr.reliquary_config_mgr,
                         *(_DWORD *)(v2 + 32));
  std::shared_ptr<Config>::~shared_ptr(&v12);
  if ( reliquary_conf_ptr )
  {
    if ( *(_BYTE *)(((unsigned __int64)&reliquary_conf_ptr->equip_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reliquary_conf_ptr + 76) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reliquary_conf_ptr->equip_type >> 3)
                                                                        + 0x7FFF8000) )
    {
      __asan_report_load4(&reliquary_conf_ptr->equip_type);
    }
    if ( (unsigned int)(reliquary_conf_ptr->equip_type - 1) <= 4 )
    {
      __k = std::make_pair<unsigned int const&,unsigned int const&>(
              &reliquary_conf_ptr->set_id,
              &reliquary_conf_ptr->rank_level);
      v9 = std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int>>,std::equal_to<std::pair<unsigned int,unsigned int>>,std::allocator<std::pair<std::pair<unsigned int,unsigned int> const,std::set<data::EquipType>>>>::operator[](
             &this->reliquary_set_map_,
             &__k);
      std::set<data::EquipType>::insert(v9, &reliquary_conf_ptr->equip_type);
    }
    else
    {
      common::milog::MiLogStream::create(
        &v13,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "recordReliquarySuit",
        7205);
      v6 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(&v13, (const char (*)[40])byte_26396840);
      v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, (const unsigned int *)(v2 + 32));
      v8 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(v7, (const char (*)[38])byte_263968A0);
      common::milog::MiLogStream::operator<<<data::EquipType,(data::EquipType*)0>(v8, &reliquary_conf_ptr->equip_type);
      common::milog::MiLogStream::~MiLogStream(&v13);
    }
  }
  if ( v14 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 7213: range 0000000017CFD1C6-0000000017CFEBB1
__int64 __fastcall PlayerItemComp::checkWeaponUpgradeAndReturnItems(
        PlayerItemComp *const this,
        uint64_t target_guid,
        const std::vector<long unsigned int> *food_weapon_guid_vec,
        const std::vector<ItemParam> *item_param_vec,
        std::vector<ItemParam> *ret_item_param_vec)
{
  unsigned int v5; // r13d
  unsigned __int64 v6; // r14
  __int64 v7; // rax
  _DWORD *v8; // r12
  PlayerBasicComp *BasicComp; // rax
  common::milog::MiLogStream *v10; // r13
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v11; // rax
  uint32_t Level; // r15d
  Weapon *v13; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  __gnu_cxx::__normal_iterator<long unsigned int const*,std::vector<long unsigned int> >::reference v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // r13
  common::milog::MiLogStream *v21; // r13
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // r13
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  int v27; // r15d
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v28; // rax
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v29; // rax
  common::milog::MiLogStream *v30; // r13
  common::milog::MiLogStream *v31; // rax
  common::milog::MiLogStream *v32; // rax
  uint32_t *p_count; // rax
  common::milog::MiLogStream *v34; // r13
  MaterialExcelConfigMgr *p_material_config_mgr; // rcx
  common::milog::MiLogStream *v36; // r13
  common::milog::MiLogStream *v37; // rax
  common::milog::MiLogStream *v38; // rax
  std::vector<data::ItemUseConfig>::const_reference v39; // rax
  common::milog::MiLogStream *v40; // rax
  common::milog::MiLogStream *v41; // rax
  common::milog::MiLogStream *v42; // r13
  common::milog::MiLogStream *v43; // rax
  common::milog::MiLogStream *v44; // rax
  common::milog::MiLogStream *v45; // rax
  common::milog::MiLogStream *v46; // rax
  common::milog::MiLogStream *v47; // rcx
  Weapon *v48; // rax
  common::milog::MiLogStream *v49; // r13
  common::milog::MiLogStream *v50; // rax
  common::milog::MiLogStream *v51; // rax
  __int64 result; // rax
  unsigned int val; // [rsp+3Ch] [rbp-1E4h] BYREF
  std::vector<long unsigned int>::const_iterator __for_begin; // [rsp+40h] [rbp-1E0h] BYREF
  std::vector<long unsigned int>::const_iterator __for_end; // [rsp+48h] [rbp-1D8h] BYREF
  const std::vector<long unsigned int> *__for_range; // [rsp+50h] [rbp-1D0h]
  const std::vector<ItemParam> *__for_range_0; // [rsp+58h] [rbp-1C8h]
  const ItemParam *item_param; // [rsp+60h] [rbp-1C0h]
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+68h] [rbp-1B8h]
  common::milog::MiLogStream v63; // [rsp+70h] [rbp-1B0h] BYREF
  common::milog::MiLogStream v64; // [rsp+90h] [rbp-190h] BYREF
  char v65[368]; // [rsp+B0h] [rbp-170h] BYREF

  v6 = (unsigned __int64)v65;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v7 = __asan_stack_malloc_3(320LL);
    if ( v7 )
      v6 = v7;
  }
  *(_QWORD *)v6 = 1102416563LL;
  *(_QWORD *)(v6 + 8) = "9 48 4 8 ret:7316 64 4 12 add_exp:7343 80 4 15 scoin_need:7344 96 4 14 extra_exp:7345 112 8 21 f"
                        "ood_weapon_guid:7245 144 8 16 target_guid:7212 176 16 15 weapon_ptr:7222 208 16 20 food_weapon_p"
                        "tr:7260 240 48 25 food_weapon_guid_set:7244";
  *(_QWORD *)(v6 + 16) = PlayerItemComp::checkWeaponUpgradeAndReturnItems;
  v8 = (_DWORD *)(v6 >> 3);
  v8[536862720] = -235802127;
  v8[536862721] = -234556943;
  v8[536862722] = -234556924;
  v8[536862723] = 61956;
  v8[536862723] = -234881024;
  v8[536862724] = 62194;
  v8[536862724] = -234881024;
  v8[536862725] = 62194;
  v8[536862726] = 62194;
  v8[536862727] = 62194;
  v8[536862729] = -202116109;
  *(_QWORD *)(v6 + 144) = target_guid;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  if ( !PlayerBasicComp::isStateOpen(BasicComp, 0xAu) )
  {
    common::milog::MiLogStream::create(
      &v64,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponUpgradeAndReturnItems",
      7217);
    common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
      &v64,
      (const char (*)[36])"OPEN_STATE_WEAPON_UPGRADE is locked");
    common::milog::MiLogStream::~MiLogStream(&v64);
    v5 = 141;
    goto LABEL_108;
  }
  ItemStore::findItem<Weapon>((ItemStore *const)(v6 + 176), (uint64_t)&this->pack_store_, *(_QWORD *)(v6 + 144));
  if ( std::operator==<Weapon>((const std::shared_ptr<Weapon> *)(v6 + 176), 0LL) )
  {
    common::milog::MiLogStream::create(
      &v64,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponUpgradeAndReturnItems",
      7225);
    v10 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
            &v64,
            (const char (*)[22])"findItem failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
LABEL_23:
    val = Player::getUid(this->player_);
    v15 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, &val);
    v16 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v15, (const char (*)[14])" target_guid:");
    common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v16, (const unsigned __int64 *)(v6 + 144));
    common::milog::MiLogStream::~MiLogStream(&v64);
    v5 = -1;
    goto LABEL_107;
  }
  v11 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v6 + 176));
  Level = Weapon::getLevel(v11);
  v13 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v6 + 176));
  if ( Level >= Weapon::getMaxLevel(v13) )
  {
    common::milog::MiLogStream::create(
      &v64,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponUpgradeAndReturnItems",
      7232);
    v10 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
            &v64,
            (const char (*)[29])"Weapon reach max_level, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    goto LABEL_23;
  }
  if ( std::vector<unsigned long>::empty(food_weapon_guid_vec) && std::vector<ItemParam>::empty(item_param_vec) )
  {
    common::milog::MiLogStream::create(
      &v64,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponUpgradeAndReturnItems",
      7239);
    v10 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
            &v64,
            (const char (*)[46])"food_weapon and item_param_vec is empty, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    goto LABEL_23;
  }
  std::set<unsigned long>::set((std::set<long unsigned int> *const)(v6 + 240));
  __for_range = food_weapon_guid_vec;
  __for_begin._M_current = std::vector<unsigned long>::begin(food_weapon_guid_vec)._M_current;
  __for_end._M_current = std::vector<unsigned long>::end(food_weapon_guid_vec)._M_current;
  while ( __gnu_cxx::operator!=<unsigned long const*,std::vector<unsigned long>>(&__for_begin, &__for_end) )
  {
    v17 = __gnu_cxx::__normal_iterator<unsigned long const*,std::vector<unsigned long>>::operator*(&__for_begin);
    if ( *(_BYTE *)(((unsigned __int64)v17 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    *(_QWORD *)(v6 + 112) = *v17;
    if ( *(_QWORD *)(v6 + 112) == *(_QWORD *)(v6 + 144) )
    {
      common::milog::MiLogStream::create(
        &v63,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7250);
      v18 = common::milog::MiLogStream::operator<<<char [59],(char *[59])0>(
              &v63,
              (const char (*)[59])"require anti-cheat check, food_weapon_guid == target_guid:");
      v19 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
              v18,
              (const unsigned __int64 *)(v6 + 144));
      v20 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v19, (const char (*)[7])", uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &val);
      common::milog::MiLogStream::~MiLogStream(&v63);
      v5 = -1;
      goto LABEL_106;
    }
    if ( std::set<unsigned long>::count(
           (const std::set<long unsigned int> *const)(v6 + 240),
           (const std::set<long unsigned int>::key_type *)(v6 + 112)) )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7255);
      v21 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
              &v64,
              (const char (*)[28])"duplicate food_weapon, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v22 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, &val);
      v23 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(
              v22,
              (const char (*)[19])" food_weapon_guid:");
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
        v23,
        (const unsigned __int64 *)(v6 + 112));
      common::milog::MiLogStream::~MiLogStream(&v64);
      v5 = -1;
      goto LABEL_106;
    }
    ItemStore::findItem<Weapon>((ItemStore *const)(v6 + 208), (uint64_t)&this->pack_store_, *(_QWORD *)(v6 + 112));
    if ( std::operator==<Weapon>((const std::shared_ptr<Weapon> *)(v6 + 208), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7263);
      v24 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
              &v64,
              (const char (*)[22])"findItem failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
LABEL_39:
      val = Player::getUid(this->player_);
      v25 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, &val);
      v26 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(
              v25,
              (const char (*)[19])" food_weapon_guid:");
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
        v26,
        (const unsigned __int64 *)(v6 + 112));
      common::milog::MiLogStream::~MiLogStream(&v64);
      v5 = -1;
      v27 = 0;
      goto LABEL_49;
    }
    v28 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v6 + 208));
    if ( !Weapon::isCanFood(v28) )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7268);
      v24 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
              &v64,
              (const char (*)[38])"food_weapon can not food others, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_39;
    }
    v29 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v6 + 208));
    if ( Equip::getIsLocked((const Equip *const)v29) )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7273);
      v30 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
              &v64,
              (const char (*)[36])"food_weapon can not be locked, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v31 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v30, &val);
      v32 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(
              v31,
              (const char (*)[19])" food_weapon_guid:");
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
        v32,
        (const unsigned __int64 *)(v6 + 112));
      common::milog::MiLogStream::~MiLogStream(&v64);
      v5 = 691;
      v27 = 0;
    }
    else
    {
      std::set<unsigned long>::insert(
        (std::set<long unsigned int> *const)(v6 + 240),
        (const std::set<long unsigned int>::value_type *)(v6 + 112));
      v27 = 1;
    }
LABEL_49:
    std::shared_ptr<Weapon>::~shared_ptr((std::shared_ptr<Weapon> *const)(v6 + 208));
    if ( v27 != 1 )
      goto LABEL_106;
    __gnu_cxx::__normal_iterator<unsigned long const*,std::vector<unsigned long>>::operator++(&__for_begin);
  }
  __for_range_0 = item_param_vec;
  __for_begin._M_current = (const unsigned __int64 *)std::vector<ItemParam>::begin(item_param_vec)._M_current;
  __for_end._M_current = (const unsigned __int64 *)std::vector<ItemParam>::end(__for_range_0)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(
            (const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *)&__for_begin,
            (const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *)&__for_end) )
  {
    item_param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*((const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *const)&__for_begin);
    p_count = &item_param->count;
    if ( *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)p_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(p_count);
    }
    if ( !item_param->count )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7285);
      v34 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
              &v64,
              (const char (*)[28])"item_param count is 0, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
LABEL_80:
      val = Player::getUid(this->player_);
      v40 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v34, &val);
      v41 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v40, (const char (*)[10])" item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v41, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v64);
      v5 = -1;
      goto LABEL_106;
    }
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v6 + 208));
    p_material_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v6 + 208))->design_config.txt_config_mgr.material_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_param);
    }
    material_config_ptr = data::MaterialExcelConfigMgrBase::findMaterialExcelConfig(
                            p_material_config_mgr,
                            item_param->item_id);
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v6 + 208));
    if ( !material_config_ptr )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7292);
      v36 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
              &v64,
              (const char (*)[37])"findMaterialExcelConfig failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v37 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v36, &val);
      v38 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v37, (const char (*)[14])" material_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v38, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v64);
      v5 = -1;
      goto LABEL_106;
    }
    if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->material_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)material_config_ptr + 76) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->material_type >> 3)
                                                                         + 0x7FFF8000) )
    {
      __asan_report_load4(&material_config_ptr->material_type);
    }
    if ( material_config_ptr->material_type != MATERIAL_WEAPON_EXP_STONE )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7298);
      v34 = common::milog::MiLogStream::operator<<<char [52],(char *[52])0>(
              &v64,
              (const char (*)[52])"MaterialType is not MATERIAL_WEAPON_EXP_STONE, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_80;
    }
    if ( std::vector<data::ItemUseConfig>::size(&material_config_ptr->item_use) != 1 )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7304);
      v34 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
              &v64,
              (const char (*)[39])"Material UseConfig is not size 1, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_80;
    }
    v39 = std::vector<data::ItemUseConfig>::operator[](&material_config_ptr->item_use, 0LL);
    if ( *(_BYTE *)(((unsigned __int64)&v39->use_op >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&v39->use_op >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&v39->use_op);
    }
    if ( v39->use_op != ITEM_USE_ADD_WEAPON_EXP )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7310);
      v34 = common::milog::MiLogStream::operator<<<char [63],(char *[63])0>(
              &v64,
              (const char (*)[63])"Material UseConfig use_op is not ITEM_USE_ADD_WEAPON_EXP, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_80;
    }
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++((__gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *const)&__for_begin);
  }
  *(_DWORD *)(v6 + 48) = -1;
  if ( !std::vector<unsigned long>::empty(food_weapon_guid_vec) )
  {
    *(_DWORD *)(v6 + 48) = PlayerItemComp::checkSubItemBatch(this, food_weapon_guid_vec);
    if ( *(_DWORD *)(v6 + 48) )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7322);
      v42 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
              &v64,
              (const char (*)[26])"checkConsume failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
LABEL_86:
      val = Player::getUid(this->player_);
      v43 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v42, &val);
      v44 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v43, (const char (*)[14])" target_guid:");
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
        v44,
        (const unsigned __int64 *)(v6 + 144));
      common::milog::MiLogStream::~MiLogStream(&v64);
      v5 = *(_DWORD *)(v6 + 48);
      goto LABEL_106;
    }
  }
  if ( !std::vector<ItemParam>::empty(item_param_vec) )
  {
    *(_DWORD *)(v6 + 48) = PlayerItemComp::checkSubItemBatch(this, item_param_vec);
    if ( *(_DWORD *)(v6 + 48) )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7332);
      v42 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
              &v64,
              (const char (*)[26])"checkConsume failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_86;
    }
  }
  if ( *(_DWORD *)(v6 + 48) )
  {
    common::milog::MiLogStream::create(
      &v64,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponUpgradeAndReturnItems",
      7339);
    v45 = common::milog::MiLogStream::operator<<<char [5],(char *[5])0>(&v64, (const char (*)[5])"ret:");
    v46 = common::milog::MiLogStream::operator<<<int,(int *)0>(v45, (const int *)(v6 + 48));
    v47 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v46, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v47, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v64);
  }
  *(_DWORD *)(v6 + 64) = 0;
  *(_DWORD *)(v6 + 80) = 0;
  *(_DWORD *)(v6 + 96) = 0;
  v48 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v6 + 176));
  if ( PlayerItemComp::getWeaponUpgradeExp(
         this,
         v48,
         food_weapon_guid_vec,
         item_param_vec,
         (uint32_t *)(v6 + 64),
         (uint32_t *)(v6 + 96),
         (uint32_t *)(v6 + 80)) )
  {
    common::milog::MiLogStream::create(
      &v64,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponUpgradeAndReturnItems",
      7348);
    v49 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
            &v64,
            (const char (*)[33])"getWeaponUpgradeExp failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v49, &val);
    common::milog::MiLogStream::~MiLogStream(&v64);
    v5 = -1;
  }
  else
  {
    *(_DWORD *)(v6 + 48) = PlayerItemComp::checkSubScoin(this, *(_DWORD *)(v6 + 80));
    if ( *(_DWORD *)(v6 + 48) )
    {
      common::milog::MiLogStream::create(
        &v64,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponUpgradeAndReturnItems",
        7355);
      v50 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
              &v64,
              (const char (*)[33])"scoin is not enough. scoin_need:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v50, (const unsigned int *)(v6 + 80));
      common::milog::MiLogStream::~MiLogStream(&v64);
      v5 = *(_DWORD *)(v6 + 48);
    }
    else
    {
      *(_DWORD *)(v6 + 48) = PlayerItemComp::checkGrantWeaponUpgradeReturnItems(
                               this,
                               *(_DWORD *)(v6 + 96),
                               ret_item_param_vec);
      if ( !*(_DWORD *)(v6 + 48) || *(_DWORD *)(v6 + 48) == 617 )
      {
        v5 = *(_DWORD *)(v6 + 48);
      }
      else
      {
        common::milog::MiLogStream::create(
          &v64,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkWeaponUpgradeAndReturnItems",
          7363);
        v51 = common::milog::MiLogStream::operator<<<char [52],(char *[52])0>(
                &v64,
                (const char (*)[52])"checkGrantWeaponUpgradeReturnItems failed, retcode:");
        common::milog::MiLogStream::operator<<<int,(int *)0>(v51, (const int *)(v6 + 48));
        common::milog::MiLogStream::~MiLogStream(&v64);
        v5 = *(_DWORD *)(v6 + 48);
      }
    }
  }
LABEL_106:
  std::set<unsigned long>::~set((std::set<long unsigned int> *const)(v6 + 240));
LABEL_107:
  std::shared_ptr<Weapon>::~shared_ptr((std::shared_ptr<Weapon> *const)(v6 + 176));
LABEL_108:
  result = v5;
  if ( v65 == (char *)v6 )
  {
    *(_QWORD *)((v6 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v6 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v6 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v6 >> 3) + 0x7FFF8018) = 0LL;
    *(_DWORD *)((v6 >> 3) + 0x7FFF8024) = 0;
  }
  else
  {
    *(_QWORD *)v6 = 1172321806LL;
    *(_QWORD *)((v6 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v6 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v6 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v6 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v6 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 7370: range 0000000017CFEBB2-0000000017CFF568
__int64 __fastcall PlayerItemComp::weaponUpgrade(
        PlayerItemComp *const this,
        uint64_t target_guid,
        const std::vector<long unsigned int> *food_weapon_guid_vec,
        const std::vector<ItemParam> *item_param_vec,
        std::vector<ItemParam> *ret_item_param_vec)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  PlayerBasicComp *BasicComp; // rax
  common::milog::MiLogStream *v9; // r14
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  unsigned int v12; // r14d
  Weapon *v13; // rax
  common::milog::MiLogStream *v14; // r14
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // r14
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  Weapon *v19; // rax
  common::milog::MiLogStream *v20; // r14
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  __int64 result; // rax
  std::string v24; // [rsp+0h] [rbp-170h]
  std::vector<ItemParam> *ret_item_param_veca; // [rsp+8h] [rbp-168h]
  const std::vector<ItemParam> *item_param_veca; // [rsp+10h] [rbp-160h]
  const std::vector<long unsigned int> *food_weapon_guid_veca; // [rsp+18h] [rbp-158h]
  unsigned int val; // [rsp+3Ch] [rbp-134h] BYREF
  std::string v29; // [rsp+40h] [rbp-130h] BYREF
  char v30[272]; // [rsp+60h] [rbp-110h] BYREF

  *(&v24._anon_0._M_allocated_capacity + 1) = (std::string::size_type)food_weapon_guid_vec;
  v24._anon_0._M_allocated_capacity = (std::string::size_type)item_param_vec;
  v24._M_string_length = (std::string::size_type)ret_item_param_vec;
  v5 = (unsigned __int64)v30;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(224LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "8 32 1 10 holer:7371 48 4 12 add_exp:7382 64 4 15 scoin_need:7383 80 4 14 extra_exp:7384 96 8 16"
                        " target_guid:7369 128 8 11 reason:7391 160 16 15 weapon_ptr:7374 192 16 15 item_param:7392";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::weaponUpgrade;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556927;
  v7[536862722] = -234556924;
  v7[536862723] = -218959360;
  v7[536862724] = -218959360;
  v7[536862725] = -219021312;
  v7[536862726] = -202178560;
  *(_QWORD *)(v5 + 96) = target_guid;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&v29, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 32), 0x6B4u, v24);
  std::string::~string(&v29);
  ItemStore::findItem<Weapon>((ItemStore *const)(v5 + 160), (uint64_t)&this->pack_store_, *(_QWORD *)(v5 + 96));
  if ( std::operator==<Weapon>((const std::shared_ptr<Weapon> *)(v5 + 160), 0LL) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v29,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "weaponUpgrade",
      7377);
    v9 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
           (common::milog::MiLogStream *const)&v29,
           (const char (*)[22])"findItem failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &val);
    v11 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v10, (const char (*)[14])" target_guid:");
    common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v11, (const unsigned __int64 *)(v5 + 96));
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v29);
    v12 = -1;
    goto LABEL_33;
  }
  *(_DWORD *)(v5 + 48) = 0;
  *(_DWORD *)(v5 + 64) = 0;
  *(_DWORD *)(v5 + 80) = 0;
  v13 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 160));
  if ( PlayerItemComp::getWeaponUpgradeExp(
         this,
         v13,
         food_weapon_guid_veca,
         item_param_veca,
         (uint32_t *)(v5 + 48),
         (uint32_t *)(v5 + 80),
         (uint32_t *)(v5 + 64)) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v29,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "weaponUpgrade",
      7387);
    v14 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
            (common::milog::MiLogStream *const)&v29,
            (const char (*)[33])"getWeaponUpgradeExp failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
LABEL_23:
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &val);
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v29);
    v12 = -1;
    goto LABEL_33;
  }
  SubItemReason::SubItemReason((SubItemReason *const)(v5 + 128), ACTION_REASON_WEAPON_UPGRADE);
  *(_QWORD *)(v5 + 192) = 0LL;
  *(_QWORD *)(v5 + 200) = 0LL;
  *(_DWORD *)(v5 + 192) = 202;
  *(_DWORD *)(v5 + 196) = *(_DWORD *)(v5 + 64);
  if ( PlayerItemComp::subItem(this, (const ItemParam *)(v5 + 192), (const SubItemReason *)(v5 + 128)) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v29,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "weaponUpgrade",
      7395);
    v15 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
            (common::milog::MiLogStream *const)&v29,
            (const char (*)[33])"scoin is not enough. scoin_need:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, (const unsigned int *)(v5 + 64));
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v29);
    v12 = -1;
    goto LABEL_33;
  }
  if ( PlayerItemComp::subItemBatch(this, food_weapon_guid_veca, (const SubItemReason *)(v5 + 128)) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v29,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "weaponUpgrade",
      7402);
    v14 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
            (common::milog::MiLogStream *const)&v29,
            (const char (*)[21])"delItem failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    goto LABEL_23;
  }
  if ( PlayerItemComp::subItemBatch(this, item_param_veca, (const SubItemReason *)(v5 + 128)) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v29,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "weaponUpgrade",
      7408);
    v14 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
            (common::milog::MiLogStream *const)&v29,
            (const char (*)[21])"delItem failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    goto LABEL_23;
  }
  if ( PlayerItemComp::checkAndGrantWeaponUpgradeReturnItems(this, *(_DWORD *)(v5 + 80), ret_item_param_veca) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v29,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "weaponUpgrade",
      7415);
    v16 = common::milog::MiLogStream::operator<<<char [43],(char *[43])0>(
            (common::milog::MiLogStream *const)&v29,
            (const char (*)[43])"grantWeaponUpgradeReturnItems failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, &val);
    v18 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v17, (const char (*)[13])", extra_exp:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v18, (const unsigned int *)(v5 + 80));
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v29);
  }
  v19 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 160));
  if ( Weapon::addExp(v19, *(_DWORD *)(v5 + 48), 1) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v29,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "weaponUpgrade",
      7421);
    v20 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
            (common::milog::MiLogStream *const)&v29,
            (const char (*)[27])"weapon addExp failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v21 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &val);
    v22 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v21, (const char (*)[14])" weapon_guid:");
    common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v22, (const unsigned __int64 *)(v5 + 96));
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v29);
  }
  v12 = 0;
LABEL_33:
  std::shared_ptr<Weapon>::~shared_ptr((std::shared_ptr<Weapon> *const)(v5 + 160));
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 32));
  result = v12;
  if ( v30 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8018) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8018) = -168430091;
  }
  return result;
};

// Line 7429: range 0000000017CFF56A-0000000017D00898
int32_t __cdecl PlayerItemComp::getWeaponUpgradeExp(
        PlayerItemComp *const this,
        Weapon *weapon,
        const std::vector<long unsigned int> *food_weapon_guid_vec,
        const std::vector<ItemParam> *item_param_vec,
        uint32_t *total_exp,
        uint32_t *extra_exp,
        uint32_t *scoin_need)
{
  int32_t v7; // r14d
  unsigned __int64 v8; // r13
  __int64 v9; // rax
  _DWORD *v10; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v11; // rax
  __m128i v12; // xmm0
  PlayerActivityComp *ActivityComp; // r15
  uint32_t ItemId; // eax
  __gnu_cxx::__normal_iterator<long unsigned int const*,std::vector<long unsigned int> >::reference v15; // rax
  common::milog::MiLogStream *v16; // r14
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  int v19; // r15d
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v20; // rax
  common::milog::MiLogStream *v21; // r14
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v24; // rax
  Weapon *v25; // rax
  float TotalExp; // xmm0_4
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i v29; // xmm0
  const unsigned int *v30; // rax
  _DWORD *v31; // rdx
  uint32_t *p_count; // rax
  common::milog::MiLogStream *v33; // rbx
  common::milog::MiLogStream *v34; // rax
  common::milog::MiLogStream *v35; // rax
  MaterialExcelConfigMgr *p_material_config_mgr; // rcx
  bool v37; // r14
  common::milog::MiLogStream *v38; // rax
  common::milog::MiLogStream *v39; // rax
  common::milog::MiLogStream *v40; // rcx
  __m128i v41; // xmm0
  __m128i v42; // xmm0
  __m128i v43; // xmm0
  const unsigned int *v44; // rax
  _DWORD *v45; // rdx
  float *v46; // rax
  float *v47; // rdx
  ConstValueExcelConfigMgr *p_const_value_config_mgr; // r14
  uint32_t RankLevel; // eax
  common::milog::MiLogStream *v50; // rbx
  uint32_t v51; // edi
  __int64 v52; // rdx
  uint32_t v53; // edi
  __int64 v54; // rdx
  unsigned int *p_val; // rsi
  uint32_t *v56; // rax
  uint32_t *v57; // rdx
  uint32_t v58; // ecx
  char v59; // dl
  __int64 v60; // rdx
  WeaponExcelConfigMgr *p_weapon_config_mgr; // r14
  uint32_t MaxLevel; // r15d
  uint32_t v63; // eax
  SelectType v64; // r14d
  common::milog::MiLogStream *v66; // r14
  common::milog::MiLogStream *v67; // rax
  common::milog::MiLogStream *v68; // rcx
  common::milog::MiLogStream *v69; // rax
  common::milog::MiLogStream *v70; // rax
  common::milog::MiLogStream *v71; // rax
  common::milog::MiLogStream *v72; // rax
  common::milog::MiLogStream *v73; // rax
  common::milog::MiLogStream *v74; // rax
  common::milog::MiLogStream *v75; // rax
  common::milog::MiLogStream *v76; // rax
  int32_t result; // eax
  unsigned int val; // [rsp+48h] [rbp-1A8h] BYREF
  float scoin_exp; // [rsp+4Ch] [rbp-1A4h]
  float left_exp; // [rsp+50h] [rbp-1A0h]
  float exp; // [rsp+54h] [rbp-19Ch]
  float exp_0; // [rsp+58h] [rbp-198h]
  float food_weapon_exp_discount_param; // [rsp+5Ch] [rbp-194h]
  float activity_sale_ratio; // [rsp+60h] [rbp-190h]
  float clamped_add_exp; // [rsp+64h] [rbp-18Ch]
  float original_exp; // [rsp+68h] [rbp-188h]
  float discounted_exp; // [rsp+6Ch] [rbp-184h]
  std::vector<long unsigned int>::const_iterator __for_begin; // [rsp+70h] [rbp-180h] BYREF
  std::vector<long unsigned int>::const_iterator __for_end; // [rsp+78h] [rbp-178h] BYREF
  const std::vector<long unsigned int> *__for_range; // [rsp+80h] [rbp-170h]
  const std::vector<ItemParam> *__for_range_0; // [rsp+88h] [rbp-168h]
  const ItemParam *item_param; // [rsp+90h] [rbp-160h]
  const data::WeaponExcelConfig *weapon_excel_config_ptr; // [rsp+98h] [rbp-158h]
  common::milog::MiLogStream v100; // [rsp+A0h] [rbp-150h] BYREF
  common::milog::MiLogStream v101; // [rsp+C0h] [rbp-130h] BYREF
  char v102[272]; // [rsp+E0h] [rbp-110h] BYREF

  v8 = (unsigned __int64)v102;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v9 = __asan_stack_malloc_2(224LL);
    if ( v9 )
      v8 = v9;
  }
  *(_QWORD *)v8 = 1102416563LL;
  *(_QWORD *)(v8 + 8) = "9 48 4 12 add_exp:7430 64 4 17 max_item_exp:7437 80 4 22 remain_exp_to_max:7495 96 4 18 total_ad"
                        "d_exp:7501 112 4 16 scoin_ratio:7503 128 4 21 weapon_total_exp:7520 144 4 12 max_exp:7521 160 8 "
                        "21 food_weapon_guid:7440 192 16 20 food_weapon_ptr:7442";
  *(_QWORD *)(v8 + 16) = PlayerItemComp::getWeaponUpgradeExp;
  v10 = (_DWORD *)(v8 >> 3);
  v10[536862720] = -235802127;
  v10[536862721] = -234556943;
  v10[536862722] = -234556924;
  v10[536862723] = -234556924;
  v10[536862724] = -234556924;
  v10[536862725] = -218959360;
  v10[536862726] = -202178560;
  *(_DWORD *)(v8 + 48) = 0;
  scoin_exp = 0.0;
  v12 = 0LL;
  left_exp = 0.0;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)(v8 + 192));
  v11 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v8 + 192));
  *(float *)v12.m128i_i32 = ConstValueExcelConfigMgr::getFoodWeaponExpDiscountParam(&v11->design_config.txt_config_mgr.const_value_config_mgr);
  food_weapon_exp_discount_param = COERCE_FLOAT(_mm_cvtsi128_si32(v12));
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v8 + 192));
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    *(double *)v12.m128i_i64 = __asan_report_load8();
  ActivityComp = Player::getActivityComp(this->player_);
  ItemId = Item::getItemId(weapon);
  *(float *)v12.m128i_i32 = PlayerActivityComp::getActivitySaleWeaponUpgradeRatio(ActivityComp, ItemId);
  activity_sale_ratio = COERCE_FLOAT(_mm_cvtsi128_si32(v12));
  *(_DWORD *)(v8 + 64) = 0;
  __for_range = food_weapon_guid_vec;
  __for_begin._M_current = std::vector<unsigned long>::begin(food_weapon_guid_vec)._M_current;
  __for_end._M_current = std::vector<unsigned long>::end(food_weapon_guid_vec)._M_current;
  while ( __gnu_cxx::operator!=<unsigned long const*,std::vector<unsigned long>>(&__for_begin, &__for_end) )
  {
    v15 = __gnu_cxx::__normal_iterator<unsigned long const*,std::vector<unsigned long>>::operator*(&__for_begin);
    if ( *(_BYTE *)(((unsigned __int64)v15 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    *(_QWORD *)(v8 + 160) = *v15;
    ItemStore::findItem<Weapon>((ItemStore *const)(v8 + 192), (uint64_t)&this->pack_store_, *(_QWORD *)(v8 + 160));
    if ( std::operator==<Weapon>((const std::shared_ptr<Weapon> *)(v8 + 192), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v101,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "getWeaponUpgradeExp",
        7445);
      v16 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
              &v101,
              (const char (*)[22])"findItem failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, &val);
      v18 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v17, (const char (*)[14])" target_guid:");
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
        v18,
        (const unsigned __int64 *)(v8 + 160));
      common::milog::MiLogStream::~MiLogStream(&v101);
      v7 = -1;
      v19 = 0;
    }
    else
    {
      v20 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v8 + 192));
      weapon_excel_config_ptr = Weapon::getWeaponExcelConfig(v20);
      if ( weapon_excel_config_ptr )
      {
        v25 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v8 + 192));
        TotalExp = (float)(int)Weapon::getTotalExp(v25);
        discounted_exp = TotalExp * food_weapon_exp_discount_param;
        if ( *(_BYTE *)(((unsigned __int64)&weapon_excel_config_ptr->weapon_base_exp >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&weapon_excel_config_ptr->weapon_base_exp >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&weapon_excel_config_ptr->weapon_base_exp);
        }
        v27 = _mm_cvtsi32_si128(LODWORD(scoin_exp));
        *(float *)v27.m128i_i32 = SAFE_ADD<float,unsigned int>(
                                    *(float *)v27.m128i_i32,
                                    weapon_excel_config_ptr->weapon_base_exp);
        scoin_exp = COERCE_FLOAT(_mm_cvtsi128_si32(v27));
        if ( *(_BYTE *)(((unsigned __int64)&weapon_excel_config_ptr->weapon_base_exp >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&weapon_excel_config_ptr->weapon_base_exp >> 3) + 0x7FFF8000) <= 3 )
        {
          *(double *)v27.m128i_i64 = __asan_report_load4(&weapon_excel_config_ptr->weapon_base_exp);
        }
        *(float *)v27.m128i_i32 = std::ceil(
                                    (float)((float)(int)weapon_excel_config_ptr->weapon_base_exp + discounted_exp)
                                  - 0.00000011920929);
        exp = COERCE_FLOAT(_mm_cvtsi128_si32(v27));
        if ( activity_sale_ratio != 0.0 )
        {
          v28 = _mm_cvtsi32_si128(LODWORD(exp));
          *(float *)v28.m128i_i32 = SAFE_MULTIPLY<float,float>(*(float *)v28.m128i_i32, activity_sale_ratio);
          exp = COERCE_FLOAT(_mm_cvtsi128_si32(v28));
        }
        v29 = _mm_cvtsi32_si128(*(_DWORD *)(v8 + 48));
        *(float *)v29.m128i_i32 = SAFE_ADD<float,float>(*(float *)v29.m128i_i32, exp);
        *(_DWORD *)(v8 + 48) = _mm_cvtsi128_si32(v29);
        val = (int)exp;
        v30 = std::max<unsigned int>((const unsigned int *)(v8 + 64), &val);
        v31 = v30;
        if ( *(_BYTE *)(((unsigned __int64)v30 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v30 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v30 >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(v30);
        }
        *(_DWORD *)(v8 + 64) = *v31;
        v19 = 1;
      }
      else
      {
        common::milog::MiLogStream::create(
          &v101,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "getWeaponUpgradeExp",
          7452);
        v21 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                &v101,
                (const char (*)[35])"findWeaponExcelConfig failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        *(_DWORD *)(v8 + 144) = Player::getUid(this->player_);
        v22 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v21,
                (const unsigned int *)(v8 + 144));
        v23 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v22, (const char (*)[12])" weapon_id:");
        v24 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v8 + 192));
        val = Item::getItemId(v24);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v23, &val);
        common::milog::MiLogStream::~MiLogStream(&v101);
        v7 = -1;
        v19 = 0;
      }
    }
    std::shared_ptr<Weapon>::~shared_ptr((std::shared_ptr<Weapon> *const)(v8 + 192));
    if ( v19 != 1 )
      goto LABEL_77;
    __gnu_cxx::__normal_iterator<unsigned long const*,std::vector<unsigned long>>::operator++(&__for_begin);
  }
  __for_range_0 = item_param_vec;
  __for_begin._M_current = (const unsigned __int64 *)std::vector<ItemParam>::begin(item_param_vec)._M_current;
  __for_end._M_current = (const unsigned __int64 *)std::vector<ItemParam>::end(__for_range_0)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(
            (const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *)&__for_begin,
            (const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *)&__for_end) )
  {
    item_param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*((const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *const)&__for_begin);
    p_count = &item_param->count;
    if ( *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)p_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(p_count);
    }
    if ( !item_param->count )
    {
      common::milog::MiLogStream::create(
        &v100,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "getWeaponUpgradeExp",
        7472);
      v33 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
              &v100,
              (const char (*)[28])"item_param count is 0, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v34 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v33, &val);
      v35 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v34, (const char (*)[10])" item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v35, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v100);
      v7 = -1;
      goto LABEL_77;
    }
    *(_DWORD *)(v8 + 144) = 0;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v8 + 192));
    p_material_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v8 + 192))->design_config.txt_config_mgr.material_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_param);
    }
    v37 = MaterialExcelConfigMgr::findWeaponExpByMaterialId(
            p_material_config_mgr,
            item_param->item_id,
            (uint32_t *)(v8 + 144)) != 0;
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v8 + 192));
    if ( v37 )
    {
      common::milog::MiLogStream::create(
        &v101,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "getWeaponUpgradeExp",
        7479);
      v38 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
              &v101,
              (const char (*)[44])"findWeaponExpByMaterialId fail, item_param:");
      v39 = operator<<(v38, item_param);
      v40 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v39, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v40, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v101);
      v7 = -1;
      goto LABEL_77;
    }
    original_exp = (float)*(int *)(v8 + 144);
    exp_0 = original_exp;
    if ( activity_sale_ratio != 0.0 )
    {
      v41 = _mm_cvtsi32_si128(LODWORD(exp_0));
      *(float *)v41.m128i_i32 = SAFE_MULTIPLY<float,float>(*(float *)v41.m128i_i32, activity_sale_ratio);
      exp_0 = COERCE_FLOAT(_mm_cvtsi128_si32(v41));
    }
    if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&item_param->count);
    }
    v42 = _mm_cvtsi32_si128(LODWORD(scoin_exp));
    *(float *)v42.m128i_i32 = SAFE_ADD<float,float>(
                                *(float *)v42.m128i_i32,
                                (float)(int)item_param->count * original_exp);
    scoin_exp = COERCE_FLOAT(_mm_cvtsi128_si32(v42));
    if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&item_param->count);
    }
    v43 = _mm_cvtsi32_si128(*(_DWORD *)(v8 + 48));
    *(float *)v43.m128i_i32 = SAFE_ADD<float,float>(*(float *)v43.m128i_i32, (float)(int)item_param->count * exp_0);
    *(_DWORD *)(v8 + 48) = _mm_cvtsi128_si32(v43);
    val = (int)exp_0;
    v44 = std::max<unsigned int>((const unsigned int *)(v8 + 64), &val);
    v45 = v44;
    if ( *(_BYTE *)(((unsigned __int64)v44 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v44 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v44 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v44);
    }
    *(_DWORD *)(v8 + 64) = *v45;
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++((__gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *const)&__for_begin);
  }
  *(float *)(v8 + 80) = (float)(int)Weapon::getRemainExpToMax(weapon);
  if ( *(float *)(v8 + 48) > *(float *)(v8 + 80) )
    left_exp = *(float *)(v8 + 48) - *(float *)(v8 + 80);
  v46 = (float *)std::min<float>((const float *)(v8 + 48), (const float *)(v8 + 80));
  v47 = v46;
  if ( *(_BYTE *)(((unsigned __int64)v46 >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)v46 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v46 >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(v46);
  }
  clamped_add_exp = *v47;
  *(_DWORD *)(v8 + 96) = (int)(float)(*(float *)(v8 + 48) + 0.00000011920929);
  *(_DWORD *)(v8 + 112) = 0;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)(v8 + 192));
  p_const_value_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v8 + 192))->design_config.txt_config_mgr.const_value_config_mgr;
  RankLevel = Weapon::getRankLevel(weapon);
  LOBYTE(p_const_value_config_mgr) = ConstValueExcelConfigMgr::getWeaponScoinRatio(
                                       p_const_value_config_mgr,
                                       RankLevel,
                                       (float *)(v8 + 112)) != 0;
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v8 + 192));
  if ( (_BYTE)p_const_value_config_mgr )
  {
    common::milog::MiLogStream::create(
      &v101,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "getWeaponUpgradeExp",
      7506);
    v50 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
            &v101,
            (const char (*)[38])"getWeaponScoinRatio fail. rank_level:");
    val = Weapon::getRankLevel(weapon);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v50, &val);
    common::milog::MiLogStream::~MiLogStream(&v101);
    v7 = -1;
  }
  else
  {
    v51 = (int)(float)(clamped_add_exp + 0.00000011920929);
    v52 = (*(_BYTE *)(((unsigned __int64)total_exp >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((unsigned __int8)total_exp & 7) + 3) >= *(_BYTE *)(((unsigned __int64)total_exp >> 3) + 0x7FFF8000));
    if ( (_BYTE)v52 )
    {
      v51 = (unsigned int)total_exp;
      __asan_report_store4(total_exp, ((unsigned __int8)total_exp & 7u) + 3, v52);
    }
    *total_exp = v51;
    if ( activity_sale_ratio != 0.0 )
      left_exp = left_exp / activity_sale_ratio;
    v53 = (int)left_exp;
    v54 = (*(_BYTE *)(((unsigned __int64)extra_exp >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((unsigned __int8)extra_exp & 7) + 3) >= *(_BYTE *)(((unsigned __int64)extra_exp >> 3) + 0x7FFF8000));
    if ( (_BYTE)v54 )
    {
      v53 = (unsigned int)extra_exp;
      __asan_report_store4(extra_exp, ((unsigned __int8)extra_exp & 7u) + 3, v54);
    }
    *extra_exp = v53;
    val = (int)(float)(*(float *)(v8 + 112) * scoin_exp);
    *(_DWORD *)(v8 + 144) = 1;
    p_val = &val;
    v56 = (uint32_t *)std::max<unsigned int>((const unsigned int *)(v8 + 144), &val);
    v57 = v56;
    if ( *(_BYTE *)(((unsigned __int64)v56 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v56 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v56 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v56);
    }
    v58 = *v57;
    v59 = *(_BYTE *)(((unsigned __int64)scoin_need >> 3) + 0x7FFF8000);
    LOBYTE(p_val) = v59 != 0;
    v60 = (v59 != 0) & (unsigned __int8)((char)(((unsigned __int8)scoin_need & 7) + 3) >= v59);
    if ( (_BYTE)v60 )
      __asan_report_store4(scoin_need, p_val, v60);
    *scoin_need = v58;
    *(_DWORD *)(v8 + 128) = Weapon::getTotalExp(weapon);
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v8 + 192));
    p_weapon_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v8 + 192))->design_config.txt_config_mgr.weapon_config_mgr;
    MaxLevel = Weapon::getMaxLevel(weapon);
    v63 = Item::getItemId(weapon);
    *(_DWORD *)(v8 + 144) = WeaponExcelConfigMgr::getTotalExpToLevel(p_weapon_config_mgr, v63, MaxLevel);
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v8 + 192));
    if ( *(_DWORD *)(v8 + 64)
      && (v64 = SAFE_ADD<unsigned int,unsigned int>(*(_DWORD *)(v8 + 144), *(_DWORD *)(v8 + 64)),
          v64 <= SAFE_ADD<unsigned int,unsigned int>(*(_DWORD *)(v8 + 128), *(_DWORD *)(v8 + 96))) )
    {
      common::milog::MiLogStream::create(
        &v101,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "getWeaponUpgradeExp",
        7524);
      v66 = common::milog::MiLogStream::operator<<<char [11],(char *[11])0>(&v101, (const char (*)[11])"weapon_id:");
      val = Item::getItemId(weapon);
      v67 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v66, &val);
      v68 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v67, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v69 = operator<<(v68, this->player_);
      v70 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v69, (const char (*)[10])" max_exp:");
      v71 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
              v70,
              (const unsigned int *)(v8 + 144));
      v72 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v71, (const char (*)[15])" max_item_exp:");
      v73 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v72, (const unsigned int *)(v8 + 64));
      v74 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(
              v73,
              (const char (*)[19])" weapon_total_exp:");
      v75 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
              v74,
              (const unsigned int *)(v8 + 128));
      v76 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v75, (const char (*)[16])" total_add_exp:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v76, (const unsigned int *)(v8 + 96));
      common::milog::MiLogStream::~MiLogStream(&v101);
      v7 = -1;
    }
    else
    {
      v7 = 0;
    }
  }
LABEL_77:
  result = v7;
  if ( v102 == (char *)v8 )
  {
    *(_QWORD *)((v8 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8010) = 0LL;
    *(_DWORD *)((v8 >> 3) + 0x7FFF8018) = 0;
  }
  else
  {
    *(_QWORD *)v8 = 1172321806LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v8 >> 3) + 0x7FFF8018) = -168430091;
  }
  return result;
};

// Line 7533: range 0000000017D0089A-0000000017D014F1
int32_t __cdecl PlayerItemComp::checkGrantWeaponUpgradeReturnItems(
        PlayerItemComp *const this,
        uint32_t extra_exp,
        std::vector<ItemParam> *ret_item_param_vec)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  int32_t result; // eax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  MaterialExcelConfigMgr *p_material_config_mgr; // rcx
  common::milog::MiLogStream *v9; // r14
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // r14
  std::vector<data::ItemUseConfig>::const_reference v13; // rax
  std::vector<data::ItemUseConfig>::const_reference v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  ItemParam *v17; // rdx
  PlayerItemComp *ItemComp; // rcx
  common::milog::MiLogStream *v19; // rbx
  unsigned int val; // [rsp+20h] [rbp-130h] BYREF
  uint32_t left_exp; // [rsp+24h] [rbp-12Ch]
  int32_t ret; // [rsp+28h] [rbp-128h]
  uint32_t count; // [rsp+2Ch] [rbp-124h]
  std::array<unsigned int,3>::const_iterator __for_begin; // [rsp+30h] [rbp-120h]
  const std::array<unsigned int,3> *ret_material_id_array; // [rsp+38h] [rbp-118h]
  const std::array<unsigned int,3> *__for_range; // [rsp+40h] [rbp-110h]
  std::array<unsigned int,3>::const_iterator __for_end; // [rsp+48h] [rbp-108h]
  const uint32_t *ret_material_id; // [rsp+50h] [rbp-100h]
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+58h] [rbp-F8h]
  common::milog::MiLogStream v31; // [rsp+60h] [rbp-F0h] BYREF
  char v32[208]; // [rsp+80h] [rbp-D0h] BYREF

  v3 = (unsigned __int64)v32;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(160LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "3 48 4 8 exp:7575 64 16 15 item_param:7592 96 24 18 action_reason:7607";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkGrantWeaponUpgradeReturnItems;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -219021312;
  v5[536862723] = -218103808;
  v5[536862724] = -202116109;
  std::vector<ItemParam>::clear(ret_item_param_vec);
  if ( extra_exp )
  {
    left_exp = extra_exp;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v3 + 64));
    v7 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
    ret_material_id_array = ConstValueExcelConfigMgr::getUpgradeWeaponReturnMaterialIdConfig(&v7->design_config.txt_config_mgr.const_value_config_mgr);
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 64));
    ret = 0;
    __for_range = ret_material_id_array;
    __for_begin = std::array<unsigned int,3ul>::begin(ret_material_id_array);
    __for_end = std::array<unsigned int,3ul>::end(ret_material_id_array);
    while ( 1 )
    {
      if ( __for_begin == __for_end )
        goto LABEL_43;
      ret_material_id = __for_begin;
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)(v3 + 64));
      p_material_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64))->design_config.txt_config_mgr.material_config_mgr;
      if ( *(_BYTE *)(((unsigned __int64)__for_begin >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)__for_begin & 7) + 3) >= *(_BYTE *)(((unsigned __int64)__for_begin >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(__for_begin);
      }
      material_config_ptr = data::MaterialExcelConfigMgrBase::findMaterialExcelConfig(
                              p_material_config_mgr,
                              *ret_material_id);
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 64));
      if ( !material_config_ptr )
        break;
      if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->material_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)material_config_ptr + 76) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->material_type >> 3)
                                                                           + 0x7FFF8000) )
      {
        __asan_report_load4(&material_config_ptr->material_type);
      }
      if ( material_config_ptr->material_type != MATERIAL_WEAPON_EXP_STONE )
      {
        common::milog::MiLogStream::create(
          &v31,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkGrantWeaponUpgradeReturnItems",
          7556);
        v12 = common::milog::MiLogStream::operator<<<char [52],(char *[52])0>(
                &v31,
                (const char (*)[52])"MaterialType is not MATERIAL_WEAPON_EXP_STONE, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
LABEL_37:
        val = Player::getUid(this->player_);
        v15 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v12, &val);
        v16 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v15, (const char (*)[10])" item_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, ret_material_id);
        common::milog::MiLogStream::~MiLogStream(&v31);
        ret = -1;
        goto LABEL_43;
      }
      if ( std::vector<data::ItemUseConfig>::size(&material_config_ptr->item_use) != 1 )
      {
        common::milog::MiLogStream::create(
          &v31,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkGrantWeaponUpgradeReturnItems",
          7563);
        v12 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v31,
                (const char (*)[39])"Material UseConfig is not size 1, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_37;
      }
      v13 = std::vector<data::ItemUseConfig>::operator[](&material_config_ptr->item_use, 0LL);
      if ( *(_BYTE *)(((unsigned __int64)&v13->use_op >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&v13->use_op >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&v13->use_op);
      }
      if ( v13->use_op != ITEM_USE_ADD_WEAPON_EXP )
      {
        common::milog::MiLogStream::create(
          &v31,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkGrantWeaponUpgradeReturnItems",
          7570);
        v12 = common::milog::MiLogStream::operator<<<char [63],(char *[63])0>(
                &v31,
                (const char (*)[63])"Material UseConfig use_op is not ITEM_USE_ADD_WEAPON_EXP, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_37;
      }
      *(_DWORD *)(v3 + 48) = 0;
      v14 = std::vector<data::ItemUseConfig>::operator[](&material_config_ptr->item_use, 0LL);
      if ( common::tools::StringUtils::strVecToNum<0u,unsigned int>(&v14->use_param, (unsigned int *)(v3 + 48)) )
      {
        common::milog::MiLogStream::create(
          &v31,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "checkGrantWeaponUpgradeReturnItems",
          7578);
        v12 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
                &v31,
                (const char (*)[24])"strVecToNum fails, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_37;
      }
      if ( !*(_DWORD *)(v3 + 48) )
      {
        common::milog::MiLogStream::create(
          &v31,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "checkGrantWeaponUpgradeReturnItems",
          7584);
        v12 = common::milog::MiLogStream::operator<<<char [69],(char *[69])0>(
                &v31,
                (const char (*)[69])"Material UseConfig use_op ITEM_USE_ADD_WEAPON_EXP add exp is 0, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_37;
      }
      count = left_exp / *(_DWORD *)(v3 + 48);
      if ( count )
      {
        left_exp -= SAFE_MULTIPLY<unsigned int,unsigned int>(count, *(_DWORD *)(v3 + 48));
        *(_DWORD *)(v3 + 64) = 0;
        *(_DWORD *)(v3 + 68) = 0;
        *(_DWORD *)(v3 + 72) = 0;
        *(_DWORD *)(v3 + 76) = 0;
        if ( *(_BYTE *)(((unsigned __int64)ret_material_id >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)ret_material_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)ret_material_id >> 3)
                                                                            + 0x7FFF8000) )
        {
          __asan_report_load4(ret_material_id);
        }
        *(_DWORD *)(v3 + 64) = *ret_material_id;
        *(_DWORD *)(v3 + 68) = count;
        v17 = std::move<ItemParam &>((ItemParam *)(v3 + 64));
        std::vector<ItemParam>::emplace_back<ItemParam>(ret_item_param_vec, v17, v17);
      }
      ++__for_begin;
    }
    common::milog::MiLogStream::create(
      &v31,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkGrantWeaponUpgradeReturnItems",
      7549);
    v9 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
           &v31,
           (const char (*)[37])"findMaterialExcelConfig failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &val);
    v11 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v10, (const char (*)[14])" material_id:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, ret_material_id);
    common::milog::MiLogStream::~MiLogStream(&v31);
    ret = -1;
LABEL_43:
    if ( ret )
    {
      std::vector<ItemParam>::clear(ret_item_param_vec);
      result = ret;
    }
    else if ( std::vector<ItemParam>::empty(ret_item_param_vec) )
    {
      result = 0;
    }
    else
    {
      ActionReason::ActionReason(
        (ActionReason *const)(v3 + 96),
        ACTION_REASON_UNGRADE_WEAPON_RETURN_MATERIAL,
        ITEM_LIMIT_UPGRADE_WEAPON_RETURN_MATERIAL);
      *(_BYTE *)(v3 + 110) = 0;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      ItemComp = Player::getItemComp(this->player_);
      ret = PlayerItemComp::checkAddItemBatch(ItemComp, ret_item_param_vec, (const ActionReason *)(v3 + 96));
      if ( ret && ret != 617 )
      {
        common::milog::MiLogStream::create(
          &v31,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkGrantWeaponUpgradeReturnItems",
          7613);
        v19 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                &v31,
                (const char (*)[31])"checkAddItemBatch fails, uid: ");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v19, &val);
        common::milog::MiLogStream::~MiLogStream(&v31);
        std::vector<ItemParam>::clear(ret_item_param_vec);
      }
      result = ret;
    }
  }
  else
  {
    result = 0;
  }
  if ( v32 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 7621: range 0000000017D014F2-0000000017D0174F
int32_t __cdecl PlayerItemComp::checkAndGrantWeaponUpgradeReturnItems(
        PlayerItemComp *const this,
        uint32_t extra_exp,
        std::vector<ItemParam> *ret_item_param_vec)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  int32_t result; // eax
  PlayerItemComp *ItemComp; // rdi
  int32_t ret; // [rsp+2Ch] [rbp-A4h]
  common::milog::MiLogStream v10; // [rsp+30h] [rbp-A0h] BYREF
  char v11[128]; // [rsp+50h] [rbp-80h] BYREF

  v3 = (unsigned __int64)v11;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 24 18 action_reason:7638";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkAndGrantWeaponUpgradeReturnItems;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  std::vector<ItemParam>::clear(ret_item_param_vec);
  if ( extra_exp )
  {
    ret = PlayerItemComp::checkGrantWeaponUpgradeReturnItems(this, extra_exp, ret_item_param_vec);
    if ( !ret || ret == 617 )
    {
      if ( std::vector<ItemParam>::empty(ret_item_param_vec) )
      {
        result = 0;
      }
      else
      {
        ActionReason::ActionReason(
          (ActionReason *const)(v3 + 32),
          ACTION_REASON_UNGRADE_WEAPON_RETURN_MATERIAL,
          ITEM_LIMIT_UPGRADE_WEAPON_RETURN_MATERIAL);
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        ItemComp = Player::getItemComp(this->player_);
        result = PlayerItemComp::addMaterialBatchWithStackLimit(
                   ItemComp,
                   ret_item_param_vec,
                   (const ActionReason *)(v3 + 32),
                   0LL);
      }
    }
    else
    {
      common::milog::MiLogStream::create(
        &v10,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAndGrantWeaponUpgradeReturnItems",
        7630);
      common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
        &v10,
        (const char (*)[42])"checkGrantWeaponUpgradeReturnItems failed");
      common::milog::MiLogStream::~MiLogStream(&v10);
      std::vector<ItemParam>::clear(ret_item_param_vec);
      result = ret;
    }
  }
  else
  {
    result = 0;
  }
  if ( v11 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 7644: range 0000000017D01750-0000000017D02282
__int64 __fastcall PlayerItemComp::modifyWeaponPromoteCostScoinCostByTalent(
        const PlayerItemComp *const this,
        uint32_t weapon_id,
        uint32_t old_scoin_cost)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v6; // rax
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  unsigned int *v9; // rax
  uint32_t *v10; // rdx
  uint32_t AvatarComp; // eax
  std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  TalentComp *TalentComp; // rax
  __gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >::reference v14; // rax
  _DWORD *v15; // rdx
  std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v16; // rax
  float *v17; // rax
  float *v18; // rdx
  int v19; // r14d
  const unsigned int *v20; // rax
  _DWORD *v21; // rdx
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rax
  common::milog::MiLogStream *v32; // rax
  common::milog::MiLogStream *v33; // rax
  common::milog::MiLogStream *v34; // rax
  common::milog::MiLogStream *v35; // rax
  common::milog::MiLogStream *v36; // rcx
  float v37; // [rsp+Ch] [rbp-214h]
  bool has_found; // [rsp+2Fh] [rbp-1F1h]
  float __lo; // [rsp+30h] [rbp-1F0h] BYREF
  uint32_t target_avatar_id; // [rsp+34h] [rbp-1ECh]
  std::set<unsigned int>::iterator __for_begin; // [rsp+38h] [rbp-1E8h] BYREF
  std::set<unsigned int>::iterator __for_end; // [rsp+40h] [rbp-1E0h] BYREF
  std::vector<unsigned int>::iterator __for_begin_0; // [rsp+48h] [rbp-1D8h] BYREF
  std::vector<unsigned int>::iterator __for_end_0; // [rsp+50h] [rbp-1D0h] BYREF
  std::__detail::_Node_iterator_base<std::pair<unsigned int const,std::set<unsigned int> >,false> __y; // [rsp+58h] [rbp-1C8h] BYREF
  const data::WeaponExcelConfig *weapon_config_ptr; // [rsp+60h] [rbp-1C0h]
  const std::unordered_map<unsigned int,std::set<unsigned int>> *proud_life_effect_avatars_map; // [rsp+68h] [rbp-1B8h]
  const std::unordered_map<unsigned int,LifeEffectWeaponPromoteReduceScoin> *target_proud_skill_config_map; // [rsp+70h] [rbp-1B0h]
  const std::set<unsigned int> *__for_range; // [rsp+78h] [rbp-1A8h]
  std::vector<unsigned int> *__for_range_0; // [rsp+80h] [rbp-1A0h]
  const LifeEffectWeaponPromoteReduceScoin *config; // [rsp+88h] [rbp-198h]
  std::vector<unsigned int> v53; // [rsp+90h] [rbp-190h] BYREF
  common::milog::MiLogStream v54; // [rsp+B0h] [rbp-170h] BYREF
  char v55[336]; // [rsp+D0h] [rbp-150h] BYREF

  v3 = (unsigned __int64)v55;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_3(288LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "11 48 4 17 reduce_ratio:7661 64 4 14 avatar_id:7662 80 4 14 talent_id:7664 96 4 17 reduce_scoin:"
                        "7701 112 4 15 scoin_cost:7702 128 4 14 weapon_id:7643 144 4 19 old_scoin_cost:7643 160 8 9 iter:"
                        "7653 192 8 16 avatar_guid:7663 224 8 16 config_iter:7675 256 16 22 formal_avatar_ptr:7668";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::modifyWeaponPromoteCostScoinCostByTalent;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -234556924;
  v5[536862723] = -234556924;
  v5[536862724] = -234556924;
  v5[536862725] = -218959360;
  v5[536862726] = -218959360;
  v5[536862727] = -218959360;
  v5[536862728] = -202178560;
  *(_DWORD *)(v3 + 128) = weapon_id;
  *(_DWORD *)(v3 + 144) = old_scoin_cost;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)(v3 + 256));
  v6 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 256));
  weapon_config_ptr = data::WeaponExcelConfigMgrBase::findWeaponExcelConfig(
                        &v6->design_config.txt_config_mgr.weapon_config_mgr,
                        *(_DWORD *)(v3 + 128));
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 256));
  if ( weapon_config_ptr )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v3 + 256));
    proud_life_effect_avatars_map = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 256))->design_config.txt_config_mgr.avatar_talent_config_mgr.proud_life_effect_avatars_map;
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 256));
    *(_DWORD *)(v3 + 112) = 501;
    *(std::unordered_map<unsigned int,std::set<unsigned int>>::const_iterator *)(v3 + 160) = std::unordered_map<unsigned int,std::set<unsigned int>>::find(
                                                                                               proud_life_effect_avatars_map,
                                                                                               (const std::unordered_map<unsigned int,std::set<unsigned int>>::key_type *)(v3 + 112));
    __y._M_cur = std::unordered_map<unsigned int,std::set<unsigned int>>::end(proud_life_effect_avatars_map)._M_cur;
    if ( std::__detail::operator==<std::pair<unsigned int const,std::set<unsigned int>>,false>(
           (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,std::set<unsigned int> >,false> *)(v3 + 160),
           &__y) )
    {
      common::milog::MiLogStream::create(
        &v54,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "modifyWeaponPromoteCostScoinCostByTalent",
        7656);
      common::milog::MiLogStream::operator<<<char [76],(char *[76])0>(
        &v54,
        (const char (*)[76])"data::PROUD_EFFECT_WEAPON_PROMOTE_REDUCE_SCOIN has no corresponding avatars");
      common::milog::MiLogStream::~MiLogStream(&v54);
      result = *(unsigned int *)(v3 + 144);
    }
    else
    {
      has_found = 0;
      *(_DWORD *)(v3 + 48) = 0;
      *(_DWORD *)(v3 + 64) = 0;
      *(_QWORD *)(v3 + 192) = 0LL;
      *(_DWORD *)(v3 + 80) = 0;
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)(v3 + 256));
      target_proud_skill_config_map = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 256))->design_config.txt_config_mgr.avatar_talent_config_mgr.proud_weapon_promote_reduce_scoin_config_map;
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 256));
      __for_range = &std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::set<unsigned int>>,false,false>::operator->((const std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::set<unsigned int> >,false,false> *const)(v3 + 160))->second;
      __for_begin._M_node = std::set<unsigned int>::begin(__for_range)._M_node;
      __for_end._M_node = std::set<unsigned int>::end(__for_range)._M_node;
      while ( std::operator!=(&__for_begin, &__for_end) )
      {
        v9 = (unsigned int *)std::_Rb_tree_const_iterator<unsigned int>::operator*(&__for_begin);
        v10 = v9;
        if ( *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v9 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(v9);
        }
        target_avatar_id = *v10;
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        AvatarComp = (unsigned int)Player::getAvatarComp(this->player_);
        PlayerAvatarComp::findFormalAvatarByAvatarId((const PlayerAvatarComp *const)(v3 + 256), AvatarComp);
        if ( !std::operator==<FormalAvatar>(0LL, (const std::shared_ptr<FormalAvatar> *)(v3 + 256)) )
        {
          v12 = std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 256));
          TalentComp = Avatar::getTalentComp(v12);
          TalentComp::getProudSkills(&v53, TalentComp);
          __for_range_0 = &v53;
          __for_begin_0._M_current = std::vector<unsigned int>::begin(&v53)._M_current;
          __for_end_0._M_current = std::vector<unsigned int>::end(__for_range_0)._M_current;
          while ( __gnu_cxx::operator!=<unsigned int *,std::vector<unsigned int>>(&__for_begin_0, &__for_end_0) )
          {
            v14 = __gnu_cxx::__normal_iterator<unsigned int *,std::vector<unsigned int>>::operator*(&__for_begin_0);
            v15 = v14;
            if ( *(_BYTE *)(((unsigned __int64)v14 >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)v14 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v14 >> 3) + 0x7FFF8000) )
            {
              __asan_report_load4(v14);
            }
            *(_DWORD *)(v3 + 112) = *v15;
            *(std::unordered_map<unsigned int,LifeEffectWeaponPromoteReduceScoin>::const_iterator *)(v3 + 224) = std::unordered_map<unsigned int,LifeEffectWeaponPromoteReduceScoin>::find(target_proud_skill_config_map, (const std::unordered_map<unsigned int,LifeEffectWeaponPromoteReduceScoin>::key_type *)(v3 + 112));
            __y._M_cur = (std::__detail::_Node_iterator_base<std::pair<unsigned int const,std::set<unsigned int> >,false>::__node_type *)std::unordered_map<unsigned int,LifeEffectWeaponPromoteReduceScoin>::end(target_proud_skill_config_map)._M_cur;
            if ( !std::__detail::operator==<std::pair<unsigned int const,LifeEffectWeaponPromoteReduceScoin>,false>(
                    (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,LifeEffectWeaponPromoteReduceScoin>,false> *)(v3 + 224),
                    (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,LifeEffectWeaponPromoteReduceScoin>,false> *)&__y) )
            {
              config = &std::__detail::_Node_const_iterator<std::pair<unsigned int const,LifeEffectWeaponPromoteReduceScoin>,false,false>::operator->((const std::__detail::_Node_const_iterator<std::pair<unsigned int const,LifeEffectWeaponPromoteReduceScoin>,false,false> *const)(v3 + 224))->second;
              if ( common::tools::MiscUtils::isContains<std::set<data::WeaponType> const,data::WeaponType>(
                     &config->weapon_type_set,
                     &weapon_config_ptr->weapon_type) )
              {
                if ( !has_found )
                  goto LABEL_25;
                if ( *(_BYTE *)(((unsigned __int64)&config->reduce_ratio >> 3) + 0x7FFF8000) != 0
                  && *(_BYTE *)(((unsigned __int64)&config->reduce_ratio >> 3) + 0x7FFF8000) <= 3 )
                {
                  __asan_report_load4(&config->reduce_ratio);
                }
                if ( config->reduce_ratio > *(float *)(v3 + 48) )
                {
LABEL_25:
                  has_found = 1;
                  if ( *(_BYTE *)(((unsigned __int64)&config->reduce_ratio >> 3) + 0x7FFF8000) != 0
                    && *(_BYTE *)(((unsigned __int64)&config->reduce_ratio >> 3) + 0x7FFF8000) <= 3 )
                  {
                    __asan_report_load4(&config->reduce_ratio);
                  }
                  *(float *)(v3 + 48) = config->reduce_ratio;
                  *(_DWORD *)(v3 + 64) = target_avatar_id;
                  v16 = std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<FormalAvatar,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 256));
                  *(_QWORD *)(v3 + 192) = Avatar::getGuid(v16);
                  *(_DWORD *)(v3 + 80) = *(_DWORD *)(v3 + 112);
                }
              }
            }
            __gnu_cxx::__normal_iterator<unsigned int *,std::vector<unsigned int>>::operator++(&__for_begin_0);
          }
          std::vector<unsigned int>::~vector(&v53);
        }
        std::shared_ptr<FormalAvatar>::~shared_ptr((std::shared_ptr<FormalAvatar> *const)(v3 + 256));
        std::_Rb_tree_const_iterator<unsigned int>::operator++(&__for_begin);
      }
      if ( !has_found )
      {
        result = *(unsigned int *)(v3 + 144);
      }
      else
      {
        v37 = (float)*(int *)(v3 + 144);
        *(_DWORD *)(v3 + 112) = 1065353216;
        __lo = 0.0;
        v17 = (float *)std::clamp<float>((const float *)(v3 + 48), &__lo, (const float *)(v3 + 112));
        v18 = v17;
        if ( *(_BYTE *)(((unsigned __int64)v17 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v17 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v17 >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(v17);
        }
        *(_DWORD *)(v3 + 96) = (int)(float)(*v18 * v37);
        v19 = *(_DWORD *)(v3 + 144);
        v20 = std::min<unsigned int>((const unsigned int *)(v3 + 144), (const unsigned int *)(v3 + 96));
        v21 = v20;
        if ( *(_BYTE *)(((unsigned __int64)v20 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v20 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v20 >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(v20);
        }
        *(_DWORD *)(v3 + 112) = v19 - *v21;
        common::milog::MiLogStream::create(
          &v54,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "modifyWeaponPromoteCostScoinCostByTalent",
          7703);
        v22 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
                &v54,
                (const char (*)[24])"reduce scoin cost from ");
        v23 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v22,
                (const unsigned int *)(v3 + 144));
        v24 = common::milog::MiLogStream::operator<<<char [5],(char *[5])0>(v23, (const char (*)[5])off_26390BA0);
        v25 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v24,
                (const unsigned int *)(v3 + 112));
        v26 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v25, (const char (*)[15])" reduce_ratio:");
        v27 = common::milog::MiLogStream::operator<<<float,(float *)0>(v26, (const float *)(v3 + 48));
        v28 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v27, (const char (*)[15])" reduce_scoin:");
        v29 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v28,
                (const unsigned int *)(v3 + 96));
        v30 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v29, (const char (*)[12])" avatar_id:");
        v31 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v30,
                (const unsigned int *)(v3 + 64));
        v32 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v31, (const char (*)[14])" avatar_guid:");
        v33 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
                v32,
                (const unsigned __int64 *)(v3 + 192));
        v34 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v33, (const char (*)[12])" talent_id:");
        v35 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v34,
                (const unsigned int *)(v3 + 80));
        v36 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v35, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v36, this->player_);
        common::milog::MiLogStream::~MiLogStream(&v54);
        result = *(unsigned int *)(v3 + 112);
      }
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v54,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "modifyWeaponPromoteCostScoinCostByTalent",
      7648);
    v7 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
           &v54,
           (const char (*)[39])"findWeaponExcelConfig fail, weapon_id:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v3 + 128));
    common::milog::MiLogStream::~MiLogStream(&v54);
    result = *(unsigned int *)(v3 + 144);
  }
  if ( v55 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8018) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8020) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8020) = -168430091;
  }
  return result;
};

// Line 7709: range 0000000017D02284-0000000017D0305E
__int64 __fastcall PlayerItemComp::checkWeaponPromote(
        PlayerItemComp *const this,
        uint64_t target_guid,
        uint32_t *scoin_cost)
{
  unsigned __int64 v3; // r12
  __int64 v4; // rax
  _DWORD *v5; // r13
  PlayerBasicComp *BasicComp; // rax
  common::milog::MiLogStream *v7; // rbx
  unsigned int v8; // r14d
  common::milog::MiLogStream *v9; // r14
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  WeaponExcelConfigMgr *p_weapon_config_mgr; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v13; // rax
  uint32_t PromoteLevel; // r15d
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v15; // rax
  uint32_t ItemId; // eax
  common::milog::MiLogStream *v17; // r14
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v22; // rax
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v23; // rax
  uint32_t Level; // ecx
  common::milog::MiLogStream *v25; // r14
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v30; // rax
  common::milog::MiLogStream *v31; // rax
  common::milog::MiLogStream *v32; // rax
  WeaponExcelConfigMgr *v33; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v34; // rax
  uint32_t v35; // r15d
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v36; // rax
  uint32_t v37; // eax
  common::milog::MiLogStream *v38; // r14
  common::milog::MiLogStream *v39; // rax
  common::milog::MiLogStream *v40; // rax
  common::milog::MiLogStream *v41; // rax
  common::milog::MiLogStream *v42; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v43; // rax
  PlayerBasicComp *v44; // rax
  uint32_t v45; // ecx
  common::milog::MiLogStream *v46; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v47; // rax
  common::milog::MiLogStream *v48; // rax
  common::milog::MiLogStream *v49; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v50; // rax
  common::milog::MiLogStream *v51; // rax
  common::milog::MiLogStream *v52; // rcx
  common::milog::MiLogStream *v53; // rax
  common::milog::MiLogStream *v54; // rax
  common::milog::MiLogStream *v55; // r14
  common::milog::MiLogStream *v56; // rax
  common::milog::MiLogStream *v57; // rax
  uint32_t coin_cost; // r14d
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v59; // rax
  uint32_t v60; // eax
  uint32_t v61; // ecx
  char v62; // dl
  __int64 v63; // rsi
  __int64 v64; // rdx
  common::milog::MiLogStream *v65; // r14
  common::milog::MiLogStream *v66; // rax
  common::milog::MiLogStream *v67; // rax
  common::milog::MiLogStream *v68; // rax
  common::milog::MiLogStream *v69; // rax
  __int64 result; // rax
  unsigned int val; // [rsp+2Ch] [rbp-F4h] BYREF
  const data::WeaponPromoteExcelConfig *cur_promote_config_ptr; // [rsp+30h] [rbp-F0h]
  const data::WeaponPromoteExcelConfig *next_promote_config_ptr; // [rsp+38h] [rbp-E8h]
  std::shared_ptr<Config> v75; // [rsp+40h] [rbp-E0h] BYREF
  common::milog::MiLogStream v76; // [rsp+50h] [rbp-D0h] BYREF
  char v77[176]; // [rsp+70h] [rbp-B0h] BYREF

  v3 = (unsigned __int64)v77;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(128LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "3 48 4 8 ret:7757 64 8 16 target_guid:7708 96 16 15 weapon_ptr:7718";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkWeaponPromote;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -218959360;
  v5[536862723] = -202178560;
  *(_QWORD *)(v3 + 64) = target_guid;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  if ( !PlayerBasicComp::isStateOpen(BasicComp, 5u) )
  {
    common::milog::MiLogStream::create(
      &v76,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponPromote",
      7713);
    v7 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
           &v76,
           (const char (*)[42])"OPEN_STATE_WEAPON_PROMOTE is locked. uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &val);
    common::milog::MiLogStream::~MiLogStream(&v76);
    v8 = 141;
  }
  else
  {
    ItemStore::findItem<Weapon>((ItemStore *const)(v3 + 96), (uint64_t)&this->pack_store_, *(_QWORD *)(v3 + 64));
    if ( std::operator==<Weapon>((const std::shared_ptr<Weapon> *)(v3 + 96), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v76,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponPromote",
        7721);
      v9 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
             &v76,
             (const char (*)[22])"findItem failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &val);
      v11 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v10, (const char (*)[14])" target_guid:");
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v11, (const unsigned __int64 *)(v3 + 64));
      common::milog::MiLogStream::~MiLogStream(&v76);
      v8 = -1;
    }
    else
    {
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v75);
      p_weapon_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v75)->design_config.txt_config_mgr.weapon_config_mgr;
      v13 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
      PromoteLevel = Weapon::getPromoteLevel(v13);
      v15 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
      ItemId = Item::getItemId(v15);
      cur_promote_config_ptr = WeaponExcelConfigMgr::findWeaponPromoteExcelConfig(
                                 p_weapon_config_mgr,
                                 ItemId,
                                 PromoteLevel);
      std::shared_ptr<Config>::~shared_ptr(&v75);
      if ( cur_promote_config_ptr )
      {
        v23 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
        Level = Weapon::getLevel(v23);
        if ( *(_BYTE *)(((unsigned __int64)&cur_promote_config_ptr->unlock_max_level >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&cur_promote_config_ptr->unlock_max_level >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&cur_promote_config_ptr->unlock_max_level);
        }
        if ( Level >= cur_promote_config_ptr->unlock_max_level )
        {
          ServiceBox::findService<GameserverService>();
          GameserverService::getConfig((GameserverService *const)&v75);
          v33 = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v75)->design_config.txt_config_mgr.weapon_config_mgr;
          v34 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
          v35 = Weapon::getPromoteLevel(v34) + 1;
          v36 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
          v37 = Item::getItemId(v36);
          next_promote_config_ptr = WeaponExcelConfigMgr::findWeaponPromoteExcelConfig(v33, v37, v35);
          std::shared_ptr<Config>::~shared_ptr(&v75);
          if ( next_promote_config_ptr )
          {
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            v44 = Player::getBasicComp(this->player_);
            v45 = PlayerBasicComp::getLevel(v44);
            if ( *(_BYTE *)(((unsigned __int64)&next_promote_config_ptr->required_player_level >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)next_promote_config_ptr + 76) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&next_promote_config_ptr->required_player_level >> 3)
                                                                                     + 0x7FFF8000) )
            {
              __asan_report_load4(&next_promote_config_ptr->required_player_level);
            }
            if ( v45 >= next_promote_config_ptr->required_player_level )
            {
              *(_DWORD *)(v3 + 48) = PlayerItemComp::checkSubItemBatch(this, &next_promote_config_ptr->cost_items);
              if ( *(_DWORD *)(v3 + 48) )
              {
                common::milog::MiLogStream::create(
                  &v76,
                  &common::milog::MiLogDefault::default_log_obj_,
                  3u,
                  "./src/player/item/player_item_comp.cpp",
                  "checkWeaponPromote",
                  7760);
                v53 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                        &v76,
                        (const char (*)[31])"checkSubItemBatch failed, ret:");
                v54 = common::milog::MiLogStream::operator<<<int,(int *)0>(v53, (const int *)(v3 + 48));
                v55 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v54, (const char (*)[6])" uid:");
                if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                  __asan_report_load8();
                val = Player::getUid(this->player_);
                v56 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v55, &val);
                v57 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(
                        v56,
                        (const char (*)[14])" target_guid:");
                common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
                  v57,
                  (const unsigned __int64 *)(v3 + 64));
                common::milog::MiLogStream::~MiLogStream(&v76);
                v8 = *(_DWORD *)(v3 + 48);
              }
              else
              {
                if ( *(_BYTE *)(((unsigned __int64)&next_promote_config_ptr->coin_cost >> 3) + 0x7FFF8000) != 0
                  && *(_BYTE *)(((unsigned __int64)&next_promote_config_ptr->coin_cost >> 3) + 0x7FFF8000) <= 3 )
                {
                  __asan_report_load4(&next_promote_config_ptr->coin_cost);
                }
                coin_cost = next_promote_config_ptr->coin_cost;
                v59 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
                v60 = Item::getItemId(v59);
                v63 = v60;
                v61 = PlayerItemComp::modifyWeaponPromoteCostScoinCostByTalent(this, v60, coin_cost);
                v62 = *(_BYTE *)(((unsigned __int64)scoin_cost >> 3) + 0x7FFF8000);
                LOBYTE(v63) = v62 != 0;
                v64 = (v62 != 0) & (unsigned __int8)((char)(((unsigned __int8)scoin_cost & 7) + 3) >= v62);
                if ( (_BYTE)v64 )
                  __asan_report_store4(scoin_cost, v63, v64);
                *scoin_cost = v61;
                if ( *scoin_cost && (*(_DWORD *)(v3 + 48) = PlayerItemComp::checkSubScoin(this, *scoin_cost)) != 0 )
                {
                  common::milog::MiLogStream::create(
                    &v76,
                    &common::milog::MiLogDefault::default_log_obj_,
                    3u,
                    "./src/player/item/player_item_comp.cpp",
                    "checkWeaponPromote",
                    7771);
                  v65 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
                          &v76,
                          (const char (*)[27])"checkSubScoin failed, uid:");
                  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                    __asan_report_load8();
                  val = Player::getUid(this->player_);
                  v66 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v65, &val);
                  v67 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(
                          v66,
                          (const char (*)[14])" target_guid:");
                  v68 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
                          v67,
                          (const unsigned __int64 *)(v3 + 64));
                  v69 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(
                          v68,
                          (const char (*)[12])" coin_cost:");
                  common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v69,
                    &next_promote_config_ptr->coin_cost);
                  common::milog::MiLogStream::~MiLogStream(&v76);
                  v8 = *(_DWORD *)(v3 + 48);
                }
                else
                {
                  v8 = 0;
                }
              }
            }
            else
            {
              common::milog::MiLogStream::create(
                &v76,
                &common::milog::MiLogDefault::default_log_obj_,
                3u,
                "./src/player/item/player_item_comp.cpp",
                "checkWeaponPromote",
                7751);
              v46 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                      &v76,
                      (const char (*)[36])"player level not enough. weapon_id:");
              v47 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
              *(_DWORD *)(v3 + 48) = Item::getItemId(v47);
              v48 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                      v46,
                      (const unsigned int *)(v3 + 48));
              v49 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
                      v48,
                      (const char (*)[21])" next_promote_level:");
              v50 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
              val = Weapon::getPromoteLevel(v50) + 1;
              v51 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v49, &val);
              v52 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v51, (const char (*)[9])" player:");
              if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                __asan_report_load8();
              operator<<(v52, this->player_);
              common::milog::MiLogStream::~MiLogStream(&v76);
              v8 = 117;
            }
          }
          else
          {
            common::milog::MiLogStream::create(
              &v76,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "checkWeaponPromote",
              7744);
            v38 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                    &v76,
                    (const char (*)[42])"findWeaponPromoteExcelConfig failed, uid:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            *(_DWORD *)(v3 + 48) = Player::getUid(this->player_);
            v39 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v38,
                    (const unsigned int *)(v3 + 48));
            v40 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(
                    v39,
                    (const char (*)[14])" target_guid:");
            v41 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
                    v40,
                    (const unsigned __int64 *)(v3 + 64));
            v42 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(
                    v41,
                    (const char (*)[16])" promote_level:");
            v43 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
            val = Weapon::getPromoteLevel(v43) + 1;
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v42, &val);
            common::milog::MiLogStream::~MiLogStream(&v76);
            v8 = -1;
          }
        }
        else
        {
          common::milog::MiLogStream::create(
            &v76,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "checkWeaponPromote",
            7736);
          v25 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                  &v76,
                  (const char (*)[36])"Weapon not satisfy need_level, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          *(_DWORD *)(v3 + 48) = Player::getUid(this->player_);
          v26 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v25,
                  (const unsigned int *)(v3 + 48));
          v27 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(
                  v26,
                  (const char (*)[14])" target_guid:");
          v28 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
                  v27,
                  (const unsigned __int64 *)(v3 + 64));
          v29 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v28, (const char (*)[8])" level:");
          v30 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
          val = Weapon::getLevel(v30);
          v31 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v29, &val);
          v32 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v31, (const char (*)[13])" need_level:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
            v32,
            &cur_promote_config_ptr->unlock_max_level);
          common::milog::MiLogStream::~MiLogStream(&v76);
          v8 = -1;
        }
      }
      else
      {
        common::milog::MiLogStream::create(
          &v76,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkWeaponPromote",
          7729);
        v17 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                &v76,
                (const char (*)[42])"findWeaponPromoteExcelConfig failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        *(_DWORD *)(v3 + 48) = Player::getUid(this->player_);
        v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v17,
                (const unsigned int *)(v3 + 48));
        v19 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v18, (const char (*)[14])" target_guid:");
        v20 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
                v19,
                (const unsigned __int64 *)(v3 + 64));
        v21 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(
                v20,
                (const char (*)[16])" promote_level:");
        v22 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
        val = Weapon::getPromoteLevel(v22);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, &val);
        common::milog::MiLogStream::~MiLogStream(&v76);
        v8 = -1;
      }
    }
    std::shared_ptr<Weapon>::~shared_ptr((std::shared_ptr<Weapon> *const)(v3 + 96));
  }
  result = v8;
  if ( v77 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 7779: range 0000000017D03060-0000000017D0386D
__int64 __fastcall PlayerItemComp::weaponPromote(PlayerItemComp *const this, __int64 target_guid, __int32 scoin_cost)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  PlayerBasicComp *BasicComp; // rax
  common::milog::MiLogStream *v7; // r14
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  unsigned int v10; // r14d
  WeaponExcelConfigMgr *p_weapon_config_mgr; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  uint32_t v13; // r15d
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v14; // rax
  uint32_t ItemId; // eax
  common::milog::MiLogStream *v16; // r14
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // r14
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // r14
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rax
  Weapon *v32; // rax
  __int64 result; // rax
  std::string v34; // [rsp+0h] [rbp-140h]
  char *v35; // [rsp+0h] [rbp-140h]
  uint32_t scoin_costa; // [rsp+Ch] [rbp-134h]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-128h]
  unsigned int val; // [rsp+24h] [rbp-11Ch] BYREF
  const data::WeaponPromoteExcelConfig *next_promote_config_ptr; // [rsp+28h] [rbp-118h]
  std::string v40; // [rsp+30h] [rbp-110h] BYREF
  char v41[240]; // [rsp+50h] [rbp-F0h] BYREF

  *(&v34._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  v34._anon_0._M_allocated_capacity = target_guid;
  HIDWORD(v34._M_string_length) = scoin_cost;
  v3 = (unsigned __int64)v41;
  v34._M_dataplus._M_p = v41;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(192LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "6 32 1 10 holer:7780 48 4 8 ret:7800 64 8 16 target_guid:7778 96 8 11 reason:7799 128 16 15 weap"
                        "on_ptr:7783 160 16 15 item_param:7809";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::weaponPromote;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556927;
  v5[536862722] = -218959360;
  v5[536862723] = -218959360;
  v5[536862724] = -219021312;
  v5[536862725] = -202178560;
  *(_QWORD *)(v3 + 64) = target_guid;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&v40, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v3 + 32), 0x6B5u, v34);
  std::string::~string(&v40);
  ItemStore::findItem<Weapon>((ItemStore *const)(v3 + 128), (uint64_t)&thisa->pack_store_, *(_QWORD *)(v3 + 64));
  if ( std::operator==<Weapon>((const std::shared_ptr<Weapon> *)(v3 + 128), 0LL) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v40,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "weaponPromote",
      7786);
    v7 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
           (common::milog::MiLogStream *const)&v40,
           (const char (*)[22])"findItem failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(thisa->player_);
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &val);
    v9 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v8, (const char (*)[14])" target_guid:");
    common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v9, (const unsigned __int64 *)(v3 + 64));
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v40);
    v10 = -1;
  }
  else
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v3 + 160));
    p_weapon_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 160))->design_config.txt_config_mgr.weapon_config_mgr;
    v12 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
    v13 = Weapon::getPromoteLevel(v12) + 1;
    v14 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
    ItemId = Item::getItemId(v14);
    next_promote_config_ptr = WeaponExcelConfigMgr::findWeaponPromoteExcelConfig(p_weapon_config_mgr, ItemId, v13);
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 160));
    if ( next_promote_config_ptr )
    {
      SubItemReason::SubItemReason((SubItemReason *const)(v3 + 96), ACTION_REASON_WEAPON_PROMOTE);
      *(_DWORD *)(v3 + 48) = PlayerItemComp::subItemBatch(
                               thisa,
                               &next_promote_config_ptr->cost_items,
                               (const SubItemReason *)(v3 + 96));
      if ( *(_DWORD *)(v3 + 48) )
      {
        common::milog::MiLogStream::create(
          (common::milog::MiLogStream *)&v40,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "weaponPromote",
          7803);
        v22 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
                (common::milog::MiLogStream *const)&v40,
                (const char (*)[26])"subItembatch failed, ret:");
        v23 = common::milog::MiLogStream::operator<<<int,(int *)0>(v22, (const int *)(v3 + 48));
        v24 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v23, (const char (*)[6])" uid:");
        if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(thisa->player_);
        v25 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, &val);
        v26 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v25, (const char (*)[14])" target_guid:");
        common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
          v26,
          (const unsigned __int64 *)(v3 + 64));
        common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v40);
        v10 = *(_DWORD *)(v3 + 48);
      }
      else if ( scoin_costa
             && (*(_QWORD *)(v3 + 160) = 0LL,
                 *(_QWORD *)(v3 + 168) = 0LL,
                 *(_DWORD *)(v3 + 160) = 202,
                 *(_DWORD *)(v3 + 164) = scoin_costa,
                 (*(_DWORD *)(v3 + 48) = PlayerItemComp::subItem(
                                           thisa,
                                           (const ItemParam *)(v3 + 160),
                                           (const SubItemReason *)(v3 + 96))) != 0) )
      {
        common::milog::MiLogStream::create(
          (common::milog::MiLogStream *)&v40,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "weaponPromote",
          7813);
        v27 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
                (common::milog::MiLogStream *const)&v40,
                (const char (*)[27])"checkSubScoin failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(thisa->player_);
        v28 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, &val);
        v29 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v28, (const char (*)[14])" target_guid:");
        v30 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
                v29,
                (const unsigned __int64 *)(v3 + 64));
        v31 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v30, (const char (*)[12])" coin_cost:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v31, &next_promote_config_ptr->coin_cost);
        common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v40);
        v10 = *(_DWORD *)(v3 + 48);
      }
      else
      {
        v32 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
        Weapon::upgradePromoteLevel(v32, 1);
        v10 = 0;
      }
    }
    else
    {
      common::milog::MiLogStream::create(
        (common::milog::MiLogStream *)&v40,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "weaponPromote",
        7794);
      v16 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
              (common::milog::MiLogStream *const)&v40,
              (const char (*)[42])"findWeaponPromoteExcelConfig failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      *(_DWORD *)(v3 + 48) = Player::getUid(thisa->player_);
      v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, (const unsigned int *)(v3 + 48));
      v18 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v17, (const char (*)[14])" target_guid:");
      v19 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
              v18,
              (const unsigned __int64 *)(v3 + 64));
      v20 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v19, (const char (*)[16])" promote_level:");
      v21 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
      val = Weapon::getPromoteLevel(v21) + 1;
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &val);
      common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v40);
      v10 = -1;
    }
  }
  std::shared_ptr<Weapon>::~shared_ptr((std::shared_ptr<Weapon> *const)(v3 + 128));
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v3 + 32));
  result = v10;
  if ( v35 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 7823: range 0000000017D0386E-0000000017D047D1
__int64 __fastcall PlayerItemComp::checkReliquaryUpgrade(
        PlayerItemComp *const this,
        uint64_t target_guid,
        const std::vector<long unsigned int> *food_guid_vec,
        const std::vector<ItemParam> *item_param_vec)
{
  unsigned int v4; // r14d
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  PlayerBasicComp *BasicComp; // rax
  common::milog::MiLogStream *v9; // r14
  std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  uint32_t Level; // r15d
  Reliquary *v12; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  __gnu_cxx::__normal_iterator<long unsigned int const*,std::vector<long unsigned int> >::reference v16; // rax
  std::__shared_ptr_access<proto_log::AntiCheatBodyReliquaryUpgradeError,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v17; // r14
  std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v18; // rax
  uint64_t Guid; // rax
  std::__shared_ptr_access<proto_log::AntiCheatBodyReliquaryUpgradeError,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v20; // r14
  std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v21; // rax
  uint32_t ItemId; // eax
  std::__shared_ptr_access<proto_log::AntiCheatBodyReliquaryUpgradeError,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v23; // r14
  std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v24; // rax
  uint32_t v25; // eax
  Player *player; // r14
  common::milog::MiLogStream *v27; // r14
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  int v30; // r15d
  common::milog::MiLogStream *v31; // r14
  common::milog::MiLogStream *v32; // rax
  common::milog::MiLogStream *v33; // rax
  common::milog::MiLogStream *v34; // r14
  common::milog::MiLogStream *v35; // rax
  common::milog::MiLogStream *v36; // rax
  Reliquary *v37; // rax
  common::milog::MiLogStream *v38; // r14
  common::milog::MiLogStream *v39; // rax
  __int64 result; // rax
  unsigned int val; // [rsp+30h] [rbp-1B0h] BYREF
  int32_t ret; // [rsp+34h] [rbp-1ACh]
  std::vector<long unsigned int>::const_iterator __for_begin; // [rsp+38h] [rbp-1A8h] BYREF
  std::vector<long unsigned int>::const_iterator __for_end; // [rsp+40h] [rbp-1A0h] BYREF
  const std::vector<long unsigned int> *__for_range; // [rsp+48h] [rbp-198h]
  common::milog::MiLogStream v48; // [rsp+50h] [rbp-190h] BYREF
  char v49[368]; // [rsp+70h] [rbp-170h] BYREF

  v5 = (unsigned __int64)v49;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_3(320LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "8 48 4 12 add_exp:7906 64 4 15 scoin_need:7907 80 8 14 food_guid:7855 112 8 16 target_guid:7822 "
                        "144 16 18 reliquary_ptr:7832 176 16 12 log_ptr:7860 208 16 23 food_reliquary_ptr:7867 240 48 18 "
                        "food_guid_set:7854";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::checkReliquaryUpgrade;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556943;
  v7[536862722] = 61956;
  v7[536862722] = -234881024;
  v7[536862723] = 62194;
  v7[536862723] = -234881024;
  v7[536862724] = 62194;
  v7[536862725] = 62194;
  v7[536862726] = 62194;
  v7[536862727] = 62194;
  v7[536862729] = -202116109;
  *(_QWORD *)(v5 + 112) = target_guid;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  if ( !PlayerBasicComp::isStateOpen(BasicComp, 0xBu) )
  {
    common::milog::MiLogStream::create(
      &v48,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkReliquaryUpgrade",
      7827);
    common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
      &v48,
      (const char (*)[39])"OPEN_STATE_RELIQUARY_UPGRADE is locked");
    common::milog::MiLogStream::~MiLogStream(&v48);
    v4 = 141;
    goto LABEL_62;
  }
  ItemStore::findItem<Reliquary>((ItemStore *const)(v5 + 144), (uint64_t)&this->pack_store_, *(_QWORD *)(v5 + 112));
  if ( std::operator==<Reliquary>((const std::shared_ptr<Reliquary> *)(v5 + 144), 0LL) )
  {
    common::milog::MiLogStream::create(
      &v48,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkReliquaryUpgrade",
      7835);
    v9 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
           &v48,
           (const char (*)[22])"findItem failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
  }
  else
  {
    v10 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 144));
    Level = Reliquary::getLevel(v10);
    v12 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 144));
    if ( Level == Reliquary::getMaxLevel(v12) )
    {
      common::milog::MiLogStream::create(
        &v48,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkReliquaryUpgrade",
        7842);
      v9 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
             &v48,
             (const char (*)[29])"Weapon reach max_level, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    else
    {
      if ( !std::vector<unsigned long>::empty(food_guid_vec) || !std::vector<ItemParam>::empty(item_param_vec) )
      {
        std::set<unsigned long>::set((std::set<long unsigned int> *const)(v5 + 240));
        __for_range = food_guid_vec;
        __for_begin._M_current = std::vector<unsigned long>::begin(food_guid_vec)._M_current;
        __for_end._M_current = std::vector<unsigned long>::end(food_guid_vec)._M_current;
        while ( __gnu_cxx::operator!=<unsigned long const*,std::vector<unsigned long>>(&__for_begin, &__for_end) )
        {
          v16 = __gnu_cxx::__normal_iterator<unsigned long const*,std::vector<unsigned long>>::operator*(&__for_begin);
          if ( *(_BYTE *)(((unsigned __int64)v16 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          *(_QWORD *)(v5 + 80) = *v16;
          if ( *(_QWORD *)(v5 + 80) == *(_QWORD *)(v5 + 112) )
          {
            common::tools::perf::make_shared<proto_log::AntiCheatBodyReliquaryUpgradeError>();
            v17 = std::__shared_ptr_access<proto_log::AntiCheatBodyReliquaryUpgradeError,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::AntiCheatBodyReliquaryUpgradeError,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 176));
            v18 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 144));
            Guid = Item::getGuid(v18);
            proto_log::AntiCheatBodyReliquaryUpgradeError::set_guid(v17, Guid);
            v20 = std::__shared_ptr_access<proto_log::AntiCheatBodyReliquaryUpgradeError,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::AntiCheatBodyReliquaryUpgradeError,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 176));
            v21 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 144));
            ItemId = Item::getItemId(v21);
            proto_log::AntiCheatBodyReliquaryUpgradeError::set_item_id(v20, ItemId);
            v23 = std::__shared_ptr_access<proto_log::AntiCheatBodyReliquaryUpgradeError,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::AntiCheatBodyReliquaryUpgradeError,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 176));
            v24 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 144));
            v25 = Reliquary::getLevel(v24);
            proto_log::AntiCheatBodyReliquaryUpgradeError::set_level(v23, v25);
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            player = this->player_;
            std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::AntiCheatBodyReliquaryUpgradeError,void>(
              (std::shared_ptr<google::protobuf::Message> *const)(v5 + 208),
              (const std::shared_ptr<proto_log::AntiCheatBodyReliquaryUpgradeError> *)(v5 + 176));
            Player::printAntiCheatLog(player, ANTI_CHEAT_ACTION_RELIQUARY_UPGRADE_ERROR, (MessagePtr *)(v5 + 208));
            std::shared_ptr<google::protobuf::Message>::~shared_ptr((std::shared_ptr<google::protobuf::Message> *const)(v5 + 208));
            v4 = -1;
            std::shared_ptr<proto_log::AntiCheatBodyReliquaryUpgradeError>::~shared_ptr((std::shared_ptr<proto_log::AntiCheatBodyReliquaryUpgradeError> *const)(v5 + 176));
            goto LABEL_60;
          }
          ItemStore::findItem<Reliquary>(
            (ItemStore *const)(v5 + 208),
            (uint64_t)&this->pack_store_,
            *(_QWORD *)(v5 + 80));
          if ( std::operator==<Reliquary>((const std::shared_ptr<Reliquary> *)(v5 + 208), 0LL) )
          {
            common::milog::MiLogStream::create(
              &v48,
              &common::milog::MiLogDefault::default_log_obj_,
              1u,
              "./src/player/item/player_item_comp.cpp",
              "checkReliquaryUpgrade",
              7870);
            v27 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
                    &v48,
                    (const char (*)[22])"findItem failed, uid:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            v28 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, &val);
            v29 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(
                    v28,
                    (const char (*)[12])" food_guid:");
            common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
              v29,
              (const unsigned __int64 *)(v5 + 80));
            common::milog::MiLogStream::~MiLogStream(&v48);
            v4 = -1;
            v30 = 0;
          }
          else if ( std::set<unsigned long>::count(
                      (const std::set<long unsigned int> *const)(v5 + 240),
                      (const std::set<long unsigned int>::key_type *)(v5 + 80)) )
          {
            common::milog::MiLogStream::create(
              &v48,
              &common::milog::MiLogDefault::default_log_obj_,
              1u,
              "./src/player/item/player_item_comp.cpp",
              "checkReliquaryUpgrade",
              7876);
            v31 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                    &v48,
                    (const char (*)[31])"duplicate food_reliquary, uid:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            v32 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v31, &val);
            v33 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
                    v32,
                    (const char (*)[22])" food_reliquary_guid:");
            common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
              v33,
              (const unsigned __int64 *)(v5 + 80));
            common::milog::MiLogStream::~MiLogStream(&v48);
            v4 = -1;
            v30 = 0;
          }
          else
          {
            std::set<unsigned long>::insert(
              (std::set<long unsigned int> *const)(v5 + 240),
              (const std::set<long unsigned int>::value_type *)(v5 + 80));
            v30 = 1;
          }
          std::shared_ptr<Reliquary>::~shared_ptr((std::shared_ptr<Reliquary> *const)(v5 + 208));
          if ( v30 != 1 )
            goto LABEL_60;
          __gnu_cxx::__normal_iterator<unsigned long const*,std::vector<unsigned long>>::operator++(&__for_begin);
        }
        ret = 0;
        if ( !std::vector<unsigned long>::empty(food_guid_vec)
          && (ret = PlayerItemComp::checkSubItemBatch(this, food_guid_vec)) != 0 )
        {
          common::milog::MiLogStream::create(
            &v48,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "checkReliquaryUpgrade",
            7890);
          v34 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
                  &v48,
                  (const char (*)[31])"checkSubItemBatch failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
        }
        else
        {
          if ( std::vector<ItemParam>::empty(item_param_vec)
            || (ret = PlayerItemComp::checkSubItemBatch(this, item_param_vec)) == 0 )
          {
            *(_DWORD *)(v5 + 48) = 0;
            *(_DWORD *)(v5 + 64) = 0;
            v37 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 144));
            if ( PlayerItemComp::getReliquaryUpgradeExp(
                   this,
                   v37,
                   food_guid_vec,
                   item_param_vec,
                   (uint32_t *)(v5 + 48),
                   (uint32_t *)(v5 + 64)) )
            {
              common::milog::MiLogStream::create(
                &v48,
                &common::milog::MiLogDefault::default_log_obj_,
                1u,
                "./src/player/item/player_item_comp.cpp",
                "checkReliquaryUpgrade",
                7910);
              v38 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                      &v48,
                      (const char (*)[36])"getReliquaryUpgradeExp failed, uid:");
              if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
                __asan_report_load8();
              val = Player::getUid(this->player_);
              common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v38, &val);
              common::milog::MiLogStream::~MiLogStream(&v48);
              v4 = -1;
            }
            else if ( (unsigned int)PlayerItemComp::checkSubScoin(this, *(_DWORD *)(v5 + 64)) )
            {
              common::milog::MiLogStream::create(
                &v48,
                &common::milog::MiLogDefault::default_log_obj_,
                1u,
                "./src/player/item/player_item_comp.cpp",
                "checkReliquaryUpgrade",
                7916);
              v39 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
                      &v48,
                      (const char (*)[33])"scoin is not enough. scoin_need:");
              common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v39,
                (const unsigned int *)(v5 + 64));
              common::milog::MiLogStream::~MiLogStream(&v48);
              v4 = 622;
            }
            else
            {
              v4 = 0;
            }
LABEL_60:
            std::set<unsigned long>::~set((std::set<long unsigned int> *const)(v5 + 240));
            goto LABEL_61;
          }
          common::milog::MiLogStream::create(
            &v48,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "checkReliquaryUpgrade",
            7900);
          v34 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
                  &v48,
                  (const char (*)[26])"checkConsume failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
        }
        val = Player::getUid(this->player_);
        v35 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v34, &val);
        v36 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v35, (const char (*)[14])" target_guid:");
        common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
          v36,
          (const unsigned __int64 *)(v5 + 112));
        common::milog::MiLogStream::~MiLogStream(&v48);
        v4 = ret;
        goto LABEL_60;
      }
      common::milog::MiLogStream::create(
        &v48,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkReliquaryUpgrade",
        7849);
      v9 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
             &v48,
             (const char (*)[30])"food_reliquary is empty, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
  }
  val = Player::getUid(this->player_);
  v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &val);
  v15 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v14, (const char (*)[14])" target_guid:");
  common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v15, (const unsigned __int64 *)(v5 + 112));
  common::milog::MiLogStream::~MiLogStream(&v48);
  v4 = -1;
LABEL_61:
  std::shared_ptr<Reliquary>::~shared_ptr((std::shared_ptr<Reliquary> *const)(v5 + 144));
LABEL_62:
  result = v4;
  if ( v49 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8018) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8024) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 7924: range 0000000017D047D2-0000000017D0518E
__int64 __fastcall PlayerItemComp::reliquaryUpgrade(
        PlayerItemComp *const this,
        uint64_t target_guid,
        const std::vector<long unsigned int> *food_guid_vec,
        uint32_t *power_up_rate,
        const std::vector<ItemParam> *item_param_vec)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  PlayerBasicComp *BasicComp; // rax
  common::milog::MiLogStream *v9; // r14
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  unsigned int v12; // r14d
  Reliquary *v13; // rax
  common::milog::MiLogStream *v14; // r14
  common::milog::MiLogStream *v15; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v16; // rax
  uint32_t v17; // ecx
  char v18; // dl
  GameserverService *v19; // rsi
  __int64 v20; // rdx
  common::milog::MiLogStream *v21; // r14
  common::milog::MiLogStream *v22; // r14
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  Reliquary *v25; // rax
  common::milog::MiLogStream *v26; // r14
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  __int64 result; // rax
  std::string v30; // [rsp+0h] [rbp-180h]
  const std::vector<ItemParam> *item_param_veca; // [rsp+8h] [rbp-178h]
  uint32_t *power_up_ratea; // [rsp+10h] [rbp-170h]
  const std::vector<long unsigned int> *food_guid_veca; // [rsp+18h] [rbp-168h]
  unsigned int val; // [rsp+3Ch] [rbp-144h] BYREF
  std::shared_ptr<Config> v35; // [rsp+40h] [rbp-140h] BYREF
  std::string v36; // [rsp+50h] [rbp-130h] BYREF
  char v37[272]; // [rsp+70h] [rbp-110h] BYREF

  *(&v30._anon_0._M_allocated_capacity + 1) = (std::string::size_type)food_guid_vec;
  v30._anon_0._M_allocated_capacity = (std::string::size_type)power_up_rate;
  v30._M_string_length = (std::string::size_type)item_param_vec;
  v5 = (unsigned __int64)v37;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(224LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "7 48 1 10 holer:7925 64 4 12 add_exp:7935 80 4 15 scoin_need:7936 96 8 16 target_guid:7923 128 8"
                        " 11 reason:7943 160 16 18 reliquary_ptr:7928 192 16 15 item_param:7944";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::reliquaryUpgrade;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234753551;
  v7[536862722] = -234556924;
  v7[536862723] = -218959360;
  v7[536862724] = -218959360;
  v7[536862725] = -219021312;
  v7[536862726] = -202178560;
  *(_QWORD *)(v5 + 96) = target_guid;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&v36, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 48), 0x6B6u, v30);
  std::string::~string(&v36);
  ItemStore::findItem<Reliquary>((ItemStore *const)(v5 + 160), (uint64_t)&this->pack_store_, *(_QWORD *)(v5 + 96));
  if ( std::operator==<Reliquary>((const std::shared_ptr<Reliquary> *)(v5 + 160), 0LL) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v36,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "reliquaryUpgrade",
      7931);
    v9 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
           (common::milog::MiLogStream *const)&v36,
           (const char (*)[22])"findItem failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &val);
    v11 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v10, (const char (*)[14])" target_guid:");
    common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v11, (const unsigned __int64 *)(v5 + 96));
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v36);
    v12 = -1;
  }
  else
  {
    *(_DWORD *)(v5 + 64) = 0;
    *(_DWORD *)(v5 + 80) = 0;
    v13 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 160));
    if ( PlayerItemComp::getReliquaryUpgradeExp(
           this,
           v13,
           food_guid_veca,
           item_param_veca,
           (uint32_t *)(v5 + 64),
           (uint32_t *)(v5 + 80)) )
    {
      common::milog::MiLogStream::create(
        (common::milog::MiLogStream *)&v36,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "reliquaryUpgrade",
        7939);
      v14 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
              (common::milog::MiLogStream *const)&v36,
              (const char (*)[36])"getReliquaryUpgradeExp failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, &val);
      common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v36);
      v12 = -1;
    }
    else
    {
      SubItemReason::SubItemReason((SubItemReason *const)(v5 + 128), ACTION_REASON_RELIC_UPGRADE);
      *(_QWORD *)(v5 + 192) = 0LL;
      *(_QWORD *)(v5 + 200) = 0LL;
      *(_DWORD *)(v5 + 192) = 202;
      *(_DWORD *)(v5 + 196) = *(_DWORD *)(v5 + 80);
      if ( PlayerItemComp::subItem(this, (const ItemParam *)(v5 + 192), (const SubItemReason *)(v5 + 128)) )
      {
        common::milog::MiLogStream::create(
          (common::milog::MiLogStream *)&v36,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "reliquaryUpgrade",
          7947);
        v15 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
                (common::milog::MiLogStream *const)&v36,
                (const char (*)[33])"scoin is not enough. scoin_need:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, (const unsigned int *)(v5 + 80));
        common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v36);
        v12 = 622;
      }
      else
      {
        v19 = ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)&v35);
        v16 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v35);
        v17 = ReliquaryExcelConfigMgr::randomPowerUpRate(&v16->design_config.txt_config_mgr.reliquary_config_mgr);
        v18 = *(_BYTE *)(((unsigned __int64)power_up_ratea >> 3) + 0x7FFF8000);
        LOBYTE(v19) = v18 != 0;
        v20 = (v18 != 0) & (unsigned __int8)((char)(((unsigned __int8)power_up_ratea & 7) + 3) >= v18);
        if ( (_BYTE)v20 )
          __asan_report_store4(power_up_ratea, v19, v20);
        *power_up_ratea = v17;
        std::shared_ptr<Config>::~shared_ptr(&v35);
        if ( *(_BYTE *)(((unsigned __int64)power_up_ratea >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)power_up_ratea & 7) + 3) >= *(_BYTE *)(((unsigned __int64)power_up_ratea >> 3)
                                                                           + 0x7FFF8000) )
        {
          __asan_report_load4(power_up_ratea);
        }
        *(_DWORD *)(v5 + 64) = SAFE_MULTIPLY<unsigned int,unsigned int>(*(_DWORD *)(v5 + 64), *power_up_ratea);
        if ( PlayerItemComp::subItemBatch(this, food_guid_veca, (const SubItemReason *)(v5 + 128)) )
        {
          common::milog::MiLogStream::create(
            (common::milog::MiLogStream *)&v36,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "reliquaryUpgrade",
            7957);
          v21 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
                  (common::milog::MiLogStream *const)&v36,
                  (const char (*)[21])"delItem failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, &val);
          common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v36);
          v12 = -1;
        }
        else if ( PlayerItemComp::subItemBatch(this, item_param_veca, (const SubItemReason *)(v5 + 128)) )
        {
          common::milog::MiLogStream::create(
            (common::milog::MiLogStream *)&v36,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "reliquaryUpgrade",
            7963);
          v22 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
                  (common::milog::MiLogStream *const)&v36,
                  (const char (*)[26])"subItemBatch failed, uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          val = Player::getUid(this->player_);
          v23 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, &val);
          v24 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(
                  v23,
                  (const char (*)[14])" target_guid:");
          common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
            v24,
            (const unsigned __int64 *)(v5 + 96));
          common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v36);
          v12 = -1;
        }
        else
        {
          v25 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 160));
          if ( Reliquary::addExp(v25, *(_DWORD *)(v5 + 64), 1) )
          {
            common::milog::MiLogStream::create(
              (common::milog::MiLogStream *)&v36,
              &common::milog::MiLogDefault::default_log_obj_,
              4u,
              "./src/player/item/player_item_comp.cpp",
              "reliquaryUpgrade",
              7969);
            v26 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
                    (common::milog::MiLogStream *const)&v36,
                    (const char (*)[27])"weapon addExp failed, uid:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            val = Player::getUid(this->player_);
            v27 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v26, &val);
            v28 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(
                    v27,
                    (const char (*)[14])" weapon_guid:");
            common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
              v28,
              (const unsigned __int64 *)(v5 + 96));
            common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v36);
            v12 = -1;
          }
          else
          {
            v12 = 0;
          }
        }
      }
    }
  }
  std::shared_ptr<Reliquary>::~shared_ptr((std::shared_ptr<Reliquary> *const)(v5 + 160));
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 48));
  result = v12;
  if ( v37 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8018) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8018) = -168430091;
  }
  return result;
};

// Line 7977: range 0000000017D05190-0000000017D0631C
int32_t __cdecl PlayerItemComp::getReliquaryUpgradeExp(
        PlayerItemComp *const this,
        Reliquary *reliquary,
        const std::vector<long unsigned int> *food_guid_vec,
        const std::vector<ItemParam> *item_param_vec,
        uint32_t *total_exp,
        uint32_t *scoin_need)
{
  int32_t v6; // r14d
  unsigned __int64 v7; // r13
  __int64 v8; // rax
  _DWORD *v9; // r12
  __m128i v10; // xmm0
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v11; // rax
  __gnu_cxx::__normal_iterator<long unsigned int const*,std::vector<long unsigned int> >::reference v12; // rax
  common::milog::MiLogStream *v13; // r14
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  int v16; // r15d
  std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v17; // rax
  common::milog::MiLogStream *v18; // r14
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // r14
  std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v21; // rax
  Reliquary *v22; // rax
  float TotalExp; // xmm0_4
  __m128i v24; // xmm0
  __m128i v25; // xmm0
  const unsigned int *v26; // rax
  _DWORD *v27; // rdx
  uint32_t *p_count; // rax
  common::milog::MiLogStream *v29; // rbx
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rax
  MaterialExcelConfigMgr *p_material_config_mgr; // rcx
  bool v33; // r14
  common::milog::MiLogStream *v34; // rax
  common::milog::MiLogStream *v35; // rax
  common::milog::MiLogStream *v36; // rcx
  __m128i v37; // xmm0
  __m128i v38; // xmm0
  const unsigned int *v39; // rax
  _DWORD *v40; // rdx
  const float *v41; // rax
  _DWORD *v42; // rdx
  ConstValueExcelConfigMgr *p_const_value_config_mgr; // r14
  uint32_t RankLevel; // eax
  common::milog::MiLogStream *v45; // rbx
  uint32_t v46; // edi
  __int64 v47; // rdx
  unsigned int *p_val; // rsi
  uint32_t *v49; // rax
  uint32_t *v50; // rdx
  uint32_t v51; // ecx
  char v52; // dl
  __int64 v53; // rdx
  ReliquaryExcelConfigMgr *p_reliquary_config_mgr; // r14
  uint32_t MaxLevel; // r15d
  uint32_t v56; // eax
  SelectType v57; // r14d
  common::milog::MiLogStream *v59; // r14
  common::milog::MiLogStream *v60; // rax
  common::milog::MiLogStream *v61; // rcx
  common::milog::MiLogStream *v62; // rax
  common::milog::MiLogStream *v63; // rax
  common::milog::MiLogStream *v64; // rax
  common::milog::MiLogStream *v65; // rax
  common::milog::MiLogStream *v66; // rax
  common::milog::MiLogStream *v67; // rax
  common::milog::MiLogStream *v68; // rax
  common::milog::MiLogStream *v69; // rax
  int32_t result; // eax
  unsigned int val; // [rsp+48h] [rbp-198h] BYREF
  float scoin_exp; // [rsp+4Ch] [rbp-194h]
  float food_reliquary_exp_discount_param; // [rsp+50h] [rbp-190h]
  float exp_0; // [rsp+54h] [rbp-18Ch]
  float discounted_exp; // [rsp+58h] [rbp-188h]
  float exp; // [rsp+5Ch] [rbp-184h]
  std::vector<long unsigned int>::const_iterator __for_begin; // [rsp+60h] [rbp-180h] BYREF
  std::vector<long unsigned int>::const_iterator __for_end; // [rsp+68h] [rbp-178h] BYREF
  const std::vector<long unsigned int> *__for_range; // [rsp+70h] [rbp-170h]
  const std::vector<ItemParam> *__for_range_0; // [rsp+78h] [rbp-168h]
  const ItemParam *item_param; // [rsp+80h] [rbp-160h]
  const data::ReliquaryExcelConfig *reliquary_excel_config_ptr; // [rsp+88h] [rbp-158h]
  common::milog::MiLogStream v89; // [rsp+90h] [rbp-150h] BYREF
  common::milog::MiLogStream v90; // [rsp+B0h] [rbp-130h] BYREF
  char v91[272]; // [rsp+D0h] [rbp-110h] BYREF

  v7 = (unsigned __int64)v91;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v8 = __asan_stack_malloc_2(224LL);
    if ( v8 )
      v7 = v8;
  }
  *(_QWORD *)v7 = 1102416563LL;
  *(_QWORD *)(v7 + 8) = "9 48 4 12 add_exp:7978 64 4 17 max_item_exp:7981 80 4 22 remain_exp_to_max:8027 96 4 18 total_ad"
                        "d_exp:8028 112 4 16 scoin_ratio:8031 128 4 24 reliquary_total_exp:8043 144 4 12 max_exp:8044 160"
                        " 8 24 food_reliquary_guid:7983 192 16 23 food_reliquary_ptr:7985";
  *(_QWORD *)(v7 + 16) = PlayerItemComp::getReliquaryUpgradeExp;
  v9 = (_DWORD *)(v7 >> 3);
  v9[536862720] = -235802127;
  v9[536862721] = -234556943;
  v9[536862722] = -234556924;
  v9[536862723] = -234556924;
  v9[536862724] = -234556924;
  v9[536862725] = -218959360;
  v9[536862726] = -202178560;
  *(_DWORD *)(v7 + 48) = 0;
  v10 = 0LL;
  scoin_exp = 0.0;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)(v7 + 192));
  v11 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192));
  *(float *)v10.m128i_i32 = ConstValueExcelConfigMgr::getFoodReliquaryExpDiscountParam(&v11->design_config.txt_config_mgr.const_value_config_mgr);
  food_reliquary_exp_discount_param = COERCE_FLOAT(_mm_cvtsi128_si32(v10));
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v7 + 192));
  *(_DWORD *)(v7 + 64) = 0;
  __for_range = food_guid_vec;
  __for_begin._M_current = std::vector<unsigned long>::begin(food_guid_vec)._M_current;
  __for_end._M_current = std::vector<unsigned long>::end(food_guid_vec)._M_current;
  while ( __gnu_cxx::operator!=<unsigned long const*,std::vector<unsigned long>>(&__for_begin, &__for_end) )
  {
    v12 = __gnu_cxx::__normal_iterator<unsigned long const*,std::vector<unsigned long>>::operator*(&__for_begin);
    if ( *(_BYTE *)(((unsigned __int64)v12 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    *(_QWORD *)(v7 + 160) = *v12;
    ItemStore::findItem<Reliquary>((ItemStore *const)(v7 + 192), (uint64_t)&this->pack_store_, *(_QWORD *)(v7 + 160));
    if ( std::operator==<Reliquary>((const std::shared_ptr<Reliquary> *)(v7 + 192), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v90,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "getReliquaryUpgradeExp",
        7988);
      v13 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
              &v90,
              (const char (*)[22])"findItem failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, &val);
      v15 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v14, (const char (*)[14])" target_guid:");
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
        v15,
        (const unsigned __int64 *)(v7 + 160));
      common::milog::MiLogStream::~MiLogStream(&v90);
      v6 = -1;
      v16 = 0;
    }
    else
    {
      v17 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192));
      reliquary_excel_config_ptr = Reliquary::getReliquaryConfig(v17);
      if ( reliquary_excel_config_ptr )
      {
        v22 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192));
        TotalExp = (float)(int)Reliquary::getTotalExp(v22);
        discounted_exp = TotalExp * food_reliquary_exp_discount_param;
        if ( *(_BYTE *)(((unsigned __int64)&reliquary_excel_config_ptr->base_conv_exp >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&reliquary_excel_config_ptr->base_conv_exp >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&reliquary_excel_config_ptr->base_conv_exp);
        }
        v24 = _mm_cvtsi32_si128(LODWORD(scoin_exp));
        *(float *)v24.m128i_i32 = SAFE_ADD<float,unsigned int>(
                                    *(float *)v24.m128i_i32,
                                    reliquary_excel_config_ptr->base_conv_exp);
        scoin_exp = COERCE_FLOAT(_mm_cvtsi128_si32(v24));
        if ( *(_BYTE *)(((unsigned __int64)&reliquary_excel_config_ptr->base_conv_exp >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&reliquary_excel_config_ptr->base_conv_exp >> 3) + 0x7FFF8000) <= 3 )
        {
          *(double *)v24.m128i_i64 = __asan_report_load4(&reliquary_excel_config_ptr->base_conv_exp);
        }
        *(float *)v24.m128i_i32 = std::ceil(
                                    (float)((float)(int)reliquary_excel_config_ptr->base_conv_exp + discounted_exp)
                                  - 0.00000011920929);
        exp = COERCE_FLOAT(_mm_cvtsi128_si32(v24));
        v25 = _mm_cvtsi32_si128(*(_DWORD *)(v7 + 48));
        *(float *)v25.m128i_i32 = SAFE_ADD<float,float>(*(float *)v25.m128i_i32, exp);
        *(_DWORD *)(v7 + 48) = _mm_cvtsi128_si32(v25);
        val = (int)exp;
        v26 = std::max<unsigned int>((const unsigned int *)(v7 + 64), &val);
        v27 = v26;
        if ( *(_BYTE *)(((unsigned __int64)v26 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v26 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v26 >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(v26);
        }
        *(_DWORD *)(v7 + 64) = *v27;
        v16 = 1;
      }
      else
      {
        common::milog::MiLogStream::create(
          &v90,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "getReliquaryUpgradeExp",
          7995);
        v18 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
                &v90,
                (const char (*)[38])"findReliquaryExcelConfig failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        *(_DWORD *)(v7 + 144) = Player::getUid(this->player_);
        v19 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v18,
                (const unsigned int *)(v7 + 144));
        v20 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v19, (const char (*)[15])" reliquary_id:");
        v21 = std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Reliquary,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192));
        val = Item::getItemId(v21);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, &val);
        common::milog::MiLogStream::~MiLogStream(&v90);
        v6 = -1;
        v16 = 0;
      }
    }
    std::shared_ptr<Reliquary>::~shared_ptr((std::shared_ptr<Reliquary> *const)(v7 + 192));
    if ( v16 != 1 )
      goto LABEL_65;
    __gnu_cxx::__normal_iterator<unsigned long const*,std::vector<unsigned long>>::operator++(&__for_begin);
  }
  __for_range_0 = item_param_vec;
  __for_begin._M_current = (const unsigned __int64 *)std::vector<ItemParam>::begin(item_param_vec)._M_current;
  __for_end._M_current = (const unsigned __int64 *)std::vector<ItemParam>::end(__for_range_0)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(
            (const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *)&__for_begin,
            (const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *)&__for_end) )
  {
    item_param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*((const __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *const)&__for_begin);
    p_count = &item_param->count;
    if ( *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)p_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(p_count);
    }
    if ( !item_param->count )
    {
      common::milog::MiLogStream::create(
        &v89,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "getReliquaryUpgradeExp",
        8010);
      v29 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
              &v89,
              (const char (*)[28])"item_param count is 0, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      val = Player::getUid(this->player_);
      v30 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v29, &val);
      v31 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v30, (const char (*)[10])" item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v31, &item_param->item_id);
      common::milog::MiLogStream::~MiLogStream(&v89);
      v6 = -1;
      goto LABEL_65;
    }
    *(_DWORD *)(v7 + 144) = 0;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v7 + 192));
    p_material_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192))->design_config.txt_config_mgr.material_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_param);
    }
    v33 = MaterialExcelConfigMgr::findReliquaryExpByMaterialId(
            p_material_config_mgr,
            item_param->item_id,
            (uint32_t *)(v7 + 144)) != 0;
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v7 + 192));
    if ( v33 )
    {
      common::milog::MiLogStream::create(
        &v90,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "getReliquaryUpgradeExp",
        8017);
      v34 = common::milog::MiLogStream::operator<<<char [47],(char *[47])0>(
              &v90,
              (const char (*)[47])"findReliquaryExpByMaterialId fail, item_param:");
      v35 = operator<<(v34, item_param);
      v36 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v35, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v36, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v90);
      v6 = -1;
      goto LABEL_65;
    }
    exp_0 = (float)*(int *)(v7 + 144);
    if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&item_param->count);
    }
    v37 = _mm_cvtsi32_si128(LODWORD(scoin_exp));
    *(float *)v37.m128i_i32 = SAFE_ADD<float,float>(*(float *)v37.m128i_i32, (float)(int)item_param->count * exp_0);
    scoin_exp = COERCE_FLOAT(_mm_cvtsi128_si32(v37));
    if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&item_param->count);
    }
    v38 = _mm_cvtsi32_si128(*(_DWORD *)(v7 + 48));
    *(float *)v38.m128i_i32 = SAFE_ADD<float,float>(*(float *)v38.m128i_i32, (float)(int)item_param->count * exp_0);
    *(_DWORD *)(v7 + 48) = _mm_cvtsi128_si32(v38);
    val = (int)exp_0;
    v39 = std::max<unsigned int>((const unsigned int *)(v7 + 64), &val);
    v40 = v39;
    if ( *(_BYTE *)(((unsigned __int64)v39 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v39 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v39 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v39);
    }
    *(_DWORD *)(v7 + 64) = *v40;
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++((__gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > *const)&__for_begin);
  }
  *(float *)(v7 + 80) = (float)(int)Reliquary::getRemainExpToMax(reliquary);
  *(_DWORD *)(v7 + 96) = (int)(float)(*(float *)(v7 + 48) + 0.00000011920929);
  v41 = std::min<float>((const float *)(v7 + 48), (const float *)(v7 + 80));
  v42 = v41;
  if ( *(_BYTE *)(((unsigned __int64)v41 >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)v41 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v41 >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(v41);
  }
  *(_DWORD *)(v7 + 48) = *v42;
  *(_DWORD *)(v7 + 112) = 0;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)(v7 + 192));
  p_const_value_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192))->design_config.txt_config_mgr.const_value_config_mgr;
  RankLevel = Reliquary::getRankLevel(reliquary);
  LOBYTE(p_const_value_config_mgr) = ConstValueExcelConfigMgr::getReliquaryScoinRatio(
                                       p_const_value_config_mgr,
                                       RankLevel,
                                       (float *)(v7 + 112)) != 0;
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v7 + 192));
  if ( (_BYTE)p_const_value_config_mgr )
  {
    common::milog::MiLogStream::create(
      &v90,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "getReliquaryUpgradeExp",
      8034);
    v45 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
            &v90,
            (const char (*)[41])"getReliquaryScoinRatio fail. rank_level:");
    val = Reliquary::getRankLevel(reliquary);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v45, &val);
    common::milog::MiLogStream::~MiLogStream(&v90);
    v6 = -1;
  }
  else
  {
    v46 = (int)(float)(*(float *)(v7 + 48) + 0.00000011920929);
    v47 = (*(_BYTE *)(((unsigned __int64)total_exp >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((unsigned __int8)total_exp & 7) + 3) >= *(_BYTE *)(((unsigned __int64)total_exp >> 3) + 0x7FFF8000));
    if ( (_BYTE)v47 )
    {
      v46 = (unsigned int)total_exp;
      __asan_report_store4(total_exp, ((unsigned __int8)total_exp & 7u) + 3, v47);
    }
    *total_exp = v46;
    val = (int)(float)(*(float *)(v7 + 112) * scoin_exp);
    *(_DWORD *)(v7 + 144) = 1;
    p_val = &val;
    v49 = (uint32_t *)std::max<unsigned int>((const unsigned int *)(v7 + 144), &val);
    v50 = v49;
    if ( *(_BYTE *)(((unsigned __int64)v49 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v49 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v49 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v49);
    }
    v51 = *v50;
    v52 = *(_BYTE *)(((unsigned __int64)scoin_need >> 3) + 0x7FFF8000);
    LOBYTE(p_val) = v52 != 0;
    v53 = (v52 != 0) & (unsigned __int8)((char)(((unsigned __int8)scoin_need & 7) + 3) >= v52);
    if ( (_BYTE)v53 )
      __asan_report_store4(scoin_need, p_val, v53);
    *scoin_need = v51;
    *(_DWORD *)(v7 + 128) = Reliquary::getTotalExp(reliquary);
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v7 + 192));
    p_reliquary_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 192))->design_config.txt_config_mgr.reliquary_config_mgr;
    MaxLevel = Reliquary::getMaxLevel(reliquary);
    v56 = Reliquary::getRankLevel(reliquary);
    *(_DWORD *)(v7 + 144) = ReliquaryExcelConfigMgr::getTotalExpToLevel(p_reliquary_config_mgr, v56, MaxLevel);
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v7 + 192));
    if ( *(_DWORD *)(v7 + 64)
      && (v57 = SAFE_ADD<unsigned int,unsigned int>(*(_DWORD *)(v7 + 144), *(_DWORD *)(v7 + 64)),
          v57 <= SAFE_ADD<unsigned int,unsigned int>(*(_DWORD *)(v7 + 128), *(_DWORD *)(v7 + 96))) )
    {
      common::milog::MiLogStream::create(
        &v90,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "getReliquaryUpgradeExp",
        8047);
      v59 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(&v90, (const char (*)[14])"reliquary_id:");
      val = Item::getItemId(reliquary);
      v60 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v59, &val);
      v61 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v60, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v62 = operator<<(v61, this->player_);
      v63 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v62, (const char (*)[10])" max_exp:");
      v64 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
              v63,
              (const unsigned int *)(v7 + 144));
      v65 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v64, (const char (*)[15])" max_item_exp:");
      v66 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v65, (const unsigned int *)(v7 + 64));
      v67 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
              v66,
              (const char (*)[22])" reliquary_total_exp:");
      v68 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
              v67,
              (const unsigned int *)(v7 + 128));
      v69 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v68, (const char (*)[16])" total_add_exp:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v69, (const unsigned int *)(v7 + 96));
      common::milog::MiLogStream::~MiLogStream(&v90);
      v6 = -1;
    }
    else
    {
      v6 = 0;
    }
  }
LABEL_65:
  result = v6;
  if ( v91 == (char *)v7 )
  {
    *(_QWORD *)((v7 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v7 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v7 >> 3) + 0x7FFF8010) = 0LL;
    *(_DWORD *)((v7 >> 3) + 0x7FFF8018) = 0;
  }
  else
  {
    *(_QWORD *)v7 = 1172321806LL;
    *(_QWORD *)((v7 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v7 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v7 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v7 >> 3) + 0x7FFF8018) = -168430091;
  }
  return result;
};

// Line 8056: range 0000000017D0631E-0000000017D07630
__int64 __fastcall PlayerItemComp::checkWeaponAwaken(
        PlayerItemComp *const this,
        Weapon *weapon,
        uint64_t food_weapon_guid,
        const std::map<unsigned int,unsigned int> *affix_level_map)
{
  unsigned int v4; // r14d
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  PlayerBasicComp *BasicComp; // rax
  common::milog::MiLogStream *v9; // r14
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // r14
  common::milog::MiLogStream *v13; // r14
  common::milog::MiLogStream *v14; // r14
  common::milog::MiLogStream *v15; // r14
  PlayerItemComp *ItemComp; // rax
  common::milog::MiLogStream *v17; // r14
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  int v20; // r15d
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v21; // rax
  uint32_t ItemId; // r15d
  common::milog::MiLogStream *v23; // r14
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // r14
  std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v26; // rax
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // r14
  common::milog::MiLogStream *v29; // r14
  std::pair<unsigned int const,unsigned int> *v30; // rax
  std::pair<unsigned int const,unsigned int> *v31; // rdx
  std::tuple_element<1,const std::pair<unsigned int const,unsigned int> >::type *v32; // rax
  common::milog::MiLogStream *v33; // rax
  const unsigned int *M_current; // r14
  std::vector<unsigned int>::const_iterator v35; // rax
  common::milog::MiLogStream *v36; // r14
  common::milog::MiLogStream *v37; // rax
  common::milog::MiLogStream *v38; // rax
  EquipAffixExcelConfigMgr *p_equip_affix_config_mgr; // rcx
  common::milog::MiLogStream *v40; // rax
  unsigned int v41; // r14d
  unsigned int AffixLevel; // eax
  common::milog::MiLogStream *v43; // rax
  common::milog::MiLogStream *v44; // rax
  common::milog::MiLogStream *v45; // rax
  common::milog::MiLogStream *v46; // rax
  common::milog::MiLogStream *v47; // rax
  std::vector<unsigned int>::size_type v48; // r14
  common::milog::MiLogStream *v50; // rax
  __int64 result; // rax
  bool all_max_level; // [rsp+3Bh] [rbp-1C5h]
  int32_t ret; // [rsp+3Ch] [rbp-1C4h]
  std::map<unsigned int,unsigned int>::const_iterator __for_begin; // [rsp+40h] [rbp-1C0h] BYREF
  std::map<unsigned int,unsigned int>::const_iterator __for_end; // [rsp+48h] [rbp-1B8h] BYREF
  __gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int> > __lhs; // [rsp+50h] [rbp-1B0h] BYREF
  __gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int> > __rhs; // [rsp+58h] [rbp-1A8h] BYREF
  const data::WeaponExcelConfig *weapon_excel_config_ptr; // [rsp+60h] [rbp-1A0h]
  const std::vector<unsigned int> *affix_vec; // [rsp+68h] [rbp-198h]
  const std::map<unsigned int,unsigned int> *__for_range; // [rsp+70h] [rbp-190h]
  std::tuple_element<0,const std::pair<unsigned int const,unsigned int> >::type *affix_id; // [rsp+78h] [rbp-188h]
  std::tuple_element<1,const std::pair<unsigned int const,unsigned int> >::type *delta_affix_level; // [rsp+80h] [rbp-180h]
  std::pair<unsigned int const,unsigned int> v65; // [rsp+88h] [rbp-178h] BYREF
  common::milog::MiLogStream v66; // [rsp+90h] [rbp-170h] BYREF
  common::milog::MiLogStream v67; // [rsp+B0h] [rbp-150h] BYREF
  common::milog::MiLogStream v68; // [rsp+D0h] [rbp-130h] BYREF
  common::milog::MiLogStream v69; // [rsp+F0h] [rbp-110h] BYREF
  char v70[240]; // [rsp+110h] [rbp-F0h] BYREF

  v5 = (unsigned __int64)v70;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(192LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "6 48 4 28 total_delta_affix_level:8134 64 4 20 affix_max_level:8149 80 4 20 new_affix_level:8155"
                        " 96 8 21 food_weapon_guid:8055 128 16 19 del_item_param:8072 160 16 15 item_param:8097";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::checkWeaponAwaken;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556943;
  v7[536862722] = -234556924;
  v7[536862723] = -218959360;
  v7[536862724] = -219021312;
  v7[536862725] = -202178560;
  *(_QWORD *)(v5 + 96) = food_weapon_guid;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  if ( !PlayerBasicComp::isStateOpen(BasicComp, 6u) )
  {
    common::milog::MiLogStream::create(
      &v69,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponAwaken",
      8060);
    v9 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
           &v69,
           (const char (*)[41])"OPEN_STATE_WEAPON_AWAKEN is locked. uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    *(_DWORD *)(v5 + 80) = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v5 + 80));
    common::milog::MiLogStream::~MiLogStream(&v69);
    v4 = 141;
    goto LABEL_76;
  }
  if ( Item::getGuid(weapon) == *(_QWORD *)(v5 + 96) )
  {
    common::milog::MiLogStream::create(
      &v69,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponAwaken",
      8067);
    v10 = common::milog::MiLogStream::operator<<<char [59],(char *[59])0>(
            &v69,
            (const char (*)[59])"require anti-cheat check, weapon.guid == food_weapon_guid:");
    v11 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
            v10,
            (const unsigned __int64 *)(v5 + 96));
    v12 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v11, (const char (*)[7])", uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    *(_DWORD *)(v5 + 80) = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v12, (const unsigned int *)(v5 + 80));
    common::milog::MiLogStream::~MiLogStream(&v69);
    v4 = -1;
    goto LABEL_76;
  }
  *(_DWORD *)(v5 + 128) = 0;
  *(_DWORD *)(v5 + 132) = 0;
  *(_DWORD *)(v5 + 136) = 0;
  *(_DWORD *)(v5 + 140) = 0;
  *(_DWORD *)(v5 + 128) = 202;
  if ( Weapon::calcAwakenScoinCost(weapon, (uint32_t *)(v5 + 132)) )
  {
    common::milog::MiLogStream::create(
      &v69,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponAwaken",
      8076);
    v13 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
            &v69,
            (const char (*)[37])"calcAwakenScoinCost fail, weapon_id:");
    *(_DWORD *)(v5 + 80) = Item::getItemId(weapon);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v5 + 80));
    common::milog::MiLogStream::~MiLogStream(&v69);
    v4 = -1;
    goto LABEL_76;
  }
  if ( PlayerItemComp::checkSubItem(this, (const ItemParam *)(v5 + 128)) )
  {
    common::milog::MiLogStream::create(
      &v69,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponAwaken",
      8083);
    v14 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
            &v69,
            (const char (*)[26])"checkSubItem failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    *(_DWORD *)(v5 + 80) = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, (const unsigned int *)(v5 + 80));
    common::milog::MiLogStream::~MiLogStream(&v69);
    v4 = 609;
    goto LABEL_76;
  }
  weapon_excel_config_ptr = Weapon::getWeaponExcelConfig(weapon);
  if ( !weapon_excel_config_ptr )
  {
    common::milog::MiLogStream::create(
      &v69,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponAwaken",
      8090);
    v15 = common::milog::MiLogStream::operator<<<char [47],(char *[47])0>(
            &v69,
            (const char (*)[47])"weapon_excel_config_ptr is nullptr, weapon_id:");
    *(_DWORD *)(v5 + 80) = Item::getItemId(weapon);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, (const unsigned int *)(v5 + 80));
    common::milog::MiLogStream::~MiLogStream(&v69);
    v4 = -1;
    goto LABEL_76;
  }
  if ( *(_BYTE *)(((unsigned __int64)&weapon_excel_config_ptr->awaken_material >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&weapon_excel_config_ptr->awaken_material >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&weapon_excel_config_ptr->awaken_material);
  }
  if ( !weapon_excel_config_ptr->awaken_material )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    ItemComp = Player::getItemComp(this->player_);
    PlayerItemComp::findItemInPack<Weapon>((PlayerItemComp *const)(v5 + 160), (uint64_t)ItemComp);
    if ( std::operator==<Weapon>((const std::shared_ptr<Weapon> *)(v5 + 160), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v69,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponAwaken",
        8110);
      v17 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
              &v69,
              (const char (*)[24])"findWeapon failed, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
LABEL_32:
      *(_DWORD *)(v5 + 80) = Player::getUid(this->player_);
      v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, (const unsigned int *)(v5 + 80));
      v19 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(
              v18,
              (const char (*)[19])" food_weapon_guid:");
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v19, (const unsigned __int64 *)(v5 + 96));
      common::milog::MiLogStream::~MiLogStream(&v69);
      v4 = -1;
      v20 = 0;
      goto LABEL_42;
    }
    v21 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 160));
    ItemId = Item::getItemId(v21);
    if ( ItemId == Item::getItemId(weapon) )
    {
      if ( PlayerItemComp::checkSubItem(this, *(_QWORD *)(v5 + 96)) )
      {
        common::milog::MiLogStream::create(
          &v69,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkWeaponAwaken",
          8121);
        v17 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
                &v69,
                (const char (*)[26])"checkConsume failed, uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_32;
      }
      v20 = 1;
    }
    else
    {
      common::milog::MiLogStream::create(
        &v69,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponAwaken",
        8115);
      v23 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(
              &v69,
              (const char (*)[38])"weaponAwaken not same weapon_id, uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      *(_DWORD *)(v5 + 48) = Player::getUid(this->player_);
      v24 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v23, (const unsigned int *)(v5 + 48));
      v25 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v24, (const char (*)[17])" food_weapon_id:");
      v26 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 160));
      *(_DWORD *)(v5 + 64) = Item::getItemId(v26);
      v27 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v25, (const unsigned int *)(v5 + 64));
      v28 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
              v27,
              (const char (*)[21])", target's weapon_id");
      *(_DWORD *)(v5 + 80) = Item::getItemId(weapon);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v28, (const unsigned int *)(v5 + 80));
      common::milog::MiLogStream::~MiLogStream(&v69);
      v4 = -1;
      v20 = 0;
    }
LABEL_42:
    std::shared_ptr<Weapon>::~shared_ptr((std::shared_ptr<Weapon> *const)(v5 + 160));
    if ( v20 != 1 )
      goto LABEL_76;
    goto LABEL_43;
  }
  *(_QWORD *)(v5 + 160) = 0LL;
  *(_QWORD *)(v5 + 168) = 0LL;
  *(_DWORD *)(v5 + 164) = 1;
  *(_DWORD *)(v5 + 160) = weapon_excel_config_ptr->awaken_material;
  ret = PlayerItemComp::checkSubItem(this, (const ItemParam *)(v5 + 160));
  if ( ret )
  {
    v4 = ret;
    goto LABEL_76;
  }
LABEL_43:
  affix_vec = &weapon_excel_config_ptr->skill_affix;
  if ( std::vector<unsigned int>::empty(&weapon_excel_config_ptr->skill_affix) )
  {
    common::milog::MiLogStream::create(
      &v69,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkWeaponAwaken",
      8130);
    v29 = common::milog::MiLogStream::operator<<<char [32],(char *[32])0>(
            &v69,
            (const char (*)[32])"weapon has no affix, weapon_id:");
    *(_DWORD *)(v5 + 80) = Item::getItemId(weapon);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v29, (const unsigned int *)(v5 + 80));
    common::milog::MiLogStream::~MiLogStream(&v69);
    v4 = -1;
  }
  else
  {
    *(_DWORD *)(v5 + 48) = 0;
    all_max_level = 1;
    __for_range = affix_level_map;
    __for_begin._M_node = std::map<unsigned int,unsigned int>::begin(affix_level_map)._M_node;
    __for_end._M_node = std::map<unsigned int,unsigned int>::end(affix_level_map)._M_node;
    while ( std::operator!=(&__for_begin, &__for_end) )
    {
      v30 = (std::pair<unsigned int const,unsigned int> *)std::_Rb_tree_const_iterator<std::pair<unsigned int const,unsigned int>>::operator*(&__for_begin);
      v31 = v30;
      if ( ((unsigned __int8)v30 & 7) >= *(_BYTE *)(((unsigned __int64)v30 >> 3) + 0x7FFF8000)
        && *(_BYTE *)(((unsigned __int64)v30 >> 3) + 0x7FFF8000) != 0
        || *(_BYTE *)((((unsigned __int64)&v30->second + 3) >> 3) + 0x7FFF8000) != 0
        && (((unsigned __int8)v30 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v30->second + 3) >> 3) + 0x7FFF8000) )
      {
        __asan_report_load_n(v30, 8LL);
      }
      v65 = *v31;
      affix_id = std::get<0ul,unsigned int const,unsigned int>(&v65);
      v32 = (std::tuple_element<1,const std::pair<unsigned int const,unsigned int> >::type *)std::get<1ul,unsigned int const,unsigned int>(&v65);
      delta_affix_level = v32;
      if ( *(_BYTE *)(((unsigned __int64)v32 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v32 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v32 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v32);
      }
      *(_DWORD *)(v5 + 48) = SAFE_ADD<unsigned int,unsigned int>(*(_DWORD *)(v5 + 48), *delta_affix_level);
      if ( *(_BYTE *)(((unsigned __int64)delta_affix_level >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)delta_affix_level & 7) + 3) >= *(_BYTE *)(((unsigned __int64)delta_affix_level >> 3)
                                                                            + 0x7FFF8000) )
      {
        __asan_report_load4(delta_affix_level);
      }
      if ( !*delta_affix_level )
      {
        common::milog::MiLogStream::create(
          &v66,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkWeaponAwaken",
          8141);
        v33 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(
                &v66,
                (const char (*)[19])"delta_affix_level:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v33, delta_affix_level);
        common::milog::MiLogStream::~MiLogStream(&v66);
        v4 = -1;
        goto LABEL_76;
      }
      __rhs._M_current = std::vector<unsigned int>::end(affix_vec)._M_current;
      M_current = std::vector<unsigned int>::end(affix_vec)._M_current;
      v35._M_current = std::vector<unsigned int>::begin(affix_vec)._M_current;
      __lhs._M_current = std::find<__gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int>>,unsigned int>(
                           v35,
                           (__gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int> >)M_current,
                           affix_id)._M_current;
      if ( __gnu_cxx::operator==<unsigned int const*,std::vector<unsigned int>>(&__lhs, &__rhs) )
      {
        common::milog::MiLogStream::create(
          &v67,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkWeaponAwaken",
          8146);
        v36 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(&v67, (const char (*)[8])"weapon:");
        *(_DWORD *)(v5 + 80) = Item::getItemId(weapon);
        v37 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v36,
                (const unsigned int *)(v5 + 80));
        v38 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                v37,
                (const char (*)[17])" not have affix:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v38, affix_id);
        common::milog::MiLogStream::~MiLogStream(&v67);
        v4 = -1;
        goto LABEL_76;
      }
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)(v5 + 160));
      p_equip_affix_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 160))->design_config.txt_config_mgr.equip_affix_config_mgr;
      if ( *(_BYTE *)(((unsigned __int64)affix_id >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)affix_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)affix_id >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(affix_id);
      }
      *(_DWORD *)(v5 + 64) = EquipAffixExcelConfigMgr::findEquipAffixMaxLevel(p_equip_affix_config_mgr, *affix_id);
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v5 + 160));
      if ( *(int *)(v5 + 64) <= 0 )
      {
        common::milog::MiLogStream::create(
          &v68,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkWeaponAwaken",
          8152);
        v40 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                &v68,
                (const char (*)[37])"affix max level not found, affix_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v40, affix_id);
        common::milog::MiLogStream::~MiLogStream(&v68);
        v4 = -1;
        goto LABEL_76;
      }
      if ( *(_BYTE *)(((unsigned __int64)delta_affix_level >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)delta_affix_level & 7) + 3) >= *(_BYTE *)(((unsigned __int64)delta_affix_level >> 3)
                                                                            + 0x7FFF8000) )
      {
        __asan_report_load4(delta_affix_level);
      }
      v41 = *delta_affix_level;
      if ( *(_BYTE *)(((unsigned __int64)affix_id >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)affix_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)affix_id >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(affix_id);
      }
      AffixLevel = Weapon::getAffixLevel(weapon, *affix_id);
      *(_DWORD *)(v5 + 80) = SAFE_ADD<unsigned int,unsigned int>(AffixLevel, v41);
      if ( *(_DWORD *)(v5 + 80) > *(_DWORD *)(v5 + 64) )
      {
        common::milog::MiLogStream::create(
          &v69,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkWeaponAwaken",
          8158);
        v43 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(&v69, (const char (*)[10])"affix_id:");
        v44 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v43, affix_id);
        v45 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v44, (const char (*)[12])" new_level:");
        v46 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v45,
                (const unsigned int *)(v5 + 80));
        v47 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v46, (const char (*)[12])" max_level:");
        common::milog::MiLogStream::operator<<<int,(int *)0>(v47, (const int *)(v5 + 64));
        common::milog::MiLogStream::~MiLogStream(&v69);
        v4 = -1;
        goto LABEL_76;
      }
      all_max_level = all_max_level && *(_DWORD *)(v5 + 80) == *(_DWORD *)(v5 + 64);
      std::_Rb_tree_const_iterator<std::pair<unsigned int const,unsigned int>>::operator++(&__for_begin);
    }
    if ( !*(_DWORD *)(v5 + 48)
      || (v48 = *(unsigned int *)(v5 + 48), v48 < std::vector<unsigned int>::size(affix_vec)) && !all_max_level )
    {
      common::milog::MiLogStream::create(
        &v69,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkWeaponAwaken",
        8165);
      v50 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(
              &v69,
              (const char (*)[25])"total_delta_affix_level:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v50, (const unsigned int *)(v5 + 48));
      common::milog::MiLogStream::~MiLogStream(&v69);
      v4 = -1;
    }
    else
    {
      v4 = 0;
    }
  }
LABEL_76:
  result = v4;
  if ( v70 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0LL;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 8172: range 0000000017D07632-0000000017D07F4E
__int64 __fastcall PlayerItemComp::weaponAwaken(
        PlayerItemComp *const this,
        Weapon *weapon,
        __int64 food_weapon_guid,
        std::map<unsigned int,unsigned int> *affix_level_map)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  PlayerBasicComp *BasicComp; // rax
  common::milog::MiLogStream *v8; // r14
  unsigned int v9; // r14d
  common::milog::MiLogStream *v10; // r14
  common::milog::MiLogStream *v11; // r14
  common::milog::MiLogStream *v12; // r14
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  proto_log::PlayerLogBodyWeaponAwaken *v15; // rax
  proto_log::WeaponLog *v16; // rax
  proto_log::PlayerLogBodyWeaponAwaken *v17; // rax
  Player *player; // r14
  unsigned int *v19; // r8
  unsigned int *v20; // r9
  PlayerEventComp *EventComp; // r14
  __int64 result; // rax
  std::string affix_level_mapa; // [rsp+0h] [rbp-190h]
  const std::map<unsigned int,unsigned int> *affix_level_mapb; // [rsp+0h] [rbp-190h]
  Weapon *weapona; // [rsp+10h] [rbp-180h]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-178h]
  unsigned int ItemId; // [rsp+24h] [rbp-16Ch] BYREF
  unsigned int val; // [rsp+28h] [rbp-168h] BYREF
  int32_t ret; // [rsp+2Ch] [rbp-164h]
  unsigned int v30[2]; // [rsp+30h] [rbp-160h] BYREF
  const data::WeaponExcelConfig *weapon_excel_config_ptr; // [rsp+38h] [rbp-158h]
  std::string v32; // [rsp+40h] [rbp-150h] BYREF
  char v33[304]; // [rsp+60h] [rbp-130h] BYREF

  *(&affix_level_mapa._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  affix_level_mapa._anon_0._M_allocated_capacity = (std::string::size_type)weapon;
  affix_level_mapa._M_string_length = food_weapon_guid;
  affix_level_mapa._M_dataplus._M_p = (std::string::pointer)affix_level_map;
  v4 = (unsigned __int64)v33;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(256LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "7 48 1 11 holder:8173 64 8 21 food_weapon_guid:8171 96 8 11 reason:8184 128 16 19 del_item_param"
                        ":8176 160 16 26 weapon_awaken_log_ptr:8221 192 16 14 event_ptr:8228 224 16 15 item_param:8202";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::weaponAwaken;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234753551;
  v6[536862722] = -218959360;
  v6[536862723] = -218959360;
  v6[536862724] = -219021312;
  v6[536862725] = -219021312;
  v6[536862726] = -219021312;
  v6[536862727] = -202178560;
  *(_QWORD *)(v4 + 64) = affix_level_mapa._M_string_length;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&v32, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 48), 0x6B3u, affix_level_mapa);
  std::string::~string(&v32);
  *(_DWORD *)(v4 + 128) = 0;
  *(_DWORD *)(v4 + 132) = 0;
  *(_DWORD *)(v4 + 136) = 0;
  *(_DWORD *)(v4 + 140) = 0;
  *(_DWORD *)(v4 + 128) = 202;
  if ( Weapon::calcAwakenScoinCost(weapona, (uint32_t *)(v4 + 132)) )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v32,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "weaponAwaken",
      8180);
    v8 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
           (common::milog::MiLogStream *const)&v32,
           (const char (*)[37])"calcAwakenScoinCost fail, weapon_id:");
    val = Item::getItemId(weapona);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, &val);
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v32);
    v9 = -1;
    goto LABEL_30;
  }
  SubItemReason::SubItemReason((SubItemReason *const)(v4 + 96), ACTION_REASON_WEAPON_AWAKEN);
  ret = PlayerItemComp::subItem(thisa, (const ItemParam *)(v4 + 128), (const SubItemReason *)(v4 + 96));
  if ( ret )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v32,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "weaponAwaken",
      8188);
    v10 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
            (common::milog::MiLogStream *const)&v32,
            (const char (*)[21])"subItem failed, uid:");
    if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(thisa->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, &val);
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v32);
    v9 = 609;
    goto LABEL_30;
  }
  weapon_excel_config_ptr = Weapon::getWeaponExcelConfig(weapona);
  if ( !weapon_excel_config_ptr )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v32,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "weaponAwaken",
      8195);
    v11 = common::milog::MiLogStream::operator<<<char [47],(char *[47])0>(
            (common::milog::MiLogStream *const)&v32,
            (const char (*)[47])"weapon_excel_config_ptr is nullptr, weapon_id:");
    val = Item::getItemId(weapona);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &val);
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v32);
    v9 = -1;
    goto LABEL_30;
  }
  if ( *(_BYTE *)(((unsigned __int64)&weapon_excel_config_ptr->awaken_material >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&weapon_excel_config_ptr->awaken_material >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&weapon_excel_config_ptr->awaken_material);
  }
  if ( weapon_excel_config_ptr->awaken_material )
  {
    *(_QWORD *)(v4 + 224) = 0LL;
    *(_QWORD *)(v4 + 232) = 0LL;
    *(_DWORD *)(v4 + 228) = 1;
    *(_DWORD *)(v4 + 224) = weapon_excel_config_ptr->awaken_material;
    ret = PlayerItemComp::subItem(thisa, (const ItemParam *)(v4 + 224), (const SubItemReason *)(v4 + 96));
    if ( ret )
    {
      v9 = ret;
      goto LABEL_30;
    }
    goto LABEL_23;
  }
  ret = PlayerItemComp::subItem(thisa, *(_QWORD *)(v4 + 64), (const SubItemReason *)(v4 + 96));
  if ( !ret )
  {
LABEL_23:
    common::tools::perf::make_shared<proto_log::PlayerLogBodyWeaponAwaken>();
    v15 = std::__shared_ptr_access<proto_log::PlayerLogBodyWeaponAwaken,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyWeaponAwaken,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 160));
    v16 = proto_log::PlayerLogBodyWeaponAwaken::mutable_weapon_log(v15);
    Weapon::getWeaponLog(weapona, v16);
    ret = Weapon::upgradeAffixLevel(weapona, affix_level_mapb, 1);
    if ( !ret )
    {
      v17 = std::__shared_ptr_access<proto_log::PlayerLogBodyWeaponAwaken,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<proto_log::PlayerLogBodyWeaponAwaken,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 160));
      Weapon::getWeaponAwakenLog(weapona, v17);
      if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      player = thisa->player_;
      std::shared_ptr<google::protobuf::Message>::shared_ptr(
        (std::shared_ptr<google::protobuf::Message> *const)(v4 + 224),
        0LL);
      std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodyWeaponAwaken,void>(
        (std::shared_ptr<google::protobuf::Message> *const)(v4 + 192),
        (const std::shared_ptr<proto_log::PlayerLogBodyWeaponAwaken> *)(v4 + 160));
      Player::printStatLog(player, (MessagePtr *)(v4 + 192), (MessagePtr *)(v4 + 224), 0xEu);
      std::shared_ptr<google::protobuf::Message>::~shared_ptr((std::shared_ptr<google::protobuf::Message> *const)(v4 + 192));
      std::shared_ptr<google::protobuf::Message>::~shared_ptr((std::shared_ptr<google::protobuf::Message> *const)(v4 + 224));
      val = Weapon::getAwakenLevel(weapona);
      ItemId = Item::getItemId(weapona);
      *(_QWORD *)v30 = Item::getGuid(weapona);
      common::tools::perf::make_shared<WeaponAwakenEvent,unsigned long,unsigned int,unsigned int>(
        (unsigned __int64 *)(v4 + 192),
        v30,
        &ItemId,
        (unsigned __int64 *)&val,
        v19,
        v20);
      if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      EventComp = Player::getEventComp(thisa->player_);
      std::shared_ptr<BaseEvent>::shared_ptr<WeaponAwakenEvent,void>(
        (std::shared_ptr<BaseEvent> *const)(v4 + 224),
        (const std::shared_ptr<WeaponAwakenEvent> *)(v4 + 192));
      PlayerEventComp::notifyEvent(EventComp, (BaseEventPtr *)(v4 + 224));
      std::shared_ptr<BaseEvent>::~shared_ptr((std::shared_ptr<BaseEvent> *const)(v4 + 224));
      std::shared_ptr<WeaponAwakenEvent>::~shared_ptr((std::shared_ptr<WeaponAwakenEvent> *const)(v4 + 192));
    }
    v9 = ret;
    std::shared_ptr<proto_log::PlayerLogBodyWeaponAwaken>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodyWeaponAwaken> *const)(v4 + 160));
    goto LABEL_30;
  }
  common::milog::MiLogStream::create(
    (common::milog::MiLogStream *)&v32,
    &common::milog::MiLogDefault::default_log_obj_,
    3u,
    "./src/player/item/player_item_comp.cpp",
    "weaponAwaken",
    8215);
  v12 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
          (common::milog::MiLogStream *const)&v32,
          (const char (*)[21])"subItem failed, uid:");
  if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  val = Player::getUid(thisa->player_);
  v13 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v12, &val);
  v14 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(v13, (const char (*)[19])" food_weapon_guid:");
  common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v14, (const unsigned __int64 *)(v4 + 64));
  common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v32);
  v9 = ret;
LABEL_30:
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 48));
  result = v9;
  if ( v33 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 8236: range 0000000017D07F50-0000000017D0811C
int32_t __cdecl PlayerItemComp::setEquipLockState(PlayerItemComp *const this, EquipPtr *p_equip_ptr, bool is_locked)
{
  std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v4; // rax
  common::milog::MiLogStream *v5; // rbx
  std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rbx
  std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  Equip *v10; // rax
  std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v11; // rax
  unsigned int val; // [rsp+24h] [rbp-3Ch] BYREF
  unsigned __int64 Guid; // [rsp+28h] [rbp-38h] BYREF
  common::milog::MiLogStream v15; // [rsp+30h] [rbp-30h] BYREF

  if ( std::operator==<Equip>(0LL, p_equip_ptr) )
  {
    common::milog::MiLogStream::create(
      &v15,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "setEquipLockState",
      8239);
    common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(&v15, (const char (*)[18])"equip_ptr nullptr");
    common::milog::MiLogStream::~MiLogStream(&v15);
    return -1;
  }
  else
  {
    v4 = std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false> *const)p_equip_ptr);
    if ( is_locked == Equip::getIsLocked(v4) )
    {
      common::milog::MiLogStream::create(
        &v15,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "setEquipLockState",
        8244);
      v5 = common::milog::MiLogStream::operator<<<char [51],(char *[51])0>(
             &v15,
             (const char (*)[51])"equip_ptr target lock state has been set, item_id:");
      v6 = std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false> *const)p_equip_ptr);
      val = Item::getItemId(v6);
      v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, &val);
      v8 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v7, (const char (*)[8])", guid:");
      v9 = std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false> *const)p_equip_ptr);
      Guid = Item::getGuid(v9);
      common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v8, &Guid);
      common::milog::MiLogStream::~MiLogStream(&v15);
    }
    else
    {
      v10 = std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false> *const)p_equip_ptr);
      Equip::setIsLocked(v10, is_locked);
      v11 = std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Equip,(__gnu_cxx::_Lock_policy)2,false,false> *const)p_equip_ptr);
      Item::notifyItemChange(v11);
    }
    return 0;
  }
};

// Line 8255: range 0000000017D0811E-0000000017D08492
void __cdecl PlayerItemComp::notifyAllItemCd(PlayerItemComp *const this)
{
  unsigned __int64 v1; // r12
  __int64 v2; // rax
  _DWORD *v3; // r13
  PlayerBasicComp *BasicComp; // rax
  std::__shared_ptr_access<proto::ItemCdGroupTimeNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> >::pointer v6; // rax
  std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> >::pointer v7; // rax
  uint64_t v8; // r14
  unsigned __int64 v9; // rax
  Player *player; // r14
  std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> >::_Self __y; // [rsp+10h] [rbp-E0h] BYREF
  uint64_t now_ms; // [rsp+18h] [rbp-D8h]
  google::protobuf::Map<unsigned int,long unsigned int> *cd_map; // [rsp+20h] [rbp-D0h]
  uint64_t cd_time; // [rsp+28h] [rbp-C8h]
  std::shared_ptr<proto::ItemCdGroupTimeNotify> __r; // [rsp+30h] [rbp-C0h] BYREF
  char v16[176]; // [rsp+40h] [rbp-B0h] BYREF

  v1 = (unsigned __int64)v16;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v2 = __asan_stack_malloc_1(128LL);
    if ( v2 )
      v1 = v2;
  }
  *(_QWORD *)v1 = 1102416563LL;
  *(_QWORD *)(v1 + 8) = "3 48 4 16 cd_group_id:8262 64 8 9 iter:8260 96 16 15 notify_ptr:8258";
  *(_QWORD *)(v1 + 16) = PlayerItemComp::notifyAllItemCd;
  v3 = (_DWORD *)(v1 >> 3);
  v3[536862720] = -235802127;
  v3[536862721] = -234556943;
  v3[536862722] = -218959360;
  v3[536862723] = -202178560;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  now_ms = PlayerBasicComp::getPlayerTimeMs(BasicComp);
  common::tools::perf::make_shared<proto::ItemCdGroupTimeNotify>();
  v5 = std::__shared_ptr_access<proto::ItemCdGroupTimeNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemCdGroupTimeNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v1 + 96));
  cd_map = proto::ItemCdGroupTimeNotify::mutable_item_cd_map(v5);
  *(std::map<unsigned int,long unsigned int>::iterator *)(v1 + 64) = std::map<unsigned int,unsigned long>::begin(&this->item_cd_map_);
  while ( 1 )
  {
    __y._M_node = std::map<unsigned int,unsigned long>::end(&this->item_cd_map_)._M_node;
    if ( !std::operator!=(
            (const std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> >::_Self *)(v1 + 64),
            &__y) )
      break;
    v6 = std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned long>>::operator->((const std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> > *const)(v1 + 64));
    if ( *(_BYTE *)(((unsigned __int64)v6 >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)v6 >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(v6);
    }
    *(_DWORD *)(v1 + 48) = v6->first;
    v7 = std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned long>>::operator->((const std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> > *const)(v1 + 64));
    if ( *(_BYTE *)(((unsigned __int64)&v7->second >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    cd_time = v7->second;
    if ( now_ms >= cd_time )
    {
      *(std::map<unsigned int,long unsigned int>::iterator *)(v1 + 64) = std::map<unsigned int,unsigned long>::erase[abi:cxx11](
                                                                           &this->item_cd_map_,
                                                                           *(std::map<unsigned int,long unsigned int>::iterator *)(v1 + 64));
    }
    else
    {
      v8 = cd_time;
      v9 = (unsigned __int64)google::protobuf::Map<unsigned int,unsigned long>::operator[](
                               cd_map,
                               (const google::protobuf::Map<unsigned int,long unsigned int>::key_type *)(v1 + 48));
      if ( *(_BYTE *)((v9 >> 3) + 0x7FFF8000) )
        v9 = __asan_report_store8(v9, v1 + 48);
      *(_QWORD *)v9 = v8;
      std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned long>>::operator++((std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> > *const)(v1 + 64));
    }
  }
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  player = this->player_;
  std::dynamic_pointer_cast<google::protobuf::Message const,proto::ItemCdGroupTimeNotify>(&__r);
  Player::sendMessage(player, (common::minet::ConstMessagePtr *)&__r, 0LL);
  std::shared_ptr<google::protobuf::Message const>::~shared_ptr((std::shared_ptr<const google::protobuf::Message> *const)&__r);
  std::shared_ptr<proto::ItemCdGroupTimeNotify>::~shared_ptr((std::shared_ptr<proto::ItemCdGroupTimeNotify> *const)(v1 + 96));
  if ( v16 == (char *)v1 )
  {
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v1 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v1 = 1172321806LL;
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v1 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 8279: range 0000000017D08494-0000000017D08850
void __cdecl PlayerItemComp::updateItemCd(PlayerItemComp *const this, const data::MaterialExcelConfig *material_config)
{
  unsigned __int64 v2; // r12
  __int64 v3; // rax
  _DWORD *v4; // r13
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  PlayerBasicComp *BasicComp; // rax
  std::map<unsigned int,long unsigned int>::mapped_type *v7; // rax
  uint64_t v8; // rcx
  std::__shared_ptr_access<proto::ItemCdGroupTimeNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  __int64 v10; // r14
  unsigned __int64 v11; // rax
  Player *player; // r14
  uint32_t cd_time; // [rsp+14h] [rbp-BCh]
  uint64_t now_ms; // [rsp+18h] [rbp-B8h]
  uint64_t *item_cd; // [rsp+20h] [rbp-B0h]
  google::protobuf::Map<unsigned int,long unsigned int> *cd_map; // [rsp+28h] [rbp-A8h]
  std::shared_ptr<const google::protobuf::Message> v17; // [rsp+30h] [rbp-A0h] BYREF
  char v18[144]; // [rsp+40h] [rbp-90h] BYREF

  v2 = (unsigned __int64)v18;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(96LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "2 48 4 16 cd_group_id:8280 64 16 15 notify_ptr:8296";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::updateItemCd;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234556943;
  v4[536862722] = -202178560;
  if ( *(_BYTE *)(((unsigned __int64)&material_config->cd_group >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)material_config + 84) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config->cd_group >> 3)
                                                                   + 0x7FFF8000) )
  {
    __asan_report_load4(&material_config->cd_group);
  }
  *(_DWORD *)(v2 + 48) = material_config->cd_group;
  if ( *(_DWORD *)(v2 + 48) )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v17);
    v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v17);
    cd_time = MaterialExcelConfigMgr::findCdGroupTime(
                &v5->design_config.txt_config_mgr.material_config_mgr,
                *(_DWORD *)(v2 + 48));
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)&v17);
    if ( cd_time )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      BasicComp = Player::getBasicComp(this->player_);
      now_ms = PlayerBasicComp::getPlayerTimeMs(BasicComp);
      v7 = std::map<unsigned int,unsigned long>::operator[](
             &this->item_cd_map_,
             (const std::map<unsigned int,long unsigned int>::key_type *)(v2 + 48));
      item_cd = v7;
      v8 = 1000LL * cd_time + now_ms;
      if ( *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) )
        __asan_report_store8(v7, v2 + 48);
      *item_cd = v8;
      common::tools::perf::make_shared<proto::ItemCdGroupTimeNotify>();
      v9 = std::__shared_ptr_access<proto::ItemCdGroupTimeNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemCdGroupTimeNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 64));
      cd_map = proto::ItemCdGroupTimeNotify::mutable_item_cd_map(v9);
      if ( *(_BYTE *)(((unsigned __int64)item_cd >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v10 = *item_cd;
      v11 = (unsigned __int64)google::protobuf::Map<unsigned int,unsigned long>::operator[](
                                cd_map,
                                (const google::protobuf::Map<unsigned int,long unsigned int>::key_type *)(v2 + 48));
      if ( *(_BYTE *)((v11 >> 3) + 0x7FFF8000) )
        v11 = __asan_report_store8(v11, v2 + 48);
      *(_QWORD *)v11 = v10;
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      player = this->player_;
      std::dynamic_pointer_cast<google::protobuf::Message const,proto::ItemCdGroupTimeNotify>((const std::shared_ptr<proto::ItemCdGroupTimeNotify> *)&v17);
      Player::sendMessage(player, &v17, 0LL);
      std::shared_ptr<google::protobuf::Message const>::~shared_ptr(&v17);
      std::shared_ptr<proto::ItemCdGroupTimeNotify>::~shared_ptr((std::shared_ptr<proto::ItemCdGroupTimeNotify> *const)(v2 + 64));
    }
  }
  if ( v18 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 8304: range 0000000017D08852-0000000017D08A77
bool __cdecl PlayerItemComp::isItemInCd(PlayerItemComp *const this, const data::MaterialExcelConfig *material_config)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  _DWORD *v4; // r12
  bool result; // al
  PlayerBasicComp *BasicComp; // rax
  std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> >::pointer v7; // rax
  std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> >::_Self __y; // [rsp+10h] [rbp-90h] BYREF
  uint64_t now_ms; // [rsp+18h] [rbp-88h]
  char v10[128]; // [rsp+20h] [rbp-80h] BYREF

  v2 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(96LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "2 48 4 16 cd_group_id:8305 64 8 9 iter:8311";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::isItemInCd;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234556943;
  v4[536862722] = -202116352;
  if ( *(_BYTE *)(((unsigned __int64)&material_config->cd_group >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)material_config + 84) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config->cd_group >> 3)
                                                                   + 0x7FFF8000) )
  {
    __asan_report_load4(&material_config->cd_group);
  }
  *(_DWORD *)(v2 + 48) = material_config->cd_group;
  if ( *(_DWORD *)(v2 + 48) )
  {
    *(std::map<unsigned int,long unsigned int>::iterator *)(v2 + 64) = std::map<unsigned int,unsigned long>::find(
                                                                         &this->item_cd_map_,
                                                                         (const std::map<unsigned int,long unsigned int>::key_type *)(v2 + 48));
    __y._M_node = std::map<unsigned int,unsigned long>::end(&this->item_cd_map_)._M_node;
    if ( std::operator==(
           (const std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> >::_Self *)(v2 + 64),
           &__y) )
    {
      result = 0;
    }
    else
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      BasicComp = Player::getBasicComp(this->player_);
      now_ms = PlayerBasicComp::getPlayerTimeMs(BasicComp);
      v7 = std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned long>>::operator->((const std::_Rb_tree_iterator<std::pair<unsigned int const,long unsigned int> > *const)(v2 + 64));
      if ( *(_BYTE *)(((unsigned __int64)&v7->second >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      result = now_ms < v7->second;
    }
  }
  else
  {
    result = 0;
  }
  if ( v10 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 8323: range 0000000017D08A78-0000000017D08D41
void __cdecl PlayerItemComp::clearItemCdByGm(PlayerItemComp *const this, bool is_notify)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  std::__shared_ptr_access<proto::ItemCdGroupTimeNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  std::tuple_element<1,std::pair<unsigned int const,long unsigned int> >::type *v6; // rax
  std::tuple_element<1,std::pair<unsigned int const,long unsigned int> >::type v7; // r14
  std::tuple_element<0,std::pair<unsigned int const,long unsigned int> >::type *v8; // rsi
  unsigned __int64 v9; // rax
  Player *player; // r14
  std::map<unsigned int,long unsigned int>::iterator __for_begin; // [rsp+18h] [rbp-B8h] BYREF
  std::map<unsigned int,long unsigned int>::iterator __for_end; // [rsp+20h] [rbp-B0h] BYREF
  google::protobuf::Map<unsigned int,long unsigned int> *cd_map; // [rsp+28h] [rbp-A8h]
  std::map<unsigned int,long unsigned int> *__for_range; // [rsp+30h] [rbp-A0h]
  std::pair<unsigned int const,long unsigned int> *__in; // [rsp+38h] [rbp-98h]
  std::tuple_element<0,std::pair<unsigned int const,long unsigned int> >::type *cd_group_id; // [rsp+40h] [rbp-90h]
  std::tuple_element<1,std::pair<unsigned int const,long unsigned int> >::type *cd_time_ms; // [rsp+48h] [rbp-88h]
  std::shared_ptr<proto::ItemCdGroupTimeNotify> __r; // [rsp+50h] [rbp-80h] BYREF
  char v20[112]; // [rsp+60h] [rbp-70h] BYREF

  v2 = (unsigned __int64)v20;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 16 15 notify_ptr:8324";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::clearItemCdByGm;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202178560;
  common::tools::perf::make_shared<proto::ItemCdGroupTimeNotify>();
  v5 = std::__shared_ptr_access<proto::ItemCdGroupTimeNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::ItemCdGroupTimeNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 32));
  cd_map = proto::ItemCdGroupTimeNotify::mutable_item_cd_map(v5);
  __for_range = &this->item_cd_map_;
  __for_begin._M_node = std::map<unsigned int,unsigned long>::begin(&this->item_cd_map_)._M_node;
  __for_end._M_node = std::map<unsigned int,unsigned long>::end(&this->item_cd_map_)._M_node;
  while ( std::operator!=(&__for_begin, &__for_end) )
  {
    __in = std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned long>>::operator*(&__for_begin);
    cd_group_id = std::get<0ul,unsigned int const,unsigned long>(__in);
    v6 = std::get<1ul,unsigned int const,unsigned long>(__in);
    cd_time_ms = v6;
    if ( *(_BYTE *)(((unsigned __int64)v6 >> 3) + 0x7FFF8000) )
      __asan_report_store8(v6, &__for_end);
    *cd_time_ms = 0LL;
    v7 = *cd_time_ms;
    v8 = cd_group_id;
    v9 = (unsigned __int64)google::protobuf::Map<unsigned int,unsigned long>::operator[](cd_map, cd_group_id);
    if ( *(_BYTE *)((v9 >> 3) + 0x7FFF8000) )
      v9 = __asan_report_store8(v9, v8);
    *(_QWORD *)v9 = v7;
    std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned long>>::operator++(&__for_begin);
  }
  if ( is_notify )
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    player = this->player_;
    std::dynamic_pointer_cast<google::protobuf::Message const,proto::ItemCdGroupTimeNotify>(&__r);
    Player::sendMessage(player, (common::minet::ConstMessagePtr *)&__r, 0LL);
    std::shared_ptr<google::protobuf::Message const>::~shared_ptr((std::shared_ptr<const google::protobuf::Message> *const)&__r);
  }
  std::shared_ptr<proto::ItemCdGroupTimeNotify>::~shared_ptr((std::shared_ptr<proto::ItemCdGroupTimeNotify> *const)(v2 + 32));
  if ( v20 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 8344: range 0000000017D08D42-0000000017D08D99
void __cdecl PlayerItemComp::logPlayerAddCoin(
        PlayerItemComp *const this,
        proto::VirtualItem virtual_item,
        int64_t old_count,
        int64_t new_count,
        uint32_t reason_type,
        data::ItemLimitType limit_type,
        bool is_pay_method)
{
  PlayerItemComp::logPlayerAddCoin(
    this,
    virtual_item,
    old_count,
    new_count,
    reason_type,
    limit_type,
    is_pay_method,
    0,
    0);
};

// Line 8356: range 0000000017D08D9A-0000000017D0927E
void __cdecl PlayerItemComp::logPlayerAddCoin(
        PlayerItemComp *const this,
        proto::VirtualItem virtual_item,
        int64_t old_count,
        int64_t new_count,
        uint32_t reason_type,
        data::ItemLimitType limit_type,
        bool is_pay_method,
        bool is_mcoin,
        uint32_t platform_type)
{
  unsigned __int64 v9; // r12
  __int64 v10; // rax
  _DWORD *v11; // r13
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v13; // rdx
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v14; // rdx
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v15; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v16; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v17; // rdx
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v18; // rdx
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v19; // rdx
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v20; // rdx
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v21; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v22; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v23; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v24; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v25; // rdx
  std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v26; // rdx
  std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v27; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v28; // r14
  uint32_t PCMPlatformType; // edx
  int64_t RealLeftMcoin; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v31; // r14
  uint32_t PsnPlatformType; // edx
  int64_t v33; // rax
  Player *player; // r14
  int64_t add_num; // [rsp+38h] [rbp-B8h]
  std::shared_ptr<google::protobuf::Message> p_body_ptr; // [rsp+40h] [rbp-B0h] BYREF
  std::shared_ptr<google::protobuf::Message> p_body_ext_ptr; // [rsp+50h] [rbp-A0h] BYREF
  char v42[144]; // [rsp+60h] [rbp-90h] BYREF

  v9 = (unsigned __int64)v42;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v10 = __asan_stack_malloc_1(96LL);
    if ( v10 )
      v9 = v10;
  }
  *(_QWORD *)v9 = 1102416563LL;
  *(_QWORD *)(v9 + 8) = "2 32 16 21 add_coin_log_ptr:8357 64 16 25 add_coin_ext_log_ptr:8381";
  *(_QWORD *)(v9 + 16) = PlayerItemComp::logPlayerAddCoin;
  v11 = (_DWORD *)(v9 >> 3);
  v11[536862720] = -235802127;
  v11[536862721] = -219021312;
  v11[536862722] = -202178560;
  common::tools::perf::make_shared<proto_log::PlayerLogBodyAddCoin>();
  v12 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 32));
  proto_log::PlayerLogBodyAddCoin::set_coin_id(v12, virtual_item);
  add_num = new_count - old_count;
  v13 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 32));
  proto_log::PlayerLogBodyAddCoin::set_add_num(v13, new_count - old_count);
  if ( is_pay_method )
  {
    v14 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 32));
    proto_log::PlayerLogBodyAddCoin::set_pay_add(v14, add_num);
    v15 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 32));
    proto_log::PlayerLogBodyAddCoin::set_free_add(v15, 0LL);
  }
  else
  {
    v16 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 32));
    proto_log::PlayerLogBodyAddCoin::set_pay_add(v16, 0LL);
    v17 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 32));
    proto_log::PlayerLogBodyAddCoin::set_free_add(v17, add_num);
  }
  v18 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 32));
  proto_log::PlayerLogBodyAddCoin::set_left_num(v18, new_count);
  v19 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 32));
  proto_log::PlayerLogBodyAddCoin::set_free_left(v19, new_count);
  v20 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 32));
  proto_log::PlayerLogBodyAddCoin::set_pay_left(v20, new_count);
  v21 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 32));
  proto_log::PlayerLogBodyAddCoin::set_reason(v21, reason_type);
  common::tools::perf::make_shared<proto_log::PlayerLogBodyExtAddCoin>();
  v22 = std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 64));
  proto_log::PlayerLogBodyExtAddCoin::set_reason_type(v22, reason_type);
  v23 = std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 64));
  proto_log::PlayerLogBodyExtAddCoin::set_item_limit_type(v23, limit_type);
  if ( is_mcoin )
  {
    if ( TxtConfigMgr::isPsnPlatform(platform_type) )
    {
      v24 = std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 64));
      proto_log::PlayerLogBodyExtAddCoin::set_pcm_mcoin_add_num(v24, 0LL);
      v25 = std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 64));
      proto_log::PlayerLogBodyExtAddCoin::set_psn_mcoin_add_num(v25, add_num);
    }
    else
    {
      v26 = std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 64));
      proto_log::PlayerLogBodyExtAddCoin::set_pcm_mcoin_add_num(v26, add_num);
      v27 = std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 64));
      proto_log::PlayerLogBodyExtAddCoin::set_psn_mcoin_add_num(v27, 0LL);
    }
    v28 = std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 64));
    PCMPlatformType = TxtConfigMgr::getPCMPlatformType();
    RealLeftMcoin = PlayerItemComp::getRealLeftMcoin(this, PCMPlatformType);
    proto_log::PlayerLogBodyExtAddCoin::set_pcm_mcoin_left_num(v28, RealLeftMcoin);
    v31 = std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyExtAddCoin,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v9 + 64));
    PsnPlatformType = TxtConfigMgr::getPsnPlatformType();
    v33 = PlayerItemComp::getRealLeftMcoin(this, PsnPlatformType);
    proto_log::PlayerLogBodyExtAddCoin::set_psn_mcoin_left_num(v31, v33);
  }
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  player = this->player_;
  std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodyExtAddCoin,void>(
    &p_body_ext_ptr,
    (const std::shared_ptr<proto_log::PlayerLogBodyExtAddCoin> *)(v9 + 64));
  std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodyAddCoin,void>(
    &p_body_ptr,
    (const std::shared_ptr<proto_log::PlayerLogBodyAddCoin> *)(v9 + 32));
  Player::printStatLog(player, &p_body_ptr, &p_body_ext_ptr, 0xEu);
  std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ptr);
  std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ext_ptr);
  std::shared_ptr<proto_log::PlayerLogBodyExtAddCoin>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodyExtAddCoin> *const)(v9 + 64));
  std::shared_ptr<proto_log::PlayerLogBodyAddCoin>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodyAddCoin> *const)(v9 + 32));
  if ( v42 == (char *)v9 )
  {
    *(_QWORD *)((v9 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v9 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v9 = 1172321806LL;
    *(_QWORD *)((v9 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v9 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 8406: range 0000000017D09280-0000000017D0955B
void __cdecl PlayerItemComp::getRewardLog(PlayerItemComp *const this, proto_log::RewardLog *reward_log)
{
  RewardExcelConfigMgr *p_reward_config_mgr; // rbx
  uint32_t v3; // eax
  common::milog::MiLogStream *v4; // rbx
  unsigned int val; // [rsp+1Ch] [rbp-74h] BYREF
  std::vector<data::RewardItemConfig>::const_iterator __for_begin; // [rsp+20h] [rbp-70h] BYREF
  std::vector<data::RewardItemConfig>::const_iterator __for_end; // [rsp+28h] [rbp-68h] BYREF
  const data::RewardExcelConfig *reward_config_ptr; // [rsp+30h] [rbp-60h]
  const std::vector<data::RewardItemConfig> *__for_range; // [rsp+38h] [rbp-58h]
  const data::RewardItemConfig *reward_item_config; // [rsp+40h] [rbp-50h]
  proto_log::EquipLog *log_ptr; // [rsp+48h] [rbp-48h]
  std::shared_ptr<Config> v12; // [rsp+50h] [rbp-40h] BYREF
  common::milog::MiLogStream v13; // [rsp+60h] [rbp-30h] BYREF

  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v12);
  p_reward_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v12)->design_config.txt_config_mgr.reward_config_mgr;
  v3 = proto_log::RewardLog::reward_id(reward_log);
  reward_config_ptr = data::RewardExcelConfigMgrBase::findRewardExcelConfig(p_reward_config_mgr, v3);
  std::shared_ptr<Config>::~shared_ptr(&v12);
  if ( reward_config_ptr )
  {
    __for_range = &reward_config_ptr->reward_item_list;
    __for_begin._M_current = std::vector<data::RewardItemConfig>::begin(&reward_config_ptr->reward_item_list)._M_current;
    __for_end._M_current = std::vector<data::RewardItemConfig>::end(&reward_config_ptr->reward_item_list)._M_current;
    while ( __gnu_cxx::operator!=<data::RewardItemConfig const*,std::vector<data::RewardItemConfig>>(
              &__for_begin,
              &__for_end) )
    {
      reward_item_config = __gnu_cxx::__normal_iterator<data::RewardItemConfig const*,std::vector<data::RewardItemConfig>>::operator*(&__for_begin);
      log_ptr = proto_log::RewardLog::add_add_equip_list(reward_log);
      if ( *(_BYTE *)(((unsigned __int64)&reward_item_config->item_id >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&reward_item_config->item_id >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&reward_item_config->item_id);
      }
      proto_log::EquipLog::set_item_id(log_ptr, reward_item_config->item_id);
      if ( *(_BYTE *)(((unsigned __int64)&reward_item_config->item_count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)reward_item_config + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reward_item_config->item_count >> 3)
                                                                          + 0x7FFF8000) )
      {
        __asan_report_load4(&reward_item_config->item_count);
      }
      proto_log::EquipLog::set_item_num(log_ptr, reward_item_config->item_count);
      if ( *(_BYTE *)(((unsigned __int64)&reward_item_config->level >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&reward_item_config->level >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&reward_item_config->level);
      }
      proto_log::EquipLog::set_item_level(log_ptr, reward_item_config->level);
      if ( *(_BYTE *)(((unsigned __int64)&reward_item_config->promote_level >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)reward_item_config + 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reward_item_config->promote_level >> 3)
                                                                          + 0x7FFF8000) )
      {
        __asan_report_load4(&reward_item_config->promote_level);
      }
      proto_log::EquipLog::set_promote_level(log_ptr, reward_item_config->promote_level);
      __gnu_cxx::__normal_iterator<data::RewardItemConfig const*,std::vector<data::RewardItemConfig>>::operator++(&__for_begin);
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v13,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "getRewardLog",
      8410);
    v4 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
           &v13,
           (const char (*)[44])"find reward excel config failed, reward_id:");
    val = proto_log::RewardLog::reward_id(reward_log);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v4, &val);
    common::milog::MiLogStream::~MiLogStream(&v13);
  }
};

// Line 8426: range 0000000017D0955C-0000000017D09769
void __cdecl PlayerItemComp::notifyDropHint(
        PlayerItemComp *const this,
        const uint32_t item_id,
        const Vector3 *position)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  unsigned __int64 v5; // r13
  std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v6; // rax
  std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  proto::Vector *v8; // rax
  Player *player; // r14
  std::shared_ptr<proto::DropHintNotify> __r; // [rsp+20h] [rbp-A0h] BYREF
  proto::Vector from; // [rsp+30h] [rbp-90h] BYREF
  char v13[112]; // [rsp+50h] [rbp-70h] BYREF

  v3 = (unsigned __int64)v13;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_0(64LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 16 25 drop_hint_notify_ptr:8427";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::notifyDropHint;
  v5 = v3 >> 3;
  *(_DWORD *)(v5 + 2147450880) = -235802127;
  *(_DWORD *)(v5 + 2147450884) = -202178560;
  common::tools::perf::make_shared<proto::DropHintNotify>();
  v6 = std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 32));
  proto::DropHintNotify::add_item_id_list(v6, item_id);
  Vector3::operator proto::Vector(&from, position);
  v7 = std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 32));
  v8 = proto::DropHintNotify::mutable_position(v7);
  proto::Vector::operator=(v8, &from);
  proto::Vector::~Vector(&from);
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  player = this->player_;
  std::dynamic_pointer_cast<google::protobuf::Message const,proto::DropHintNotify>(&__r);
  Player::sendMessage(player, (common::minet::ConstMessagePtr *)&__r, 0LL);
  std::shared_ptr<google::protobuf::Message const>::~shared_ptr((std::shared_ptr<const google::protobuf::Message> *const)&__r);
  std::shared_ptr<proto::DropHintNotify>::~shared_ptr((std::shared_ptr<proto::DropHintNotify> *const)(v3 + 32));
  if ( v13 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 8434: range 0000000017D0976A-0000000017D09A3B
void __cdecl PlayerItemComp::notifyDropHint(
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec,
        const Vector3 *position)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  unsigned __int64 v5; // r13
  std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v6; // rcx
  std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  proto::Vector *v8; // rax
  Player *player; // r14
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+20h] [rbp-C0h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+28h] [rbp-B8h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+30h] [rbp-B0h]
  const ItemParam *item_param; // [rsp+38h] [rbp-A8h]
  std::shared_ptr<proto::DropHintNotify> __r; // [rsp+40h] [rbp-A0h] BYREF
  proto::Vector from; // [rsp+50h] [rbp-90h] BYREF
  char v17[112]; // [rsp+70h] [rbp-70h] BYREF

  v3 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_0(64LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 16 25 drop_hint_notify_ptr:8435";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::notifyDropHint;
  v5 = v3 >> 3;
  *(_DWORD *)(v5 + 2147450880) = -235802127;
  *(_DWORD *)(v5 + 2147450884) = -202178560;
  common::tools::perf::make_shared<proto::DropHintNotify>();
  __for_range = item_param_vec;
  __for_begin._M_current = std::vector<ItemParam>::begin(item_param_vec)._M_current;
  __for_end._M_current = std::vector<ItemParam>::end(item_param_vec)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
  {
    item_param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
    v6 = std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 32));
    if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_param);
    }
    proto::DropHintNotify::add_item_id_list(v6, item_param->item_id);
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
  }
  Vector3::operator proto::Vector(&from, position);
  v7 = std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::DropHintNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 32));
  v8 = proto::DropHintNotify::mutable_position(v7);
  proto::Vector::operator=(v8, &from);
  proto::Vector::~Vector(&from);
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  player = this->player_;
  std::dynamic_pointer_cast<google::protobuf::Message const,proto::DropHintNotify>(&__r);
  Player::sendMessage(player, (common::minet::ConstMessagePtr *)&__r, 0LL);
  std::shared_ptr<google::protobuf::Message const>::~shared_ptr((std::shared_ptr<const google::protobuf::Message> *const)&__r);
  std::shared_ptr<proto::DropHintNotify>::~shared_ptr((std::shared_ptr<proto::DropHintNotify> *const)(v3 + 32));
  if ( v17 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 8445: range 0000000017D09A3C-0000000017D09EE9
void __cdecl PlayerItemComp::tryNotifyCheckAddItemExceedLimitNotify(
        const PlayerItemComp *const this,
        const ActionReason *reason,
        bool is_drop,
        const std::set<unsigned int> *exceeded_item_set,
        const std::set<unsigned int> *exceeded_item_type_set)
{
  unsigned __int64 v5; // r12
  __int64 v6; // rax
  _DWORD *v7; // r13
  unsigned int *v8; // rax
  uint32_t *v9; // rdx
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  google::protobuf::RepeatedField<unsigned int> *v11; // rdx
  const google::protobuf::RepeatedField<unsigned int> *v12; // rax
  const google::protobuf::RepeatedField<unsigned int> *v13; // rax
  uint32_t item_id; // [rsp+3Ch] [rbp-104h]
  std::set<unsigned int>::iterator __for_begin; // [rsp+40h] [rbp-100h] BYREF
  std::set<unsigned int>::iterator __for_end; // [rsp+48h] [rbp-F8h] BYREF
  const std::set<unsigned int> *__for_range; // [rsp+50h] [rbp-F0h]
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+58h] [rbp-E8h]
  std::shared_ptr<Config> v23; // [rsp+60h] [rbp-E0h] BYREF
  char v24[208]; // [rsp+70h] [rbp-D0h] BYREF

  v5 = (unsigned __int64)v24;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(160LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "1 48 80 11 notify:8450";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::tryNotifyCheckAddItemExceedLimitNotify;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = 61937;
  v7[536862724] = -202116109;
  if ( *(_BYTE *)(((unsigned __int64)&reason->is_show_check_add_item_exceed_limit_notify >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)reason + 14) & 7) >= *(_BYTE *)(((unsigned __int64)&reason->is_show_check_add_item_exceed_limit_notify >> 3)
                                                        + 0x7FFF8000) )
  {
    __asan_report_load1(&reason->is_show_check_add_item_exceed_limit_notify);
  }
  if ( reason->is_show_check_add_item_exceed_limit_notify )
  {
    proto::CheckAddItemExceedLimitNotify::CheckAddItemExceedLimitNotify((proto::CheckAddItemExceedLimitNotify *const)(v5 + 48));
    proto::CheckAddItemExceedLimitNotify::set_is_drop((proto::CheckAddItemExceedLimitNotify *const)(v5 + 48), is_drop);
    __for_range = exceeded_item_set;
    __for_begin._M_node = std::set<unsigned int>::begin(exceeded_item_set)._M_node;
    __for_end._M_node = std::set<unsigned int>::end(exceeded_item_set)._M_node;
    while ( std::operator!=(&__for_begin, &__for_end) )
    {
      v8 = (unsigned int *)std::_Rb_tree_const_iterator<unsigned int>::operator*(&__for_begin);
      v9 = v8;
      if ( *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v8 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v8);
      }
      item_id = *v9;
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v23);
      v10 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v23);
      material_config_ptr = data::MaterialExcelConfigMgrBase::findMaterialExcelConfig(
                              &v10->design_config.txt_config_mgr.material_config_mgr,
                              item_id);
      std::shared_ptr<Config>::~shared_ptr(&v23);
      if ( !material_config_ptr )
        goto LABEL_15;
      if ( *(char *)(((unsigned __int64)&material_config_ptr->use_on_gain >> 3) + 0x7FFF8000) < 0 )
        __asan_report_load1(&material_config_ptr->use_on_gain);
      if ( !material_config_ptr->use_on_gain )
LABEL_15:
        proto::CheckAddItemExceedLimitNotify::add_exceeded_item_list(
          (proto::CheckAddItemExceedLimitNotify *const)(v5 + 48),
          item_id);
      std::_Rb_tree_const_iterator<unsigned int>::operator++(&__for_begin);
    }
    v11 = proto::CheckAddItemExceedLimitNotify::mutable_exceeded_item_type_list((proto::CheckAddItemExceedLimitNotify *const)(v5 + 48));
    common::tools::MiscUtils::setToRepeated<std::set<unsigned int>,unsigned int>(exceeded_item_type_set, v11);
    v12 = proto::CheckAddItemExceedLimitNotify::exceeded_item_list((const proto::CheckAddItemExceedLimitNotify *const)(v5 + 48));
    if ( !google::protobuf::RepeatedField<unsigned int>::empty(v12)
      || (v13 = proto::CheckAddItemExceedLimitNotify::exceeded_item_type_list((const proto::CheckAddItemExceedLimitNotify *const)(v5 + 48)),
          !google::protobuf::RepeatedField<unsigned int>::empty(v13)) )
    {
      if ( *(_BYTE *)(((unsigned __int64)&reason->item_exceed_msg_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)reason + 16) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->item_exceed_msg_type >> 3)
                                                              + 0x7FFF8000) )
      {
        __asan_report_load4(&reason->item_exceed_msg_type);
      }
      proto::CheckAddItemExceedLimitNotify::set_msg_type(
        (proto::CheckAddItemExceedLimitNotify *const)(v5 + 48),
        reason->item_exceed_msg_type);
      if ( *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)reason & 7) + 3) >= *(_BYTE *)(((unsigned __int64)reason >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(reason);
      }
      proto::CheckAddItemExceedLimitNotify::set_reason(
        (proto::CheckAddItemExceedLimitNotify *const)(v5 + 48),
        reason->reason_type);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::sendProto(this->player_, (const google::protobuf::Message *)(v5 + 48));
    }
    proto::CheckAddItemExceedLimitNotify::~CheckAddItemExceedLimitNotify((proto::CheckAddItemExceedLimitNotify *const)(v5 + 48));
  }
  if ( v24 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8010) = -168430091;
  }
};

// Line 8471: range 0000000017D09EEA-0000000017D09F19
std::vector<TransferItemParam> *__cdecl PlayerItemComp::getTransferItems(
        std::vector<TransferItemParam> *retstr,
        PlayerItemComp *const this)
{
  std::vector<TransferItemParam>::vector(retstr, &this->transfer_item_vec_);
  return retstr;
};

// Line 8476: range 0000000017D09F1A-0000000017D09F3A
void __cdecl PlayerItemComp::clearTransferItems(PlayerItemComp *const this)
{
  std::vector<TransferItemParam>::clear(&this->transfer_item_vec_);
};

// Line 8482: range 0000000017D09F3C-0000000017D0AB81
void __cdecl PlayerItemComp::clearItemsByGm(
        PlayerItemComp *const this,
        std::set<unsigned int> *item_id_set,
        std::set<data::ItemType> *item_type_set)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  char v7; // al
  std::tuple_element<1,const std::pair<unsigned int const,data::ItemConfig*> >::type v8; // rdx
  char v9; // cl
  std::_Rb_tree_const_iterator<unsigned int>::reference v10; // rax
  _DWORD *v11; // rdx
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  common::milog::MiLogStream *v13; // rax
  std::_Rb_tree_const_iterator<long unsigned int>::reference v14; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v15; // rax
  unsigned __int64 v16; // rdx
  char v17; // al
  uint32_t item_count_0; // [rsp+28h] [rbp-1A8h]
  uint32_t item_count; // [rsp+2Ch] [rbp-1A4h]
  std::set<unsigned int>::iterator __for_begin_0; // [rsp+30h] [rbp-1A0h] BYREF
  std::set<unsigned int>::iterator __for_end_0; // [rsp+38h] [rbp-198h] BYREF
  std::unordered_map<unsigned int,data::ItemConfig*>::const_iterator __for_begin; // [rsp+40h] [rbp-190h] BYREF
  const std::unordered_map<unsigned int,data::ItemConfig*> *__for_range; // [rsp+48h] [rbp-188h]
  const std::pair<unsigned int const,data::ItemConfig*> *v25; // [rsp+50h] [rbp-180h]
  std::tuple_element<0,const std::pair<unsigned int const,data::ItemConfig*> >::type *item_id; // [rsp+58h] [rbp-178h]
  std::tuple_element<1,const std::pair<unsigned int const,data::ItemConfig*> >::type *item_config_ptr; // [rsp+60h] [rbp-170h]
  std::set<unsigned int> *__for_range_0; // [rsp+68h] [rbp-168h]
  const data::ItemConfig *item_config_ptr_0; // [rsp+70h] [rbp-160h]
  std::set<long unsigned int> *item_guid_set_ptr; // [rsp+78h] [rbp-158h]
  std::set<long unsigned int> *__for_range_1; // [rsp+80h] [rbp-150h]
  std::unordered_map<unsigned int,data::ItemConfig*>::const_iterator __for_end; // [rsp+88h] [rbp-148h] BYREF
  common::milog::MiLogStream v33; // [rsp+90h] [rbp-140h] BYREF
  char v34[288]; // [rsp+B0h] [rbp-120h] BYREF

  v3 = (unsigned __int64)v34;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(256LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "5 48 4 12 item_id:8516 64 8 9 guid:8567 96 16 13 item_ptr:8569 128 24 23 sub_item_param_vec:8513"
                        " 192 24 22 sub_item_guid_vec:8514";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::clearItemsByGm;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -218959360;
  v5[536862723] = -219021312;
  v5[536862724] = -234881024;
  v5[536862725] = -218959118;
  v5[536862726] = -218103808;
  v5[536862727] = -202116109;
  if ( std::set<unsigned int>::empty(item_id_set) || !std::set<data::ItemType>::empty(item_type_set) )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v3 + 96));
    __for_range = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96))->design_config.txt_config_mgr.item_config_mgr.item_config_map;
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 96));
    __for_begin._M_cur = std::unordered_map<unsigned int,data::ItemConfig *>::begin(__for_range)._M_cur;
    __for_end._M_cur = std::unordered_map<unsigned int,data::ItemConfig *>::end(__for_range)._M_cur;
    while ( std::__detail::operator!=<std::pair<unsigned int const,data::ItemConfig *>,false>(&__for_begin, &__for_end) )
    {
      v25 = std::__detail::_Node_const_iterator<std::pair<unsigned int const,data::ItemConfig *>,false,false>::operator*(&__for_begin);
      item_id = std::get<0ul,unsigned int const,data::ItemConfig *>(v25);
      item_config_ptr = (std::tuple_element<1,const std::pair<unsigned int const,data::ItemConfig*> >::type *)std::get<1ul,unsigned int const,data::ItemConfig *>(v25);
      if ( std::set<data::ItemType>::empty(item_type_set) )
        goto LABEL_16;
      if ( *(_BYTE *)(((unsigned __int64)item_config_ptr >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      if ( !common::tools::MiscUtils::isContains<std::set<data::ItemType>,data::ItemType>(
              item_type_set,
              &(*item_config_ptr)->item_type) )
        v7 = 1;
      else
LABEL_16:
        v7 = 0;
      if ( !v7 )
      {
        if ( *(_BYTE *)(((unsigned __int64)item_config_ptr >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v8 = *item_config_ptr;
        v9 = *(_BYTE *)(((unsigned __int64)&(*item_config_ptr)->item_type >> 3) + 0x7FFF8000);
        if ( v9 != 0 && (char)(((*(_BYTE *)item_config_ptr + 12) & 7) + 3) >= v9 )
          __asan_report_load4(&(*item_config_ptr)->item_type);
        if ( v8->item_type != ITEM_VIRTUAL )
          goto LABEL_26;
        if ( *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(item_id);
        }
        if ( *item_id - 201 <= 2 )
LABEL_26:
          std::set<unsigned int>::insert(item_id_set, item_id);
      }
      std::__detail::_Node_const_iterator<std::pair<unsigned int const,data::ItemConfig *>,false,false>::operator++(&__for_begin);
    }
  }
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v3 + 128));
  std::vector<unsigned long>::vector((std::vector<long unsigned int> *const)(v3 + 192));
  __for_range_0 = item_id_set;
  __for_begin_0._M_node = std::set<unsigned int>::begin(item_id_set)._M_node;
  __for_end_0._M_node = std::set<unsigned int>::end(__for_range_0)._M_node;
  while ( std::operator!=(&__for_begin_0, &__for_end_0) )
  {
    v10 = std::_Rb_tree_const_iterator<unsigned int>::operator*(&__for_begin_0);
    v11 = v10;
    if ( *(_BYTE *)(((unsigned __int64)v10 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v10 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v10 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v10);
    }
    *(_DWORD *)(v3 + 48) = *v11;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v3 + 96));
    v12 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
    item_config_ptr_0 = ItemExcelConfigMgr::findItemConfig(
                          &v12->design_config.txt_config_mgr.item_config_mgr,
                          *(_DWORD *)(v3 + 48));
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 96));
    if ( item_config_ptr_0 )
    {
      if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr_0->item_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_config_ptr_0 + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr_0->item_type >> 3)
                                                                         + 0x7FFF8000) )
      {
        __asan_report_load4(&item_config_ptr_0->item_type);
      }
      if ( item_config_ptr_0->item_type == ITEM_VIRTUAL )
      {
        switch ( *(_DWORD *)(v3 + 48) )
        {
          case 0xCB:
            *(_DWORD *)(v3 + 96) = *(_DWORD *)(v3 + 48);
            *(_DWORD *)(v3 + 100) = PlayerItemComp::getMcoin(this);
            *(_DWORD *)(v3 + 104) = 0;
            *(_DWORD *)(v3 + 108) = 0;
            std::vector<ItemParam>::push_back(
              (std::vector<ItemParam> *const)(v3 + 128),
              (std::vector<ItemParam>::value_type *)(v3 + 96));
            break;
          case 0xC9:
            *(_DWORD *)(v3 + 96) = *(_DWORD *)(v3 + 48);
            if ( *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)this - 28) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->hcoin_ >> 3) + 0x7FFF8000) )
            {
              __asan_report_load4(&this->hcoin_);
            }
            *(_DWORD *)(v3 + 100) = this->hcoin_;
            *(_DWORD *)(v3 + 104) = 0;
            *(_DWORD *)(v3 + 108) = 0;
            std::vector<ItemParam>::push_back(
              (std::vector<ItemParam> *const)(v3 + 128),
              (std::vector<ItemParam>::value_type *)(v3 + 96));
            break;
          case 0xCA:
            *(_DWORD *)(v3 + 96) = *(_DWORD *)(v3 + 48);
            if ( *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) != 0
              && *(_BYTE *)(((unsigned __int64)&this->scoin_ >> 3) + 0x7FFF8000) <= 3 )
            {
              __asan_report_load4(&this->scoin_);
            }
            *(_DWORD *)(v3 + 100) = this->scoin_;
            *(_DWORD *)(v3 + 104) = 0;
            *(_DWORD *)(v3 + 108) = 0;
            std::vector<ItemParam>::push_back(
              (std::vector<ItemParam> *const)(v3 + 128),
              (std::vector<ItemParam>::value_type *)(v3 + 96));
            break;
          case 0xCC:
            *(_DWORD *)(v3 + 96) = *(_DWORD *)(v3 + 48);
            if ( *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)this - 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->home_coin_ >> 3)
                                                                  + 0x7FFF8000) )
            {
              __asan_report_load4(&this->home_coin_);
            }
            *(_DWORD *)(v3 + 100) = this->home_coin_;
            *(_DWORD *)(v3 + 104) = 0;
            *(_DWORD *)(v3 + 108) = 0;
            std::vector<ItemParam>::push_back(
              (std::vector<ItemParam> *const)(v3 + 128),
              (std::vector<ItemParam>::value_type *)(v3 + 96));
            break;
        }
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr_0->item_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_config_ptr_0 + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr_0->item_type >> 3)
                                                                           + 0x7FFF8000) )
        {
          __asan_report_load4(&item_config_ptr_0->item_type);
        }
        if ( item_config_ptr_0->item_type == ITEM_MATERIAL )
        {
          item_count = ItemStore::getMaterialCount(&this->pack_store_, *(_DWORD *)(v3 + 48));
          if ( item_count )
          {
            *(_DWORD *)(v3 + 96) = *(_DWORD *)(v3 + 48);
            *(_DWORD *)(v3 + 100) = item_count;
            *(_DWORD *)(v3 + 104) = 0;
            *(_DWORD *)(v3 + 108) = 0;
            std::vector<ItemParam>::push_back(
              (std::vector<ItemParam> *const)(v3 + 128),
              (std::vector<ItemParam>::value_type *)(v3 + 96));
          }
        }
        else
        {
          if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr_0->item_type >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_config_ptr_0 + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr_0->item_type >> 3)
                                                                             + 0x7FFF8000) )
          {
            __asan_report_load4(&item_config_ptr_0->item_type);
          }
          if ( item_config_ptr_0->item_type == ITEM_FURNITURE )
          {
            item_count_0 = ItemStore::getItemCount(&this->pack_store_, *(_DWORD *)(v3 + 48));
            if ( item_count_0 )
            {
              *(_DWORD *)(v3 + 96) = *(_DWORD *)(v3 + 48);
              *(_DWORD *)(v3 + 100) = item_count_0;
              *(_DWORD *)(v3 + 104) = 0;
              *(_DWORD *)(v3 + 108) = 0;
              std::vector<ItemParam>::push_back(
                (std::vector<ItemParam> *const)(v3 + 128),
                (std::vector<ItemParam>::value_type *)(v3 + 96));
            }
          }
          else
          {
            item_guid_set_ptr = ItemStore::getItemGuidSetByItemId(&this->pack_store_, *(_DWORD *)(v3 + 48));
            if ( item_guid_set_ptr )
            {
              __for_range_1 = item_guid_set_ptr;
              __for_begin._M_cur = (std::__detail::_Node_iterator_base<std::pair<unsigned int const,data::ItemConfig*>,false>::__node_type *)std::set<unsigned long>::begin(item_guid_set_ptr)._M_node;
              __for_end._M_cur = (std::__detail::_Node_iterator_base<std::pair<unsigned int const,data::ItemConfig*>,false>::__node_type *)std::set<unsigned long>::end(__for_range_1)._M_node;
              while ( std::operator!=(
                        (const std::_Rb_tree_const_iterator<long unsigned int>::_Self *)&__for_begin,
                        (const std::_Rb_tree_const_iterator<long unsigned int>::_Self *)&__for_end) )
              {
                v14 = std::_Rb_tree_const_iterator<unsigned long>::operator*((const std::_Rb_tree_const_iterator<long unsigned int> *const)&__for_begin);
                if ( *(_BYTE *)(((unsigned __int64)v14 >> 3) + 0x7FFF8000) )
                  __asan_report_load8();
                *(_QWORD *)(v3 + 64) = *v14;
                ItemStore::findItem((ItemStore *const)(v3 + 96), (uint64_t)&this->pack_store_, *(_QWORD *)(v3 + 64));
                if ( !std::operator!=<Item>(0LL, (const std::shared_ptr<Item> *)(v3 + 96)) )
                  goto LABEL_73;
                v15 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
                if ( *(_BYTE *)(((unsigned __int64)v15 >> 3) + 0x7FFF8000) )
                  __asan_report_load8();
                v16 = (unsigned __int64)(v15->_vptr_Item + 11);
                if ( *(_BYTE *)((v16 >> 3) + 0x7FFF8000) )
                  __asan_report_load8();
                if ( (*(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v16)(v15) )
LABEL_73:
                  v17 = 0;
                else
                  v17 = 1;
                if ( v17 )
                  std::vector<unsigned long>::push_back(
                    (std::vector<long unsigned int> *const)(v3 + 192),
                    (const std::vector<long unsigned int>::value_type *)(v3 + 64));
                std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v3 + 96));
                std::_Rb_tree_const_iterator<unsigned long>::operator++((std::_Rb_tree_const_iterator<long unsigned int> *const)&__for_begin);
              }
            }
          }
        }
      }
    }
    else
    {
      common::milog::MiLogStream::create(
        &v33,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "clearItemsByGm",
        8521);
      v13 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
              &v33,
              (const char (*)[35])"findItemExcelConfig fail, item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v3 + 48));
      common::milog::MiLogStream::~MiLogStream(&v33);
    }
    std::_Rb_tree_const_iterator<unsigned int>::operator++(&__for_begin_0);
  }
  SubItemReason::SubItemReason((SubItemReason *const)&__for_end, ACTION_REASON_GM);
  PlayerItemComp::subItemBatch(this, (const std::vector<ItemParam> *)(v3 + 128), (const SubItemReason *)&__for_end);
  SubItemReason::SubItemReason((SubItemReason *const)&__for_end, ACTION_REASON_GM);
  PlayerItemComp::subItemBatch(
    this,
    (const std::vector<long unsigned int> *)(v3 + 192),
    (const SubItemReason *)&__for_end);
  std::vector<unsigned long>::~vector((std::vector<long unsigned int> *const)(v3 + 192));
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 128));
  if ( v34 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8018) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 8584: range 0000000017D0AB82-0000000017D0ABA7
bool __cdecl PlayerItemComp::hasItemById(const PlayerItemComp *const this, uint32_t item_id)
{
  return ItemStore::hasItemById(&this->pack_store_, item_id);
};

// Line 8590: range 0000000017D0ABA8-0000000017D0AC79
bool __fastcall PlayerItemComp::hasOnceGotItemById(const PlayerItemComp *const this, uint32_t item_id)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  bool result; // al
  char v6[96]; // [rsp+10h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v6;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 12 item_id:8589";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::hasOnceGotItemById;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = item_id;
  result = common::tools::MiscUtils::isContains<std::set<unsigned int> const,unsigned int>(
             &this->history_item_set_,
             (const unsigned int *)(v2 + 32));
  if ( v6 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 8595: range 0000000017D0AC7A-0000000017D0B017
bool __cdecl PlayerItemComp::isOnceGotAllItemsInSet(const PlayerItemComp *const this, uint32_t set_id)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  bool v6; // r15
  unsigned int *v7; // rax
  uint32_t *v8; // rdx
  bool result; // al
  unsigned int item_id; // [rsp+1Ch] [rbp-104h]
  std::unordered_set<unsigned int>::iterator __for_begin; // [rsp+20h] [rbp-100h] BYREF
  std::unordered_set<unsigned int>::iterator __for_end; // [rsp+28h] [rbp-F8h] BYREF
  std::unordered_set<unsigned int> *item_id_set; // [rsp+30h] [rbp-F0h]
  std::unordered_set<unsigned int> *__for_range; // [rsp+38h] [rbp-E8h]
  std::shared_ptr<Config> v15; // [rsp+40h] [rbp-E0h] BYREF
  common::milog::MiLogStream v16; // [rsp+50h] [rbp-D0h] BYREF
  char v17[176]; // [rsp+70h] [rbp-B0h] BYREF

  v2 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(128LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 64 20 item_id_set_opt:8596";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::isOnceGotAllItemsInSet;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450892) = -202116109;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v15);
  v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v15);
  MaterialExcelConfigMgr::queryItemIDsInSet(
    (std::optional<std::unordered_set<unsigned int> > *)(v2 + 32),
    &v5->design_config.txt_config_mgr.material_config_mgr,
    set_id);
  std::shared_ptr<Config>::~shared_ptr(&v15);
  if ( !std::optional<std::unordered_set<unsigned int>>::has_value((const std::optional<std::unordered_set<unsigned int> > *const)(v2 + 32)) )
  {
    common::milog::MiLogStream::create(
      &v16,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "isOnceGotAllItemsInSet",
      8599);
    common::milog::MiLogStream::operator()(&v16, "set_id=%u not exists.", set_id);
    common::milog::MiLogStream::~MiLogStream(&v16);
    v6 = 0;
  }
  else
  {
    item_id_set = std::optional<std::unordered_set<unsigned int>>::value((std::optional<std::unordered_set<unsigned int> > *const)(v2 + 32));
    __for_range = item_id_set;
    __for_begin._M_cur = std::unordered_set<unsigned int>::begin(item_id_set)._M_cur;
    __for_end._M_cur = std::unordered_set<unsigned int>::end(item_id_set)._M_cur;
    while ( std::__detail::operator!=<unsigned int,false>(&__for_begin, &__for_end) )
    {
      v7 = (unsigned int *)std::__detail::_Node_iterator<unsigned int,true,false>::operator*(&__for_begin);
      v8 = v7;
      if ( *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v7 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v7);
      }
      item_id = *v8;
      if ( !PlayerItemComp::hasOnceGotItemById(this, *v8) )
      {
        common::milog::MiLogStream::create(
          &v16,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "isOnceGotAllItemsInSet",
          8609);
        common::milog::MiLogStream::operator()(&v16, "item_id=%u NOT once got in set_id=%u.", item_id, set_id);
        common::milog::MiLogStream::~MiLogStream(&v16);
        v6 = 0;
        goto LABEL_14;
      }
      std::__detail::_Node_iterator<unsigned int,true,false>::operator++(&__for_begin);
    }
    v6 = 1;
  }
LABEL_14:
  std::optional<std::unordered_set<unsigned int>>::~optional((std::optional<std::unordered_set<unsigned int> > *const)(v2 + 32));
  result = v6;
  if ( v17 == (char *)v2 )
  {
    *(_DWORD *)((v2 >> 3) + 0x7FFF8000) = 0;
    *(_DWORD *)((v2 >> 3) + 0x7FFF800C) = 0;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 8619: range 0000000017D0B018-0000000017D0B2DD
float __cdecl PlayerItemComp::getCurMultiPlayFetterExpRatio(const PlayerItemComp *const this)
{
  int v1; // r14d
  __m128i v2; // xmm0
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  unsigned __int64 v5; // r12
  PlayerMpComp *MpComp; // rax
  PlayerMpComp *v7; // rax
  char v8; // al
  std::__shared_ptr_access<SceneTeam,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // r15
  uint32_t Uid; // eax
  char v11; // al
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  int v13; // r15d
  float result; // xmm0_4
  std::shared_ptr<Config> v15; // [rsp+10h] [rbp-80h] BYREF
  char v16[112]; // [rsp+20h] [rbp-70h] BYREF

  v3 = (unsigned __int64)v16;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_0(64LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 16 19 scene_team_ptr:8622";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::getCurMultiPlayFetterExpRatio;
  v5 = v3 >> 3;
  *(_DWORD *)(v5 + 2147450880) = -235802127;
  *(_DWORD *)(v5 + 2147450884) = -202178560;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    *(double *)v2.m128i_i64 = __asan_report_load8();
  MpComp = Player::getMpComp(this->player_);
  if ( !PlayerMpComp::isInMpMode(MpComp) )
    goto LABEL_11;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    *(double *)v2.m128i_i64 = __asan_report_load8();
  v7 = Player::getMpComp(this->player_);
  if ( !PlayerMpComp::isInSingleMpMode(v7) )
    v8 = 1;
  else
LABEL_11:
    v8 = 0;
  if ( !v8 )
    goto LABEL_25;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    *(double *)v2.m128i_i64 = __asan_report_load8();
  Player::getAvatarComp(this->player_);
  PlayerAvatarComp::findSceneTeam((PlayerAvatarComp *const)(v3 + 32));
  if ( !std::operator!=<SceneTeam>(0LL, (const std::shared_ptr<SceneTeam> *)(v3 + 32)) )
    goto LABEL_20;
  v9 = std::__shared_ptr_access<SceneTeam,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<SceneTeam,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 32));
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    *(double *)v2.m128i_i64 = __asan_report_load8();
  Uid = Player::getUid(this->player_);
  if ( SceneTeam::getAvatarGuidVecSize(v9, Uid) <= 2 )
    v11 = 1;
  else
LABEL_20:
    v11 = 0;
  if ( v11 )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v15);
    v12 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v15);
    *(float *)v2.m128i_i32 = ConstValueExcelConfigMgr::getMultiPlayFetterExpRatio(&v12->design_config.txt_config_mgr.const_value_config_mgr);
    v1 = _mm_cvtsi128_si32(v2);
    std::shared_ptr<Config>::~shared_ptr(&v15);
    v13 = 0;
  }
  else
  {
    v13 = 1;
  }
  std::shared_ptr<SceneTeam>::~shared_ptr((std::shared_ptr<SceneTeam> *const)(v3 + 32));
  if ( v13 == 1 )
LABEL_25:
    v1 = 1065353216;
  result = *(float *)&v1;
  if ( v16 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 8633: range 0000000017D0B2DE-0000000017D0B35D
bool __cdecl PlayerItemComp::checkAndModifyTotalObtainCountAndModifyItemCount(
        PlayerItemComp *const this,
        ItemParam *item_param,
        const ActionReason *reason,
        bool is_by_drop)
{
  ItemParam *p_count; // rdi

  p_count = (ItemParam *)&item_param->count;
  if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
  {
    p_count = item_param;
    __asan_report_load4(item_param);
  }
  return PlayerItemComp::checkAndModifyTotalObtainCountAndModifyItemCount(
           this,
           item_param->item_id,
           &p_count->item_id,
           reason,
           is_by_drop);
};

// Line 8638: range 0000000017D0B35E-0000000017D0BB27
bool __cdecl PlayerItemComp::checkAndModifyTotalObtainCountAndModifyItemCount(
        PlayerItemComp *const this,
        ItemPtr *item_ptr,
        const ActionReason *reason,
        bool is_by_drop)
{
  bool v4; // r15
  unsigned __int64 v5; // r12
  __int64 v6; // rax
  _DWORD *v7; // r13
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  unsigned __int64 v10; // rdx
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v11; // rax
  uint32_t ItemId; // esi
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v13; // rax
  int ItemType; // r14d
  common::milog::MiLogStream *v15; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v16; // rax
  unsigned __int64 v17; // rdx
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2> *v18; // rdx
  int v19; // r14d
  Material *v20; // rax
  common::milog::MiLogStream *v21; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v22; // rax
  unsigned __int64 v23; // rdx
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2> *v24; // rdx
  int v25; // r14d
  Furniture *v26; // rax
  common::milog::MiLogStream *v27; // rbx
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v28; // rax
  unsigned __int64 v29; // rdx
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2> *v30; // rdx
  bool result; // al
  uint32_t item_id; // [rsp+38h] [rbp-C8h]
  uint32_t old_count; // [rsp+3Ch] [rbp-C4h]
  std::shared_ptr<Config> v37; // [rsp+40h] [rbp-C0h] BYREF
  common::milog::MiLogStream v38; // [rsp+50h] [rbp-B0h] BYREF
  char v39[144]; // [rsp+70h] [rbp-90h] BYREF

  v5 = (unsigned __int64)v39;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_1(96LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "2 48 4 10 count:8645 64 16 18 furniture_ptr:8678";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::checkAndModifyTotalObtainCountAndModifyItemCount;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556943;
  v7[536862722] = -202178560;
  if ( std::operator==<Item>(0LL, item_ptr) )
  {
    v4 = 0;
    goto LABEL_48;
  }
  v8 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
  item_id = Item::getItemId(v8);
  v9 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
  if ( *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  v10 = (unsigned __int64)(v9->_vptr_Item + 8);
  if ( *(_BYTE *)((v10 >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  *(_DWORD *)(v5 + 48) = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v10)(v9);
  old_count = *(_DWORD *)(v5 + 48);
  v11 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
  ItemId = Item::getItemId(v11);
  PlayerItemComp::checkAndModifyTotalObtainCountAndModifyItemCount(
    this,
    ItemId,
    (uint32_t *)(v5 + 48),
    reason,
    is_by_drop);
  if ( old_count <= *(_DWORD *)(v5 + 48) )
  {
    v4 = 1;
    goto LABEL_48;
  }
  if ( !*(_DWORD *)(v5 + 48) )
  {
    v4 = 0;
    goto LABEL_48;
  }
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v37);
  v13 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v37);
  ItemType = ItemExcelConfigMgr::getItemType(&v13->design_config.txt_config_mgr.item_config_mgr, item_id);
  std::shared_ptr<Config>::~shared_ptr(&v37);
  if ( ItemType == 6 )
  {
    std::dynamic_pointer_cast<Furniture,Item>((const std::shared_ptr<Item> *)(v5 + 64));
    if ( std::operator==<Furniture>(0LL, (const std::shared_ptr<Furniture> *)(v5 + 64)) )
    {
      common::milog::MiLogStream::create(
        &v38,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAndModifyTotalObtainCountAndModifyItemCount",
        8681);
      v21 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
              &v38,
              (const char (*)[29])"item is not furniture, item:");
      v22 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
      if ( *(_BYTE *)(((unsigned __int64)v22 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v23 = (unsigned __int64)(v22->_vptr_Item + 10);
      if ( *(_BYTE *)((v23 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v37._M_ptr = (std::__shared_ptr<Config,(__gnu_cxx::_Lock_policy)2>::element_type *)(*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v23)(v22);
      v37._M_refcount._M_pi = v24;
      operator<<(v21, (const ItemParam *)&v37);
      common::milog::MiLogStream::~MiLogStream(&v38);
      v4 = 0;
      v25 = 0;
    }
    else
    {
      v26 = std::__shared_ptr_access<Furniture,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Furniture,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
      Furniture::setCount(v26, *(_DWORD *)(v5 + 48));
      v25 = 1;
    }
    std::shared_ptr<Furniture>::~shared_ptr((std::shared_ptr<Furniture> *const)(v5 + 64));
    if ( !v25 )
      goto LABEL_48;
LABEL_47:
    v4 = 1;
    goto LABEL_48;
  }
  if ( ItemType > 6 )
    goto LABEL_42;
  if ( ItemType != 2 )
  {
    if ( ItemType == 4 )
    {
      common::milog::MiLogStream::create(
        &v38,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAndModifyTotalObtainCountAndModifyItemCount",
        8689);
      v27 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
              &v38,
              (const char (*)[42])"item is weapon but not sub to zero, item:");
      v28 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
      if ( *(_BYTE *)(((unsigned __int64)v28 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v29 = (unsigned __int64)(v28->_vptr_Item + 10);
      if ( *(_BYTE *)((v29 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_41;
    }
LABEL_42:
    common::milog::MiLogStream::create(
      &v38,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkAndModifyTotalObtainCountAndModifyItemCount",
      8693);
    v27 = common::milog::MiLogStream::operator<<<char [46],(char *[46])0>(
            &v38,
            (const char (*)[46])"item sub but is not material or weapon, item:");
    v28 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
    if ( *(_BYTE *)(((unsigned __int64)v28 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v29 = (unsigned __int64)(v28->_vptr_Item + 10);
    if ( *(_BYTE *)((v29 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
LABEL_41:
    v37._M_ptr = (std::__shared_ptr<Config,(__gnu_cxx::_Lock_policy)2>::element_type *)(*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v29)(v28);
    v37._M_refcount._M_pi = v30;
    operator<<(v27, (const ItemParam *)&v37);
    common::milog::MiLogStream::~MiLogStream(&v38);
    v4 = 0;
    goto LABEL_48;
  }
  std::dynamic_pointer_cast<Material,Item>((const std::shared_ptr<Item> *)(v5 + 64));
  if ( std::operator==<Material>(0LL, (const std::shared_ptr<Material> *)(v5 + 64)) )
  {
    common::milog::MiLogStream::create(
      &v38,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkAndModifyTotalObtainCountAndModifyItemCount",
      8670);
    v15 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
            &v38,
            (const char (*)[28])"item is not material, item:");
    v16 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
    if ( *(_BYTE *)(((unsigned __int64)v16 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v17 = (unsigned __int64)(v16->_vptr_Item + 10);
    if ( *(_BYTE *)((v17 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v37._M_ptr = (std::__shared_ptr<Config,(__gnu_cxx::_Lock_policy)2>::element_type *)(*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v17)(v16);
    v37._M_refcount._M_pi = v18;
    operator<<(v15, (const ItemParam *)&v37);
    common::milog::MiLogStream::~MiLogStream(&v38);
    v4 = 0;
    v19 = 0;
  }
  else
  {
    v20 = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
    Material::setCount(v20, *(_DWORD *)(v5 + 48));
    v19 = 1;
  }
  std::shared_ptr<Material>::~shared_ptr((std::shared_ptr<Material> *const)(v5 + 64));
  if ( v19 )
    goto LABEL_47;
LABEL_48:
  result = v4;
  if ( v39 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 8701: range 0000000017D0BB28-0000000017D0C2AF
__int64 __fastcall PlayerItemComp::checkAndModifyTotalObtainCountAndModifyItemCount(
        PlayerItemComp *const this,
        uint32_t item_id,
        uint32_t *count,
        const ActionReason *reason,
        bool is_by_drop)
{
  unsigned __int64 v5; // r12
  __int64 v6; // rax
  _DWORD *v7; // r13
  __int64 result; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rcx
  unsigned int item_type; // eax
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v16; // rax
  uint32_t v17; // eax
  char *v18; // rsi
  uint32_t *v19; // rax
  uint32_t *v20; // rdx
  uint32_t v21; // ecx
  char v22; // dl
  __int64 v23; // rdx
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rax
  common::milog::MiLogStream *v32; // rax
  common::milog::MiLogStream *v33; // rax
  common::milog::MiLogStream *v34; // rcx
  unsigned int v35; // ecx
  uint32_t global_item_limit; // [rsp+2Ch] [rbp-C4h]
  const data::ItemConfig *item_config_ptr; // [rsp+30h] [rbp-C0h]
  uint32_t *total_obtain_count; // [rsp+38h] [rbp-B8h]
  std::shared_ptr<Config> v42; // [rsp+40h] [rbp-B0h] BYREF
  common::milog::MiLogStream v43; // [rsp+50h] [rbp-A0h] BYREF
  char v44[128]; // [rsp+70h] [rbp-80h] BYREF

  v5 = (unsigned __int64)v44;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_1(96LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "3 32 4 15 rest_count:8726 48 4 14 old_count:8727 64 4 12 item_id:8700";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::checkAndModifyTotalObtainCountAndModifyItemCount;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556924;
  v7[536862722] = -202116348;
  *(_DWORD *)(v5 + 64) = item_id;
  if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&reason->limit_type);
  }
  if ( reason->limit_type == ITEM_LIMIT_GM )
  {
    result = 1LL;
    goto LABEL_44;
  }
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v42);
  v9 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v42);
  item_config_ptr = ItemExcelConfigMgr::findItemConfig(
                      &v9->design_config.txt_config_mgr.item_config_mgr,
                      *(_DWORD *)(v5 + 64));
  std::shared_ptr<Config>::~shared_ptr(&v42);
  if ( item_config_ptr )
  {
    if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                     + 0x7FFF8000) )
    {
      __asan_report_load4(&item_config_ptr->item_type);
    }
    item_type = item_config_ptr->item_type;
    if ( item_type <= 6 && ((1LL << item_type) & 0x54) != 0 )
    {
      if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->global_item_limit >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_config_ptr + 36) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->global_item_limit >> 3)
                                                                       + 0x7FFF8000) )
      {
        __asan_report_load4(&item_config_ptr->global_item_limit);
      }
      global_item_limit = item_config_ptr->global_item_limit;
      if ( !global_item_limit )
      {
        result = 1LL;
        goto LABEL_44;
      }
      v16 = std::unordered_map<unsigned int,unsigned int>::operator[](
              &this->item_total_obtain_count_map_,
              (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v5 + 64));
      total_obtain_count = v16;
      if ( *(_BYTE *)(((unsigned __int64)v16 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v16 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v16 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v16);
      }
      if ( global_item_limit <= *total_obtain_count )
        v17 = 0;
      else
        v17 = global_item_limit - *total_obtain_count;
      *(_DWORD *)(v5 + 32) = v17;
      if ( *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(count);
      }
      *(_DWORD *)(v5 + 48) = *count;
      v18 = (char *)(v5 + 32);
      v19 = (uint32_t *)std::min<unsigned int>(count, (const unsigned int *)(v5 + 32));
      v20 = v19;
      if ( *(_BYTE *)(((unsigned __int64)v19 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v19 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v19 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v19);
      }
      v21 = *v20;
      v22 = *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000);
      LOBYTE(v18) = v22 != 0;
      v23 = (v22 != 0) & (unsigned __int8)((char)(((unsigned __int8)count & 7) + 3) >= v22);
      if ( (_BYTE)v23 )
        __asan_report_store4(count, v18, v23);
      *count = v21;
      common::milog::MiLogStream::create(
        &v43,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkAndModifyTotalObtainCountAndModifyItemCount",
        8729);
      v24 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(&v43, (const char (*)[9])"item_id:");
      v25 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, (const unsigned int *)(v5 + 64));
      v26 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v25, (const char (*)[12])" old_count:");
      v27 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v26, (const unsigned int *)(v5 + 48));
      v28 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v27, (const char (*)[13])" rest_count:");
      v29 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v28, (const unsigned int *)(v5 + 32));
      v30 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v29, (const char (*)[8])" count:");
      v31 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v30, count);
      v32 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
              v31,
              (const char (*)[21])" total_obtain_count:");
      v33 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v32, total_obtain_count);
      v34 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v33, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v34, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v43);
      if ( *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(count);
      }
      if ( !*count )
      {
        result = 0LL;
        goto LABEL_44;
      }
      if ( !is_by_drop )
      {
        if ( *(_BYTE *)(((unsigned __int64)total_obtain_count >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)total_obtain_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)total_obtain_count >> 3)
                                                                               + 0x7FFF8000) )
        {
          __asan_report_load4(total_obtain_count);
        }
        v35 = *total_obtain_count;
        if ( *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(count);
        }
        *total_obtain_count = v35 + *count;
      }
    }
    result = 1LL;
  }
  else
  {
    common::milog::MiLogStream::create(
      &v43,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkAndModifyTotalObtainCountAndModifyItemCount",
      8710);
    v10 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
            &v43,
            (const char (*)[30])"findItemConfig fail, item_id:");
    v11 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, (const unsigned int *)(v5 + 64));
    v12 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v11, (const char (*)[8])" count:");
    v13 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v12, count);
    v14 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v13, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v14, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v43);
    result = 0LL;
  }
LABEL_44:
  if ( v44 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 8750: range 0000000017D0C2B0-0000000017D0CB34
OutputResult __fastcall PlayerItemComp::checkAndRecordBeforeDrop(
        PlayerItemComp *const this,
        uint32_t drop_id,
        uint32_t drop_count,
        const ActionReason *action_reason)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r13
  PlayerBasicComp *BasicComp; // rax
  char v8; // r14
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  bool v10; // r15
  OutputResult v11; // r14
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rcx
  uint32_t v18; // ecx
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddDrop,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v19; // rax
  google::protobuf::uint32 v20; // eax
  google::protobuf::uint32 v21; // eax
  uint32_t v22; // ecx
  google::protobuf::uint32 ActivityOutputCountForLog; // eax
  Player *player; // r14
  std::string v25; // [rsp+0h] [rbp-140h]
  char *v26; // [rsp+0h] [rbp-140h]
  const ActionReason *action_reasona; // [rsp+8h] [rbp-138h]
  uint32_t drop_counta; // [rsp+10h] [rbp-130h]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-128h]
  std::map<data::OutputControlType,OutputControlRecord>::key_type __k; // [rsp+2Ch] [rbp-114h] BYREF
  const data::DropExcelConfig *drop_config_ptr; // [rsp+30h] [rbp-110h]
  const OutputControlRecord *output_control_record; // [rsp+38h] [rbp-108h]
  proto_log::DropLog *drop_log; // [rsp+40h] [rbp-100h]
  OutputResult v34; // [rsp+48h] [rbp-F8h] BYREF
  std::shared_ptr<google::protobuf::Message> p_body_ptr; // [rsp+50h] [rbp-F0h] BYREF
  std::shared_ptr<google::protobuf::Message> v36; // [rsp+60h] [rbp-E0h] BYREF
  std::string value; // [rsp+70h] [rbp-D0h] BYREF
  char v38[176]; // [rsp+90h] [rbp-B0h] BYREF
  OutputResult result; // 0:rax.6

  *(&v25._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  v25._anon_0._M_allocated_capacity = __PAIR64__(drop_id, drop_count);
  v25._M_string_length = (std::string::size_type)action_reason;
  v4 = (unsigned __int64)v38;
  v25._M_dataplus._M_p = v38;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "4 32 1 11 holder:8751 48 4 12 drop_id:8749 64 8 18 output_result:8753 96 16 21 add_drop_log_ptr:8775";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkAndRecordBeforeDrop;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556927;
  v6[536862722] = -218959360;
  v6[536862723] = -202178560;
  *(_DWORD *)(v4 + 48) = drop_id;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&value, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32), 0xA28u, v25);
  std::string::~string(&value);
  *(OutputResult *)(v4 + 64) = PlayerItemComp::internalCheckBeforeDrop(
                                 thisa,
                                 *(_DWORD *)(v4 + 48),
                                 drop_counta,
                                 action_reasona);
  v8 = 0;
  v10 = 0;
  if ( *(_DWORD *)(v4 + 64) )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v36);
    v8 = 1;
    v9 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v36);
    if ( ConstValueExcelConfigMgr::getIsOutputControlCanForbid(&v9->design_config.txt_config_mgr.const_value_config_mgr) )
      v10 = 1;
  }
  if ( v8 )
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)&v36);
  if ( v10 )
  {
    v11 = *(OutputResult *)(v4 + 64);
  }
  else
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v36);
    v12 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v36);
    drop_config_ptr = data::DropExcelConfigMgrBase::findDropExcelConfig(
                        &v12->design_config.txt_config_mgr.drop_config_mgr,
                        *(_DWORD *)(v4 + 48));
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)&v36);
    if ( drop_config_ptr )
    {
      PlayerItemComp::internalRecordItemLimitOutputCount(thisa, OUTPUT_CONTROL_DROP, action_reasona);
      if ( !ItemLimitExcelConfigMgr::isAllOutputControlConfigUnlimited(drop_config_ptr) )
      {
        v18 = *(_DWORD *)(v4 + 48);
        if ( *(_BYTE *)(((unsigned __int64)&action_reasona->limit_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)action_reasona + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reasona->limit_type >> 3)
                                                                       + 0x7FFF8000) )
        {
          __asan_report_load4(&action_reasona->limit_type);
        }
        PlayerItemComp::internalRecordOutputControl(
          thisa,
          OUTPUT_CONTROL_DROP,
          action_reasona->limit_type,
          v18,
          drop_counta);
      }
      __k = OUTPUT_CONTROL_DROP;
      output_control_record = std::map<data::OutputControlType,OutputControlRecord>::operator[](
                                &thisa->output_control_record_map_,
                                &__k);
      common::tools::perf::make_shared<proto_log::PlayerLogBodyAddDrop>();
      v19 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddDrop,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddDrop,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 96));
      drop_log = proto_log::PlayerLogBodyAddDrop::add_drop_log_list(v19);
      proto_log::DropLog::set_drop_id(drop_log, *(_DWORD *)(v4 + 48));
      proto_log::DropLog::set_drop_num(drop_log, drop_counta);
      if ( *(_BYTE *)(((unsigned __int64)&action_reasona->limit_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)action_reasona + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reasona->limit_type >> 3)
                                                                     + 0x7FFF8000) )
      {
        __asan_report_load4(&action_reasona->limit_type);
      }
      proto_log::DropLog::set_item_limit_type(drop_log, action_reasona->limit_type);
      v20 = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
              &output_control_record->daily_count_map,
              (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v4 + 48),
              0);
      proto_log::DropLog::set_daily_num(drop_log, v20);
      v21 = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
              &output_control_record->total_count_map,
              (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v4 + 48),
              0);
      proto_log::DropLog::set_history_num(drop_log, v21);
      TxtConfigMgr::serializeOptionalLimitConfig[abi:cxx11](&value, &drop_config_ptr->daily_output_limit);
      proto_log::DropLog::set_daily_num_limit(drop_log, &value);
      std::string::~string(&value);
      TxtConfigMgr::serializeOptionalLimitConfig[abi:cxx11](&value, &drop_config_ptr->total_output_limit);
      proto_log::DropLog::set_history_num_limit(drop_log, &value);
      std::string::~string(&value);
      v22 = *(_DWORD *)(v4 + 48);
      if ( *(_BYTE *)(((unsigned __int64)&action_reasona->limit_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)action_reasona + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reasona->limit_type >> 3)
                                                                     + 0x7FFF8000) )
      {
        __asan_report_load4(&action_reasona->limit_type);
      }
      ActivityOutputCountForLog = PlayerItemComp::internalGetActivityOutputCountForLog(
                                    thisa,
                                    action_reasona->limit_type,
                                    OUTPUT_CONTROL_DROP,
                                    v22);
      proto_log::DropLog::set_activity_num(drop_log, ActivityOutputCountForLog);
      TxtConfigMgr::serializeOptionalLimitConfig[abi:cxx11](&value, &drop_config_ptr->activity_output_limit);
      proto_log::DropLog::set_activity_num_limit(drop_log, &value);
      std::string::~string(&value);
      if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      player = thisa->player_;
      std::shared_ptr<google::protobuf::Message>::shared_ptr(&v36, 0LL);
      std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodyAddDrop,void>(
        &p_body_ptr,
        (const std::shared_ptr<proto_log::PlayerLogBodyAddDrop> *)(v4 + 96));
      Player::printStatLog(player, &p_body_ptr, &v36, 0xEu);
      std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ptr);
      std::shared_ptr<google::protobuf::Message>::~shared_ptr(&v36);
      OutputResult::OutputResult(&v34);
      v11 = v34;
      std::shared_ptr<proto_log::PlayerLogBodyAddDrop>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodyAddDrop> *const)(v4 + 96));
    }
    else
    {
      common::milog::MiLogStream::create(
        (common::milog::MiLogStream *)&value,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkAndRecordBeforeDrop",
        8762);
      v13 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
              (common::milog::MiLogStream *const)&value,
              (const char (*)[35])"findDropExcelConfig fail, drop_id:");
      v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v4 + 48));
      v15 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v14, (const char (*)[16])" action_reason:");
      v16 = operator<<(v15, action_reasona);
      v17 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v16, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v17, thisa->player_);
      common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&value);
      OutputResult::OutputResult(&v34, -1);
      v11 = v34;
    }
  }
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 32));
  result = v11;
  if ( v26 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 8792: range 0000000017D0CB36-0000000017D0D174
OutputResult __fastcall PlayerItemComp::internalCheckBeforeDrop(
        PlayerItemComp *const this,
        uint32_t drop_id,
        uint32_t drop_count,
        const ActionReason *action_reason)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r13
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rcx
  uint32_t LogLevel; // eax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rcx
  uint32_t v21; // eax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // rax
  const data::DropExcelConfig *drop_config_ptr; // [rsp+20h] [rbp-C0h]
  OutputResult v31; // [rsp+28h] [rbp-B8h] BYREF
  std::shared_ptr<Config> v32; // [rsp+30h] [rbp-B0h] BYREF
  common::milog::MiLogStream v33; // [rsp+40h] [rbp-A0h] BYREF
  char v34[128]; // [rsp+60h] [rbp-80h] BYREF
  OutputResult result; // 0:rax.6

  v4 = (unsigned __int64)v34;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(96LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 4 12 drop_id:8791 48 4 15 drop_count:8791 64 8 18 output_result:8808";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::internalCheckBeforeDrop;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556924;
  v6[536862722] = -202116352;
  *(_DWORD *)(v4 + 32) = drop_id;
  *(_DWORD *)(v4 + 48) = drop_count;
  if ( *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)action_reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3)
                                                                + 0x7FFF8000) )
  {
    __asan_report_load4(&action_reason->limit_type);
  }
  if ( action_reason->limit_type == ITEM_LIMIT_GM )
    goto LABEL_21;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v32);
  v7 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v32);
  drop_config_ptr = data::DropExcelConfigMgrBase::findDropExcelConfig(
                      &v7->design_config.txt_config_mgr.drop_config_mgr,
                      *(_DWORD *)(v4 + 32));
  std::shared_ptr<Config>::~shared_ptr(&v32);
  if ( drop_config_ptr )
  {
    *(OutputResult *)(v4 + 64) = PlayerItemComp::internalCheckItemLimitOutputCount(
                                   this,
                                   OUTPUT_CONTROL_DROP,
                                   action_reason);
    if ( *(_DWORD *)(v4 + 64) )
    {
      LogLevel = OutputResult::getLogLevel((const OutputResult *const)(v4 + 64));
      common::milog::MiLogStream::create(
        &v33,
        &common::milog::MiLogDefault::default_log_obj_,
        LogLevel,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckBeforeDrop",
        8811);
      v14 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
              &v33,
              (const char (*)[49])"internalCheckItemLimitOutputCount fail, drop_id:");
      v15 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, (const unsigned int *)(v4 + 32));
      v16 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v15, (const char (*)[13])" drop_count:");
      v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, (const unsigned int *)(v4 + 48));
      v18 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v17, (const char (*)[16])" action_reason:");
      v19 = operator<<(v18, action_reason);
      v20 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v19, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
LABEL_14:
      operator<<(v20, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v33);
      result = *(OutputResult *)(v4 + 64);
      goto LABEL_22;
    }
    if ( *(_BYTE *)(((unsigned __int64)&drop_config_ptr->item_limit_type >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&drop_config_ptr->item_limit_type >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&drop_config_ptr->item_limit_type);
    }
    v31 = PlayerItemComp::internalCheckOutputControl(
            this,
            OUTPUT_CONTROL_DROP,
            *(_DWORD *)(v4 + 32),
            *(_DWORD *)(v4 + 48),
            action_reason,
            drop_config_ptr->item_limit_type,
            drop_config_ptr,
            0);
    *(OutputResult *)(v4 + 64) = v31;
    if ( *(_DWORD *)(v4 + 64) )
    {
      v21 = OutputResult::getLogLevel((const OutputResult *const)(v4 + 64));
      common::milog::MiLogStream::create(
        &v33,
        &common::milog::MiLogDefault::default_log_obj_,
        v21,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckBeforeDrop",
        8818);
      v22 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
              &v33,
              (const char (*)[42])"internalCheckOutputControl fail, drop_id:");
      v23 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, (const unsigned int *)(v4 + 32));
      v24 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v23, (const char (*)[13])" drop_count:");
      v25 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v24, (const unsigned int *)(v4 + 48));
      v26 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v25, (const char (*)[16])" action_reason:");
      v27 = operator<<(v26, action_reason);
      v20 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v27, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_14;
    }
LABEL_21:
    OutputResult::OutputResult(&v31);
    result = v31;
    goto LABEL_22;
  }
  common::milog::MiLogStream::create(
    &v33,
    &common::milog::MiLogDefault::default_log_obj_,
    3u,
    "./src/player/item/player_item_comp.cpp",
    "internalCheckBeforeDrop",
    8802);
  v8 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
         &v33,
         (const char (*)[35])"findDropExcelConfig fail, drop_id:");
  v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, (const unsigned int *)(v4 + 32));
  v10 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v9, (const char (*)[16])" action_reason:");
  v11 = operator<<(v10, action_reason);
  v12 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v11, (const char (*)[9])" player:");
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  operator<<(v12, this->player_);
  common::milog::MiLogStream::~MiLogStream(&v33);
  OutputResult::OutputResult(&v31, -1);
  result = v31;
LABEL_22:
  if ( v34 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 8827: range 0000000017D0D176-0000000017D0DDF5
int32_t __cdecl PlayerItemComp::checkAndRecordBeforeReward(
        PlayerItemComp *const this,
        std::vector<unsigned int> *reward_id_vec,
        const ActionReason *action_reason)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  PlayerBasicComp *BasicComp; // rax
  __gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >::reference v7; // rax
  _DWORD *v8; // rdx
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  bool isRewardIdNeedBeReplaced; // r14
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rcx
  __gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >::reference v16; // rax
  _DWORD *v17; // rdx
  char v18; // r14
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v19; // rax
  bool v20; // r15
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rdx
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rdx
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rcx
  uint32_t v29; // ecx
  std::__shared_ptr_access<proto_log::PlayerLogBodyAddReward,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v30; // rax
  google::protobuf::uint32 v31; // eax
  google::protobuf::uint32 v32; // eax
  uint32_t v33; // ecx
  google::protobuf::uint32 ActivityOutputCountForLog; // eax
  Player *player; // r14
  int32_t result; // eax
  std::string v37; // [rsp+0h] [rbp-210h]
  char *v38; // [rsp+0h] [rbp-210h]
  const ActionReason *action_reasona; // [rsp+8h] [rbp-208h]
  std::vector<unsigned int> *reward_id_veca; // [rsp+10h] [rbp-200h]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-1F8h]
  std::vector<unsigned int>::iterator __for_begin_0; // [rsp+28h] [rbp-1E8h] BYREF
  std::vector<unsigned int>::iterator __for_end; // [rsp+30h] [rbp-1E0h] BYREF
  std::vector<unsigned int> *__for_range; // [rsp+38h] [rbp-1D8h]
  std::vector<unsigned int> *__for_range_0; // [rsp+40h] [rbp-1D0h]
  const data::RewardExcelConfig *reward_config_ptr; // [rsp+48h] [rbp-1C8h]
  const OutputControlRecord *output_control_record; // [rsp+50h] [rbp-1C0h]
  proto_log::PlayerRewardLog *player_reward_log; // [rsp+58h] [rbp-1B8h]
  std::shared_ptr<google::protobuf::Message> v49; // [rsp+60h] [rbp-1B0h] BYREF
  std::shared_ptr<google::protobuf::Message> v50; // [rsp+70h] [rbp-1A0h] BYREF
  common::milog::MiLogStream v51; // [rsp+80h] [rbp-190h] BYREF
  std::string value; // [rsp+A0h] [rbp-170h] BYREF
  std::string v53; // [rsp+C0h] [rbp-150h] BYREF
  std::string v54; // [rsp+E0h] [rbp-130h] BYREF
  char v55[272]; // [rsp+100h] [rbp-110h] BYREF

  *(&v37._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  v37._anon_0._M_allocated_capacity = (std::string::size_type)reward_id_vec;
  v37._M_string_length = (std::string::size_type)action_reason;
  v3 = (unsigned __int64)v55;
  v37._M_dataplus._M_p = v55;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(224LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "6 48 1 11 holder:8828 64 4 14 reward_id:8852 80 4 22 replace_reward_id:8836 96 8 18 output_resul"
                        "t:8855 128 16 23 add_reward_log_ptr:8851 160 24 27 original_reward_id_vec:8830";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkAndRecordBeforeReward;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234753551;
  v5[536862722] = -234556924;
  v5[536862723] = -218959360;
  v5[536862724] = -219021312;
  v5[536862725] = -218103808;
  v5[536862726] = -202116109;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&v54, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v3 + 48), 0xA29u, v37);
  std::string::~string(&v54);
  std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v3 + 160));
  std::vector<unsigned int>::swap((std::vector<unsigned int> *const)(v3 + 160), reward_id_veca);
  __for_range = (std::vector<unsigned int> *)(v3 + 160);
  __for_end._M_current = std::vector<unsigned int>::begin((std::vector<unsigned int> *const)(v3 + 160))._M_current;
  *(std::vector<unsigned int>::iterator *)(v3 + 96) = std::vector<unsigned int>::end((std::vector<unsigned int> *const)(v3 + 160));
  while ( __gnu_cxx::operator!=<unsigned int *,std::vector<unsigned int>>(
            &__for_end,
            (const __gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> > *)(v3 + 96)) )
  {
    v7 = __gnu_cxx::__normal_iterator<unsigned int *,std::vector<unsigned int>>::operator*(&__for_end);
    v8 = v7;
    if ( *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v7 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v7);
    }
    *(_DWORD *)(v3 + 64) = *v8;
    *(_DWORD *)(v3 + 80) = 0;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v50);
    v9 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v50);
    isRewardIdNeedBeReplaced = FeatureSwitchMgr::isRewardIdNeedBeReplaced(
                                 &v9->feature_switch_mgr,
                                 *(_DWORD *)(v3 + 64),
                                 (uint32_t *)(v3 + 80));
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)&v50);
    if ( isRewardIdNeedBeReplaced )
    {
      common::milog::MiLogStream::create(
        (common::milog::MiLogStream *)&v54,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "checkAndRecordBeforeReward",
        8839);
      v11 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(
              (common::milog::MiLogStream *const)&v54,
              (const char (*)[19])"replace reward_id:");
      v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v3 + 64));
      v13 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v12, (const char (*)[7])" with ");
      v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v3 + 80));
      v15 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v14, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v15, thisa->player_);
      common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v54);
      std::vector<unsigned int>::push_back(reward_id_veca, (const std::vector<unsigned int>::value_type *)(v3 + 80));
    }
    else
    {
      std::vector<unsigned int>::push_back(reward_id_veca, (const std::vector<unsigned int>::value_type *)(v3 + 64));
    }
    __gnu_cxx::__normal_iterator<unsigned int *,std::vector<unsigned int>>::operator++(&__for_end);
  }
  std::vector<unsigned int>::clear((std::vector<unsigned int> *const)(v3 + 160));
  std::vector<unsigned int>::swap((std::vector<unsigned int> *const)(v3 + 160), reward_id_veca);
  common::tools::perf::make_shared<proto_log::PlayerLogBodyAddReward>();
  __for_range_0 = (std::vector<unsigned int> *)(v3 + 160);
  __for_begin_0._M_current = std::vector<unsigned int>::begin((std::vector<unsigned int> *const)(v3 + 160))._M_current;
  __for_end._M_current = std::vector<unsigned int>::end(__for_range_0)._M_current;
  while ( __gnu_cxx::operator!=<unsigned int *,std::vector<unsigned int>>(&__for_begin_0, &__for_end) )
  {
    v16 = __gnu_cxx::__normal_iterator<unsigned int *,std::vector<unsigned int>>::operator*(&__for_begin_0);
    v17 = v16;
    if ( *(_BYTE *)(((unsigned __int64)v16 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v16 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v16 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v16);
    }
    *(_DWORD *)(v3 + 64) = *v17;
    *(OutputResult *)(v3 + 96) = PlayerItemComp::internalCheckBeforeReward(thisa, *(_DWORD *)(v3 + 64), action_reasona);
    v18 = 0;
    v20 = 0;
    if ( *(_DWORD *)(v3 + 96) )
    {
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v49);
      v18 = 1;
      v19 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v49);
      if ( ConstValueExcelConfigMgr::getIsOutputControlCanForbid(&v19->design_config.txt_config_mgr.const_value_config_mgr) )
        v20 = 1;
    }
    if ( v18 )
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)&v49);
    if ( !v20 )
    {
      std::vector<unsigned int>::push_back(reward_id_veca, (const std::vector<unsigned int>::value_type *)(v3 + 64));
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v50);
      v21 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v50);
      reward_config_ptr = data::RewardExcelConfigMgrBase::findRewardExcelConfig(
                            &v21->design_config.txt_config_mgr.reward_config_mgr,
                            *(_DWORD *)(v3 + 64));
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)&v50);
      if ( reward_config_ptr )
      {
        PlayerItemComp::internalRecordItemLimitOutputCount(thisa, OUTPUT_CONTROL_REWARD, action_reasona);
        if ( !ItemLimitExcelConfigMgr::isAllOutputControlConfigUnlimited(reward_config_ptr) )
        {
          v29 = *(_DWORD *)(v3 + 64);
          if ( *(_BYTE *)(((unsigned __int64)&action_reasona->limit_type >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)action_reasona + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reasona->limit_type >> 3)
                                                                         + 0x7FFF8000) )
          {
            __asan_report_load4(&action_reasona->limit_type);
          }
          PlayerItemComp::internalRecordOutputControl(thisa, OUTPUT_CONTROL_REWARD, action_reasona->limit_type, v29, 1u);
        }
        *(_DWORD *)(v3 + 80) = 2;
        output_control_record = std::map<data::OutputControlType,OutputControlRecord>::operator[](
                                  &thisa->output_control_record_map_,
                                  (std::map<data::OutputControlType,OutputControlRecord>::key_type *)(v3 + 80));
        v30 = std::__shared_ptr_access<proto_log::PlayerLogBodyAddReward,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyAddReward,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
        player_reward_log = proto_log::PlayerLogBodyAddReward::add_reward_log_list(v30);
        proto_log::PlayerRewardLog::set_reward_id(player_reward_log, *(_DWORD *)(v3 + 64));
        proto_log::PlayerRewardLog::set_reward_num(player_reward_log, 1u);
        v31 = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
                &output_control_record->daily_count_map,
                (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v3 + 64),
                0);
        proto_log::PlayerRewardLog::set_daily_num(player_reward_log, v31);
        v32 = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
                &output_control_record->total_count_map,
                (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v3 + 64),
                0);
        proto_log::PlayerRewardLog::set_history_num(player_reward_log, v32);
        if ( *(_BYTE *)(((unsigned __int64)&reward_config_ptr->item_limit_type >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&reward_config_ptr->item_limit_type >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&reward_config_ptr->item_limit_type);
        }
        proto_log::PlayerRewardLog::set_item_limit_type(player_reward_log, reward_config_ptr->item_limit_type);
        TxtConfigMgr::serializeOptionalLimitConfig[abi:cxx11](&value, &reward_config_ptr->daily_output_limit);
        proto_log::PlayerRewardLog::set_daily_num_limit(player_reward_log, &value);
        std::string::~string(&value);
        TxtConfigMgr::serializeOptionalLimitConfig[abi:cxx11](&v53, &reward_config_ptr->total_output_limit);
        proto_log::PlayerRewardLog::set_history_num_limit(player_reward_log, &v53);
        std::string::~string(&v53);
        v33 = *(_DWORD *)(v3 + 64);
        if ( *(_BYTE *)(((unsigned __int64)&action_reasona->limit_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)action_reasona + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reasona->limit_type >> 3)
                                                                       + 0x7FFF8000) )
        {
          __asan_report_load4(&action_reasona->limit_type);
        }
        ActivityOutputCountForLog = PlayerItemComp::internalGetActivityOutputCountForLog(
                                      thisa,
                                      action_reasona->limit_type,
                                      OUTPUT_CONTROL_REWARD,
                                      v33);
        proto_log::PlayerRewardLog::set_activity_num(player_reward_log, ActivityOutputCountForLog);
        TxtConfigMgr::serializeOptionalLimitConfig[abi:cxx11](&v54, &reward_config_ptr->total_output_limit);
        proto_log::PlayerRewardLog::set_activity_num_limit(player_reward_log, &v54);
        std::string::~string(&v54);
      }
      else
      {
        common::milog::MiLogStream::create(
          &v51,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkAndRecordBeforeReward",
          8866);
        v22 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
                &v51,
                (const char (*)[39])"findRewardExcelConfig fail, reward_id:");
        v23 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v22,
                (const unsigned int *)(v3 + 64));
        v24 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(
                v23,
                (const char (*)[16])" reward_id_vec:");
        v25 = common::milog::MiLogStream::operator<<<unsigned int>(v24, reward_id_veca);
        v26 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(
                v25,
                (const char (*)[16])" action_reason:");
        v27 = operator<<(v26, action_reasona);
        v28 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v27, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v28, thisa->player_);
        common::milog::MiLogStream::~MiLogStream(&v51);
      }
    }
    __gnu_cxx::__normal_iterator<unsigned int *,std::vector<unsigned int>>::operator++(&__for_begin_0);
  }
  if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  player = thisa->player_;
  std::shared_ptr<google::protobuf::Message>::shared_ptr(&v50, 0LL);
  std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodyAddReward,void>(
    &v49,
    (const std::shared_ptr<proto_log::PlayerLogBodyAddReward> *)(v3 + 128));
  Player::printStatLog(player, &v49, &v50, 0xEu);
  std::shared_ptr<google::protobuf::Message>::~shared_ptr(&v49);
  std::shared_ptr<google::protobuf::Message>::~shared_ptr(&v50);
  std::shared_ptr<proto_log::PlayerLogBodyAddReward>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodyAddReward> *const)(v3 + 128));
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v3 + 160));
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v3 + 48));
  result = 0;
  if ( v38 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8018) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8018) = -168430091;
  }
  return result;
};

// Line 8894: range 0000000017D0DDF6-0000000017D0E3D3
OutputResult __fastcall PlayerItemComp::internalCheckBeforeReward(
        PlayerItemComp *const this,
        uint32_t reward_id,
        const ActionReason *action_reason)
{
  unsigned __int64 v3; // r12
  __int64 v4; // rax
  _DWORD *v5; // r13
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rcx
  uint32_t LogLevel; // eax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rcx
  const data::OutputControlConfig *v18; // rcx
  uint32_t v19; // eax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  const data::RewardExcelConfig *reward_config_ptr; // [rsp+20h] [rbp-C0h]
  OutputResult v26; // [rsp+28h] [rbp-B8h] BYREF
  std::shared_ptr<Config> v27; // [rsp+30h] [rbp-B0h] BYREF
  common::milog::MiLogStream v28; // [rsp+40h] [rbp-A0h] BYREF
  char v29[128]; // [rsp+60h] [rbp-80h] BYREF
  OutputResult result; // 0:rax.6

  v3 = (unsigned __int64)v29;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "2 48 4 14 reward_id:8893 64 8 18 output_result:8906";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::internalCheckBeforeReward;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -202116352;
  *(_DWORD *)(v3 + 48) = reward_id;
  if ( *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)action_reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3)
                                                                + 0x7FFF8000) )
  {
    __asan_report_load4(&action_reason->limit_type);
  }
  if ( action_reason->limit_type == ITEM_LIMIT_GM )
  {
    OutputResult::OutputResult(&v26);
    result = v26;
    goto LABEL_23;
  }
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v27);
  v6 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v27);
  reward_config_ptr = data::RewardExcelConfigMgrBase::findRewardExcelConfig(
                        &v6->design_config.txt_config_mgr.reward_config_mgr,
                        *(_DWORD *)(v3 + 48));
  std::shared_ptr<Config>::~shared_ptr(&v27);
  if ( reward_config_ptr )
  {
    *(OutputResult *)(v3 + 64) = PlayerItemComp::internalCheckItemLimitOutputCount(
                                   this,
                                   OUTPUT_CONTROL_REWARD,
                                   action_reason);
    if ( *(_DWORD *)(v3 + 64) )
    {
      LogLevel = OutputResult::getLogLevel((const OutputResult *const)(v3 + 64));
      common::milog::MiLogStream::create(
        &v28,
        &common::milog::MiLogDefault::default_log_obj_,
        LogLevel,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckBeforeReward",
        8909);
      v13 = common::milog::MiLogStream::operator<<<char [51],(char *[51])0>(
              &v28,
              (const char (*)[51])"internalCheckItemLimitOutputCount fail, reward_id:");
      v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v3 + 48));
      v15 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v14, (const char (*)[16])" action_reason:");
      v16 = operator<<(v15, action_reason);
      v17 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v16, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    else
    {
      v18 = reward_config_ptr;
      if ( *(_BYTE *)(((unsigned __int64)&reward_config_ptr->item_limit_type >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&reward_config_ptr->item_limit_type >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&reward_config_ptr->item_limit_type);
      }
      v26 = PlayerItemComp::internalCheckOutputControl(
              this,
              OUTPUT_CONTROL_REWARD,
              *(_DWORD *)(v3 + 48),
              1u,
              action_reason,
              reward_config_ptr->item_limit_type,
              v18,
              0);
      *(OutputResult *)(v3 + 64) = v26;
      if ( !*(_DWORD *)(v3 + 64) )
      {
        result = *(OutputResult *)(v3 + 64);
        goto LABEL_23;
      }
      v19 = OutputResult::getLogLevel((const OutputResult *const)(v3 + 64));
      common::milog::MiLogStream::create(
        &v28,
        &common::milog::MiLogDefault::default_log_obj_,
        v19,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckBeforeReward",
        8916);
      v20 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
              &v28,
              (const char (*)[44])"internalCheckOutputControl fail, reward_id:");
      v21 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, (const unsigned int *)(v3 + 48));
      v22 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v21, (const char (*)[16])" action_reason:");
      v23 = operator<<(v22, action_reason);
      v17 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v23, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
    }
    operator<<(v17, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v28);
    result = *(OutputResult *)(v3 + 64);
    goto LABEL_23;
  }
  common::milog::MiLogStream::create(
    &v28,
    &common::milog::MiLogDefault::default_log_obj_,
    3u,
    "./src/player/item/player_item_comp.cpp",
    "internalCheckBeforeReward",
    8902);
  v7 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
         &v28,
         (const char (*)[39])"findRewardExcelConfig fail, reward_id:");
  v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v3 + 48));
  v9 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v8, (const char (*)[16])" action_reason:");
  v10 = operator<<(v9, action_reason);
  v11 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v10, (const char (*)[9])" player:");
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  operator<<(v11, this->player_);
  common::milog::MiLogStream::~MiLogStream(&v28);
  OutputResult::OutputResult(&v26, -1);
  result = v26;
LABEL_23:
  if ( v29 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 8924: range 0000000017D0E3D4-0000000017D0E57F
OutputResult __cdecl PlayerItemComp::checkAndRecordItemLimitOutputCount(
        PlayerItemComp *const this,
        data::OutputControlType output_control_type,
        const ActionReason *action_reason)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  unsigned __int64 v5; // r12
  char v6; // r14
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  bool v8; // r15
  std::shared_ptr<Config> v10; // [rsp+20h] [rbp-80h] BYREF
  char v11[112]; // [rsp+30h] [rbp-70h] BYREF
  OutputResult result; // 0:rax.6

  v3 = (unsigned __int64)v11;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_0(64LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 8 18 output_result:8925";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkAndRecordItemLimitOutputCount;
  v5 = v3 >> 3;
  *(_DWORD *)(v5 + 2147450880) = -235802127;
  *(_DWORD *)(v5 + 2147450884) = -202116352;
  *(OutputResult *)(v3 + 32) = PlayerItemComp::internalCheckItemLimitOutputCount(
                                 this,
                                 output_control_type,
                                 action_reason);
  v6 = 0;
  v8 = 0;
  if ( *(_DWORD *)(v3 + 32) )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v10);
    v6 = 1;
    v7 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v10);
    if ( ConstValueExcelConfigMgr::getIsOutputControlCanForbid(&v7->design_config.txt_config_mgr.const_value_config_mgr) )
      v8 = 1;
  }
  if ( v6 )
    std::shared_ptr<Config>::~shared_ptr(&v10);
  if ( v8 )
    result = *(OutputResult *)(v3 + 32);
  else
    result = PlayerItemComp::internalRecordItemLimitOutputCount(this, output_control_type, action_reason);
  if ( v11 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 8935: range 0000000017D0E580-0000000017D0E978
OutputResult __fastcall PlayerItemComp::internalCheckItemLimitOutputCount(
        PlayerItemComp *const this,
        data::OutputControlType output_control_type,
        const ActionReason *action_reason)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rcx
  const data::OutputControlLimitExcelConfig *output_control_config_ptr; // [rsp+30h] [rbp-C0h]
  OutputResult v16; // [rsp+38h] [rbp-B8h] BYREF
  std::shared_ptr<Config> v17; // [rsp+40h] [rbp-B0h] BYREF
  common::milog::MiLogStream v18; // [rsp+50h] [rbp-A0h] BYREF
  char v19[128]; // [rsp+70h] [rbp-80h] BYREF
  OutputResult result; // 0:rax.6

  v3 = (unsigned __int64)v19;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "2 48 4 20 item_limit_type:8941 64 4 24 output_control_type:8934";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::internalCheckItemLimitOutputCount;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -202116348;
  *(_DWORD *)(v3 + 64) = output_control_type;
  if ( *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)action_reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3)
                                                                + 0x7FFF8000) )
  {
    __asan_report_load4(&action_reason->limit_type);
  }
  if ( action_reason->limit_type == ITEM_LIMIT_GM )
  {
    OutputResult::OutputResult(&v16);
    result = v16;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)action_reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3)
                                                                  + 0x7FFF8000) )
    {
      __asan_report_load4(&action_reason->limit_type);
    }
    *(_DWORD *)(v3 + 48) = action_reason->limit_type;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v17);
    v6 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v17);
    output_control_config_ptr = data::ItemLimitExcelConfigMgrBase::findOutputControlLimitExcelConfig(
                                  &v6->design_config.txt_config_mgr.item_limit_config_mgr,
                                  (data::ItemLimitType)*(_DWORD *)(v3 + 48));
    std::shared_ptr<Config>::~shared_ptr(&v17);
    if ( output_control_config_ptr )
    {
      if ( *(char *)(((unsigned __int64)&output_control_config_ptr->is_forbid_alert_on_output_control_daily_limit >> 3)
                   + 0x7FFF8000) < 0 )
        __asan_report_load1(&output_control_config_ptr->is_forbid_alert_on_output_control_daily_limit);
      result = PlayerItemComp::internalCheckOutputControl(
                 this,
                 OUTPUT_CONTROL_NONE,
                 *(_DWORD *)(v3 + 48),
                 1u,
                 action_reason,
                 ITEM_LIMIT_NONE,
                 output_control_config_ptr,
                 output_control_config_ptr->is_forbid_alert_on_output_control_daily_limit);
    }
    else
    {
      common::milog::MiLogStream::create(
        &v18,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckItemLimitOutputCount",
        8945);
      v7 = common::milog::MiLogStream::operator<<<char [61],(char *[61])0>(
             &v18,
             (const char (*)[61])"findOutputControlLimitExcelConfig fail! output_control_type:");
      v8 = common::milog::MiLogStream::operator<<<data::OutputControlType,(data::OutputControlType*)0>(
             v7,
             (const data::OutputControlType *)(v3 + 64));
      v9 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(v8, (const char (*)[18])" item_limit_type:");
      v10 = common::milog::MiLogStream::operator<<<data::ItemLimitType,(data::ItemLimitType*)0>(
              v9,
              (const data::ItemLimitType *)(v3 + 48));
      v11 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v10, (const char (*)[16])" action_reason:");
      v12 = operator<<(v11, action_reason);
      v13 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v12, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v13, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v18);
      OutputResult::OutputResult(&v16, -1);
      result = v16;
    }
  }
  if ( v19 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 8954: range 0000000017D0E97A-0000000017D0EFB2
OutputResult __cdecl PlayerItemComp::internalRecordItemLimitOutputCount(
        PlayerItemComp *const this,
        data::OutputControlType output_control_type,
        const ActionReason *action_reason)
{
  unsigned __int64 v3; // r12
  __int64 v4; // rax
  _DWORD *v5; // r13
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v6; // rax
  OutputResult v7; // r14
  PlayerBasicComp *BasicComp; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // r14
  google::protobuf::uint32 v11; // eax
  std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // r14
  google::protobuf::uint32 v13; // eax
  std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v14; // r14
  std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v15; // r14
  std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v16; // r14
  google::protobuf::uint32 ActivityOutputCountForLog; // eax
  std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v18; // r14
  Player *player; // r14
  std::string v20; // [rsp+0h] [rbp-110h]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-F8h]
  std::map<data::OutputControlType,OutputControlRecord>::key_type __k; // [rsp+20h] [rbp-F0h] BYREF
  data::ItemLimitType item_limit_type; // [rsp+24h] [rbp-ECh]
  const data::OutputControlLimitExcelConfig *output_control_config_ptr; // [rsp+28h] [rbp-E8h]
  const OutputControlRecord *output_control_record; // [rsp+30h] [rbp-E0h]
  OutputResult v26; // [rsp+38h] [rbp-D8h] BYREF
  std::shared_ptr<google::protobuf::Message> p_body_ptr; // [rsp+40h] [rbp-D0h] BYREF
  std::shared_ptr<google::protobuf::Message> v28; // [rsp+50h] [rbp-C0h] BYREF
  std::string value; // [rsp+60h] [rbp-B0h] BYREF
  char v30[144]; // [rsp+80h] [rbp-90h] BYREF
  OutputResult result; // 0:rax.6

  *(&v20._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  HIDWORD(v20._anon_0._M_allocated_capacity) = output_control_type;
  v20._M_string_length = (std::string::size_type)action_reason;
  v3 = (unsigned __int64)v30;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "2 48 1 11 holder:8965 64 16 23 limit_type_log_ptr:8969";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::internalRecordItemLimitOutputCount;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234753551;
  v5[536862722] = -202178560;
  if ( *(_BYTE *)(((v20._M_string_length + 4) >> 3) + 0x7FFF8000) != 0
    && (char)(((LOBYTE(v20._M_string_length) + 4) & 7) + 3) >= *(_BYTE *)(((v20._M_string_length + 4) >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(v20._M_string_length + 4);
  }
  item_limit_type = *(_DWORD *)(v20._M_string_length + 4);
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v28);
  v6 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v28);
  output_control_config_ptr = data::ItemLimitExcelConfigMgrBase::findOutputControlLimitExcelConfig(
                                &v6->design_config.txt_config_mgr.item_limit_config_mgr,
                                item_limit_type);
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)&v28);
  if ( !output_control_config_ptr
    || ItemLimitExcelConfigMgr::isAllOutputControlConfigUnlimited(output_control_config_ptr) )
  {
    OutputResult::OutputResult(&v26);
    v7 = v26;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    BasicComp = Player::getBasicComp(this->player_);
    PlayerBasicComp::getNextTransNo[abi:cxx11](&value, BasicComp);
    StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v3 + 48), 0xA2Au, v20);
    std::string::~string(&value);
    PlayerItemComp::internalRecordOutputControl(thisa, OUTPUT_CONTROL_NONE, item_limit_type, item_limit_type, 1u);
    __k = OUTPUT_CONTROL_NONE;
    output_control_record = std::map<data::OutputControlType,OutputControlRecord>::operator[](
                              &thisa->output_control_record_map_,
                              &__k);
    common::tools::perf::make_shared<proto_log::PlayerLogBodyItemLimitTypeLimit>();
    v9 = std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
    proto_log::PlayerLogBodyItemLimitTypeLimit::set_item_limit_type(v9, item_limit_type);
    v10 = std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
    __k = item_limit_type;
    v11 = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
            &output_control_record->daily_count_map,
            (const std::unordered_map<unsigned int,unsigned int>::key_type *)&__k,
            0);
    proto_log::PlayerLogBodyItemLimitTypeLimit::set_daily_num(v10, v11);
    v12 = std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
    __k = item_limit_type;
    v13 = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
            &output_control_record->total_count_map,
            (const std::unordered_map<unsigned int,unsigned int>::key_type *)&__k,
            0);
    proto_log::PlayerLogBodyItemLimitTypeLimit::set_history_num(v12, v13);
    v14 = std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
    TxtConfigMgr::serializeOptionalLimitConfig[abi:cxx11](&value, &output_control_config_ptr->daily_output_limit);
    proto_log::PlayerLogBodyItemLimitTypeLimit::set_daily_num_limit(v14, &value);
    std::string::~string(&value);
    v15 = std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
    TxtConfigMgr::serializeOptionalLimitConfig[abi:cxx11](&value, &output_control_config_ptr->total_output_limit);
    proto_log::PlayerLogBodyItemLimitTypeLimit::set_history_num_limit(v15, &value);
    std::string::~string(&value);
    v16 = std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
    ActivityOutputCountForLog = PlayerItemComp::internalGetActivityOutputCountForLog(
                                  thisa,
                                  item_limit_type,
                                  OUTPUT_CONTROL_NONE,
                                  item_limit_type);
    proto_log::PlayerLogBodyItemLimitTypeLimit::set_activity_num(v16, ActivityOutputCountForLog);
    v18 = std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyItemLimitTypeLimit,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 64));
    TxtConfigMgr::serializeOptionalLimitConfig[abi:cxx11](&value, &output_control_config_ptr->activity_output_limit);
    proto_log::PlayerLogBodyItemLimitTypeLimit::set_activity_num_limit(v18, &value);
    std::string::~string(&value);
    if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    player = thisa->player_;
    std::shared_ptr<google::protobuf::Message>::shared_ptr(&v28, 0LL);
    std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodyItemLimitTypeLimit,void>(
      &p_body_ptr,
      (const std::shared_ptr<proto_log::PlayerLogBodyItemLimitTypeLimit> *)(v3 + 64));
    Player::printStatLog(player, &p_body_ptr, &v28, 0xEu);
    std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ptr);
    std::shared_ptr<google::protobuf::Message>::~shared_ptr(&v28);
    OutputResult::OutputResult(&v26);
    v7 = v26;
    std::shared_ptr<proto_log::PlayerLogBodyItemLimitTypeLimit>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodyItemLimitTypeLimit> *const)(v3 + 64));
    StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v3 + 48));
  }
  result = v7;
  if ( v30 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 8985: range 0000000017D0FD5A-0000000017D11A48
OutputResult __fastcall PlayerItemComp::internalCheckOutputControl(
        PlayerItemComp *const this,
        data::OutputControlType output_control_type,
        uint32_t output_index,
        uint32_t output_count,
        const ActionReason *action_reason,
        data::ItemLimitType config_item_limit_type,
        const data::OutputControlConfig *output_control_config,
        bool is_forbid_alert_on_output_control_daily_limit)
{
  unsigned __int64 v8; // r13
  __int64 v9; // rax
  _DWORD *v10; // r12
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rcx
  OutputResult v16; // r14
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rcx
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v29; // r14
  const char *v30; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v31; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v32; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v33; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v34; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v35; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v36; // r14
  const char *v37; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v38; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v39; // r14
  const char *v40; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v41; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v42; // r14
  unsigned int Uid; // eax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v44; // rax
  bool v45; // r14
  uint32_t LogLevel; // eax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v47; // rax
  time_t v48; // rdx
  time_t last_refresh_time; // rsi
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v50; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v51; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v52; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v53; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v54; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v55; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v56; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v57; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v58; // r14
  const char *v59; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v60; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v61; // r14
  const char *v62; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v63; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v64; // r14
  unsigned int v65; // eax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v66; // rax
  bool v67; // r14
  uint32_t v68; // eax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v69; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v70; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v71; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v72; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v73; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v74; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v75; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v76; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v77; // r14
  const char *v78; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v79; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v80; // r14
  const char *v81; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v82; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v83; // r14
  unsigned int v84; // eax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v85; // rax
  bool v86; // r14
  uint32_t v87; // eax
  NewActivityExcelConfigMgr *p_new_activity_config_mgr; // rcx
  bool v89; // r14
  const NewActivityExcelConfigMgr *v90; // rdi
  __int64 v91; // rsi
  bool isCrossActivityBeginTime; // r14
  PlayerActivityComp *ActivityComp; // rax
  const char *v95; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v96; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v97; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v98; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v99; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v100; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v101; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v102; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v103; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v104; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v105; // r14
  const char *v106; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v107; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v108; // r14
  const char *v109; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v110; // rax
  common::tools::StringStream<common::tools::FixedBuffer<4096> > *v111; // r14
  unsigned int v112; // eax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v113; // rax
  bool v114; // r14
  const char *v115; // rax
  uint32_t v116; // eax
  std::allocator<char> __a; // [rsp+3Ah] [rbp-236h] BYREF
  bool is_activity_open; // [rsp+3Bh] [rbp-235h]
  uint32_t now; // [rsp+3Ch] [rbp-234h]
  uint32_t time_offset; // [rsp+40h] [rbp-230h]
  uint32_t old_daily_count; // [rsp+44h] [rbp-22Ch]
  uint32_t old_total_count; // [rsp+48h] [rbp-228h]
  uint32_t old_activity_count; // [rsp+4Ch] [rbp-224h]
  const data::OutputControlLimitExcelConfig *output_config_ptr; // [rsp+50h] [rbp-220h]
  OutputControlRecord *output_control_record; // [rsp+58h] [rbp-218h]
  ActivityOutputControlRecord *activity_output_control_record; // [rsp+60h] [rbp-210h]
  ActivityOutputIndexRecord *index_record; // [rsp+68h] [rbp-208h]
  std::shared_ptr<Config> v134; // [rsp+70h] [rbp-200h] BYREF
  common::milog::MiLogStream v135; // [rsp+80h] [rbp-1F0h] BYREF
  char v136[464]; // [rsp+A0h] [rbp-1D0h] BYREF
  OutputResult result; // 0:rax.6

  v8 = (unsigned __int64)v136;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v9 = __asan_stack_malloc_3(416LL);
    if ( v9 )
      v8 = v9;
  }
  *(_QWORD *)v8 = 1102416563LL;
  *(_QWORD *)(v8 + 8) = "12 32 4 18 activity_type:9141 48 4 24 output_control_type:8982 64 4 17 output_index:8982 80 4 17"
                        " output_count:8982 96 4 27 config_item_limit_type:8983 112 8 30 daily_output_check_result:9060 1"
                        "44 8 30 total_output_check_result:9061 176 8 33 activity_output_check_result:9062 208 8 18 outpu"
                        "t_result:9184 240 16 8 oss:9157 272 32 6 s:9165 336 48 15 send_alarm:8986";
  *(_QWORD *)(v8 + 16) = PlayerItemComp::internalCheckOutputControl;
  v10 = (_DWORD *)(v8 >> 3);
  v10[536862720] = -235802127;
  v10[536862721] = -234556924;
  v10[536862722] = -234556924;
  v10[536862723] = 61956;
  v10[536862723] = -234881024;
  v10[536862724] = 62194;
  v10[536862724] = -234881024;
  v10[536862725] = 62194;
  v10[536862725] = -234881024;
  v10[536862726] = 62194;
  v10[536862726] = -234881024;
  v10[536862727] = 62194;
  v10[536862728] = 62194;
  v10[536862729] = -219021312;
  v10[536862730] = 62194;
  v10[536862732] = -202116109;
  *(_DWORD *)(v8 + 48) = output_control_type;
  *(_DWORD *)(v8 + 64) = output_index;
  *(_DWORD *)(v8 + 80) = output_count;
  *(_DWORD *)(v8 + 96) = config_item_limit_type;
  *(_QWORD *)(v8 + 336) = v8 + 48;
  *(_QWORD *)(v8 + 344) = v8 + 64;
  *(_QWORD *)(v8 + 352) = v8 + 80;
  *(_QWORD *)(v8 + 360) = v8 + 96;
  *(_QWORD *)(v8 + 368) = output_control_config;
  *(_QWORD *)(v8 + 376) = this;
  if ( !data::isValidOutputControlType(*(_DWORD *)(v8 + 48)) )
  {
    common::milog::MiLogStream::create(
      &v135,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "internalCheckOutputControl",
      9014);
    v11 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
            &v135,
            (const char (*)[29])"invalid output control type:");
    v12 = common::milog::MiLogStream::operator<<<data::OutputControlType,(data::OutputControlType*)0>(
            v11,
            (const data::OutputControlType *)(v8 + 48));
    v13 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v12, (const char (*)[16])" action_reason:");
    v14 = operator<<(v13, action_reason);
    v15 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v14, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v15, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v135);
    OutputResult::OutputResult((OutputResult *const)(v8 + 208), -1);
    v16 = *(OutputResult *)(v8 + 208);
    goto LABEL_113;
  }
  if ( *(_DWORD *)(v8 + 96) )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v134);
    v17 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v134);
    output_config_ptr = data::ItemLimitExcelConfigMgrBase::findOutputControlLimitExcelConfig(
                          &v17->design_config.txt_config_mgr.item_limit_config_mgr,
                          (data::ItemLimitType)*(_DWORD *)(v8 + 96));
    std::shared_ptr<Config>::~shared_ptr(&v134);
    if ( !output_config_ptr )
    {
      common::milog::MiLogStream::create(
        &v135,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckOutputControl",
        9024);
      v18 = common::milog::MiLogStream::operator<<<char [61],(char *[61])0>(
              &v135,
              (const char (*)[61])"findOutputControlLimitExcelConfig fail! output_control_type:");
      v19 = common::milog::MiLogStream::operator<<<data::OutputControlType,(data::OutputControlType*)0>(
              v18,
              (const data::OutputControlType *)(v8 + 48));
      v20 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v19, " output_index:");
      v21 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v20, (const unsigned int *)(v8 + 64));
      v22 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v21, " output_count:");
      v23 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v22, (const unsigned int *)(v8 + 80));
      v24 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(v23, " config_item_limit_type:");
      v25 = common::milog::MiLogStream::operator<<<data::ItemLimitType,(data::ItemLimitType*)0>(
              v24,
              (const data::ItemLimitType *)(v8 + 96));
      v26 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v25, (const char (*)[16])" action_reason:");
      v27 = operator<<(v26, action_reason);
      v28 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v27, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v28, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v135);
      OutputResult::OutputResult((OutputResult *const)(v8 + 208), -1);
      v16 = *(OutputResult *)(v8 + 208);
      goto LABEL_113;
    }
    if ( *(char *)(((unsigned __int64)&output_config_ptr->is_ignore_item_limit_type >> 3) + 0x7FFF8000) < 0 )
      __asan_report_load1(&output_config_ptr->is_ignore_item_limit_type);
    if ( !output_config_ptr->is_ignore_item_limit_type )
    {
      if ( *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)action_reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3)
                                                                    + 0x7FFF8000) )
      {
        __asan_report_load4(&action_reason->limit_type);
      }
      if ( action_reason->limit_type != *(_DWORD *)(v8 + 96) )
      {
        common::tools::StringStream<common::tools::FixedBuffer<4096>>::StringStream((common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
        v29 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(
                (common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240),
                "item_limit_type not match! output_control_type:");
        v30 = data::enumValToStr((data::OutputControlType)*(_DWORD *)(v8 + 48));
        v31 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v29, v30);
        v32 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v31, aOutputIndex[0]);
        v33 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v32, *(_DWORD *)(v8 + 64));
        v34 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v33, aOutputCount[0]);
        v35 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v34, *(_DWORD *)(v8 + 80));
        v36 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v35, aConfigItemLimi_1[0]);
        v37 = data::enumValToStr((data::ItemLimitType)*(_DWORD *)(v8 + 96));
        v38 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v36, v37);
        v39 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v38, " item_limit_type:");
        if ( *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)action_reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3)
                                                                      + 0x7FFF8000) )
        {
          __asan_report_load4(&action_reason->limit_type);
        }
        v40 = data::enumValToStr(action_reason->limit_type);
        v41 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v39, v40);
        v42 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v41, " uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Uid = Player::getUid(this->player_);
        common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v42, Uid);
        common::tools::StringStream<common::tools::FixedBuffer<4096>>::str[abi:cxx11](
          (std::string *)(v8 + 272),
          (common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
        OutputResult::OutputResult((OutputResult *const)(v8 + 208), -1);
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)&v134);
        v44 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v134);
        v45 = !ItemLimitExcelConfigMgr::isOutputControlInWhiteList(
                 &v44->design_config.txt_config_mgr.item_limit_config_mgr,
                 *(data::OutputControlType *)(v8 + 48),
                 ITEM_LIMIT_WHITE_SUB_LIMIT_TYPE_MATCH,
                 *(_DWORD *)(v8 + 96));
        std::shared_ptr<Config>::~shared_ptr(&v134);
        if ( v45 )
        {
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          Player::notifyGMServerLog(this->player_, SERVER_LOG_NONE, LOG_LEVEL_ERROR_0, (const std::string *)(v8 + 272));
          std::allocator<char>::allocator(&__a);
          std::string::basic_string<std::allocator<char>>((std::string *const)&v135, "item_limit_type not match!", &__a);
          PlayerItemComp::internalCheckOutputControl(data::OutputControlType,unsigned int,unsigned int,ActionReason const&,data::ItemLimitType,data::OutputControlConfig const&,bool)::{lambda(std::string const&,unsigned int)#1}::operator()(
            (const PlayerItemComp::internalCheckOutputControl::<lambda(const string&, uint32_t)> *const)(v8 + 336),
            (const std::string *)&v135,
            0);
          std::string::~string(&v135);
          std::allocator<char>::~allocator(&__a);
          *(_BYTE *)(v8 + 213) = 1;
        }
        else
        {
          *(_BYTE *)(v8 + 212) = 1;
        }
        LogLevel = OutputResult::getLogLevel((const OutputResult *const)(v8 + 208));
        common::milog::MiLogStream::create(
          &v135,
          &common::milog::MiLogDefault::default_log_obj_,
          LogLevel,
          "./src/player/item/player_item_comp.cpp",
          "internalCheckOutputControl",
          9048);
        common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(&v135, (const std::string *)(v8 + 272));
        common::milog::MiLogStream::~MiLogStream(&v135);
        v16 = *(OutputResult *)(v8 + 208);
        std::string::~string((void *)(v8 + 272));
        common::tools::StringStream<common::tools::FixedBuffer<4096>>::~StringStream((common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
        goto LABEL_113;
      }
    }
    if ( *(char *)(((unsigned __int64)&output_config_ptr->is_forbid_alert_on_output_control_daily_limit >> 3)
                 + 0x7FFF8000) < 0 )
      __asan_report_load1(&output_config_ptr->is_forbid_alert_on_output_control_daily_limit);
    is_forbid_alert_on_output_control_daily_limit = output_config_ptr->is_forbid_alert_on_output_control_daily_limit;
  }
  if ( ItemLimitExcelConfigMgr::isAllOutputControlConfigUnlimited(output_control_config) )
  {
    OutputResult::OutputResult((OutputResult *const)(v8 + 208));
    v16 = *(OutputResult *)(v8 + 208);
  }
  else
  {
    now = common::tools::TimeUtils::getNow();
    OutputResult::OutputResult((OutputResult *const)(v8 + 112));
    OutputResult::OutputResult((OutputResult *const)(v8 + 144));
    OutputResult::OutputResult((OutputResult *const)(v8 + 176));
    output_control_record = std::map<data::OutputControlType,OutputControlRecord>::operator[](
                              &this->output_control_record_map_,
                              (const std::map<data::OutputControlType,OutputControlRecord>::key_type *)(v8 + 48));
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v134);
    v47 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v134);
    time_offset = ConstValueExcelConfigMgr::getTimeOffsetSec(&v47->design_config.txt_config_mgr.const_value_config_mgr);
    std::shared_ptr<Config>::~shared_ptr(&v134);
    v48 = time_offset;
    if ( *(_BYTE *)(((unsigned __int64)output_control_record >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)output_control_record >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(output_control_record);
    }
    last_refresh_time = output_control_record->last_refresh_time;
    if ( !common::tools::TimeUtils::isSameDay(now, last_refresh_time, v48) )
    {
      std::unordered_map<unsigned int,unsigned int>::clear(&output_control_record->daily_count_map);
      if ( *(_BYTE *)(((unsigned __int64)output_control_record >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)output_control_record >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_store4(output_control_record, last_refresh_time, output_control_record);
      }
      output_control_record->last_refresh_time = now;
    }
    old_daily_count = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
                        &output_control_record->daily_count_map,
                        (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v8 + 64),
                        0);
    if ( PlayerItemComp::internalCheckOutputLimit(
           this,
           old_daily_count,
           *(_DWORD *)(v8 + 80),
           &output_control_config->daily_output_limit,
           0) )
    {
      common::tools::StringStream<common::tools::FixedBuffer<4096>>::StringStream((common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
      v50 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(
              (common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240),
              "output count exceed daily limit! output_control_type:");
      v51 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v50, *(_DWORD *)(v8 + 48));
      v52 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v51, " old_daily_count:");
      v53 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v52, old_daily_count);
      v54 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v53, aOutputIndex[0]);
      v55 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v54, *(_DWORD *)(v8 + 64));
      v56 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v55, aOutputCount[0]);
      v57 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v56, *(_DWORD *)(v8 + 80));
      v58 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v57, aConfigItemLimi_1[0]);
      v59 = data::enumValToStr((data::ItemLimitType)*(_DWORD *)(v8 + 96));
      v60 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v58, v59);
      v61 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v60, " item_limit_type:");
      if ( *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)action_reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3)
                                                                    + 0x7FFF8000) )
      {
        __asan_report_load4(&action_reason->limit_type);
      }
      v62 = data::enumValToStr(action_reason->limit_type);
      v63 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v61, v62);
      v64 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v63, " uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v65 = Player::getUid(this->player_);
      common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v64, v65);
      common::tools::StringStream<common::tools::FixedBuffer<4096>>::str[abi:cxx11](
        (std::string *)(v8 + 272),
        (common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
      if ( is_forbid_alert_on_output_control_daily_limit )
      {
        *(_BYTE *)(v8 + 116) = 1;
      }
      else
      {
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)&v134);
        v66 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v134);
        v67 = !ItemLimitExcelConfigMgr::isOutputControlInWhiteList(
                 &v66->design_config.txt_config_mgr.item_limit_config_mgr,
                 *(data::OutputControlType *)(v8 + 48),
                 ITEM_LIMIT_WHITE_SUB_DAILY_LIMIT,
                 *(_DWORD *)(v8 + 64));
        std::shared_ptr<Config>::~shared_ptr(&v134);
        if ( v67 )
        {
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          Player::notifyGMServerLog(this->player_, SERVER_LOG_NONE, LOG_LEVEL_ERROR_0, (const std::string *)(v8 + 272));
          std::allocator<char>::allocator(&__a);
          std::string::basic_string<std::allocator<char>>(
            (std::string *const)&v135,
            "output count exceed daily limit!",
            &__a);
          PlayerItemComp::internalCheckOutputControl(data::OutputControlType,unsigned int,unsigned int,ActionReason const&,data::ItemLimitType,data::OutputControlConfig const&,bool)::{lambda(std::string const&,unsigned int)#1}::operator()(
            (const PlayerItemComp::internalCheckOutputControl::<lambda(const string&, uint32_t)> *const)(v8 + 336),
            (const std::string *)&v135,
            old_daily_count);
          std::string::~string(&v135);
          std::allocator<char>::~allocator(&__a);
          *(_BYTE *)(v8 + 117) = 1;
        }
        else
        {
          *(_BYTE *)(v8 + 116) = 1;
        }
      }
      v68 = OutputResult::getLogLevel((const OutputResult *const)(v8 + 112));
      common::milog::MiLogStream::create(
        &v135,
        &common::milog::MiLogDefault::default_log_obj_,
        v68,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckOutputControl",
        9105);
      common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(&v135, (const std::string *)(v8 + 272));
      common::milog::MiLogStream::~MiLogStream(&v135);
      if ( PlayerItemComp::internalCheckOutputLimit(
             this,
             old_daily_count,
             *(_DWORD *)(v8 + 80),
             &output_control_config->daily_output_limit,
             1) )
      {
        *(_DWORD *)(v8 + 112) = -1;
      }
      std::string::~string((void *)(v8 + 272));
      common::tools::StringStream<common::tools::FixedBuffer<4096>>::~StringStream((common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
    }
    old_total_count = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
                        &output_control_record->total_count_map,
                        (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v8 + 64),
                        0);
    if ( PlayerItemComp::internalCheckOutputLimit(
           this,
           old_total_count,
           *(_DWORD *)(v8 + 80),
           &output_control_config->total_output_limit,
           0) )
    {
      common::tools::StringStream<common::tools::FixedBuffer<4096>>::StringStream((common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
      v69 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(
              (common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240),
              "output count exceed total limit! output_control_type:");
      v70 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v69, *(_DWORD *)(v8 + 48));
      v71 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v70, " old_total_count:");
      v72 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v71, old_total_count);
      v73 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v72, aOutputIndex[0]);
      v74 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v73, *(_DWORD *)(v8 + 64));
      v75 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v74, aOutputCount[0]);
      v76 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v75, *(_DWORD *)(v8 + 80));
      v77 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v76, aConfigItemLimi_1[0]);
      v78 = data::enumValToStr((data::ItemLimitType)*(_DWORD *)(v8 + 96));
      v79 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v77, v78);
      v80 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v79, " item_limit_type:");
      if ( *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)action_reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3)
                                                                    + 0x7FFF8000) )
      {
        __asan_report_load4(&action_reason->limit_type);
      }
      v81 = data::enumValToStr(action_reason->limit_type);
      v82 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v80, v81);
      v83 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v82, " uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v84 = Player::getUid(this->player_);
      common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v83, v84);
      common::tools::StringStream<common::tools::FixedBuffer<4096>>::str[abi:cxx11](
        (std::string *)(v8 + 272),
        (common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v134);
      v85 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v134);
      v86 = !ItemLimitExcelConfigMgr::isOutputControlInWhiteList(
               &v85->design_config.txt_config_mgr.item_limit_config_mgr,
               *(data::OutputControlType *)(v8 + 48),
               ITEM_LIMIT_WHITE_SUB_TOTAL_LIMIT,
               *(_DWORD *)(v8 + 64));
      std::shared_ptr<Config>::~shared_ptr(&v134);
      if ( v86 )
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        Player::notifyGMServerLog(this->player_, SERVER_LOG_NONE, LOG_LEVEL_ERROR_0, (const std::string *)(v8 + 272));
        std::allocator<char>::allocator(&__a);
        std::string::basic_string<std::allocator<char>>(
          (std::string *const)&v135,
          "output count exceed total limit!",
          &__a);
        PlayerItemComp::internalCheckOutputControl(data::OutputControlType,unsigned int,unsigned int,ActionReason const&,data::ItemLimitType,data::OutputControlConfig const&,bool)::{lambda(std::string const&,unsigned int)#1}::operator()(
          (const PlayerItemComp::internalCheckOutputControl::<lambda(const string&, uint32_t)> *const)(v8 + 336),
          (const std::string *)&v135,
          old_total_count);
        std::string::~string(&v135);
        std::allocator<char>::~allocator(&__a);
        *(_BYTE *)(v8 + 149) = 1;
      }
      else
      {
        *(_BYTE *)(v8 + 148) = 1;
      }
      v87 = OutputResult::getLogLevel((const OutputResult *const)(v8 + 144));
      common::milog::MiLogStream::create(
        &v135,
        &common::milog::MiLogDefault::default_log_obj_,
        v87,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckOutputControl",
        9135);
      common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(&v135, (const std::string *)(v8 + 272));
      common::milog::MiLogStream::~MiLogStream(&v135);
      *(_DWORD *)(v8 + 144) = -1;
      std::string::~string((void *)(v8 + 272));
      common::tools::StringStream<common::tools::FixedBuffer<4096>>::~StringStream((common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
    }
    *(_DWORD *)(v8 + 32) = 0;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v134);
    p_new_activity_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v134)->design_config.txt_config_mgr.new_activity_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)action_reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3)
                                                                  + 0x7FFF8000) )
    {
      __asan_report_load4(&action_reason->limit_type);
    }
    v89 = NewActivityExcelConfigMgr::checkAndFindActivityTypeByItemLimitType(
            p_new_activity_config_mgr,
            action_reason->limit_type,
            (data::NewActivityType *)(v8 + 32)) == 0;
    std::shared_ptr<Config>::~shared_ptr(&v134);
    if ( v89 )
    {
      activity_output_control_record = std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::operator[](
                                         &this->activity_output_control_record_map_,
                                         (const std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::key_type *)(v8 + 32));
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v134);
      v90 = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v134)->design_config.txt_config_mgr.new_activity_config_mgr;
      if ( *(_BYTE *)(((unsigned __int64)activity_output_control_record >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)activity_output_control_record >> 3) + 0x7FFF8000) <= 3 )
      {
        v90 = (const NewActivityExcelConfigMgr *)activity_output_control_record;
        __asan_report_load4(activity_output_control_record);
      }
      v91 = *(unsigned int *)(v8 + 32);
      isCrossActivityBeginTime = NewActivityExcelConfigMgr::isCrossActivityBeginTime(
                                   v90,
                                   (data::NewActivityType)v91,
                                   activity_output_control_record->last_refresh_time,
                                   now);
      std::shared_ptr<Config>::~shared_ptr(&v134);
      if ( isCrossActivityBeginTime )
      {
        std::map<data::OutputControlType,ActivityOutputIndexRecord>::clear(&activity_output_control_record->activity_output_index_record_map);
        if ( *(_BYTE *)(((unsigned __int64)activity_output_control_record >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)activity_output_control_record >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_store4(activity_output_control_record, v91, activity_output_control_record);
        }
        activity_output_control_record->last_refresh_time = now;
      }
      index_record = std::map<data::OutputControlType,ActivityOutputIndexRecord>::operator[](
                       &activity_output_control_record->activity_output_index_record_map,
                       (const std::map<data::OutputControlType,ActivityOutputIndexRecord>::key_type *)(v8 + 48));
      old_activity_count = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
                             &index_record->activity_count_map,
                             (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v8 + 64),
                             0);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      ActivityComp = Player::getActivityComp(this->player_);
      is_activity_open = PlayerActivityComp::isActivityTypeOpen(ActivityComp, *(data::NewActivityType *)(v8 + 32), 4u);
      if ( !is_activity_open
        || PlayerItemComp::internalCheckOutputLimit(
             this,
             old_activity_count,
             *(_DWORD *)(v8 + 80),
             &output_control_config->activity_output_limit,
             0) )
      {
        common::tools::StringStream<common::tools::FixedBuffer<4096>>::StringStream((common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
        if ( is_activity_open )
          v95 = "output count exceed activity limit!";
        else
          v95 = "output when activity not open!";
        v96 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(
                (common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240),
                v95);
        v97 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v96, " output_control_type:");
        v98 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v97, *(_DWORD *)(v8 + 48));
        v99 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v98, " old_activity_count:");
        v100 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v99, old_activity_count);
        v101 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v100, aOutputIndex[0]);
        v102 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v101, *(_DWORD *)(v8 + 64));
        v103 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v102, aOutputCount[0]);
        v104 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v103, *(_DWORD *)(v8 + 80));
        v105 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v104, aConfigItemLimi_1[0]);
        v106 = data::enumValToStr((data::ItemLimitType)*(_DWORD *)(v8 + 96));
        v107 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v105, v106);
        v108 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v107, " item_limit_type:");
        if ( *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)action_reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&action_reason->limit_type >> 3)
                                                                      + 0x7FFF8000) )
        {
          __asan_report_load4(&action_reason->limit_type);
        }
        v109 = data::enumValToStr(action_reason->limit_type);
        v110 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v108, v109);
        v111 = common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v110, " uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        v112 = Player::getUid(this->player_);
        common::tools::StringStream<common::tools::FixedBuffer<4096>>::operator<<(v111, v112);
        common::tools::StringStream<common::tools::FixedBuffer<4096>>::str[abi:cxx11](
          (std::string *)(v8 + 272),
          (common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)&v134);
        v113 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v134);
        v114 = !ItemLimitExcelConfigMgr::isOutputControlInWhiteList(
                  &v113->design_config.txt_config_mgr.item_limit_config_mgr,
                  *(data::OutputControlType *)(v8 + 48),
                  ITEM_LIMIT_WHITE_SUB_ACTIVITY_LIMIT,
                  *(_DWORD *)(v8 + 64));
        std::shared_ptr<Config>::~shared_ptr(&v134);
        if ( v114 )
        {
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          Player::notifyGMServerLog(this->player_, SERVER_LOG_NONE, LOG_LEVEL_ERROR_0, (const std::string *)(v8 + 272));
          std::allocator<char>::allocator(&__a);
          if ( is_activity_open )
            v115 = "output count exceed activity limit!";
          else
            v115 = "output when activity not open!";
          std::string::basic_string<std::allocator<char>>((std::string *const)&v135, v115, &__a);
          PlayerItemComp::internalCheckOutputControl(data::OutputControlType,unsigned int,unsigned int,ActionReason const&,data::ItemLimitType,data::OutputControlConfig const&,bool)::{lambda(std::string const&,unsigned int)#1}::operator()(
            (const PlayerItemComp::internalCheckOutputControl::<lambda(const string&, uint32_t)> *const)(v8 + 336),
            (const std::string *)&v135,
            old_activity_count);
          std::string::~string(&v135);
          std::allocator<char>::~allocator(&__a);
          *(_BYTE *)(v8 + 181) = 1;
        }
        else
        {
          *(_BYTE *)(v8 + 180) = 1;
        }
        v116 = OutputResult::getLogLevel((const OutputResult *const)(v8 + 176));
        common::milog::MiLogStream::create(
          &v135,
          &common::milog::MiLogDefault::default_log_obj_,
          v116,
          "./src/player/item/player_item_comp.cpp",
          "internalCheckOutputControl",
          9176);
        common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(&v135, (const std::string *)(v8 + 272));
        common::milog::MiLogStream::~MiLogStream(&v135);
        if ( PlayerItemComp::internalCheckOutputLimit(
               this,
               old_activity_count,
               *(_DWORD *)(v8 + 80),
               &output_control_config->activity_output_limit,
               1) )
        {
          *(_DWORD *)(v8 + 176) = -1;
        }
        std::string::~string((void *)(v8 + 272));
        common::tools::StringStream<common::tools::FixedBuffer<4096>>::~StringStream((common::tools::StringStream<common::tools::FixedBuffer<4096> > *const)(v8 + 240));
      }
    }
    OutputResult::OutputResult((OutputResult *const)(v8 + 208));
    if ( *(_DWORD *)(v8 + 112) || *(_DWORD *)(v8 + 144) || *(_DWORD *)(v8 + 176) )
      *(_DWORD *)(v8 + 208) = -1;
    if ( *(_DWORD *)(v8 + 208)
      && (!*(_DWORD *)(v8 + 112) || *(_BYTE *)(v8 + 116))
      && (!*(_DWORD *)(v8 + 144) || *(_BYTE *)(v8 + 148))
      && (!*(_DWORD *)(v8 + 176) || *(_BYTE *)(v8 + 180)) )
    {
      *(_BYTE *)(v8 + 212) = 1;
    }
    v16 = *(OutputResult *)(v8 + 208);
  }
LABEL_113:
  result = v16;
  if ( v136 == (char *)v8 )
  {
    *(_QWORD *)((v8 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8018) = 0LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8020) = 0LL;
    *(_DWORD *)((v8 >> 3) + 0x7FFF8028) = 0;
    *(_DWORD *)((v8 >> 3) + 0x7FFF8030) = 0;
  }
  else
  {
    *(_QWORD *)v8 = 1172321806LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v8 >> 3) + 0x7FFF8028) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v8 >> 3) + 0x7FFF8030) = -168430091;
  }
  return result;
};

// Line 8986: range 0000000017D0EFB4-0000000017D0FD59
void __cdecl PlayerItemComp::internalCheckOutputControl(data::OutputControlType,unsigned int,unsigned int,ActionReason const&,data::ItemLimitType,data::OutputControlConfig const&,bool)::{lambda(std::string const&,unsigned int)#1}::operator()(
        const PlayerItemComp::internalCheckOutputControl::<lambda(const string&, uint32_t)> *const __closure,
        const std::string *alarm_message,
        uint32_t old_output_count)
{
  unsigned __int64 v3; // r12
  __int64 v4; // rax
  _DWORD *v5; // r13
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v6; // rdx
  bool is_output_control_can_alarm; // r14
  int *output_control_type; // rdx
  Json::Value_0 *v9; // rax
  data::OutputControlType *v10; // rdx
  const char *v11; // rax
  Json::Value_0 *v12; // rax
  unsigned int *output_index; // rdx
  Json::Value_0 *v14; // rax
  Json::Value_0 *v15; // rax
  unsigned int *output_count; // rdx
  Json::Value_0 *v17; // rax
  int *config_item_limit_type; // rdx
  Json::Value_0 *v19; // rax
  data::ItemLimitType *v20; // rdx
  const char *v21; // rax
  Json::Value_0 *v22; // rax
  const data::OutputControlConfig *output_control_config; // rax
  char v24; // r14
  const data::OutputControlConfig *v25; // rdx
  Json::Value_0 *v26; // rax
  const data::OutputControlConfig *v27; // rax
  char v28; // r14
  const data::OutputControlConfig *v29; // rdx
  Json::Value_0 *v30; // rax
  const data::OutputControlConfig *v31; // rax
  char v32; // r14
  const data::OutputControlConfig *v33; // rdx
  Json::Value_0 *v34; // rax
  Json::Value_0 *v35; // rax
  Json::Value_0 *v36; // rax
  std::allocator<char> __a; // [rsp+2Fh] [rbp-111h] BYREF
  std::shared_ptr<Config> v39; // [rsp+30h] [rbp-110h] BYREF
  std::string v40; // [rsp+40h] [rbp-100h] BYREF
  Json::Value_0 other; // [rsp+60h] [rbp-E0h] BYREF
  char v42[176]; // [rsp+90h] [rbp-B0h] BYREF

  v3 = (unsigned __int64)v42;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(128LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 48 40 9 jval:8991";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::internalCheckOutputControl(data::OutputControlType,unsigned int,unsigned int,ActionReason const&,data::ItemLimitType,data::OutputControlConfig const&,bool)::{lambda(std::string const&,unsigned int)#1}::operator();
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = 61937;
  v5[536862722] = -218103808;
  v5[536862723] = -202116109;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v39);
  v6 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v39);
  if ( *(_BYTE *)(((unsigned __int64)&v6->is_output_control_can_alarm >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)v6 - 87) & 7) >= *(_BYTE *)(((unsigned __int64)&v6->is_output_control_can_alarm >> 3)
                                                    + 0x7FFF8000) )
  {
    __asan_report_load1(&v6->is_output_control_can_alarm);
  }
  is_output_control_can_alarm = v6->is_output_control_can_alarm;
  std::shared_ptr<Config>::~shared_ptr(&v39);
  if ( is_output_control_can_alarm )
  {
    Json::Value::Value(v3 + 48, 0LL);
    if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    output_control_type = (int *)__closure->__output_control_type;
    if ( *(_BYTE *)(((unsigned __int64)__closure->__output_control_type >> 3) + 0x7FFF8000) != 0
      && (char)(((__int64)__closure->__output_control_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)__closure->__output_control_type >> 3)
                                                                                 + 0x7FFF8000) )
    {
      __asan_report_load4(__closure->__output_control_type);
    }
    Json::Value::Value((Json::Value *)&other, *output_control_type);
    v9 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "output_control_type");
    Json::Value::operator=(v9, &other);
    Json::Value::~Value(&other);
    if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v10 = __closure->__output_control_type;
    if ( *(_BYTE *)(((unsigned __int64)__closure->__output_control_type >> 3) + 0x7FFF8000) != 0
      && (char)(((__int64)__closure->__output_control_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)__closure->__output_control_type >> 3)
                                                                                 + 0x7FFF8000) )
    {
      __asan_report_load4(__closure->__output_control_type);
    }
    v11 = data::enumValToStr(*v10);
    Json::Value::Value((Json::Value *)&other, v11);
    v12 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "output_control_type_str");
    Json::Value::operator=(v12, &other);
    Json::Value::~Value(&other);
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__output_index >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    output_index = __closure->__output_index;
    if ( *(_BYTE *)(((unsigned __int64)output_index >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)output_index & 7) + 3) >= *(_BYTE *)(((unsigned __int64)output_index >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(__closure->__output_index);
    }
    Json::Value::Value((Json::Value *)&other, *output_index);
    v14 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "output_index");
    Json::Value::operator=(v14, &other);
    Json::Value::~Value(&other);
    if ( old_output_count )
    {
      Json::Value::Value((Json::Value *)&other, old_output_count);
      v15 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "old_output_count");
      Json::Value::operator=(v15, &other);
      Json::Value::~Value(&other);
    }
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__output_count >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    output_count = __closure->__output_count;
    if ( *(_BYTE *)(((unsigned __int64)output_count >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)output_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)output_count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(__closure->__output_count);
    }
    Json::Value::Value((Json::Value *)&other, *output_count);
    v17 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "output_count");
    Json::Value::operator=(v17, &other);
    Json::Value::~Value(&other);
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__config_item_limit_type >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    config_item_limit_type = (int *)__closure->__config_item_limit_type;
    if ( *(_BYTE *)(((unsigned __int64)config_item_limit_type >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)config_item_limit_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)config_item_limit_type >> 3)
                                                                               + 0x7FFF8000) )
    {
      __asan_report_load4(__closure->__config_item_limit_type);
    }
    Json::Value::Value((Json::Value *)&other, *config_item_limit_type);
    v19 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "config_item_limit_type");
    Json::Value::operator=(v19, &other);
    Json::Value::~Value(&other);
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__config_item_limit_type >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v20 = __closure->__config_item_limit_type;
    if ( *(_BYTE *)(((unsigned __int64)v20 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v20 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v20 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(__closure->__config_item_limit_type);
    }
    v21 = data::enumValToStr(*v20);
    Json::Value::Value((Json::Value *)&other, v21);
    v22 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "config_item_limit_type_str");
    Json::Value::operator=(v22, &other);
    Json::Value::~Value(&other);
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__output_control_config >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    output_control_config = __closure->__output_control_config;
    if ( *(char *)(((unsigned __int64)&output_control_config->daily_output_limit.is_unlimited >> 3) + 0x7FFF8000) < 0 )
      output_control_config = (const data::OutputControlConfig *)__asan_report_load1(&output_control_config->daily_output_limit.is_unlimited);
    v24 = 0;
    if ( output_control_config->daily_output_limit.is_unlimited )
    {
      std::allocator<char>::allocator(&__a);
      v24 = 1;
      std::string::basic_string<std::allocator<char>>(&v40, "unlimited", &__a);
    }
    else
    {
      if ( *(_BYTE *)(((unsigned __int64)&__closure->__output_control_config >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v25 = __closure->__output_control_config;
      if ( *(_BYTE *)(((unsigned __int64)&v25->daily_output_limit.limit_count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)v25 + 20) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&v25->daily_output_limit.limit_count >> 3)
                                                           + 0x7FFF8000) )
      {
        __asan_report_load4(&v25->daily_output_limit.limit_count);
      }
      std::to_string(&v40, v25->daily_output_limit.limit_count);
    }
    Json::Value::Value(&other, &v40);
    v26 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "daily_limit");
    Json::Value::operator=(v26, &other);
    Json::Value::~Value(&other);
    std::string::~string(&v40);
    if ( v24 )
      std::allocator<char>::~allocator(&__a);
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__output_control_config >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v27 = __closure->__output_control_config;
    if ( *(char *)(((unsigned __int64)&v27->total_output_limit.is_unlimited >> 3) + 0x7FFF8000) < 0 )
      v27 = (const data::OutputControlConfig *)__asan_report_load1(&v27->total_output_limit.is_unlimited);
    v28 = 0;
    if ( v27->total_output_limit.is_unlimited )
    {
      std::allocator<char>::allocator(&__a);
      v28 = 1;
      std::string::basic_string<std::allocator<char>>(&v40, "unlimited", &__a);
    }
    else
    {
      if ( *(_BYTE *)(((unsigned __int64)&__closure->__output_control_config >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v29 = __closure->__output_control_config;
      if ( *(_BYTE *)(((unsigned __int64)&v29->total_output_limit.limit_count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)v29 + 36) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&v29->total_output_limit.limit_count >> 3)
                                                           + 0x7FFF8000) )
      {
        __asan_report_load4(&v29->total_output_limit.limit_count);
      }
      std::to_string(&v40, v29->total_output_limit.limit_count);
    }
    Json::Value::Value(&other, &v40);
    v30 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "total_limit");
    Json::Value::operator=(v30, &other);
    Json::Value::~Value(&other);
    std::string::~string(&v40);
    if ( v28 )
      std::allocator<char>::~allocator(&__a);
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__output_control_config >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v31 = __closure->__output_control_config;
    if ( *(char *)(((unsigned __int64)&v31->activity_output_limit.is_unlimited >> 3) + 0x7FFF8000) < 0 )
      v31 = (const data::OutputControlConfig *)__asan_report_load1(&v31->activity_output_limit.is_unlimited);
    v32 = 0;
    if ( v31->activity_output_limit.is_unlimited )
    {
      std::allocator<char>::allocator(&__a);
      v32 = 1;
      std::string::basic_string<std::allocator<char>>(&v40, "unlimited", &__a);
    }
    else
    {
      if ( *(_BYTE *)(((unsigned __int64)&__closure->__output_control_config >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v33 = __closure->__output_control_config;
      if ( *(_BYTE *)(((unsigned __int64)&v33->activity_output_limit.limit_count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)v33 + 52) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&v33->activity_output_limit.limit_count >> 3)
                                                           + 0x7FFF8000) )
      {
        __asan_report_load4(&v33->activity_output_limit.limit_count);
      }
      std::to_string(&v40, v33->activity_output_limit.limit_count);
    }
    Json::Value::Value(&other, &v40);
    v34 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "activity_limit");
    Json::Value::operator=(v34, &other);
    Json::Value::~Value(&other);
    std::string::~string(&v40);
    if ( v32 )
      std::allocator<char>::~allocator(&__a);
    Json::Value::Value(&other, alarm_message);
    v35 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "message");
    Json::Value::operator=(v35, &other);
    Json::Value::~Value(&other);
    Json::Value::Value((Json::Value *)&other, "output_control");
    v36 = Json::Value::operator[]((Json::Value_0 *const)(v3 + 48), "type");
    Json::Value::operator=(v36, &other);
    Json::Value::~Value(&other);
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__this >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    PlayerItemComp::asyncSendAlarmToPlatform(__closure->__this, (Json::Value *)(v3 + 48));
    Json::Value::~Value((Json::Value_0 *const)(v3 + 48));
  }
  if ( v42 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 9201: range 0000000017D11A4A-0000000017D11E89
void __fastcall PlayerItemComp::internalRecordOutputControl(
        PlayerItemComp *const this,
        data::OutputControlType output_control_type,
        data::ItemLimitType item_limit_type,
        uint32_t output_index,
        uint32_t output_count)
{
  unsigned __int64 v5; // r12
  __int64 v6; // rax
  _DWORD *v7; // r13
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v8; // rax
  unsigned int *v9; // rdx
  SelectType v10; // r14d
  char *v11; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v12; // rax
  SelectType *v13; // rdx
  char v14; // cl
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v15; // rax
  unsigned int *v16; // rdx
  SelectType v17; // r14d
  char *v18; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v19; // rax
  SelectType *v20; // rdx
  char v21; // cl
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v22; // rax
  bool v23; // r14
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v24; // rax
  unsigned int *v25; // rdx
  SelectType v26; // r14d
  char *v27; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v28; // rax
  SelectType *v29; // rdx
  char v30; // cl
  OutputControlRecord *output_control_record; // [rsp+28h] [rbp-B8h]
  ActivityOutputControlRecord *activity_output_control_record; // [rsp+30h] [rbp-B0h]
  ActivityOutputIndexRecord *index_record; // [rsp+38h] [rbp-A8h]
  std::shared_ptr<Config> v37; // [rsp+40h] [rbp-A0h] BYREF
  char v38[144]; // [rsp+50h] [rbp-90h] BYREF

  v5 = (unsigned __int64)v38;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_1(96LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "3 32 4 18 activity_type:9205 48 4 24 output_control_type:9200 64 4 17 output_index:9200";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::internalRecordOutputControl;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556924;
  v7[536862722] = -202116348;
  *(_DWORD *)(v5 + 48) = output_control_type;
  *(_DWORD *)(v5 + 64) = output_index;
  output_control_record = std::map<data::OutputControlType,OutputControlRecord>::operator[](
                            &this->output_control_record_map_,
                            (const std::map<data::OutputControlType,OutputControlRecord>::key_type *)(v5 + 48));
  v8 = std::unordered_map<unsigned int,unsigned int>::operator[](
         &output_control_record->daily_count_map,
         (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v5 + 64));
  v9 = v8;
  if ( *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)v8 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(v8);
  }
  v10 = SAFE_ADD<unsigned int,unsigned int>(*v9, output_count);
  v11 = (char *)(v5 + 64);
  v12 = std::unordered_map<unsigned int,unsigned int>::operator[](
          &output_control_record->daily_count_map,
          (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v5 + 64));
  v13 = v12;
  v14 = *(_BYTE *)(((unsigned __int64)v12 >> 3) + 0x7FFF8000);
  if ( v14 != 0 && (char)(((unsigned __int8)v12 & 7) + 3) >= v14 )
  {
    LOBYTE(v11) = v14 != 0;
    __asan_report_store4(v12, v11, v12);
  }
  *v13 = v10;
  v15 = std::unordered_map<unsigned int,unsigned int>::operator[](
          &output_control_record->total_count_map,
          (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v5 + 64));
  v16 = v15;
  if ( *(_BYTE *)(((unsigned __int64)v15 >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)v15 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v15 >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(v15);
  }
  v17 = SAFE_ADD<unsigned int,unsigned int>(*v16, output_count);
  v18 = (char *)(v5 + 64);
  v19 = std::unordered_map<unsigned int,unsigned int>::operator[](
          &output_control_record->total_count_map,
          (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v5 + 64));
  v20 = v19;
  v21 = *(_BYTE *)(((unsigned __int64)v19 >> 3) + 0x7FFF8000);
  if ( v21 != 0 && (char)(((unsigned __int8)v19 & 7) + 3) >= v21 )
  {
    LOBYTE(v18) = v21 != 0;
    __asan_report_store4(v19, v18, v19);
  }
  *v20 = v17;
  *(_DWORD *)(v5 + 32) = 0;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v37);
  v22 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v37);
  v23 = NewActivityExcelConfigMgr::checkAndFindActivityTypeByItemLimitType(
          &v22->design_config.txt_config_mgr.new_activity_config_mgr,
          item_limit_type,
          (data::NewActivityType *)(v5 + 32)) == 0;
  std::shared_ptr<Config>::~shared_ptr(&v37);
  if ( v23 )
  {
    activity_output_control_record = std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::operator[](
                                       &this->activity_output_control_record_map_,
                                       (const std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::key_type *)(v5 + 32));
    index_record = std::map<data::OutputControlType,ActivityOutputIndexRecord>::operator[](
                     &activity_output_control_record->activity_output_index_record_map,
                     (const std::map<data::OutputControlType,ActivityOutputIndexRecord>::key_type *)(v5 + 48));
    v24 = std::unordered_map<unsigned int,unsigned int>::operator[](
            &index_record->activity_count_map,
            (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v5 + 64));
    v25 = v24;
    if ( *(_BYTE *)(((unsigned __int64)v24 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v24 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v24 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v24);
    }
    v26 = SAFE_ADD<unsigned int,unsigned int>(*v25, output_count);
    v27 = (char *)(v5 + 64);
    v28 = std::unordered_map<unsigned int,unsigned int>::operator[](
            &index_record->activity_count_map,
            (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v5 + 64));
    v29 = v28;
    v30 = *(_BYTE *)(((unsigned __int64)v28 >> 3) + 0x7FFF8000);
    if ( v30 != 0 && (char)(((unsigned __int8)v28 & 7) + 3) >= v30 )
    {
      LOBYTE(v27) = v30 != 0;
      __asan_report_store4(v28, v27, v28);
    }
    *v29 = v26;
  }
  if ( v38 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 9216: range 0000000017D11E8A-0000000017D12169
uint32_t __fastcall PlayerItemComp::internalGetActivityOutputCountForLog(
        const PlayerItemComp *const this,
        data::ItemLimitType item_limit_type,
        data::OutputControlType output_control_type,
        uint32_t output_index)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  bool v8; // r14
  uint32_t result; // eax
  std::__detail::_Node_const_iterator<std::pair<const data::NewActivityType,ActivityOutputControlRecord>,false,false>::pointer v10; // rax
  std::__detail::_Node_iterator_base<std::pair<const data::NewActivityType,ActivityOutputControlRecord>,false> __y; // [rsp+28h] [rbp-F8h] BYREF
  const ActivityOutputControlRecord *activity_output_control_record; // [rsp+30h] [rbp-F0h]
  const ActivityOutputIndexRecord *index_record; // [rsp+38h] [rbp-E8h]
  std::shared_ptr<Config> v16; // [rsp+40h] [rbp-E0h] BYREF
  char v17[208]; // [rsp+50h] [rbp-D0h] BYREF

  v4 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(160LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "5 48 4 18 activity_type:9217 64 4 24 output_control_type:9215 80 4 17 output_index:9215 96 8 25 "
                        "activity_record_iter:9222 128 8 22 index_record_iter:9228";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::internalGetActivityOutputCountForLog;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556943;
  v6[536862722] = -234556924;
  v6[536862723] = -218959360;
  v6[536862724] = -202116352;
  *(_DWORD *)(v4 + 64) = output_control_type;
  *(_DWORD *)(v4 + 80) = output_index;
  *(_DWORD *)(v4 + 48) = 0;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v16);
  v7 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v16);
  v8 = NewActivityExcelConfigMgr::checkAndFindActivityTypeByItemLimitType(
         &v7->design_config.txt_config_mgr.new_activity_config_mgr,
         item_limit_type,
         (data::NewActivityType *)(v4 + 48)) != 0;
  std::shared_ptr<Config>::~shared_ptr(&v16);
  if ( v8 )
  {
    result = 0;
  }
  else
  {
    *(std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::const_iterator *)(v4 + 96) = std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::find(&this->activity_output_control_record_map_, (const std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::key_type *)(v4 + 48));
    __y._M_cur = std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::end(&this->activity_output_control_record_map_)._M_cur;
    if ( std::__detail::operator==<std::pair<data::NewActivityType const,ActivityOutputControlRecord>,false>(
           (const std::__detail::_Node_iterator_base<std::pair<const data::NewActivityType,ActivityOutputControlRecord>,false> *)(v4 + 96),
           &__y) )
    {
      result = 0;
    }
    else
    {
      v10 = std::__detail::_Node_const_iterator<std::pair<data::NewActivityType const,ActivityOutputControlRecord>,false,false>::operator->((const std::__detail::_Node_const_iterator<std::pair<const data::NewActivityType,ActivityOutputControlRecord>,false,false> *const)(v4 + 96));
      activity_output_control_record = &v10->second;
      *(std::map<data::OutputControlType,ActivityOutputIndexRecord>::const_iterator *)(v4 + 128) = std::map<data::OutputControlType,ActivityOutputIndexRecord>::find(
                                                                                                     &v10->second.activity_output_index_record_map,
                                                                                                     (const std::map<data::OutputControlType,ActivityOutputIndexRecord>::key_type *)(v4 + 64));
      __y._M_cur = (std::__detail::_Node_iterator_base<std::pair<const data::NewActivityType,ActivityOutputControlRecord>,false>::__node_type *)std::map<data::OutputControlType,ActivityOutputIndexRecord>::end(&activity_output_control_record->activity_output_index_record_map)._M_node;
      if ( std::operator==(
             (const std::_Rb_tree_const_iterator<std::pair<const data::OutputControlType,ActivityOutputIndexRecord> >::_Self *)(v4 + 128),
             (const std::_Rb_tree_const_iterator<std::pair<const data::OutputControlType,ActivityOutputIndexRecord> >::_Self *)&__y) )
      {
        result = 0;
      }
      else
      {
        index_record = &std::_Rb_tree_const_iterator<std::pair<data::OutputControlType const,ActivityOutputIndexRecord>>::operator->((const std::_Rb_tree_const_iterator<std::pair<const data::OutputControlType,ActivityOutputIndexRecord> > *const)(v4 + 128))->second;
        result = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
                   &index_record->activity_count_map,
                   (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v4 + 80),
                   0);
      }
    }
  }
  if ( v17 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 9239: range 0000000017D1216A-0000000017D127DD
__int64 __fastcall PlayerItemComp::internalCheckOutputLimit(
        const PlayerItemComp *const this,
        uint32_t old_output_count,
        uint32_t delta_output_count,
        const data::OptionalLimitConfig *optional_limit_config,
        bool is_double_limit)
{
  unsigned __int64 v5; // r12
  __int64 v6; // rax
  _DWORD *v7; // r13
  __int64 result; // rax
  SelectType_0 limit_count; // eax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rcx
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rax
  common::milog::MiLogStream *v32; // rax
  common::milog::MiLogStream *v33; // rax
  common::milog::MiLogStream *v34; // rax
  common::milog::MiLogStream *v35; // rax
  common::milog::MiLogStream *v36; // rax
  common::milog::MiLogStream *v37; // rax
  common::milog::MiLogStream *v38; // rax
  common::milog::MiLogStream *v39; // rax
  common::milog::MiLogStream *v40; // rax
  common::milog::MiLogStream *v41; // rcx
  common::milog::MiLogStream v45; // [rsp+20h] [rbp-C0h] BYREF
  char v46[160]; // [rsp+40h] [rbp-A0h] BYREF

  v5 = (unsigned __int64)v46;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_1(128LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "4 48 4 16 limit_count:9244 64 4 21 new_output_count:9245 80 4 21 old_output_count:9238 96 4 23 d"
                        "elta_output_count:9238";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::internalCheckOutputLimit;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556943;
  v7[536862722] = -234556924;
  v7[536862723] = -202116348;
  *(_DWORD *)(v5 + 80) = old_output_count;
  *(_DWORD *)(v5 + 96) = delta_output_count;
  if ( *(char *)(((unsigned __int64)&optional_limit_config->is_unlimited >> 3) + 0x7FFF8000) < 0 )
    __asan_report_load1(&optional_limit_config->is_unlimited);
  if ( optional_limit_config->is_unlimited )
  {
    result = 0LL;
    goto LABEL_26;
  }
  if ( is_double_limit )
  {
    if ( *(_BYTE *)(((unsigned __int64)&optional_limit_config->limit_count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)optional_limit_config + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&optional_limit_config->limit_count >> 3)
                                                                           + 0x7FFF8000) )
    {
      __asan_report_load4(&optional_limit_config->limit_count);
    }
    limit_count = SAFE_MULTIPLY<unsigned int,int>(optional_limit_config->limit_count, 2);
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&optional_limit_config->limit_count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)optional_limit_config + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&optional_limit_config->limit_count >> 3)
                                                                           + 0x7FFF8000) )
    {
      __asan_report_load4(&optional_limit_config->limit_count);
    }
    limit_count = optional_limit_config->limit_count;
  }
  *(_DWORD *)(v5 + 48) = limit_count;
  *(_DWORD *)(v5 + 64) = *(_DWORD *)(v5 + 80) + *(_DWORD *)(v5 + 96);
  if ( *(_DWORD *)(v5 + 64) < *(_DWORD *)(v5 + 80) )
  {
    common::milog::MiLogStream::create(
      &v45,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "internalCheckOutputLimit",
      9248);
    v10 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
            &v45,
            (const char (*)[21])"count overflow. old:");
    v11 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, (const unsigned int *)(v5 + 80));
    v12 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v11, (const char (*)[8])" delta:");
    v13 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v12, (const unsigned int *)(v5 + 96));
    v14 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v13, (const char (*)[6])" new:");
    v15 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, (const unsigned int *)(v5 + 64));
    v16 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v15, (const char (*)[8])" limit:");
    v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, (const unsigned int *)(v5 + 48));
    v18 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(v17, (const char (*)[18])" is_double_limit:");
    v19 = common::milog::MiLogStream::operator<<(v18, is_double_limit);
    v20 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v19, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
LABEL_18:
    operator<<(v20, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v45);
    result = 0xFFFFFFFFLL;
    goto LABEL_26;
  }
  if ( *(_DWORD *)(v5 + 64) > *(_DWORD *)(v5 + 48) )
  {
    common::milog::MiLogStream::create(
      &v45,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "internalCheckOutputLimit",
      9254);
    v21 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
            &v45,
            (const char (*)[26])"output exceed limit. old:");
    v22 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, (const unsigned int *)(v5 + 80));
    v23 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v22, (const char (*)[8])" delta:");
    v24 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v23, (const unsigned int *)(v5 + 96));
    v25 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v24, (const char (*)[6])" new:");
    v26 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v25, (const unsigned int *)(v5 + 64));
    v27 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v26, (const char (*)[8])" limit:");
    v28 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, (const unsigned int *)(v5 + 48));
    v29 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(v28, (const char (*)[18])" is_double_limit:");
    v30 = common::milog::MiLogStream::operator<<(v29, is_double_limit);
    v20 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v30, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    goto LABEL_18;
  }
  common::milog::MiLogStream::create(
    &v45,
    &common::milog::MiLogDefault::default_log_obj_,
    1u,
    "./src/player/item/player_item_comp.cpp",
    "internalCheckOutputLimit",
    9257);
  v31 = common::milog::MiLogStream::operator<<<char [5],(char *[5])0>(&v45, (const char (*)[5])"old:");
  v32 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v31, (const unsigned int *)(v5 + 80));
  v33 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v32, (const char (*)[8])" delta:");
  v34 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v33, (const unsigned int *)(v5 + 96));
  v35 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v34, (const char (*)[6])" new:");
  v36 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v35, (const unsigned int *)(v5 + 64));
  v37 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v36, (const char (*)[8])" limit:");
  v38 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v37, (const unsigned int *)(v5 + 48));
  v39 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(v38, (const char (*)[18])" is_double_limit:");
  v40 = common::milog::MiLogStream::operator<<(v39, is_double_limit);
  v41 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v40, (const char (*)[9])" player:");
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  operator<<(v41, this->player_);
  common::milog::MiLogStream::~MiLogStream(&v45);
  result = 0LL;
LABEL_26:
  if ( v46 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 9263: range 0000000017D127DE-0000000017D12AE7
std::vector<ItemParam> *__cdecl PlayerItemComp::checkOutputLimitAndModifyItemParamsOnDrop(
        std::vector<ItemParam> *retstr,
        PlayerItemComp *const this,
        const std::vector<ItemParam> *original_item_param_vec,
        const ActionReason *reason)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  _DWORD *v6; // r13
  __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> >::reference v7; // rax
  _QWORD *p_item_id; // rdx
  __int64 v9; // rax
  __int64 v10; // rdx
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+28h] [rbp-B8h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+30h] [rbp-B0h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+38h] [rbp-A8h]
  char v17[160]; // [rsp+40h] [rbp-A0h] BYREF

  v4 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "2 32 16 15 item_param:9265 64 24 19 item_param_vec:9264";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkOutputLimitAndModifyItemParamsOnDrop;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -219021312;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 64));
  __for_range = original_item_param_vec;
  __for_begin._M_current = std::vector<ItemParam>::begin(original_item_param_vec)._M_current;
  __for_end._M_current = std::vector<ItemParam>::end(original_item_param_vec)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
  {
    v7 = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
    p_item_id = &v7->item_id;
    if ( ((unsigned __int8)v7 & 7) >= *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000)
      && *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) != 0
      || *(_BYTE *)((((unsigned __int64)&v7->promote_level + 3) >> 3) + 0x7FFF8000) != 0
      && (((unsigned __int8)v7 + 15) & 7) >= *(_BYTE *)((((unsigned __int64)&v7->promote_level + 3) >> 3) + 0x7FFF8000) )
    {
      __asan_report_load_n(v7, 16LL);
    }
    v9 = *p_item_id;
    v10 = p_item_id[1];
    *(_QWORD *)(v4 + 32) = v9;
    *(_QWORD *)(v4 + 40) = v10;
    if ( PlayerItemComp::checkAndModifyTotalObtainCountAndModifyItemCount(this, (ItemParam *)(v4 + 32), reason, 1) )
      std::vector<ItemParam>::push_back(
        (std::vector<ItemParam> *const)(v4 + 64),
        (const std::vector<ItemParam>::value_type *)(v4 + 32));
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
  }
  if ( *(char *)(((unsigned __int64)retstr >> 3) + 0x7FFF8000) < 0
    || *(_BYTE *)((((unsigned __int64)&retstr->_M_impl._M_end_of_storage + 7) >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)retstr + 23) & 7) >= *(_BYTE *)((((unsigned __int64)&retstr->_M_impl._M_end_of_storage + 7) >> 3)
                                                        + 0x7FFF8000) )
  {
    __asan_report_store_n(retstr, 24LL);
  }
  PlayerItemComp::internalCheckOutputLimitAndModifyItemParamsOnDrop(
    retstr,
    this,
    (const std::vector<ItemParam> *)(v4 + 64),
    reason);
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 64));
  if ( v17 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return retstr;
};

// Line 9276: range 0000000017D12AE8-0000000017D13332
std::vector<ItemParam> *__cdecl PlayerItemComp::internalCheckOutputLimitAndModifyItemParamsOnDrop(
        std::vector<ItemParam> *retstr,
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec,
        const ActionReason *reason)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  ItemLimitExcelConfigMgr *p_item_limit_config_mgr; // rcx
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // r14
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rcx
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rcx
  char v16; // al
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rcx
  data::ItemLimitRefreshType refresh_type; // [rsp+2Ch] [rbp-174h]
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+30h] [rbp-170h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+38h] [rbp-168h] BYREF
  const OutputLimitConfig *output_limit_config_ptr; // [rsp+40h] [rbp-160h]
  ItemLimitRecord *item_limit_record; // [rsp+48h] [rbp-158h]
  const std::vector<ItemParam> *__for_range; // [rsp+50h] [rbp-150h]
  const ItemParam *item_param; // [rsp+58h] [rbp-148h]
  std::shared_ptr<Config> v36; // [rsp+60h] [rbp-140h] BYREF
  std::vector<ItemParam> vec; // [rsp+70h] [rbp-130h] BYREF
  common::milog::MiLogStream v38; // [rsp+90h] [rbp-110h] BYREF
  common::milog::MiLogStream v39; // [rsp+B0h] [rbp-F0h] BYREF
  char v40[208]; // [rsp+D0h] [rbp-D0h] BYREF

  v4 = (unsigned __int64)v40;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(160LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "4 32 4 12 item_id:9296 48 4 10 count:9297 64 8 19 item_index_key:9298 96 24 26 result_item_param_vec:9278";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::internalCheckOutputLimitAndModifyItemParamsOnDrop;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556924;
  v6[536862722] = -218959360;
  v6[536862723] = -218103808;
  v6[536862724] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 96));
  if ( !PlayerItemComp::isNeedCheckItemLimit<ItemParam>(
          this,
          reason,
          item_param_vec,
          (std::vector<ItemParam> *)(v4 + 96)) )
  {
    std::vector<ItemParam>::vector(retstr, (std::vector<ItemParam> *)(v4 + 96));
  }
  else
  {
    std::vector<ItemParam>::clear((std::vector<ItemParam> *const)(v4 + 96));
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v36);
    p_item_limit_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v36)->design_config.txt_config_mgr.item_limit_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&reason->limit_type);
    }
    output_limit_config_ptr = ItemLimitExcelConfigMgr::findOutputLimitConfig(
                                p_item_limit_config_mgr,
                                reason->limit_type);
    std::shared_ptr<Config>::~shared_ptr(&v36);
    if ( output_limit_config_ptr )
    {
      if ( *(_BYTE *)(((unsigned __int64)&output_limit_config_ptr->item_limit_refresh_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)output_limit_config_ptr + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&output_limit_config_ptr->item_limit_refresh_type >> 3)
                                                                              + 0x7FFF8000) )
      {
        __asan_report_load4(&output_limit_config_ptr->item_limit_refresh_type);
      }
      refresh_type = output_limit_config_ptr->item_limit_refresh_type;
      item_limit_record = std::unordered_map<data::ItemLimitType,ItemLimitRecord>::operator[](
                            &this->item_limit_record_map_,
                            &reason->limit_type);
      PlayerItemComp::refreshItemLimitRecord(this, refresh_type, item_limit_record);
      __for_range = item_param_vec;
      __for_begin._M_current = std::vector<ItemParam>::begin(item_param_vec)._M_current;
      __for_end._M_current = std::vector<ItemParam>::end(item_param_vec)._M_current;
      while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
      {
        item_param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
        *(_DWORD *)(v4 + 32) = 0;
        *(_DWORD *)(v4 + 48) = 0;
        *(_DWORD *)(v4 + 64) = 0;
        *(_DWORD *)(v4 + 68) = 0;
        if ( PlayerItemComp::getItemIdCountAndIndex(
               this,
               item_param,
               (uint32_t *)(v4 + 32),
               (uint32_t *)(v4 + 48),
               (ItemIndexKey *)(v4 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v38,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "internalCheckOutputLimitAndModifyItemParamsOnDrop",
            9301);
          v13 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                  &v38,
                  (const char (*)[41])"getItemIdCountAndIndex fail, item_param:");
          v14 = operator<<(v13, item_param);
          v15 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v14, (const char (*)[9])" player:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          operator<<(v15, this->player_);
          common::milog::MiLogStream::~MiLogStream(&v38);
          std::vector<ItemParam>::push_back((std::vector<ItemParam> *const)(v4 + 96), item_param);
        }
        else
        {
          if ( PlayerItemComp::checkIsItemLimitValid(
                 this,
                 (const ItemIndexKey *)(v4 + 64),
                 *(_DWORD *)(v4 + 32),
                 *(_DWORD *)(v4 + 48),
                 item_limit_record,
                 output_limit_config_ptr,
                 1) )
          {
            goto LABEL_25;
          }
          if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3)
                                                                 + 0x7FFF8000) )
          {
            __asan_report_load4(&reason->limit_type);
          }
          if ( PlayerItemComp::isCanForbidItemOutput(this, reason->limit_type, (const ItemIndexKey *)(v4 + 64)) )
            v16 = 1;
          else
LABEL_25:
            v16 = 0;
          if ( v16 )
          {
            common::milog::MiLogStream::create(
              &v39,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "internalCheckOutputLimitAndModifyItemParamsOnDrop",
              9309);
            v17 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                    &v39,
                    (const char (*)[44])"checkIsItemLimitValid fail, item_index_key:");
            v18 = operator<<(v17, (const ItemIndexKey *)(v4 + 64));
            v19 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v18, (const char (*)[10])" item_id:");
            v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v19,
                    (const unsigned int *)(v4 + 32));
            v21 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v20, (const char (*)[8])" count:");
            v22 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v21,
                    (const unsigned int *)(v4 + 48));
            v23 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v22, (const char (*)[9])" reason:");
            v24 = operator<<(v23, reason);
            v25 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v24, (const char (*)[9])" player:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            operator<<(v25, this->player_);
            common::milog::MiLogStream::~MiLogStream(&v39);
          }
          else
          {
            std::vector<ItemParam>::push_back((std::vector<ItemParam> *const)(v4 + 96), item_param);
          }
        }
        __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
      }
      std::vector<ItemParam>::vector(retstr, (std::vector<ItemParam> *)(v4 + 96));
    }
    else
    {
      common::milog::MiLogStream::create(
        &v39,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckOutputLimitAndModifyItemParamsOnDrop",
        9288);
      v8 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
             &v39,
             (const char (*)[36])"findOutputLimitConfig fail, reason:");
      v9 = operator<<(v8, reason);
      v10 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v9, (const char (*)[17])" item_param_vec:");
      PlayerItemComp::getItemParamVec(&vec, this, item_param_vec);
      v11 = common::milog::MiLogStream::operator<<<ItemParam>(v10, &vec);
      v12 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v11, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v12, this->player_);
      std::vector<ItemParam>::~vector(&vec);
      common::milog::MiLogStream::~MiLogStream(&v39);
      std::vector<ItemParam>::vector(retstr, item_param_vec);
    }
  }
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 96));
  if ( v40 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = -168430091;
  }
  return retstr;
};

// Line 9319: range 0000000017DAF858-0000000017DB0180
int32_t __cdecl PlayerItemComp::checkOutputLimitBeforeCheckAddItemBatch<ItemParam>(
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec,
        const ActionReason *reason)
{
  unsigned __int64 v3; // r12
  __int64 v4; // rax
  _DWORD *v5; // r13
  char v6; // r14
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rdx
  bool *p_is_gm_talk_open; // rax
  char v9; // r15
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rbx
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rcx
  int32_t result; // eax
  ItemLimitExcelConfigMgr *p_item_limit_config_mgr; // rcx
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rbx
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rcx
  common::milog::MiLogStream *v22; // rcx
  char v23; // al
  data::ItemLimitRefreshType refresh_type; // [rsp+2Ch] [rbp-114h]
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+30h] [rbp-110h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+38h] [rbp-108h] BYREF
  const OutputLimitConfig *output_limit_config_ptr; // [rsp+40h] [rbp-100h]
  ItemLimitRecord *item_limit_record; // [rsp+48h] [rbp-F8h]
  const std::vector<ItemParam> *__for_range; // [rsp+50h] [rbp-F0h]
  const ItemParam *item_param; // [rsp+58h] [rbp-E8h]
  std::shared_ptr<Config> v32; // [rsp+60h] [rbp-E0h] BYREF
  std::vector<ItemParam> vec; // [rsp+70h] [rbp-D0h] BYREF
  common::milog::MiLogStream v34; // [rsp+90h] [rbp-B0h] BYREF
  char v35[144]; // [rsp+B0h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v35;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "3 32 4 12 item_id:9345 48 4 10 count:9346 64 8 19 item_index_key:9347";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkOutputLimitBeforeCheckAddItemBatch<ItemParam>;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556924;
  v5[536862722] = -202116352;
  v6 = 0;
  if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&reason->limit_type);
  }
  if ( reason->limit_type == ITEM_LIMIT_GM )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v32);
    v6 = 1;
    v7 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v32);
    p_is_gm_talk_open = &v7->is_gm_talk_open;
    if ( *(_BYTE *)(((unsigned __int64)p_is_gm_talk_open >> 3) + 0x7FFF8000) != 0
      && ((unsigned __int8)p_is_gm_talk_open & 7) >= *(_BYTE *)(((unsigned __int64)p_is_gm_talk_open >> 3) + 0x7FFF8000) )
    {
      __asan_report_load1(p_is_gm_talk_open);
    }
    if ( !v7->is_gm_talk_open )
      goto LABEL_14;
  }
  if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&reason->limit_type);
  }
  if ( reason->limit_type == ITEM_LIMIT_NONE || !data::isValidItemLimitType(reason->limit_type) )
LABEL_14:
    v9 = 1;
  else
    v9 = 0;
  if ( v6 )
    std::shared_ptr<Config>::~shared_ptr(&v32);
  if ( v9 )
  {
    common::milog::MiLogStream::create(
      &v34,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkOutputLimitBeforeCheckAddItemBatch",
      9326);
    v10 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(&v34, (const char (*)[8])"reason:");
    v11 = operator<<(v10, reason);
    v12 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v11, (const char (*)[17])" item_param_vec:");
    PlayerItemComp::getItemParamVec(&vec, this, item_param_vec);
    v13 = common::milog::MiLogStream::operator<<<ItemParam>(v12, &vec);
    v14 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v13, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v14, this->player_);
    std::vector<ItemParam>::~vector(&vec);
    common::milog::MiLogStream::~MiLogStream(&v34);
    result = 649;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&reason->limit_type);
    }
    if ( reason->limit_type == ITEM_LIMIT_GM || reason->limit_type == ITEM_LIMIT_UNLIMITED )
    {
      result = 0;
    }
    else
    {
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v32);
      p_item_limit_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v32)->design_config.txt_config_mgr.item_limit_config_mgr;
      if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&reason->limit_type);
      }
      output_limit_config_ptr = ItemLimitExcelConfigMgr::findOutputLimitConfig(
                                  p_item_limit_config_mgr,
                                  reason->limit_type);
      std::shared_ptr<Config>::~shared_ptr(&v32);
      if ( output_limit_config_ptr )
      {
        if ( *(_BYTE *)(((unsigned __int64)&output_limit_config_ptr->item_limit_refresh_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)output_limit_config_ptr + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&output_limit_config_ptr->item_limit_refresh_type >> 3)
                                                                                + 0x7FFF8000) )
        {
          __asan_report_load4(&output_limit_config_ptr->item_limit_refresh_type);
        }
        refresh_type = output_limit_config_ptr->item_limit_refresh_type;
        item_limit_record = std::unordered_map<data::ItemLimitType,ItemLimitRecord>::operator[](
                              &this->item_limit_record_map_,
                              &reason->limit_type);
        PlayerItemComp::refreshItemLimitRecord(this, refresh_type, item_limit_record);
        __for_range = item_param_vec;
        __for_begin._M_current = std::vector<ItemParam>::begin(item_param_vec)._M_current;
        __for_end._M_current = std::vector<ItemParam>::end(item_param_vec)._M_current;
        while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
        {
          item_param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
          *(_DWORD *)(v3 + 32) = 0;
          *(_DWORD *)(v3 + 48) = 0;
          *(_DWORD *)(v3 + 64) = 0;
          *(_DWORD *)(v3 + 68) = 0;
          if ( PlayerItemComp::getItemIdCountAndIndex(
                 this,
                 item_param,
                 (uint32_t *)(v3 + 32),
                 (uint32_t *)(v3 + 48),
                 (ItemIndexKey *)(v3 + 64)) )
          {
            common::milog::MiLogStream::create(
              &v34,
              &common::milog::MiLogDefault::default_log_obj_,
              4u,
              "./src/player/item/player_item_comp.cpp",
              "checkOutputLimitBeforeCheckAddItemBatch",
              9350);
            v22 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                    &v34,
                    (const char (*)[37])"getItemIdCountAndIndex fail, player:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            operator<<(v22, this->player_);
            common::milog::MiLogStream::~MiLogStream(&v34);
          }
          else
          {
            if ( PlayerItemComp::checkIsItemLimitValid(
                   this,
                   (const ItemIndexKey *)(v3 + 64),
                   *(_DWORD *)(v3 + 32),
                   *(_DWORD *)(v3 + 48),
                   item_limit_record,
                   output_limit_config_ptr,
                   0) )
            {
              goto LABEL_46;
            }
            if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3)
                                                                   + 0x7FFF8000) )
            {
              __asan_report_load4(&reason->limit_type);
            }
            if ( PlayerItemComp::isCanForbidItemOutput(this, reason->limit_type, (const ItemIndexKey *)(v3 + 64)) )
              v23 = 1;
            else
LABEL_46:
              v23 = 0;
            if ( v23 )
            {
              result = 649;
              goto LABEL_51;
            }
          }
          __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
        }
        result = 0;
      }
      else
      {
        common::milog::MiLogStream::create(
          &v34,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "checkOutputLimitBeforeCheckAddItemBatch",
          9337);
        v17 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                &v34,
                (const char (*)[36])"findOutputLimitConfig fail, reason:");
        v18 = operator<<(v17, reason);
        v19 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                v18,
                (const char (*)[17])" item_param_vec:");
        PlayerItemComp::getItemParamVec(&vec, this, item_param_vec);
        v20 = common::milog::MiLogStream::operator<<<ItemParam>(v19, &vec);
        v21 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v20, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v21, this->player_);
        std::vector<ItemParam>::~vector(&vec);
        common::milog::MiLogStream::~MiLogStream(&v34);
        result = 0;
      }
    }
  }
LABEL_51:
  if ( v35 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 9319: range 0000000017DB06A0-0000000017DB0FC8
int32_t __cdecl PlayerItemComp::checkOutputLimitBeforeCheckAddItemBatch<std::shared_ptr<Item>>(
        PlayerItemComp *const this,
        const std::vector<std::shared_ptr<Item>> *item_param_vec,
        const ActionReason *reason)
{
  unsigned __int64 v3; // r12
  __int64 v4; // rax
  _DWORD *v5; // r13
  char v6; // r14
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rdx
  bool *p_is_gm_talk_open; // rax
  char v9; // r15
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rbx
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rcx
  int32_t result; // eax
  ItemLimitExcelConfigMgr *p_item_limit_config_mgr; // rcx
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rbx
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rcx
  common::milog::MiLogStream *v22; // rcx
  char v23; // al
  data::ItemLimitRefreshType refresh_type; // [rsp+2Ch] [rbp-114h]
  std::vector<std::shared_ptr<Item>>::const_iterator __for_begin; // [rsp+30h] [rbp-110h] BYREF
  std::vector<std::shared_ptr<Item>>::const_iterator __for_end; // [rsp+38h] [rbp-108h] BYREF
  const OutputLimitConfig *output_limit_config_ptr; // [rsp+40h] [rbp-100h]
  ItemLimitRecord *item_limit_record; // [rsp+48h] [rbp-F8h]
  const std::vector<std::shared_ptr<Item>> *__for_range; // [rsp+50h] [rbp-F0h]
  const std::shared_ptr<Item> *item_param; // [rsp+58h] [rbp-E8h]
  std::shared_ptr<Config> v32; // [rsp+60h] [rbp-E0h] BYREF
  std::vector<ItemParam> vec; // [rsp+70h] [rbp-D0h] BYREF
  common::milog::MiLogStream v34; // [rsp+90h] [rbp-B0h] BYREF
  char v35[144]; // [rsp+B0h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v35;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "3 32 4 12 item_id:9345 48 4 10 count:9346 64 8 19 item_index_key:9347";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkOutputLimitBeforeCheckAddItemBatch<std::shared_ptr<Item>>;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556924;
  v5[536862722] = -202116352;
  v6 = 0;
  if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&reason->limit_type);
  }
  if ( reason->limit_type == ITEM_LIMIT_GM )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v32);
    v6 = 1;
    v7 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v32);
    p_is_gm_talk_open = &v7->is_gm_talk_open;
    if ( *(_BYTE *)(((unsigned __int64)p_is_gm_talk_open >> 3) + 0x7FFF8000) != 0
      && ((unsigned __int8)p_is_gm_talk_open & 7) >= *(_BYTE *)(((unsigned __int64)p_is_gm_talk_open >> 3) + 0x7FFF8000) )
    {
      __asan_report_load1(p_is_gm_talk_open);
    }
    if ( !v7->is_gm_talk_open )
      goto LABEL_14;
  }
  if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&reason->limit_type);
  }
  if ( reason->limit_type == ITEM_LIMIT_NONE || !data::isValidItemLimitType(reason->limit_type) )
LABEL_14:
    v9 = 1;
  else
    v9 = 0;
  if ( v6 )
    std::shared_ptr<Config>::~shared_ptr(&v32);
  if ( v9 )
  {
    common::milog::MiLogStream::create(
      &v34,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkOutputLimitBeforeCheckAddItemBatch",
      9326);
    v10 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(&v34, (const char (*)[8])"reason:");
    v11 = operator<<(v10, reason);
    v12 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v11, (const char (*)[17])" item_param_vec:");
    PlayerItemComp::getItemParamVec(&vec, this, item_param_vec);
    v13 = common::milog::MiLogStream::operator<<<ItemParam>(v12, &vec);
    v14 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v13, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v14, this->player_);
    std::vector<ItemParam>::~vector(&vec);
    common::milog::MiLogStream::~MiLogStream(&v34);
    result = 649;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&reason->limit_type);
    }
    if ( reason->limit_type == ITEM_LIMIT_GM || reason->limit_type == ITEM_LIMIT_UNLIMITED )
    {
      result = 0;
    }
    else
    {
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v32);
      p_item_limit_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v32)->design_config.txt_config_mgr.item_limit_config_mgr;
      if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&reason->limit_type);
      }
      output_limit_config_ptr = ItemLimitExcelConfigMgr::findOutputLimitConfig(
                                  p_item_limit_config_mgr,
                                  reason->limit_type);
      std::shared_ptr<Config>::~shared_ptr(&v32);
      if ( output_limit_config_ptr )
      {
        if ( *(_BYTE *)(((unsigned __int64)&output_limit_config_ptr->item_limit_refresh_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)output_limit_config_ptr + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&output_limit_config_ptr->item_limit_refresh_type >> 3)
                                                                                + 0x7FFF8000) )
        {
          __asan_report_load4(&output_limit_config_ptr->item_limit_refresh_type);
        }
        refresh_type = output_limit_config_ptr->item_limit_refresh_type;
        item_limit_record = std::unordered_map<data::ItemLimitType,ItemLimitRecord>::operator[](
                              &this->item_limit_record_map_,
                              &reason->limit_type);
        PlayerItemComp::refreshItemLimitRecord(this, refresh_type, item_limit_record);
        __for_range = item_param_vec;
        __for_begin._M_current = std::vector<std::shared_ptr<Item>>::begin(item_param_vec)._M_current;
        __for_end._M_current = std::vector<std::shared_ptr<Item>>::end(item_param_vec)._M_current;
        while ( __gnu_cxx::operator!=<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>(
                  &__for_begin,
                  &__for_end) )
        {
          item_param = __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator*(&__for_begin);
          *(_DWORD *)(v3 + 32) = 0;
          *(_DWORD *)(v3 + 48) = 0;
          *(_DWORD *)(v3 + 64) = 0;
          *(_DWORD *)(v3 + 68) = 0;
          if ( PlayerItemComp::getItemIdCountAndIndex(
                 this,
                 item_param,
                 (uint32_t *)(v3 + 32),
                 (uint32_t *)(v3 + 48),
                 (ItemIndexKey *)(v3 + 64)) )
          {
            common::milog::MiLogStream::create(
              &v34,
              &common::milog::MiLogDefault::default_log_obj_,
              4u,
              "./src/player/item/player_item_comp.cpp",
              "checkOutputLimitBeforeCheckAddItemBatch",
              9350);
            v22 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                    &v34,
                    (const char (*)[37])"getItemIdCountAndIndex fail, player:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            operator<<(v22, this->player_);
            common::milog::MiLogStream::~MiLogStream(&v34);
          }
          else
          {
            if ( PlayerItemComp::checkIsItemLimitValid(
                   this,
                   (const ItemIndexKey *)(v3 + 64),
                   *(_DWORD *)(v3 + 32),
                   *(_DWORD *)(v3 + 48),
                   item_limit_record,
                   output_limit_config_ptr,
                   0) )
            {
              goto LABEL_46;
            }
            if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
              && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3)
                                                                   + 0x7FFF8000) )
            {
              __asan_report_load4(&reason->limit_type);
            }
            if ( PlayerItemComp::isCanForbidItemOutput(this, reason->limit_type, (const ItemIndexKey *)(v3 + 64)) )
              v23 = 1;
            else
LABEL_46:
              v23 = 0;
            if ( v23 )
            {
              result = 649;
              goto LABEL_51;
            }
          }
          __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator++(&__for_begin);
        }
        result = 0;
      }
      else
      {
        common::milog::MiLogStream::create(
          &v34,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "checkOutputLimitBeforeCheckAddItemBatch",
          9337);
        v17 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
                &v34,
                (const char (*)[36])"findOutputLimitConfig fail, reason:");
        v18 = operator<<(v17, reason);
        v19 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                v18,
                (const char (*)[17])" item_param_vec:");
        PlayerItemComp::getItemParamVec(&vec, this, item_param_vec);
        v20 = common::milog::MiLogStream::operator<<<ItemParam>(v19, &vec);
        v21 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v20, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v21, this->player_);
        std::vector<ItemParam>::~vector(&vec);
        common::milog::MiLogStream::~MiLogStream(&v34);
        result = 0;
      }
    }
  }
LABEL_51:
  if ( v35 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 9365: range 0000000017DB0396-0000000017DB069F
std::vector<ItemParam> *__cdecl PlayerItemComp::checkOutputLimitAndModifyItemParams<ItemParam>(
        std::vector<ItemParam> *retstr,
        PlayerItemComp *const this,
        const std::vector<ItemParam> *original_item_param_vec,
        const ActionReason *reason)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  _DWORD *v6; // r13
  __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> >::reference v7; // rax
  _QWORD *p_item_id; // rdx
  __int64 v9; // rax
  __int64 v10; // rdx
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+28h] [rbp-B8h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+30h] [rbp-B0h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+38h] [rbp-A8h]
  char v17[160]; // [rsp+40h] [rbp-A0h] BYREF

  v4 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "2 32 16 15 item_param:9368 64 24 19 item_param_vec:9367";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkOutputLimitAndModifyItemParams<ItemParam>;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -219021312;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 64));
  __for_range = original_item_param_vec;
  __for_begin._M_current = std::vector<ItemParam>::begin(original_item_param_vec)._M_current;
  __for_end._M_current = std::vector<ItemParam>::end(original_item_param_vec)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
  {
    v7 = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
    p_item_id = &v7->item_id;
    if ( ((unsigned __int8)v7 & 7) >= *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000)
      && *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) != 0
      || *(_BYTE *)((((unsigned __int64)&v7->promote_level + 3) >> 3) + 0x7FFF8000) != 0
      && (((unsigned __int8)v7 + 15) & 7) >= *(_BYTE *)((((unsigned __int64)&v7->promote_level + 3) >> 3) + 0x7FFF8000) )
    {
      __asan_report_load_n(v7, 16LL);
    }
    v9 = *p_item_id;
    v10 = p_item_id[1];
    *(_QWORD *)(v4 + 32) = v9;
    *(_QWORD *)(v4 + 40) = v10;
    if ( PlayerItemComp::checkAndModifyTotalObtainCountAndModifyItemCount(this, (ItemParam *)(v4 + 32), reason, 0) )
      std::vector<ItemParam>::push_back(
        (std::vector<ItemParam> *const)(v4 + 64),
        (const std::vector<ItemParam>::value_type *)(v4 + 32));
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
  }
  if ( *(char *)(((unsigned __int64)retstr >> 3) + 0x7FFF8000) < 0
    || *(_BYTE *)((((unsigned __int64)&retstr->_M_impl._M_end_of_storage + 7) >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)retstr + 23) & 7) >= *(_BYTE *)((((unsigned __int64)&retstr->_M_impl._M_end_of_storage + 7) >> 3)
                                                        + 0x7FFF8000) )
  {
    __asan_report_store_n(retstr, 24LL);
  }
  PlayerItemComp::internalCheckOutputLimitAndModifyItemParams<ItemParam>(
    retstr,
    this,
    (const std::vector<ItemParam> *)(v4 + 64),
    reason);
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 64));
  if ( v17 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return retstr;
};

// Line 9365: range 0000000017DB110A-0000000017DB13BD
std::vector<std::shared_ptr<Item>> *__cdecl PlayerItemComp::checkOutputLimitAndModifyItemParams<std::shared_ptr<Item>>(
        std::vector<std::shared_ptr<Item>> *retstr,
        PlayerItemComp *const this,
        const std::vector<std::shared_ptr<Item>> *original_item_param_vec,
        const ActionReason *reason)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r13
  const std::shared_ptr<Item> *v7; // rax
  std::vector<std::shared_ptr<Item>>::const_iterator __for_begin; // [rsp+28h] [rbp-B8h] BYREF
  std::vector<std::shared_ptr<Item>>::const_iterator __for_end; // [rsp+30h] [rbp-B0h] BYREF
  const std::vector<std::shared_ptr<Item>> *__for_range; // [rsp+38h] [rbp-A8h]
  char v14[160]; // [rsp+40h] [rbp-A0h] BYREF

  v4 = (unsigned __int64)v14;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(128LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "2 32 16 15 item_param:9368 64 24 19 item_param_vec:9367";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::checkOutputLimitAndModifyItemParams<std::shared_ptr<Item>>;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -219021312;
  v6[536862722] = -218103808;
  v6[536862723] = -202116109;
  std::vector<std::shared_ptr<Item>>::vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 64));
  __for_range = original_item_param_vec;
  __for_begin._M_current = std::vector<std::shared_ptr<Item>>::begin(original_item_param_vec)._M_current;
  __for_end._M_current = std::vector<std::shared_ptr<Item>>::end(original_item_param_vec)._M_current;
  while ( __gnu_cxx::operator!=<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>(
            &__for_begin,
            &__for_end) )
  {
    v7 = __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator*(&__for_begin);
    std::shared_ptr<Item>::shared_ptr((std::shared_ptr<Item> *const)(v4 + 32), v7);
    if ( PlayerItemComp::checkAndModifyTotalObtainCountAndModifyItemCount(this, (ItemPtr *)(v4 + 32), reason, 0) )
      std::vector<std::shared_ptr<Item>>::push_back(
        (std::vector<std::shared_ptr<Item>> *const)(v4 + 64),
        (const std::vector<std::shared_ptr<Item>>::value_type *)(v4 + 32));
    std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v4 + 32));
    __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator++(&__for_begin);
  }
  if ( *(char *)(((unsigned __int64)retstr >> 3) + 0x7FFF8000) < 0
    || *(_BYTE *)((((unsigned __int64)&retstr->_M_impl._M_end_of_storage + 7) >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)retstr + 23) & 7) >= *(_BYTE *)((((unsigned __int64)&retstr->_M_impl._M_end_of_storage + 7) >> 3)
                                                        + 0x7FFF8000) )
  {
    __asan_report_store_n(retstr, 24LL);
  }
  PlayerItemComp::internalCheckOutputLimitAndModifyItemParams<std::shared_ptr<Item>>(
    retstr,
    this,
    (const std::vector<std::shared_ptr<Item>> *)(v4 + 64),
    reason);
  std::vector<std::shared_ptr<Item>>::~vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 64));
  if ( v14 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return retstr;
};

// Line 9379: range 0000000017DE136A-0000000017DE1C75
std::vector<ItemParam> *__cdecl PlayerItemComp::internalCheckOutputLimitAndModifyItemParams<ItemParam>(
        std::vector<ItemParam> *retstr,
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec,
        const ActionReason *reason)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  ItemLimitExcelConfigMgr *p_item_limit_config_mgr; // rcx
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // r14
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rcx
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rcx
  char v16; // al
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rcx
  unsigned int v26; // r14d
  std::unordered_map<ItemIndexKey,unsigned int>::mapped_type *v27; // rax
  unsigned int *v28; // rdx
  SelectType v29; // r14d
  char *v30; // rsi
  std::unordered_map<ItemIndexKey,unsigned int>::mapped_type *v31; // rax
  SelectType *v32; // rdx
  char v33; // cl
  data::ItemLimitRefreshType refresh_type; // [rsp+2Ch] [rbp-174h]
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+30h] [rbp-170h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+38h] [rbp-168h] BYREF
  const OutputLimitConfig *output_limit_config_ptr; // [rsp+40h] [rbp-160h]
  ItemLimitRecord *item_limit_record; // [rsp+48h] [rbp-158h]
  const std::vector<ItemParam> *__for_range; // [rsp+50h] [rbp-150h]
  const ItemParam *item_param; // [rsp+58h] [rbp-148h]
  std::shared_ptr<Config> v45; // [rsp+60h] [rbp-140h] BYREF
  std::vector<ItemParam> vec; // [rsp+70h] [rbp-130h] BYREF
  common::milog::MiLogStream v47; // [rsp+90h] [rbp-110h] BYREF
  common::milog::MiLogStream v48; // [rsp+B0h] [rbp-F0h] BYREF
  char v49[208]; // [rsp+D0h] [rbp-D0h] BYREF

  v4 = (unsigned __int64)v49;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(160LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "4 32 4 12 item_id:9400 48 4 10 count:9401 64 8 19 item_index_key:9402 96 24 26 result_item_param_vec:9382";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::internalCheckOutputLimitAndModifyItemParams<ItemParam>;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556924;
  v6[536862722] = -218959360;
  v6[536862723] = -218103808;
  v6[536862724] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 96));
  if ( !PlayerItemComp::isNeedCheckItemLimit<ItemParam>(
          this,
          reason,
          item_param_vec,
          (std::vector<ItemParam> *)(v4 + 96)) )
  {
    std::vector<ItemParam>::vector(retstr, (std::vector<ItemParam> *)(v4 + 96));
  }
  else
  {
    std::vector<ItemParam>::clear((std::vector<ItemParam> *const)(v4 + 96));
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v45);
    p_item_limit_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v45)->design_config.txt_config_mgr.item_limit_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&reason->limit_type);
    }
    output_limit_config_ptr = ItemLimitExcelConfigMgr::findOutputLimitConfig(
                                p_item_limit_config_mgr,
                                reason->limit_type);
    std::shared_ptr<Config>::~shared_ptr(&v45);
    if ( output_limit_config_ptr )
    {
      if ( *(_BYTE *)(((unsigned __int64)&output_limit_config_ptr->item_limit_refresh_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)output_limit_config_ptr + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&output_limit_config_ptr->item_limit_refresh_type >> 3)
                                                                              + 0x7FFF8000) )
      {
        __asan_report_load4(&output_limit_config_ptr->item_limit_refresh_type);
      }
      refresh_type = output_limit_config_ptr->item_limit_refresh_type;
      item_limit_record = std::unordered_map<data::ItemLimitType,ItemLimitRecord>::operator[](
                            &this->item_limit_record_map_,
                            &reason->limit_type);
      PlayerItemComp::refreshItemLimitRecord(this, refresh_type, item_limit_record);
      __for_range = item_param_vec;
      __for_begin._M_current = std::vector<ItemParam>::begin(item_param_vec)._M_current;
      __for_end._M_current = std::vector<ItemParam>::end(item_param_vec)._M_current;
      while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
      {
        item_param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
        *(_DWORD *)(v4 + 32) = 0;
        *(_DWORD *)(v4 + 48) = 0;
        *(_DWORD *)(v4 + 64) = 0;
        *(_DWORD *)(v4 + 68) = 0;
        if ( PlayerItemComp::getItemIdCountAndIndex(
               this,
               item_param,
               (uint32_t *)(v4 + 32),
               (uint32_t *)(v4 + 48),
               (ItemIndexKey *)(v4 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v47,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "internalCheckOutputLimitAndModifyItemParams",
            9405);
          v13 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                  &v47,
                  (const char (*)[41])"getItemIdCountAndIndex fail, item_param:");
          v14 = operator<<(v13, item_param);
          v15 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v14, (const char (*)[9])" player:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          operator<<(v15, this->player_);
          common::milog::MiLogStream::~MiLogStream(&v47);
          std::vector<ItemParam>::push_back((std::vector<ItemParam> *const)(v4 + 96), item_param);
        }
        else
        {
          if ( PlayerItemComp::checkIsItemLimitValid(
                 this,
                 (const ItemIndexKey *)(v4 + 64),
                 *(_DWORD *)(v4 + 32),
                 *(_DWORD *)(v4 + 48),
                 item_limit_record,
                 output_limit_config_ptr,
                 0) )
          {
            goto LABEL_25;
          }
          if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3)
                                                                 + 0x7FFF8000) )
          {
            __asan_report_load4(&reason->limit_type);
          }
          if ( PlayerItemComp::isCanForbidItemOutput(this, reason->limit_type, (const ItemIndexKey *)(v4 + 64)) )
            v16 = 1;
          else
LABEL_25:
            v16 = 0;
          if ( v16 )
          {
            common::milog::MiLogStream::create(
              &v48,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "internalCheckOutputLimitAndModifyItemParams",
              9413);
            v17 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                    &v48,
                    (const char (*)[44])"checkIsItemLimitValid fail, item_index_key:");
            v18 = operator<<(v17, (const ItemIndexKey *)(v4 + 64));
            v19 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v18, (const char (*)[10])" item_id:");
            v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v19,
                    (const unsigned int *)(v4 + 32));
            v21 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v20, (const char (*)[8])" count:");
            v22 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v21,
                    (const unsigned int *)(v4 + 48));
            v23 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v22, (const char (*)[9])" reason:");
            v24 = operator<<(v23, reason);
            v25 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v24, (const char (*)[9])" player:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            operator<<(v25, this->player_);
            common::milog::MiLogStream::~MiLogStream(&v48);
          }
          else
          {
            v26 = *(_DWORD *)(v4 + 48);
            v27 = std::unordered_map<ItemIndexKey,unsigned int>::operator[](
                    &item_limit_record->item_count_map,
                    (const std::unordered_map<ItemIndexKey,unsigned int>::key_type *)(v4 + 64));
            v28 = v27;
            if ( *(_BYTE *)(((unsigned __int64)v27 >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)v27 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v27 >> 3) + 0x7FFF8000) )
            {
              __asan_report_load4(v27);
            }
            v29 = SAFE_ADD<unsigned int,unsigned int>(*v28, v26);
            v30 = (char *)(v4 + 64);
            v31 = std::unordered_map<ItemIndexKey,unsigned int>::operator[](
                    &item_limit_record->item_count_map,
                    (const std::unordered_map<ItemIndexKey,unsigned int>::key_type *)(v4 + 64));
            v32 = v31;
            v33 = *(_BYTE *)(((unsigned __int64)v31 >> 3) + 0x7FFF8000);
            if ( v33 != 0 && (char)(((unsigned __int8)v31 & 7) + 3) >= v33 )
            {
              LOBYTE(v30) = v33 != 0;
              __asan_report_store4(v31, v30, v31);
            }
            *v32 = v29;
            std::vector<ItemParam>::push_back((std::vector<ItemParam> *const)(v4 + 96), item_param);
          }
        }
        __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
      }
      std::vector<ItemParam>::vector(retstr, (std::vector<ItemParam> *)(v4 + 96));
    }
    else
    {
      common::milog::MiLogStream::create(
        &v48,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckOutputLimitAndModifyItemParams",
        9392);
      v8 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
             &v48,
             (const char (*)[36])"findOutputLimitConfig fail, reason:");
      v9 = operator<<(v8, reason);
      v10 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v9, (const char (*)[17])" item_param_vec:");
      PlayerItemComp::getItemParamVec(&vec, this, item_param_vec);
      v11 = common::milog::MiLogStream::operator<<<ItemParam>(v10, &vec);
      v12 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v11, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v12, this->player_);
      std::vector<ItemParam>::~vector(&vec);
      common::milog::MiLogStream::~MiLogStream(&v48);
      std::vector<ItemParam>::vector(retstr, item_param_vec);
    }
  }
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 96));
  if ( v49 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = -168430091;
  }
  return retstr;
};

// Line 9379: range 0000000017DE1CB6-0000000017DE25C1
std::vector<std::shared_ptr<Item>> *__cdecl PlayerItemComp::internalCheckOutputLimitAndModifyItemParams<std::shared_ptr<Item>>(
        std::vector<std::shared_ptr<Item>> *retstr,
        PlayerItemComp *const this,
        const std::vector<std::shared_ptr<Item>> *item_param_vec,
        const ActionReason *reason)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  ItemLimitExcelConfigMgr *p_item_limit_config_mgr; // rcx
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // r14
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rcx
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rcx
  char v16; // al
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rcx
  unsigned int v26; // r14d
  std::unordered_map<ItemIndexKey,unsigned int>::mapped_type *v27; // rax
  unsigned int *v28; // rdx
  SelectType v29; // r14d
  char *v30; // rsi
  std::unordered_map<ItemIndexKey,unsigned int>::mapped_type *v31; // rax
  SelectType *v32; // rdx
  char v33; // cl
  data::ItemLimitRefreshType refresh_type; // [rsp+2Ch] [rbp-174h]
  std::vector<std::shared_ptr<Item>>::const_iterator __for_begin; // [rsp+30h] [rbp-170h] BYREF
  std::vector<std::shared_ptr<Item>>::const_iterator __for_end; // [rsp+38h] [rbp-168h] BYREF
  const OutputLimitConfig *output_limit_config_ptr; // [rsp+40h] [rbp-160h]
  ItemLimitRecord *item_limit_record; // [rsp+48h] [rbp-158h]
  const std::vector<std::shared_ptr<Item>> *__for_range; // [rsp+50h] [rbp-150h]
  const std::shared_ptr<Item> *item_param; // [rsp+58h] [rbp-148h]
  std::shared_ptr<Config> v45; // [rsp+60h] [rbp-140h] BYREF
  std::vector<ItemParam> vec; // [rsp+70h] [rbp-130h] BYREF
  common::milog::MiLogStream v47; // [rsp+90h] [rbp-110h] BYREF
  common::milog::MiLogStream v48; // [rsp+B0h] [rbp-F0h] BYREF
  char v49[208]; // [rsp+D0h] [rbp-D0h] BYREF

  v4 = (unsigned __int64)v49;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(160LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "4 32 4 12 item_id:9400 48 4 10 count:9401 64 8 19 item_index_key:9402 96 24 26 result_item_param_vec:9382";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::internalCheckOutputLimitAndModifyItemParams<std::shared_ptr<Item>>;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556924;
  v6[536862722] = -218959360;
  v6[536862723] = -218103808;
  v6[536862724] = -202116109;
  std::vector<std::shared_ptr<Item>>::vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 96));
  if ( !PlayerItemComp::isNeedCheckItemLimit<std::shared_ptr<Item>>(
          this,
          reason,
          item_param_vec,
          (std::vector<std::shared_ptr<Item>> *)(v4 + 96)) )
  {
    std::vector<std::shared_ptr<Item>>::vector(retstr, (std::vector<std::shared_ptr<Item>> *)(v4 + 96));
  }
  else
  {
    std::vector<std::shared_ptr<Item>>::clear((std::vector<std::shared_ptr<Item>> *const)(v4 + 96));
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v45);
    p_item_limit_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v45)->design_config.txt_config_mgr.item_limit_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&reason->limit_type);
    }
    output_limit_config_ptr = ItemLimitExcelConfigMgr::findOutputLimitConfig(
                                p_item_limit_config_mgr,
                                reason->limit_type);
    std::shared_ptr<Config>::~shared_ptr(&v45);
    if ( output_limit_config_ptr )
    {
      if ( *(_BYTE *)(((unsigned __int64)&output_limit_config_ptr->item_limit_refresh_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)output_limit_config_ptr + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&output_limit_config_ptr->item_limit_refresh_type >> 3)
                                                                              + 0x7FFF8000) )
      {
        __asan_report_load4(&output_limit_config_ptr->item_limit_refresh_type);
      }
      refresh_type = output_limit_config_ptr->item_limit_refresh_type;
      item_limit_record = std::unordered_map<data::ItemLimitType,ItemLimitRecord>::operator[](
                            &this->item_limit_record_map_,
                            &reason->limit_type);
      PlayerItemComp::refreshItemLimitRecord(this, refresh_type, item_limit_record);
      __for_range = item_param_vec;
      __for_begin._M_current = std::vector<std::shared_ptr<Item>>::begin(item_param_vec)._M_current;
      __for_end._M_current = std::vector<std::shared_ptr<Item>>::end(item_param_vec)._M_current;
      while ( __gnu_cxx::operator!=<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>(
                &__for_begin,
                &__for_end) )
      {
        item_param = __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator*(&__for_begin);
        *(_DWORD *)(v4 + 32) = 0;
        *(_DWORD *)(v4 + 48) = 0;
        *(_DWORD *)(v4 + 64) = 0;
        *(_DWORD *)(v4 + 68) = 0;
        if ( PlayerItemComp::getItemIdCountAndIndex(
               this,
               item_param,
               (uint32_t *)(v4 + 32),
               (uint32_t *)(v4 + 48),
               (ItemIndexKey *)(v4 + 64)) )
        {
          common::milog::MiLogStream::create(
            &v47,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "internalCheckOutputLimitAndModifyItemParams",
            9405);
          v13 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
                  &v47,
                  (const char (*)[41])"getItemIdCountAndIndex fail, item_param:");
          v14 = common::milog::MiLogStream::operator<<<Item,(Item*)0>(v13, item_param);
          v15 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v14, (const char (*)[9])" player:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          operator<<(v15, this->player_);
          common::milog::MiLogStream::~MiLogStream(&v47);
          std::vector<std::shared_ptr<Item>>::push_back(
            (std::vector<std::shared_ptr<Item>> *const)(v4 + 96),
            item_param);
        }
        else
        {
          if ( PlayerItemComp::checkIsItemLimitValid(
                 this,
                 (const ItemIndexKey *)(v4 + 64),
                 *(_DWORD *)(v4 + 32),
                 *(_DWORD *)(v4 + 48),
                 item_limit_record,
                 output_limit_config_ptr,
                 0) )
          {
            goto LABEL_25;
          }
          if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3)
                                                                 + 0x7FFF8000) )
          {
            __asan_report_load4(&reason->limit_type);
          }
          if ( PlayerItemComp::isCanForbidItemOutput(this, reason->limit_type, (const ItemIndexKey *)(v4 + 64)) )
            v16 = 1;
          else
LABEL_25:
            v16 = 0;
          if ( v16 )
          {
            common::milog::MiLogStream::create(
              &v48,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "internalCheckOutputLimitAndModifyItemParams",
              9413);
            v17 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
                    &v48,
                    (const char (*)[44])"checkIsItemLimitValid fail, item_index_key:");
            v18 = operator<<(v17, (const ItemIndexKey *)(v4 + 64));
            v19 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v18, (const char (*)[10])" item_id:");
            v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v19,
                    (const unsigned int *)(v4 + 32));
            v21 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v20, (const char (*)[8])" count:");
            v22 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v21,
                    (const unsigned int *)(v4 + 48));
            v23 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v22, (const char (*)[9])" reason:");
            v24 = operator<<(v23, reason);
            v25 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v24, (const char (*)[9])" player:");
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            operator<<(v25, this->player_);
            common::milog::MiLogStream::~MiLogStream(&v48);
          }
          else
          {
            v26 = *(_DWORD *)(v4 + 48);
            v27 = std::unordered_map<ItemIndexKey,unsigned int>::operator[](
                    &item_limit_record->item_count_map,
                    (const std::unordered_map<ItemIndexKey,unsigned int>::key_type *)(v4 + 64));
            v28 = v27;
            if ( *(_BYTE *)(((unsigned __int64)v27 >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)v27 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v27 >> 3) + 0x7FFF8000) )
            {
              __asan_report_load4(v27);
            }
            v29 = SAFE_ADD<unsigned int,unsigned int>(*v28, v26);
            v30 = (char *)(v4 + 64);
            v31 = std::unordered_map<ItemIndexKey,unsigned int>::operator[](
                    &item_limit_record->item_count_map,
                    (const std::unordered_map<ItemIndexKey,unsigned int>::key_type *)(v4 + 64));
            v32 = v31;
            v33 = *(_BYTE *)(((unsigned __int64)v31 >> 3) + 0x7FFF8000);
            if ( v33 != 0 && (char)(((unsigned __int8)v31 & 7) + 3) >= v33 )
            {
              LOBYTE(v30) = v33 != 0;
              __asan_report_store4(v31, v30, v31);
            }
            *v32 = v29;
            std::vector<std::shared_ptr<Item>>::push_back(
              (std::vector<std::shared_ptr<Item>> *const)(v4 + 96),
              item_param);
          }
        }
        __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator++(&__for_begin);
      }
      std::vector<std::shared_ptr<Item>>::vector(retstr, (std::vector<std::shared_ptr<Item>> *)(v4 + 96));
    }
    else
    {
      common::milog::MiLogStream::create(
        &v48,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "internalCheckOutputLimitAndModifyItemParams",
        9392);
      v8 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
             &v48,
             (const char (*)[36])"findOutputLimitConfig fail, reason:");
      v9 = operator<<(v8, reason);
      v10 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v9, (const char (*)[17])" item_param_vec:");
      PlayerItemComp::getItemParamVec(&vec, this, item_param_vec);
      v11 = common::milog::MiLogStream::operator<<<ItemParam>(v10, &vec);
      v12 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v11, (const char (*)[9])" player:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v12, this->player_);
      std::vector<ItemParam>::~vector(&vec);
      common::milog::MiLogStream::~MiLogStream(&v48);
      std::vector<std::shared_ptr<Item>>::vector(retstr, item_param_vec);
    }
  }
  std::vector<std::shared_ptr<Item>>::~vector((std::vector<std::shared_ptr<Item>> *const)(v4 + 96));
  if ( v49 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = -168430091;
  }
  return retstr;
};

// Line 9426: range 0000000017DB4514-0000000017DB482F
bool __cdecl PlayerItemComp::isNeedCheckItemLimit<ItemParam>(
        const PlayerItemComp *const this,
        const ActionReason *reason,
        const std::vector<ItemParam> *item_vec,
        std::vector<ItemParam> *result_item_vec)
{
  char v4; // bl
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rdx
  bool *p_is_gm_talk_open; // rax
  char v7; // r12
  common::milog::MiLogStream *v8; // rdx
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rbx
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rcx
  std::shared_ptr<Config> v16; // [rsp+20h] [rbp-60h] BYREF
  std::vector<ItemParam> vec; // [rsp+30h] [rbp-50h] BYREF
  common::milog::MiLogStream v18; // [rsp+50h] [rbp-30h] BYREF

  v4 = 0;
  if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&reason->limit_type);
  }
  if ( reason->limit_type == ITEM_LIMIT_GM )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v16);
    v4 = 1;
    v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v16);
    p_is_gm_talk_open = &v5->is_gm_talk_open;
    if ( *(_BYTE *)(((unsigned __int64)p_is_gm_talk_open >> 3) + 0x7FFF8000) != 0
      && ((unsigned __int8)p_is_gm_talk_open & 7) >= *(_BYTE *)(((unsigned __int64)p_is_gm_talk_open >> 3) + 0x7FFF8000) )
    {
      __asan_report_load1(p_is_gm_talk_open);
    }
    if ( !v5->is_gm_talk_open )
      goto LABEL_11;
  }
  if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&reason->limit_type);
  }
  if ( reason->limit_type == ITEM_LIMIT_NONE || !data::isValidItemLimitType(reason->limit_type) )
LABEL_11:
    v7 = 1;
  else
    v7 = 0;
  if ( v4 )
    std::shared_ptr<Config>::~shared_ptr(&v16);
  if ( v7 )
  {
    common::milog::MiLogStream::create(
      &v18,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "isNeedCheckItemLimit",
      9433);
    v8 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(&v18, (const char (*)[8])"reason:");
    v9 = operator<<(v8, reason);
    v10 = common::milog::MiLogStream::operator<<<char [11],(char *[11])0>(v9, (const char (*)[11])" item_vec:");
    PlayerItemComp::getItemParamVec(&vec, this, item_vec);
    v11 = common::milog::MiLogStream::operator<<<ItemParam>(v10, &vec);
    v12 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v11, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v12, this->player_);
    std::vector<ItemParam>::~vector(&vec);
    common::milog::MiLogStream::~MiLogStream(&v18);
    return 0;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&reason->limit_type);
    }
    if ( reason->limit_type == ITEM_LIMIT_GM || reason->limit_type == ITEM_LIMIT_UNLIMITED )
    {
      std::vector<ItemParam>::operator=(result_item_vec, item_vec);
      return 0;
    }
    else
    {
      return 1;
    }
  }
};

// Line 9426: range 0000000017E11A6C-0000000017E11D87
bool __cdecl PlayerItemComp::isNeedCheckItemLimit<std::shared_ptr<Item>>(
        const PlayerItemComp *const this,
        const ActionReason *reason,
        const std::vector<std::shared_ptr<Item>> *item_vec,
        std::vector<std::shared_ptr<Item>> *result_item_vec)
{
  char v4; // bl
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rdx
  bool *p_is_gm_talk_open; // rax
  char v7; // r12
  common::milog::MiLogStream *v8; // rdx
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rbx
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rcx
  std::shared_ptr<Config> v16; // [rsp+20h] [rbp-60h] BYREF
  std::vector<ItemParam> vec; // [rsp+30h] [rbp-50h] BYREF
  common::milog::MiLogStream v18; // [rsp+50h] [rbp-30h] BYREF

  v4 = 0;
  if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&reason->limit_type);
  }
  if ( reason->limit_type == ITEM_LIMIT_GM )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v16);
    v4 = 1;
    v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v16);
    p_is_gm_talk_open = &v5->is_gm_talk_open;
    if ( *(_BYTE *)(((unsigned __int64)p_is_gm_talk_open >> 3) + 0x7FFF8000) != 0
      && ((unsigned __int8)p_is_gm_talk_open & 7) >= *(_BYTE *)(((unsigned __int64)p_is_gm_talk_open >> 3) + 0x7FFF8000) )
    {
      __asan_report_load1(p_is_gm_talk_open);
    }
    if ( !v5->is_gm_talk_open )
      goto LABEL_11;
  }
  if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&reason->limit_type);
  }
  if ( reason->limit_type == ITEM_LIMIT_NONE || !data::isValidItemLimitType(reason->limit_type) )
LABEL_11:
    v7 = 1;
  else
    v7 = 0;
  if ( v4 )
    std::shared_ptr<Config>::~shared_ptr(&v16);
  if ( v7 )
  {
    common::milog::MiLogStream::create(
      &v18,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "isNeedCheckItemLimit",
      9433);
    v8 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(&v18, (const char (*)[8])"reason:");
    v9 = operator<<(v8, reason);
    v10 = common::milog::MiLogStream::operator<<<char [11],(char *[11])0>(v9, (const char (*)[11])" item_vec:");
    PlayerItemComp::getItemParamVec(&vec, this, item_vec);
    v11 = common::milog::MiLogStream::operator<<<ItemParam>(v10, &vec);
    v12 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v11, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v12, this->player_);
    std::vector<ItemParam>::~vector(&vec);
    common::milog::MiLogStream::~MiLogStream(&v18);
    return 0;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)reason + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reason->limit_type >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&reason->limit_type);
    }
    if ( reason->limit_type == ITEM_LIMIT_GM || reason->limit_type == ITEM_LIMIT_UNLIMITED )
    {
      std::vector<std::shared_ptr<Item>>::operator=(result_item_vec, item_vec);
      return 0;
    }
    else
    {
      return 1;
    }
  }
};

// Line 9447: range 0000000017D13334-0000000017D13504
void __cdecl PlayerItemComp::refreshItemLimitRecord(
        PlayerItemComp *const this,
        data::ItemLimitRefreshType refresh_type,
        ItemLimitRecord *item_limit_record)
{
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v3; // rax
  time_t v4; // rdx
  time_t v5; // rcx
  time_t v6; // rsi
  time_t v7; // rdx
  time_t v8; // rcx
  time_t v9; // rdx
  time_t v10; // rcx
  bool is_need_refresh; // [rsp+27h] [rbp-19h]
  uint32_t now; // [rsp+28h] [rbp-18h]
  uint32_t time_offset; // [rsp+2Ch] [rbp-14h]
  std::shared_ptr<Config> v15; // [rsp+30h] [rbp-10h] BYREF

  now = common::tools::TimeUtils::getNow();
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v15);
  v3 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v15);
  time_offset = ConstValueExcelConfigMgr::getTimeOffsetSec(&v3->design_config.txt_config_mgr.const_value_config_mgr);
  std::shared_ptr<Config>::~shared_ptr(&v15);
  if ( refresh_type == ITEM_LIMIT_REFRESH_WEEKLY )
  {
    v9 = time_offset;
    v10 = now;
    if ( *(_BYTE *)(((unsigned __int64)item_limit_record >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)item_limit_record >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(item_limit_record);
    }
    v6 = v10;
    is_need_refresh = !common::tools::TimeUtils::isSameWeek(item_limit_record->last_refresh_time, v10, v9);
  }
  else
  {
    if ( refresh_type > ITEM_LIMIT_REFRESH_WEEKLY )
      return;
    if ( refresh_type == ITEM_LIMIT_REFRESH_DAILY )
    {
      v4 = time_offset;
      v5 = now;
      if ( *(_BYTE *)(((unsigned __int64)item_limit_record >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)item_limit_record >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(item_limit_record);
      }
      v6 = v5;
      is_need_refresh = !common::tools::TimeUtils::isSameDay(item_limit_record->last_refresh_time, v5, v4);
    }
    else
    {
      if ( refresh_type != ITEM_LIMIT_REFRESH_MONTHLY )
        return;
      v7 = time_offset;
      v8 = now;
      if ( *(_BYTE *)(((unsigned __int64)item_limit_record >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)item_limit_record >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(item_limit_record);
      }
      v6 = v8;
      is_need_refresh = !common::tools::TimeUtils::isSameMonth(item_limit_record->last_refresh_time, v8, v7);
    }
  }
  if ( is_need_refresh )
  {
    if ( *(_BYTE *)(((unsigned __int64)item_limit_record >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)item_limit_record >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_store4(item_limit_record, v6, item_limit_record);
    }
    item_limit_record->last_refresh_time = now;
    std::unordered_map<ItemIndexKey,unsigned int>::clear(&item_limit_record->item_count_map);
  }
};

// Line 9475: range 0000000017D13506-0000000017D14BA9
_BOOL8 __fastcall PlayerItemComp::checkIsItemLimitValid(
        const PlayerItemComp *const this,
        const ItemIndexKey *item_index_key,
        uint32_t item_id,
        uint32_t count,
        const ItemLimitRecord *item_limit_record,
        unsigned __int64 output_limit_config,
        bool is_drop)
{
  __int64 v7; // rax
  _DWORD *v8; // r15
  _BOOL8 result; // rax
  std::__detail::_Node_const_iterator<std::pair<const ItemIndexKey,unsigned int>,false,false>::pointer v10; // rcx
  char v11; // r14
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rcx
  ItemLimitExcelConfigMgr *p_item_limit_config_mgr; // rdi
  bool v14; // al
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // rax
  common::milog::MiLogStream *v24; // rax
  common::milog::MiLogStream *v25; // rcx
  char v26; // al
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rax
  common::milog::MiLogStream *v32; // rax
  common::milog::MiLogStream *v33; // rax
  common::milog::MiLogStream *v34; // rax
  common::milog::MiLogStream *v35; // rax
  common::milog::MiLogStream *v36; // rax
  common::milog::MiLogStream *v37; // rcx
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v38; // rax
  common::milog::MiLogStream *v39; // rax
  common::milog::MiLogStream *v40; // rax
  common::milog::MiLogStream *v41; // rax
  common::milog::MiLogStream *v42; // rax
  common::milog::MiLogStream *v43; // rax
  common::milog::MiLogStream *v44; // rax
  common::milog::MiLogStream *v45; // rax
  common::milog::MiLogStream *v46; // rax
  common::milog::MiLogStream *v47; // rcx
  ItemLimitExcelConfigMgr *v48; // r13
  ItemLimitExcelConfigMgr *v49; // r13
  ItemLimitExcelConfigMgr *v50; // r13
  char v51; // bl
  Json::Value_0 *v52; // rax
  const char *v53; // rax
  Json::Value_0 *v54; // rax
  Json::Value_0 *v55; // rax
  const char *v56; // rax
  Json::Value_0 *v57; // rax
  Json::Value_0 *v58; // rax
  Json::Value_0 *v59; // rax
  Json::Value_0 *v60; // rax
  Json::Value_0 *v61; // rax
  Json::Value_0 *v62; // rax
  Json::Value_0 *v63; // rax
  Json::Value_0 *v64; // rax
  std::initializer_list<unsigned int> __l; // [rsp+10h] [rbp-290h]
  std::initializer_list<unsigned int> v66; // [rsp+20h] [rbp-280h]
  std::initializer_list<unsigned int> v67; // [rsp+30h] [rbp-270h]
  char v68; // [rsp+47h] [rbp-259h]
  unsigned __int64 v69; // [rsp+48h] [rbp-258h]
  char v70; // [rsp+50h] [rbp-250h]
  char v71; // [rsp+51h] [rbp-24Fh]
  char v72; // [rsp+55h] [rbp-24Bh]
  char v73; // [rsp+56h] [rbp-24Ah]
  char v74; // [rsp+57h] [rbp-249h]
  std::allocator<unsigned int> __a; // [rsp+83h] [rbp-21Dh] BYREF
  std::allocator<unsigned int> v81; // [rsp+84h] [rbp-21Ch] BYREF
  std::allocator<unsigned int> v82; // [rsp+85h] [rbp-21Bh] BYREF
  bool allow_output; // [rsp+86h] [rbp-21Ah]
  bool is_need_alarm; // [rsp+87h] [rbp-219h]
  const data::ItemConfig *item_config_ptr; // [rsp+88h] [rbp-218h]
  std::__detail::_Node_iterator_base<std::pair<const ItemIndexKey,unsigned int>,false> __y; // [rsp+90h] [rbp-210h] BYREF
  int v87[3]; // [rsp+98h] [rbp-208h] BYREF
  int v88[3]; // [rsp+A4h] [rbp-1FCh] BYREF
  std::shared_ptr<Config> v89; // [rsp+B0h] [rbp-1F0h] BYREF
  std::shared_ptr<Config> v90; // [rsp+C0h] [rbp-1E0h] BYREF
  std::shared_ptr<Config> v91; // [rsp+D0h] [rbp-1D0h] BYREF
  std::vector<unsigned int> p_param_vec; // [rsp+E0h] [rbp-1C0h] BYREF
  std::vector<unsigned int> v93; // [rsp+100h] [rbp-1A0h] BYREF
  std::vector<unsigned int> v94; // [rsp+120h] [rbp-180h] BYREF
  common::milog::MiLogStream v95; // [rsp+140h] [rbp-160h] BYREF
  Json::Value_0 other; // [rsp+160h] [rbp-140h] BYREF
  char v97[272]; // [rsp+190h] [rbp-110h] BYREF

  v69 = (unsigned __int64)v97;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v7 = __asan_stack_malloc_2(224LL);
    if ( v7 )
      v69 = v7;
  }
  *(_QWORD *)v69 = 1102416563LL;
  *(_QWORD *)(v69 + 8) = "7 32 4 22 config_item_limit:9487 48 4 19 old_item_count:9489 64 4 19 new_item_count:9490 80 4 1"
                         "2 item_id:9474 96 4 10 count:9474 112 8 9 iter:9482 144 40 9 jval:9540";
  *(_QWORD *)(v69 + 16) = PlayerItemComp::checkIsItemLimitValid;
  v8 = (_DWORD *)(v69 >> 3);
  v8[536862720] = -235802127;
  v8[536862721] = -234556924;
  v8[536862722] = -234556924;
  v8[536862723] = 61956;
  v8[536862723] = -234881024;
  v8[536862724] = 62194;
  v8[536862725] = -218103808;
  v8[536862726] = -202116109;
  *(_DWORD *)(v69 + 80) = item_id;
  *(_DWORD *)(v69 + 96) = count;
  if ( *(_DWORD *)(v69 + 96) )
  {
    *(std::unordered_map<ItemIndexKey,unsigned int>::const_iterator *)(v69 + 112) = std::unordered_map<ItemIndexKey,unsigned int>::find(
                                                                                      (const std::unordered_map<ItemIndexKey,unsigned int> *const)(output_limit_config + 8),
                                                                                      item_index_key);
    __y._M_cur = std::unordered_map<ItemIndexKey,unsigned int>::end((const std::unordered_map<ItemIndexKey,unsigned int> *const)(output_limit_config + 8))._M_cur;
    if ( std::__detail::operator==<std::pair<ItemIndexKey const,unsigned int>,false>(
           (const std::__detail::_Node_iterator_base<std::pair<const ItemIndexKey,unsigned int>,false> *)(v69 + 112),
           &__y) )
    {
      result = 1LL;
    }
    else
    {
      v10 = std::__detail::_Node_const_iterator<std::pair<ItemIndexKey const,unsigned int>,false,false>::operator->((const std::__detail::_Node_const_iterator<std::pair<const ItemIndexKey,unsigned int>,false,false> *const)(v69 + 112));
      if ( *(_BYTE *)(((unsigned __int64)&v10->second >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)v10 + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&v10->second >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&v10->second);
      }
      *(_DWORD *)(v69 + 32) = v10->second;
      *(_DWORD *)(v69 + 48) = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<ItemIndexKey,unsigned int>>(
                                &item_limit_record->item_count_map,
                                item_index_key,
                                0);
      *(_DWORD *)(v69 + 64) = SAFE_ADD<unsigned int,unsigned int>(*(_DWORD *)(v69 + 48), *(_DWORD *)(v69 + 96));
      allow_output = 1;
      v11 = 0;
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v90);
      v12 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v90);
      if ( *(char *)(((unsigned __int64)&v12->is_output_limit_can_alarm >> 3) + 0x7FFF8000) < 0 )
        __asan_report_load1(&v12->is_output_limit_can_alarm);
      if ( !v12->is_output_limit_can_alarm )
        goto LABEL_17;
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v91);
      v11 = 1;
      p_item_limit_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v91)->design_config.txt_config_mgr.item_limit_config_mgr;
      if ( *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) <= 3 )
      {
        p_item_limit_config_mgr = (ItemLimitExcelConfigMgr *)output_limit_config;
        __asan_report_load4(output_limit_config);
      }
      if ( !ItemLimitExcelConfigMgr::isForbidAlertItemLimitConfig(
              p_item_limit_config_mgr,
              *(data::ItemLimitType *)output_limit_config,
              item_index_key) )
        v14 = 1;
      else
LABEL_17:
        v14 = 0;
      is_need_alarm = v14;
      if ( v11 )
        std::shared_ptr<Config>::~shared_ptr(&v91);
      std::shared_ptr<Config>::~shared_ptr(&v90);
      if ( (unsigned int)(2 * *(_DWORD *)(v69 + 32)) >= *(_DWORD *)(v69 + 64) )
      {
        if ( *(_DWORD *)(v69 + 64) <= *(_DWORD *)(v69 + 32) )
        {
          is_need_alarm = 0;
        }
        else
        {
          common::milog::MiLogStream::create(
            &v95,
            &common::milog::MiLogDefault::default_log_obj_,
            1u,
            "./src/player/item/player_item_comp.cpp",
            "checkIsItemLimitValid",
            9505);
          v27 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                  &v95,
                  (const char (*)[45])"new_item_count exceed limit! item_index_key:");
          v28 = operator<<(v27, item_index_key);
          v29 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v28, (const char (*)[8])" count:");
          v30 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v29,
                  (const unsigned int *)(v69 + 96));
          v31 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                  v30,
                  (const char (*)[17])" old_item_count:");
          v32 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v31,
                  (const unsigned int *)(v69 + 48));
          v33 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                  v32,
                  (const char (*)[17])" new_item_count:");
          v34 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v33,
                  (const unsigned int *)(v69 + 64));
          v35 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(
                  v34,
                  (const char (*)[20])" config_item_limit:");
          v36 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v35,
                  (const unsigned int *)(v69 + 32));
          v37 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v36, (const char (*)[9])" player:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          operator<<(v37, this->player_);
          common::milog::MiLogStream::~MiLogStream(&v95);
          is_need_alarm = is_need_alarm && !is_drop;
        }
      }
      else
      {
        common::milog::MiLogStream::create(
          &v95,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkIsItemLimitValid",
          9497);
        v15 = common::milog::MiLogStream::operator<<<char [57],(char *[57])0>(
                &v95,
                (const char (*)[57])"new_item_count will exceed double limit! item_index_key:");
        v16 = operator<<(v15, item_index_key);
        v17 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v16, (const char (*)[8])" count:");
        v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v17,
                (const unsigned int *)(v69 + 96));
        v19 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                v18,
                (const char (*)[17])" old_item_count:");
        v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v19,
                (const unsigned int *)(v69 + 48));
        v21 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                v20,
                (const char (*)[17])" new_item_count:");
        v22 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v21,
                (const unsigned int *)(v69 + 64));
        v23 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(
                v22,
                (const char (*)[20])" config_item_limit:");
        v24 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v23,
                (const unsigned int *)(v69 + 32));
        v25 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v24, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v25, this->player_);
        common::milog::MiLogStream::~MiLogStream(&v95);
        allow_output = 0;
        if ( !is_drop )
          goto LABEL_27;
        if ( *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(output_limit_config);
        }
        if ( PlayerItemComp::isCanForbidItemOutput(this, *(data::ItemLimitType *)output_limit_config, item_index_key) )
LABEL_27:
          v26 = 1;
        else
          v26 = 0;
        is_need_alarm = (is_need_alarm & (unsigned __int8)v26) != 0;
      }
      if ( is_need_alarm )
      {
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)&v91);
        v38 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v91);
        item_config_ptr = ItemExcelConfigMgr::findItemConfig(
                            &v38->design_config.txt_config_mgr.item_config_mgr,
                            *(_DWORD *)(v69 + 80));
        std::shared_ptr<Config>::~shared_ptr(&v91);
        if ( item_config_ptr )
        {
          v71 = 0;
          v70 = 0;
          v74 = 0;
          v73 = 0;
          v72 = 0;
          v68 = 0;
          ServiceBox::findService<GameserverService>();
          GameserverService::getConfig((GameserverService *const)&v89);
          v48 = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v89)->design_config.txt_config_mgr.item_limit_config_mgr;
          if ( *(_BYTE *)(((unsigned __int64)item_index_key >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)item_index_key & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_index_key >> 3)
                                                                             + 0x7FFF8000) )
          {
            __asan_report_load4(item_index_key);
          }
          v87[0] = item_index_key->item_type;
          if ( *(_BYTE *)(((unsigned __int64)&item_index_key->index_value >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_index_key + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_index_key->index_value >> 3)
                                                                         + 0x7FFF8000) )
          {
            __asan_report_load4(&item_index_key->index_value);
          }
          v87[1] = item_index_key->index_value;
          if ( *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(output_limit_config);
          }
          v87[2] = *(_DWORD *)output_limit_config;
          __l._M_array = (std::initializer_list<unsigned int>::iterator)v87;
          __l._M_len = 3LL;
          std::allocator<unsigned int>::allocator(&__a);
          std::vector<unsigned int>::vector(&p_param_vec, __l, &__a);
          if ( ItemLimitExcelConfigMgr::isInItemLimitWhiteList(v48, ITEM_LIMIT_WHITE_ITEM, &p_param_vec) )
            goto LABEL_57;
          ServiceBox::findService<GameserverService>();
          GameserverService::getConfig((GameserverService *const)&v90);
          v71 = 1;
          v49 = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v90)->design_config.txt_config_mgr.item_limit_config_mgr;
          if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
            && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                           + 0x7FFF8000) )
          {
            __asan_report_load4(&item_config_ptr->item_type);
          }
          v88[0] = item_config_ptr->item_type;
          if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_rank_level >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_rank_level >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(&item_config_ptr->item_rank_level);
          }
          v88[1] = item_config_ptr->item_rank_level;
          if ( *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(output_limit_config);
          }
          v88[2] = *(_DWORD *)output_limit_config;
          v66._M_array = (std::initializer_list<unsigned int>::iterator)v88;
          v66._M_len = 3LL;
          std::allocator<unsigned int>::allocator(&v81);
          v70 = 1;
          std::vector<unsigned int>::vector(&v93, v66, &v81);
          v74 = 1;
          if ( ItemLimitExcelConfigMgr::isInItemLimitWhiteList(v49, ITEM_LIMIT_WHITE_ITEM_RANK, &v93) )
            goto LABEL_57;
          ServiceBox::findService<GameserverService>();
          GameserverService::getConfig((GameserverService *const)&v91);
          v73 = 1;
          v50 = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v91)->design_config.txt_config_mgr.item_limit_config_mgr;
          LODWORD(__y._M_cur) = *(_DWORD *)(v69 + 80);
          if ( *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(output_limit_config);
          }
          HIDWORD(__y._M_cur) = *(_DWORD *)output_limit_config;
          v67._M_array = (std::initializer_list<unsigned int>::iterator)&__y;
          v67._M_len = 2LL;
          std::allocator<unsigned int>::allocator(&v82);
          v72 = 1;
          std::vector<unsigned int>::vector(&v94, v67, &v82);
          v68 = 1;
          if ( ItemLimitExcelConfigMgr::isInItemLimitWhiteList(v50, ITEM_LIMIT_WHITE_ITEM_ID, &v94) )
LABEL_57:
            v51 = 1;
          else
            v51 = 0;
          if ( v68 )
            std::vector<unsigned int>::~vector(&v94);
          if ( v72 )
            std::allocator<unsigned int>::~allocator(&v82);
          if ( v73 )
            std::shared_ptr<Config>::~shared_ptr(&v91);
          if ( v74 )
            std::vector<unsigned int>::~vector(&v93);
          if ( v70 )
            std::allocator<unsigned int>::~allocator(&v81);
          if ( v71 )
            std::shared_ptr<Config>::~shared_ptr(&v90);
          std::vector<unsigned int>::~vector(&p_param_vec);
          std::allocator<unsigned int>::~allocator(&__a);
          std::shared_ptr<Config>::~shared_ptr(&v89);
          if ( v51 )
            is_need_alarm = 0;
        }
        else
        {
          common::milog::MiLogStream::create(
            &v95,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "checkIsItemLimitValid",
            9524);
          v39 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                  &v95,
                  (const char (*)[30])"findItemConfig fail, item_id:");
          v40 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v39,
                  (const unsigned int *)(v69 + 80));
          v41 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v40, (const char (*)[8])" count:");
          v42 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v41,
                  (const unsigned int *)(v69 + 96));
          v43 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(
                  v42,
                  (const char (*)[18])" item_limit_type:");
          v44 = common::milog::MiLogStream::operator<<<data::ItemLimitType,(data::ItemLimitType*)0>(
                  v43,
                  (const data::ItemLimitType *)output_limit_config);
          v45 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v44, (const char (*)[10])" is_drop:");
          v46 = common::milog::MiLogStream::operator<<(v45, is_drop);
          v47 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v46, (const char (*)[9])" player:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          operator<<(v47, this->player_);
          common::milog::MiLogStream::~MiLogStream(&v95);
        }
      }
      if ( is_need_alarm )
      {
        Json::Value::Value(v69 + 144, 0LL);
        if ( *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(output_limit_config);
        }
        Json::Value::Value((Json::Value *)&other, *(_DWORD *)output_limit_config);
        v52 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "item_limit_type");
        Json::Value::operator=(v52, &other);
        Json::Value::~Value(&other);
        if ( *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)((output_limit_config >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(output_limit_config);
        }
        v53 = data::enumValToStr((data::ItemLimitType)*(_DWORD *)output_limit_config);
        Json::Value::Value((Json::Value *)&other, v53);
        v54 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "item_limit_type_str");
        Json::Value::operator=(v54, &other);
        Json::Value::~Value(&other);
        if ( *(_BYTE *)(((output_limit_config + 4) >> 3) + 0x7FFF8000) != 0
          && (char)(((output_limit_config + 4) & 7) + 3) >= *(_BYTE *)(((output_limit_config + 4) >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(output_limit_config + 4);
        }
        Json::Value::Value((Json::Value *)&other, *(_DWORD *)(output_limit_config + 4));
        v55 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "item_limit_refresh_type");
        Json::Value::operator=(v55, &other);
        Json::Value::~Value(&other);
        if ( *(_BYTE *)(((output_limit_config + 4) >> 3) + 0x7FFF8000) != 0
          && (char)(((output_limit_config + 4) & 7) + 3) >= *(_BYTE *)(((output_limit_config + 4) >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(output_limit_config + 4);
        }
        v56 = data::enumValToStr((data::ItemLimitRefreshType)*(_DWORD *)(output_limit_config + 4));
        Json::Value::Value((Json::Value *)&other, v56);
        v57 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "item_limit_refresh_type_str");
        Json::Value::operator=(v57, &other);
        Json::Value::~Value(&other);
        if ( *(_BYTE *)(((unsigned __int64)item_index_key >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)item_index_key & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_index_key >> 3)
                                                                           + 0x7FFF8000) )
        {
          __asan_report_load4(item_index_key);
        }
        Json::Value::Value((Json::Value *)&other, item_index_key->item_type);
        v58 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "item_type");
        Json::Value::operator=(v58, &other);
        Json::Value::~Value(&other);
        if ( *(_BYTE *)(((unsigned __int64)&item_index_key->index_value >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_index_key + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_index_key->index_value >> 3)
                                                                       + 0x7FFF8000) )
        {
          __asan_report_load4(&item_index_key->index_value);
        }
        Json::Value::Value((Json::Value *)&other, item_index_key->index_value);
        v59 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "index_value");
        Json::Value::operator=(v59, &other);
        Json::Value::~Value(&other);
        Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v69 + 80));
        v60 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "item_id");
        Json::Value::operator=(v60, &other);
        Json::Value::~Value(&other);
        Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v69 + 48));
        v61 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "old_count");
        Json::Value::operator=(v61, &other);
        Json::Value::~Value(&other);
        Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v69 + 96));
        v62 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "delta_count");
        Json::Value::operator=(v62, &other);
        Json::Value::~Value(&other);
        Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v69 + 32));
        v63 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "config_item_limit");
        Json::Value::operator=(v63, &other);
        Json::Value::~Value(&other);
        Json::Value::Value((Json::Value *)&other, "output_limit");
        v64 = Json::Value::operator[]((Json::Value_0 *const)(v69 + 144), "type");
        Json::Value::operator=(v64, &other);
        Json::Value::~Value(&other);
        PlayerItemComp::asyncSendAlarmToPlatform(this, (Json::Value *)(v69 + 144));
        Json::Value::~Value((Json::Value_0 *const)(v69 + 144));
      }
      result = allow_output;
    }
  }
  else
  {
    result = 0LL;
  }
  if ( v97 == (char *)v69 )
  {
    *(_QWORD *)((v69 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v69 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v69 >> 3) + 0x7FFF8010) = 0LL;
    *(_DWORD *)((v69 >> 3) + 0x7FFF8018) = 0;
  }
  else
  {
    *(_QWORD *)v69 = 1172321806LL;
    *(_QWORD *)((v69 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v69 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v69 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v69 >> 3) + 0x7FFF8018) = -168430091;
  }
  return result;
};

// Line 9559: range 0000000017D14BAA-0000000017D14D00
std::vector<ItemParam> *__cdecl PlayerItemComp::getItemParamVec(
        std::vector<ItemParam> *retstr,
        const PlayerItemComp *const this,
        const std::vector<std::shared_ptr<Item>> *item_vec)
{
  std::vector<ItemParam>::size_type v3; // rdx
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v4; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // rdx
  std::vector<std::shared_ptr<Item>>::const_iterator __for_begin; // [rsp+20h] [rbp-40h] BYREF
  std::vector<std::shared_ptr<Item>>::const_iterator __for_end; // [rsp+28h] [rbp-38h] BYREF
  const std::vector<std::shared_ptr<Item>> *__for_range; // [rsp+30h] [rbp-30h]
  const ItemPtr *item_ptr; // [rsp+38h] [rbp-28h]
  std::vector<ItemParam>::value_type __x; // [rsp+40h] [rbp-20h] BYREF

  std::vector<ItemParam>::vector(retstr);
  v3 = std::vector<std::shared_ptr<Item>>::size(item_vec);
  std::vector<ItemParam>::reserve(retstr, v3);
  __for_range = item_vec;
  __for_begin._M_current = std::vector<std::shared_ptr<Item>>::begin(item_vec)._M_current;
  __for_end._M_current = std::vector<std::shared_ptr<Item>>::end(item_vec)._M_current;
  while ( __gnu_cxx::operator!=<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>(
            &__for_begin,
            &__for_end) )
  {
    item_ptr = __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator*(&__for_begin);
    if ( std::operator!=<Item>(0LL, item_ptr) )
    {
      v4 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
      if ( *(_BYTE *)(((unsigned __int64)v4 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v5 = (unsigned __int64)(v4->_vptr_Item + 10);
      if ( *(_BYTE *)((v5 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      *(_QWORD *)&__x.item_id = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v5)(v4);
      *(_QWORD *)&__x.level = v6;
      std::vector<ItemParam>::push_back(retstr, &__x);
    }
    __gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>::operator++(&__for_begin);
  }
  return retstr;
};

// Line 9573: range 0000000017D14D02-0000000017D14FF4
int32_t __cdecl PlayerItemComp::getItemIdCountAndIndex(
        const PlayerItemComp *const this,
        const ItemPtr *item_ptr,
        uint32_t *item_id,
        uint32_t *count,
        ItemIndexKey *item_index_key)
{
  unsigned __int64 v5; // rbx
  __int64 v6; // rax
  unsigned __int64 v7; // r12
  int32_t result; // eax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  uint32_t ItemId; // ecx
  char v11; // dl
  __int64 v12; // rdx
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v13; // rax
  unsigned __int64 v14; // rdx
  __int64 v15; // rsi
  uint32_t v16; // ecx
  char v17; // dl
  __int64 v18; // rdx
  TxtConfigMgr *p_txt_config_mgr; // rcx
  const ItemPtr *item_ptra; // [rsp+20h] [rbp-A0h]
  std::pair<int,ItemIndexKey> __in; // [rsp+34h] [rbp-8Ch] BYREF
  std::tuple<int&,ItemIndexKey&> v25; // [rsp+40h] [rbp-80h] BYREF
  std::shared_ptr<Config> v26; // [rsp+50h] [rbp-70h] BYREF
  char v27[96]; // [rsp+60h] [rbp-60h] BYREF

  item_ptra = item_ptr;
  v5 = (unsigned __int64)v27;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_0(64LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "1 32 4 8 ret:9580";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::getItemIdCountAndIndex;
  v7 = v5 >> 3;
  *(_DWORD *)(v7 + 2147450880) = -235802127;
  *(_DWORD *)(v7 + 2147450884) = -202116348;
  if ( std::operator==<Item>(0LL, item_ptr) )
  {
    result = -1;
  }
  else
  {
    v9 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptr);
    ItemId = Item::getItemId(v9);
    v11 = *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000);
    LOBYTE(item_ptr) = v11 != 0;
    v12 = (v11 != 0) & (unsigned __int8)((char)(((unsigned __int8)item_id & 7) + 3) >= v11);
    if ( (_BYTE)v12 )
      __asan_report_store4(item_id, item_ptr, v12);
    *item_id = ItemId;
    v13 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)item_ptra);
    if ( *(_BYTE *)(((unsigned __int64)v13 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v14 = (unsigned __int64)(v13->_vptr_Item + 8);
    v15 = *(unsigned __int8 *)((v14 >> 3) + 0x7FFF8000);
    if ( (_BYTE)v15 )
      __asan_report_load8();
    v16 = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v14)(v13);
    v17 = *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000);
    LOBYTE(v15) = v17 != 0;
    v18 = (v17 != 0) & (unsigned __int8)((char)(((unsigned __int8)count & 7) + 3) >= v17);
    if ( (_BYTE)v18 )
      __asan_report_store4(count, v15, v18);
    *count = v16;
    *(_DWORD *)(v5 + 32) = 0;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v26);
    p_txt_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v26)->design_config.txt_config_mgr;
    if ( *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_id);
    }
    __in = TxtConfigMgr::getItemIndexKey(p_txt_config_mgr, *item_id);
    std::tie<int,ItemIndexKey>((int *)&v25, (ItemIndexKey *)(v5 + 32), (int *)item_index_key, (ItemIndexKey *)(v5 + 32));
    std::tuple<int &,ItemIndexKey &>::operator=<int,ItemIndexKey>(&v25, &__in);
    std::shared_ptr<Config>::~shared_ptr(&v26);
    result = *(_DWORD *)(v5 + 32);
  }
  if ( v27 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 9586: range 0000000017D14FF6-0000000017D152D7
int32_t __cdecl PlayerItemComp::getItemIdCountAndIndex(
        const PlayerItemComp *const this,
        const ItemParam *item_param,
        uint32_t *item_id,
        uint32_t *count,
        ItemIndexKey *item_index_key)
{
  unsigned __int64 v5; // rbx
  __int64 v6; // rax
  unsigned __int64 v7; // r12
  __int64 v8; // rsi
  uint32_t v9; // ecx
  char v10; // dl
  __int64 v11; // rdx
  __int64 v12; // rsi
  uint32_t v13; // ecx
  char v14; // dl
  __int64 v15; // rdx
  TxtConfigMgr *p_txt_config_mgr; // rcx
  int32_t result; // eax
  std::pair<int,ItemIndexKey> __in; // [rsp+34h] [rbp-8Ch] BYREF
  std::tuple<int&,ItemIndexKey&> v23; // [rsp+40h] [rbp-80h] BYREF
  std::shared_ptr<Config> v24; // [rsp+50h] [rbp-70h] BYREF
  char v25[96]; // [rsp+60h] [rbp-60h] BYREF

  v5 = (unsigned __int64)v25;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_0(64LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "1 32 4 8 ret:9589";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::getItemIdCountAndIndex;
  v7 = v5 >> 3;
  *(_DWORD *)(v7 + 2147450880) = -235802127;
  *(_DWORD *)(v7 + 2147450884) = -202116348;
  v8 = ((unsigned __int8)item_param & 7u) + 3;
  if ( *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)item_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(item_param);
  }
  v9 = item_param->item_id;
  v10 = *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000);
  LOBYTE(v8) = v10 != 0;
  v11 = (v10 != 0) & (unsigned __int8)((char)(((unsigned __int8)item_id & 7) + 3) >= v10);
  if ( (_BYTE)v11 )
    __asan_report_store4(item_id, v8, v11);
  *item_id = v9;
  v12 = (((_BYTE)item_param + 4) & 7u) + 3;
  if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&item_param->count);
  }
  v13 = item_param->count;
  v14 = *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000);
  LOBYTE(v12) = v14 != 0;
  v15 = (v14 != 0) & (unsigned __int8)((char)(((unsigned __int8)count & 7) + 3) >= v14);
  if ( (_BYTE)v15 )
    __asan_report_store4(count, v12, v15);
  *count = v13;
  *(_DWORD *)(v5 + 32) = 0;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v24);
  p_txt_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v24)->design_config.txt_config_mgr;
  if ( *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)item_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(item_id);
  }
  __in = TxtConfigMgr::getItemIndexKey(p_txt_config_mgr, *item_id);
  std::tie<int,ItemIndexKey>((int *)&v23, (ItemIndexKey *)(v5 + 32), (int *)item_index_key, (ItemIndexKey *)(v5 + 32));
  std::tuple<int &,ItemIndexKey &>::operator=<int,ItemIndexKey>(&v23, &__in);
  std::shared_ptr<Config>::~shared_ptr(&v24);
  result = *(_DWORD *)(v5 + 32);
  if ( v25 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 9596: range 0000000017D154C8-0000000017D15C08
void __cdecl PlayerItemComp::asyncSendAlarmToPlatform(const PlayerItemComp *const this, Json::Value *jval)
{
  unsigned __int64 v2; // r13
  __int64 v3; // rax
  _DWORD *v4; // r12
  unsigned int Uid; // eax
  Json::Value_0 *v6; // rax
  __int64 Now; // rax
  Json::Value_0 *v8; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  const std::string *v10; // rax
  Json::Value_0 *v11; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  unsigned int RegionId; // eax
  Json::Value_0 *v14; // rax
  __int64 v15; // rax
  PlayerItemComp::asyncSendAlarmToPlatform::<lambda(common::minet::http_client::HttpRetcode, common::minet::http_client::HttpRequest&&, common::minet::http_client::HttpResponse&&)> v16; // si
  GameserverService *v17; // r14
  common::milog::MiLogStream *v18; // rax
  OutputControlMonitorConfig *config; // [rsp+18h] [rbp-258h]
  std::shared_ptr<Config> v20; // [rsp+20h] [rbp-250h] BYREF
  Json::String v21; // [rsp+30h] [rbp-240h] BYREF
  Json::Value_0 other; // [rsp+50h] [rbp-220h] BYREF
  char v23[496]; // [rsp+80h] [rbp-1F0h] BYREF

  v2 = (unsigned __int64)v23;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_3(448LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "3 48 1 22 response_callback:9597 64 48 16 json_writer:9616 144 240 17 http_request:9608";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::asyncSendAlarmToPlatform;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234753551;
  v4[536862723] = -219021312;
  v4[536862724] = 62194;
  v4[536862732] = -202116109;
  v4[536862733] = -202116109;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  Uid = Player::getUid(this->player_);
  Json::Value::Value((Json::Value *)&other, Uid);
  v6 = Json::Value::operator[]((Json::Value_0 *const)jval, off_2639B920);
  Json::Value::operator=(v6, &other);
  Json::Value::~Value(&other);
  Now = common::tools::TimeUtils::getNow();
  Json::Value::Value((Json::Value *)&other, Now);
  v8 = Json::Value::operator[]((Json::Value_0 *const)jval, "timestamp");
  Json::Value::operator=(v8, &other);
  Json::Value::~Value(&other);
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v20);
  v9 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v20);
  v10 = ConfigBase::getRegionName[abi:cxx11](v9);
  Json::Value::Value(&other, v10);
  v11 = Json::Value::operator[]((Json::Value_0 *const)jval, "region");
  Json::Value::operator=(v11, &other);
  Json::Value::~Value(&other);
  std::shared_ptr<Config>::~shared_ptr(&v20);
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v20);
  v12 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v20);
  RegionId = Config::getRegionId(v12);
  Json::Value::Value((Json::Value *)&other, RegionId);
  v14 = Json::Value::operator[]((Json::Value_0 *const)jval, "region_id");
  Json::Value::operator=(v14, &other);
  Json::Value::~Value(&other);
  std::shared_ptr<Config>::~shared_ptr(&v20);
  common::minet::http_client::HttpRequest::HttpRequest((common::minet::http_client::HttpRequest *const)(v2 + 144));
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v20);
  config = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v20)->output_control_monitor_config;
  std::shared_ptr<Config>::~shared_ptr(&v20);
  std::string::operator=(v2 + 144, config);
  std::string::operator=(v2 + 176, &config->port);
  std::string::operator=(v2 + 208, &config->uri);
  if ( *(_BYTE *)(((unsigned __int64)&config->method >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&config->method >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&config->method);
  }
  *(_DWORD *)(v2 + 368) = config->method;
  if ( *(_BYTE *)(((unsigned __int64)&config->version >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)config + 100) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&config->version >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&config->version);
  }
  *(_DWORD *)(v2 + 372) = config->version;
  if ( *(char *)(((unsigned __int64)&config->is_ssl >> 3) + 0x7FFF8000) < 0 )
    __asan_report_load1(&config->is_ssl);
  *(_BYTE *)(v2 + 376) = config->is_ssl;
  Json::FastWriter::FastWriter((Json::FastWriter *const)(v2 + 64));
  Json::FastWriter::write[abi:cxx11](&v21, (Json::FastWriter *const)(v2 + 64), jval);
  v15 = std::string::c_str(&v21);
  v16.gap0[0] = v15;
  std::string::operator=(v2 + 336, v15);
  std::string::~string(&v21);
  v17 = ServiceBox::findService<GameserverService>();
  std::function<void ()(common::minet::http_client::HttpRetcode,common::minet::http_client::HttpRequest &&,common::minet::http_client::HttpResponse &&)>::function<PlayerItemComp::asyncSendAlarmToPlatform(Json::Value &)::{lambda(common::minet::http_client::HttpRetcode,common::minet::http_client::HttpRequest &,common::minet::http_client::HttpResponse)#1},void,void>(
    (std::function<void(common::minet::http_client::HttpRetcode,common::minet::http_client::HttpRequest&&,common::minet::http_client::HttpResponse&&)> *const)&v21,
    v16);
  LOBYTE(v17) = GameserverService::asyncHttpRequest(
                  v17,
                  (const common::minet::http_client::HttpRequest *)(v2 + 144),
                  5LL,
                  4u,
                  (common::minet::http_client::ResponseCallBackFunc *)&v21) != 0;
  std::function<void ()(common::minet::http_client::HttpRetcode,common::minet::http_client::HttpRequest &&,common::minet::http_client::HttpResponse &&)>::~function((std::function<void(common::minet::http_client::HttpRetcode,common::minet::http_client::HttpRequest&&,common::minet::http_client::HttpResponse&&)> *const)&v21);
  if ( (_BYTE)v17 )
  {
    common::milog::MiLogStream::create(
      (common::milog::MiLogStream *)&v21,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "asyncSendAlarmToPlatform",
      9620);
    v18 = common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
            (common::milog::MiLogStream *const)&v21,
            (const char (*)[34])"asyncHttpRequest fail, http body:");
    common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(v18, (const std::string *)(v2 + 336));
    common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v21);
  }
  Json::FastWriter::~FastWriter((Json::FastWriter *const)(v2 + 64));
  common::minet::http_client::HttpRequest::~HttpRequest((common::minet::http_client::HttpRequest *const)(v2 + 144));
  if ( v23 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF800C) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8030) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8028) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8030) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 9597: range 0000000017D152D8-0000000017D154C6
void __fastcall PlayerItemComp::asyncSendAlarmToPlatform(Json::Value &)const::{lambda(common::minet::http_client::HttpRetcode,common::minet::http_client::HttpRequest &&,common::minet::http_client::HttpResponse &&)#1}::operator()(
        const PlayerItemComp::asyncSendAlarmToPlatform::<lambda(common::minet::http_client::HttpRetcode, common::minet::http_client::HttpRequest&&, common::minet::http_client::HttpResponse&&)> *const __closure,
        common::minet::http_client::HttpRetcode http_retcode,
        common::minet::http_client::HttpRequest *http_request,
        common::minet::http_client::HttpResponse *http_response)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  unsigned __int64 v6; // r12
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream v18; // [rsp+20h] [rbp-80h] BYREF
  char v19[96]; // [rsp+40h] [rbp-60h] BYREF

  v4 = (unsigned __int64)v19;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_0(64LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 4 17 http_retcode:9597";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::asyncSendAlarmToPlatform(Json::Value &)const::{lambda(common::minet::http_client::HttpRetcode,common::minet::http_client::HttpRequest &&,common::minet::http_client::HttpResponse &&)#1}::operator();
  v6 = v4 >> 3;
  *(_DWORD *)(v6 + 2147450880) = -235802127;
  *(_DWORD *)(v6 + 2147450884) = -202116348;
  *(_DWORD *)(v4 + 32) = http_retcode;
  common::milog::MiLogStream::create(
    &v18,
    &common::milog::MiLogDefault::default_log_obj_,
    1u,
    "./src/player/item/player_item_comp.cpp",
    "operator()",
    9599);
  v7 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
         &v18,
         (const char (*)[33])"response_callback: http_retcode:");
  v8 = common::milog::MiLogStream::operator<<<common::minet::http_client::HttpRetcode,(common::minet::http_client::HttpRetcode*)0>(
         v7,
         (const common::minet::http_client::HttpRetcode *)(v4 + 32));
  v9 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(v8, (const char (*)[20])" http_request.body:");
  v10 = common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(v9, &http_request->body);
  v11 = common::milog::MiLogStream::operator<<<char [23],(char *[23])0>(
          v10,
          (const char (*)[23])" http_response.status:");
  v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &http_response->status);
  v13 = common::milog::MiLogStream::operator<<<char [25],(char *[25])0>(
          v12,
          (const char (*)[25])" http_response.head_map:");
  v14 = common::milog::MiLogStream::operator<<<std::string,std::string>(v13, &http_response->head_map);
  v15 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(v14, (const char (*)[21])" http_response.body:");
  common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(v15, &http_response->body);
  common::milog::MiLogStream::~MiLogStream(&v18);
  if ( v19 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 9626: range 0000000017D16326-0000000017D16809
void __cdecl PlayerItemComp::removeOutdatedOutputControlRecords(PlayerItemComp *const this)
{
  unsigned __int64 v1; // rbx
  __int64 v2; // rax
  _DWORD *v3; // r13
  std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::iterator __for_begin_0; // [rsp+10h] [rbp-100h] BYREF
  std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::iterator __for_end_0; // [rsp+18h] [rbp-F8h] BYREF
  std::map<data::OutputControlType,OutputControlRecord>::iterator __for_begin; // [rsp+20h] [rbp-F0h] BYREF
  std::map<data::OutputControlType,OutputControlRecord>::iterator __for_end; // [rsp+28h] [rbp-E8h] BYREF
  std::map<data::OutputControlType,OutputControlRecord> *__for_range; // [rsp+30h] [rbp-E0h]
  std::unordered_map<data::NewActivityType,ActivityOutputControlRecord> *__for_range_0; // [rsp+38h] [rbp-D8h]
  std::pair<const data::NewActivityType,ActivityOutputControlRecord> *v10; // [rsp+40h] [rbp-D0h]
  std::tuple_element<0,std::pair<const data::NewActivityType,ActivityOutputControlRecord> >::type *_; // [rsp+48h] [rbp-C8h]
  std::tuple_element<1,std::pair<const data::NewActivityType,ActivityOutputControlRecord> >::type *activity_output_control_record; // [rsp+50h] [rbp-C0h]
  std::map<data::OutputControlType,ActivityOutputIndexRecord> *__for_range_1; // [rsp+58h] [rbp-B8h]
  std::pair<const data::OutputControlType,ActivityOutputIndexRecord> *v14; // [rsp+60h] [rbp-B0h]
  std::tuple_element<0,std::pair<const data::OutputControlType,ActivityOutputIndexRecord> >::type *output_control_type_0; // [rsp+68h] [rbp-A8h]
  std::tuple_element<1,std::pair<const data::OutputControlType,ActivityOutputIndexRecord> >::type *index_record; // [rsp+70h] [rbp-A0h]
  std::pair<const data::OutputControlType,OutputControlRecord> *__in; // [rsp+78h] [rbp-98h]
  std::tuple_element<0,std::pair<const data::OutputControlType,OutputControlRecord> >::type *output_control_type; // [rsp+80h] [rbp-90h]
  std::tuple_element<1,std::pair<const data::OutputControlType,OutputControlRecord> >::type *output_control_record; // [rsp+88h] [rbp-88h]
  char v20[128]; // [rsp+90h] [rbp-80h] BYREF

  v1 = (unsigned __int64)v20;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v2 = __asan_stack_malloc_1(96LL);
    if ( v2 )
      v1 = v2;
  }
  *(_QWORD *)v1 = 1102416563LL;
  *(_QWORD *)(v1 + 8) = "2 32 8 23 is_drop_id_invalid:9627 64 8 25 is_reward_id_invalid:9643";
  *(_QWORD *)(v1 + 16) = PlayerItemComp::removeOutdatedOutputControlRecords;
  v3 = (_DWORD *)(v1 >> 3);
  v3[536862720] = -235802127;
  v3[536862721] = -218959360;
  v3[536862722] = -202116352;
  *(_QWORD *)(v1 + 32) = this;
  *(_QWORD *)(v1 + 64) = this;
  __for_range = &this->output_control_record_map_;
  __for_begin._M_node = std::map<data::OutputControlType,OutputControlRecord>::begin(&this->output_control_record_map_)._M_node;
  __for_end._M_node = std::map<data::OutputControlType,OutputControlRecord>::end(&this->output_control_record_map_)._M_node;
  while ( std::operator!=(&__for_begin, &__for_end) )
  {
    __in = std::_Rb_tree_iterator<std::pair<data::OutputControlType const,OutputControlRecord>>::operator*(&__for_begin);
    output_control_type = std::get<0ul,data::OutputControlType const,OutputControlRecord>(__in);
    output_control_record = std::get<1ul,data::OutputControlType const,OutputControlRecord>(__in);
    if ( *(_BYTE *)(((unsigned __int64)output_control_type >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)output_control_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)output_control_type >> 3)
                                                                            + 0x7FFF8000) )
    {
      __asan_report_load4(output_control_type);
    }
    if ( *output_control_type == OUTPUT_CONTROL_DROP )
    {
      common::tools::MiscUtils::erase_if<unsigned int,unsigned int,PlayerItemComp::removeOutdatedOutputControlRecords(void)::{lambda(std::pair<unsigned int const,unsigned int> const&)#1}>(
        &output_control_record->daily_count_map,
        *(PlayerItemComp::removeOutdatedOutputControlRecords::<lambda(const std::pair<unsigned int const, unsigned int>&)> *)(v1 + 32));
      common::tools::MiscUtils::erase_if<unsigned int,unsigned int,PlayerItemComp::removeOutdatedOutputControlRecords(void)::{lambda(std::pair<unsigned int const,unsigned int> const&)#1}>(
        &output_control_record->total_count_map,
        *(PlayerItemComp::removeOutdatedOutputControlRecords::<lambda(const std::pair<unsigned int const, unsigned int>&)> *)(v1 + 32));
    }
    else
    {
      if ( *(_BYTE *)(((unsigned __int64)output_control_type >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)output_control_type & 7) + 3) >= *(_BYTE *)(((unsigned __int64)output_control_type >> 3)
                                                                              + 0x7FFF8000) )
      {
        __asan_report_load4(output_control_type);
      }
      if ( *output_control_type == OUTPUT_CONTROL_REWARD )
      {
        common::tools::MiscUtils::erase_if<unsigned int,unsigned int,PlayerItemComp::removeOutdatedOutputControlRecords(void)::{lambda(std::pair<unsigned int const,unsigned int> const&)#2}>(
          &output_control_record->daily_count_map,
          *(PlayerItemComp::removeOutdatedOutputControlRecords::<lambda(const std::pair<unsigned int const, unsigned int>&)> *)(v1 + 64));
        common::tools::MiscUtils::erase_if<unsigned int,unsigned int,PlayerItemComp::removeOutdatedOutputControlRecords(void)::{lambda(std::pair<unsigned int const,unsigned int> const&)#2}>(
          &output_control_record->total_count_map,
          *(PlayerItemComp::removeOutdatedOutputControlRecords::<lambda(const std::pair<unsigned int const, unsigned int>&)> *)(v1 + 64));
      }
    }
    std::_Rb_tree_iterator<std::pair<data::OutputControlType const,OutputControlRecord>>::operator++(&__for_begin);
  }
  __for_range_0 = &this->activity_output_control_record_map_;
  __for_begin_0._M_cur = std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::begin(&this->activity_output_control_record_map_)._M_cur;
  __for_end_0._M_cur = std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::end(__for_range_0)._M_cur;
  while ( std::__detail::operator!=<std::pair<data::NewActivityType const,ActivityOutputControlRecord>,false>(
            &__for_begin_0,
            &__for_end_0) )
  {
    v10 = std::__detail::_Node_iterator<std::pair<data::NewActivityType const,ActivityOutputControlRecord>,false,false>::operator*(&__for_begin_0);
    _ = std::get<0ul,data::NewActivityType const,ActivityOutputControlRecord>(v10);
    activity_output_control_record = std::get<1ul,data::NewActivityType const,ActivityOutputControlRecord>(v10);
    __for_range_1 = &activity_output_control_record->activity_output_index_record_map;
    __for_begin._M_node = std::map<data::OutputControlType,ActivityOutputIndexRecord>::begin(&activity_output_control_record->activity_output_index_record_map)._M_node;
    __for_end._M_node = std::map<data::OutputControlType,ActivityOutputIndexRecord>::end(__for_range_1)._M_node;
    while ( std::operator!=(
              (const std::_Rb_tree_iterator<std::pair<const data::OutputControlType,ActivityOutputIndexRecord> >::_Self *)&__for_begin,
              (const std::_Rb_tree_iterator<std::pair<const data::OutputControlType,ActivityOutputIndexRecord> >::_Self *)&__for_end) )
    {
      v14 = std::_Rb_tree_iterator<std::pair<data::OutputControlType const,ActivityOutputIndexRecord>>::operator*((const std::_Rb_tree_iterator<std::pair<const data::OutputControlType,ActivityOutputIndexRecord> > *const)&__for_begin);
      output_control_type_0 = std::get<0ul,data::OutputControlType const,ActivityOutputIndexRecord>(v14);
      index_record = std::get<1ul,data::OutputControlType const,ActivityOutputIndexRecord>(v14);
      if ( *(_BYTE *)(((unsigned __int64)output_control_type_0 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)output_control_type_0 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)output_control_type_0 >> 3)
                                                                                + 0x7FFF8000) )
      {
        __asan_report_load4(output_control_type_0);
      }
      if ( *output_control_type_0 == OUTPUT_CONTROL_DROP )
      {
        common::tools::MiscUtils::erase_if<unsigned int,unsigned int,PlayerItemComp::removeOutdatedOutputControlRecords(void)::{lambda(std::pair<unsigned int const,unsigned int> const&)#1}>(
          &index_record->activity_count_map,
          *(PlayerItemComp::removeOutdatedOutputControlRecords::<lambda(const std::pair<unsigned int const, unsigned int>&)> *)(v1 + 32));
      }
      else
      {
        if ( *(_BYTE *)(((unsigned __int64)output_control_type_0 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)output_control_type_0 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)output_control_type_0 >> 3)
                                                                                  + 0x7FFF8000) )
        {
          __asan_report_load4(output_control_type_0);
        }
        if ( *output_control_type_0 == OUTPUT_CONTROL_REWARD )
          common::tools::MiscUtils::erase_if<unsigned int,unsigned int,PlayerItemComp::removeOutdatedOutputControlRecords(void)::{lambda(std::pair<unsigned int const,unsigned int> const&)#2}>(
            &index_record->activity_count_map,
            *(PlayerItemComp::removeOutdatedOutputControlRecords::<lambda(const std::pair<unsigned int const, unsigned int>&)> *)(v1 + 64));
      }
      std::_Rb_tree_iterator<std::pair<data::OutputControlType const,ActivityOutputIndexRecord>>::operator++((std::_Rb_tree_iterator<std::pair<const data::OutputControlType,ActivityOutputIndexRecord> > *const)&__for_begin);
    }
    std::__detail::_Node_iterator<std::pair<data::NewActivityType const,ActivityOutputControlRecord>,false,false>::operator++(&__for_begin_0);
  }
  if ( v20 == (char *)v1 )
  {
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v1 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v1 = 1172321806LL;
    *(_QWORD *)((v1 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v1 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 9627: range 0000000017D15C0A-0000000017D15F96
bool __cdecl PlayerItemComp::removeOutdatedOutputControlRecords(void)::{lambda(std::pair<unsigned int const,unsigned int> const&)#1}::operator()(
        const PlayerItemComp::removeOutdatedOutputControlRecords::<lambda(const std::pair<unsigned int const, unsigned int>&)> *const __closure,
        const std::pair<unsigned int const,unsigned int> *pr)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *p_player; // rdi
  PlayerItemComp *this; // rax
  bool result; // al
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  const data::DropExcelConfig *drop_config_ptr; // [rsp+18h] [rbp-98h]
  std::shared_ptr<Config> v15; // [rsp+20h] [rbp-90h] BYREF
  common::milog::MiLogStream v16; // [rsp+30h] [rbp-80h] BYREF
  char v17[96]; // [rsp+50h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 12 drop_id:9629";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::removeOutdatedOutputControlRecords(void)::{lambda(std::pair<unsigned int const,unsigned int> const&)#1}::operator();
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  if ( *(_BYTE *)(((unsigned __int64)pr >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)pr & 7) + 3) >= *(_BYTE *)(((unsigned __int64)pr >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(pr);
  }
  *(_DWORD *)(v2 + 32) = pr->first;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v15);
  v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v15);
  drop_config_ptr = data::DropExcelConfigMgrBase::findDropExcelConfig(
                      &v5->design_config.txt_config_mgr.drop_config_mgr,
                      *(_DWORD *)(v2 + 32));
  std::shared_ptr<Config>::~shared_ptr(&v15);
  if ( !drop_config_ptr )
  {
    common::milog::MiLogStream::create(
      &v16,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "operator()",
      9633);
    v6 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
           &v16,
           (const char (*)[33])"drop_config is removed. drop_id:");
    v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, (const unsigned int *)(v2 + 32));
    p_player = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v7, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
    {
      p_player = (common::milog::MiLogStream *)__closure;
      __asan_report_load8();
    }
    this = __closure->__this;
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__this->player_ >> 3) + 0x7FFF8000) )
    {
      p_player = (common::milog::MiLogStream *)&__closure->__this->player_;
      __asan_report_load8();
    }
LABEL_11:
    operator<<(p_player, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v16);
    result = 1;
    goto LABEL_19;
  }
  if ( ItemLimitExcelConfigMgr::isAllOutputControlConfigUnlimited(drop_config_ptr) )
  {
    common::milog::MiLogStream::create(
      &v16,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "operator()",
      9638);
    v11 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
            &v16,
            (const char (*)[35])"drop_config is unlimited. drop_id:");
    v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v2 + 32));
    p_player = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v12, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
    {
      p_player = (common::milog::MiLogStream *)__closure;
      __asan_report_load8();
    }
    this = __closure->__this;
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__this->player_ >> 3) + 0x7FFF8000) )
    {
      p_player = (common::milog::MiLogStream *)&__closure->__this->player_;
      __asan_report_load8();
    }
    goto LABEL_11;
  }
  result = 0;
LABEL_19:
  if ( v17 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 9643: range 0000000017D15F98-0000000017D16324
bool __cdecl PlayerItemComp::removeOutdatedOutputControlRecords(void)::{lambda(std::pair<unsigned int const,unsigned int> const&)#2}::operator()(
        const PlayerItemComp::removeOutdatedOutputControlRecords::<lambda(const std::pair<unsigned int const, unsigned int>&)> *const __closure,
        const std::pair<unsigned int const,unsigned int> *pr)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *p_player; // rdi
  PlayerItemComp *this; // rax
  bool result; // al
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  const data::RewardExcelConfig *reward_config_ptr; // [rsp+18h] [rbp-98h]
  std::shared_ptr<Config> v15; // [rsp+20h] [rbp-90h] BYREF
  common::milog::MiLogStream v16; // [rsp+30h] [rbp-80h] BYREF
  char v17[96]; // [rsp+50h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 14 reward_id:9645";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::removeOutdatedOutputControlRecords(void)::{lambda(std::pair<unsigned int const,unsigned int> const&)#2}::operator();
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  if ( *(_BYTE *)(((unsigned __int64)pr >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)pr & 7) + 3) >= *(_BYTE *)(((unsigned __int64)pr >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(pr);
  }
  *(_DWORD *)(v2 + 32) = pr->first;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v15);
  v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v15);
  reward_config_ptr = data::RewardExcelConfigMgrBase::findRewardExcelConfig(
                        &v5->design_config.txt_config_mgr.reward_config_mgr,
                        *(_DWORD *)(v2 + 32));
  std::shared_ptr<Config>::~shared_ptr(&v15);
  if ( !reward_config_ptr )
  {
    common::milog::MiLogStream::create(
      &v16,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "operator()",
      9649);
    v6 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
           &v16,
           (const char (*)[37])"reward_config is removed. reward_id:");
    v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, (const unsigned int *)(v2 + 32));
    p_player = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v7, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
    {
      p_player = (common::milog::MiLogStream *)__closure;
      __asan_report_load8();
    }
    this = __closure->__this;
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__this->player_ >> 3) + 0x7FFF8000) )
    {
      p_player = (common::milog::MiLogStream *)&__closure->__this->player_;
      __asan_report_load8();
    }
LABEL_11:
    operator<<(p_player, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v16);
    result = 1;
    goto LABEL_19;
  }
  if ( ItemLimitExcelConfigMgr::isAllOutputControlConfigUnlimited(reward_config_ptr) )
  {
    common::milog::MiLogStream::create(
      &v16,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "operator()",
      9654);
    v11 = common::milog::MiLogStream::operator<<<char [39],(char *[39])0>(
            &v16,
            (const char (*)[39])"reward_config is unlimited. reward_id:");
    v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v2 + 32));
    p_player = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v12, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
    {
      p_player = (common::milog::MiLogStream *)__closure;
      __asan_report_load8();
    }
    this = __closure->__this;
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__this->player_ >> 3) + 0x7FFF8000) )
    {
      p_player = (common::milog::MiLogStream *)&__closure->__this->player_;
      __asan_report_load8();
    }
    goto LABEL_11;
  }
  result = 0;
LABEL_19:
  if ( v17 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 9689: range 0000000017D1680A-0000000017D16C1A
int32_t __cdecl PlayerItemComp::logResinChange(
        PlayerItemComp *const this,
        int32_t org_delta,
        int32_t real_delta,
        uint32_t reason_type,
        data::ItemLimitType limit_type)
{
  unsigned __int64 v5; // r12
  __int64 v6; // rax
  _DWORD *v7; // r13
  PlayerBasicComp *BasicComp; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v10; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v11; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // r14
  uint32_t Resin; // eax
  common::milog::MiLogStream *v14; // r14
  std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // r14
  std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v18; // rax
  Player *player; // r14
  int32_t result; // eax
  std::string v21; // [rsp+0h] [rbp-100h]
  google::protobuf::uint32 reason_typea; // [rsp+Ch] [rbp-F4h]
  google::protobuf::int32 real_deltaa; // [rsp+10h] [rbp-F0h]
  google::protobuf::int32 org_deltaa; // [rsp+14h] [rbp-ECh]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-E8h]
  int val; // [rsp+28h] [rbp-D8h] BYREF
  unsigned int v27; // [rsp+2Ch] [rbp-D4h] BYREF
  std::shared_ptr<google::protobuf::Message> p_body_ptr; // [rsp+30h] [rbp-D0h] BYREF
  std::shared_ptr<google::protobuf::Message> p_body_ext_ptr; // [rsp+40h] [rbp-C0h] BYREF
  std::string v30; // [rsp+50h] [rbp-B0h] BYREF
  char v31[144]; // [rsp+70h] [rbp-90h] BYREF

  *(&v21._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  HIDWORD(v21._anon_0._M_allocated_capacity) = org_delta;
  *(_DWORD *)v21._anon_0._M_local_buf = real_delta;
  HIDWORD(v21._M_string_length) = reason_type;
  LODWORD(v21._M_string_length) = limit_type;
  v5 = (unsigned __int64)v31;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_1(96LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "2 48 1 11 holder:9691 64 16 12 log_ptr:9693";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::logResinChange;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234753551;
  v7[536862722] = -202178560;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&v30, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 48), 0x9C4u, v21);
  std::string::~string(&v30);
  common::tools::perf::make_shared<proto_log::PlayerLogBodyResinChange>();
  v9 = std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  proto_log::PlayerLogBodyResinChange::set_original_delta(v9, org_deltaa);
  v10 = std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  proto_log::PlayerLogBodyResinChange::set_real_delta(v10, real_deltaa);
  v11 = std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  proto_log::PlayerLogBodyResinChange::set_reason(v11, reason_typea);
  v12 = std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  Resin = PlayerItemComp::getResin(thisa);
  proto_log::PlayerLogBodyResinChange::set_cur_value(v12, Resin);
  common::milog::MiLogStream::create(
    (common::milog::MiLogStream *)&v30,
    &common::milog::MiLogDefault::default_log_obj_,
    1u,
    "./src/player/item/player_item_comp.cpp",
    "logResinChange",
    9699);
  v14 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(
          (common::milog::MiLogStream *const)&v30,
          (const char (*)[26])"[RECOVER] logResinChange ");
  v15 = std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  val = proto_log::PlayerLogBodyResinChange::real_delta(v15);
  v16 = common::milog::MiLogStream::operator<<<int,(int *)0>(v14, &val);
  v17 = common::milog::MiLogStream::operator<<<char [3],(char *[3])0>(v16, (const char (*)[3])", ");
  v18 = std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyResinChange,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
  v27 = proto_log::PlayerLogBodyResinChange::reason(v18);
  common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, &v27);
  common::milog::MiLogStream::~MiLogStream((common::milog::MiLogStream *const)&v30);
  if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  player = thisa->player_;
  std::shared_ptr<google::protobuf::Message>::shared_ptr(&p_body_ext_ptr, 0LL);
  std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodyResinChange,void>(
    &p_body_ptr,
    (const std::shared_ptr<proto_log::PlayerLogBodyResinChange> *)(v5 + 64));
  Player::printStatLog(player, &p_body_ptr, &p_body_ext_ptr, 0xEu);
  std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ptr);
  std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ext_ptr);
  std::shared_ptr<proto_log::PlayerLogBodyResinChange>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodyResinChange> *const)(v5 + 64));
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v5 + 48));
  result = 0;
  if ( v31 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 9705: range 0000000017D16C1C-0000000017D16E54
void __cdecl PlayerItemComp::checkAllMaterialDelete(PlayerItemComp *const this, uint32_t now)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  _DWORD *v4; // r12
  std::unordered_map<unsigned int,data::MaterialDeleteExcelConfig>::const_iterator __for_begin; // [rsp+10h] [rbp-C0h] BYREF
  std::unordered_map<unsigned int,data::MaterialDeleteExcelConfig>::const_iterator __for_end; // [rsp+18h] [rbp-B8h] BYREF
  const std::unordered_map<unsigned int,data::MaterialDeleteExcelConfig> *__for_range; // [rsp+20h] [rbp-B0h]
  const std::pair<unsigned int const,data::MaterialDeleteExcelConfig> *v8; // [rsp+28h] [rbp-A8h]
  std::tuple_element<0,const std::pair<unsigned int const,data::MaterialDeleteExcelConfig> >::type *material_id; // [rsp+30h] [rbp-A0h]
  std::tuple_element<1,const std::pair<unsigned int const,data::MaterialDeleteExcelConfig> >::type *_; // [rsp+38h] [rbp-98h]
  std::shared_ptr<Config> v11; // [rsp+40h] [rbp-90h] BYREF
  char v12[128]; // [rsp+50h] [rbp-80h] BYREF

  v2 = (unsigned __int64)v12;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(96LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 24 11 id_vec:9706";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkAllMaterialDelete;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -218103808;
  v4[536862722] = -202116109;
  std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v2 + 32));
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v11);
  __for_range = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v11)->design_config.txt_config_mgr.material_config_mgr.material_delete_excel_config_map;
  std::shared_ptr<Config>::~shared_ptr(&v11);
  __for_begin._M_cur = std::unordered_map<unsigned int,data::MaterialDeleteExcelConfig>::begin(__for_range)._M_cur;
  __for_end._M_cur = std::unordered_map<unsigned int,data::MaterialDeleteExcelConfig>::end(__for_range)._M_cur;
  while ( std::__detail::operator!=<std::pair<unsigned int const,data::MaterialDeleteExcelConfig>,false>(
            &__for_begin,
            &__for_end) )
  {
    v8 = std::__detail::_Node_const_iterator<std::pair<unsigned int const,data::MaterialDeleteExcelConfig>,false,false>::operator*(&__for_begin);
    material_id = std::get<0ul,unsigned int const,data::MaterialDeleteExcelConfig>(v8);
    _ = (std::tuple_element<1,const std::pair<unsigned int const,data::MaterialDeleteExcelConfig> >::type *)std::get<1ul,unsigned int const,data::MaterialDeleteExcelConfig>(v8);
    std::vector<unsigned int>::emplace_back<unsigned int const&>(
      (std::vector<unsigned int> *const)(v2 + 32),
      material_id,
      material_id);
    std::__detail::_Node_const_iterator<std::pair<unsigned int const,data::MaterialDeleteExcelConfig>,false,false>::operator++(&__for_begin);
  }
  PlayerItemComp::checkMaterialDelete(this, now, (const std::vector<unsigned int> *)(v2 + 32));
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v2 + 32));
  if ( v12 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 9714: range 0000000017D16E56-0000000017D17D1F
void __cdecl PlayerItemComp::checkMaterialDelete(
        PlayerItemComp *const this,
        uint32_t now,
        const std::vector<unsigned int> *material_id_vec)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  unsigned int *v6; // rax
  unsigned int *v7; // rdx
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  unsigned __int64 *v9; // rax
  uint32_t v10; // r14d
  uint32_t ItemId; // eax
  uint32_t v12; // r14d
  uint32_t v13; // esi
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rcx
  std::vector<unsigned int>::const_iterator *p_for_end_0; // rsi
  unsigned int *v21; // rax
  unsigned int *v22; // rdx
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v23; // rax
  unsigned __int64 *v24; // rax
  Material *v25; // rax
  const unsigned int *v26; // rax
  _DWORD *v27; // rdx
  uint32_t v29; // ecx
  char v30; // al
  common::milog::MiLogStream *v31; // rcx
  common::milog::MiLogStream *v32; // r14
  unsigned int __b; // [rsp+2Ch] [rbp-264h] BYREF
  unsigned int material_id_0; // [rsp+30h] [rbp-260h]
  unsigned int material_id; // [rsp+34h] [rbp-25Ch]
  std::vector<unsigned int>::const_iterator __for_begin_1; // [rsp+38h] [rbp-258h] BYREF
  std::vector<unsigned int>::const_iterator __for_end_0; // [rsp+40h] [rbp-250h] BYREF
  std::set<long unsigned int>::iterator __for_begin; // [rsp+48h] [rbp-248h] BYREF
  std::set<long unsigned int>::iterator __for_end; // [rsp+50h] [rbp-240h] BYREF
  const std::vector<unsigned int> *__for_range; // [rsp+58h] [rbp-238h]
  const std::vector<unsigned int> *__for_range_1; // [rsp+60h] [rbp-230h]
  const data::MaterialDeleteExcelConfig *delete_config_ptr_0; // [rsp+68h] [rbp-228h]
  std::set<long unsigned int> *set_ptr_0; // [rsp+70h] [rbp-220h]
  std::set<long unsigned int> *__for_range_2; // [rsp+78h] [rbp-218h]
  unsigned __int64 guid_0; // [rsp+80h] [rbp-210h]
  const data::MaterialDeleteExcelConfig *delete_config_ptr; // [rsp+88h] [rbp-208h]
  std::set<long unsigned int> *set_ptr; // [rsp+90h] [rbp-200h]
  std::set<long unsigned int> *__for_range_0; // [rsp+98h] [rbp-1F8h]
  unsigned __int64 guid; // [rsp+A0h] [rbp-1F0h]
  Material *m; // [rsp+A8h] [rbp-1E8h]
  std::tuple_element<0,std::pair<unsigned int,std::unordered_map<unsigned int,unsigned int> > >::type *delete_num; // [rsp+B0h] [rbp-1E0h]
  std::tuple_element<1,std::pair<unsigned int,std::unordered_map<unsigned int,unsigned int> > >::type *return_item_map; // [rsp+B8h] [rbp-1D8h]
  common::milog::MiLogStream v55; // [rsp+C0h] [rbp-1D0h] BYREF
  common::milog::MiLogStream v56; // [rsp+E0h] [rbp-1B0h] BYREF
  std::pair<unsigned int,std::unordered_map<unsigned int,unsigned int> > __in; // [rsp+100h] [rbp-190h] BYREF
  char v58[336]; // [rsp+140h] [rbp-150h] BYREF

  v3 = (unsigned __int64)v58;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_3(288LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "6 48 4 30 next_material_delete_time:9759 64 8 11 reason:9751 96 16 17 material_ptr:9730 128 16 1"
                        "7 material_ptr:9774 160 24 19 item_param_vec:9715 224 24 11 notify:9800";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::checkMaterialDelete;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -218959360;
  v5[536862723] = -219021312;
  v5[536862724] = -219021312;
  v5[536862725] = -234881024;
  v5[536862726] = -218959118;
  v5[536862727] = -218103808;
  v5[536862728] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v3 + 160));
  __for_range = material_id_vec;
  __for_end_0._M_current = std::vector<unsigned int>::begin(material_id_vec)._M_current;
  __for_begin._M_node = (std::_Rb_tree_const_iterator<long unsigned int>::_Base_ptr)std::vector<unsigned int>::end(material_id_vec)._M_current;
  while ( __gnu_cxx::operator!=<unsigned int const*,std::vector<unsigned int>>(
            &__for_end_0,
            (const __gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int> > *)&__for_begin) )
  {
    v6 = (unsigned int *)__gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int>>::operator*(&__for_end_0);
    v7 = v6;
    if ( *(_BYTE *)(((unsigned __int64)v6 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v6 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v6 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v6);
    }
    material_id = *v7;
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v3 + 128));
    v8 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
    delete_config_ptr = data::MaterialExcelConfigMgrBase::findMaterialDeleteExcelConfig(
                          &v8->design_config.txt_config_mgr.material_config_mgr,
                          material_id);
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 128));
    if ( delete_config_ptr )
    {
      set_ptr = ItemStore::getItemGuidSetByItemId(&this->pack_store_, material_id);
      if ( set_ptr )
      {
        __for_range_0 = set_ptr;
        __for_end._M_node = std::set<unsigned long>::begin(set_ptr)._M_node;
        *(std::set<long unsigned int>::iterator *)(v3 + 64) = std::set<unsigned long>::end(__for_range_0);
        while ( std::operator!=(&__for_end, (const std::_Rb_tree_const_iterator<long unsigned int>::_Self *)(v3 + 64)) )
        {
          v9 = (unsigned __int64 *)std::_Rb_tree_const_iterator<unsigned long>::operator*(&__for_end);
          if ( *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          guid = *v9;
          ItemStore::findItem<Material>((ItemStore *const)(v3 + 96), (uint64_t)&this->pack_store_, guid);
          if ( !std::operator==<Material>((const std::shared_ptr<Material> *)(v3 + 96), 0LL) )
          {
            m = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator*((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
            Material::getDeleteReturn(&__in, m, now);
            delete_num = std::get<0ul,unsigned int,std::unordered_map<unsigned int,unsigned int>>(&__in);
            return_item_map = std::get<1ul,unsigned int,std::unordered_map<unsigned int,unsigned int>>(&__in);
            if ( *(_BYTE *)(((unsigned __int64)delete_num >> 3) + 0x7FFF8000) != 0
              && (char)(((unsigned __int8)delete_num & 7) + 3) >= *(_BYTE *)(((unsigned __int64)delete_num >> 3)
                                                                           + 0x7FFF8000) )
            {
              __asan_report_load4(delete_num);
            }
            if ( *delete_num )
            {
              v10 = *delete_num;
              ItemId = Item::getItemId(m);
              MaterialDeleteReturnRecord::recordDeleteMaterial(&this->material_delete_return_record_, ItemId, v10);
              MaterialDeleteReturnRecord::recordReturnItem(&this->material_delete_return_record_, return_item_map);
              *(_DWORD *)(v3 + 128) = 0;
              *(_DWORD *)(v3 + 132) = 0;
              *(_DWORD *)(v3 + 136) = 0;
              *(_DWORD *)(v3 + 140) = 0;
              *(_DWORD *)(v3 + 128) = Item::getItemId(m);
              if ( *(_BYTE *)(((unsigned __int64)delete_num >> 3) + 0x7FFF8000) != 0
                && (char)(((unsigned __int8)delete_num & 7) + 3) >= *(_BYTE *)(((unsigned __int64)delete_num >> 3)
                                                                             + 0x7FFF8000) )
              {
                __asan_report_load4(delete_num);
              }
              *(_DWORD *)(v3 + 132) = *delete_num;
              std::vector<ItemParam>::emplace_back<ItemParam&>(
                (std::vector<ItemParam> *const)(v3 + 160),
                (ItemParam *)(v3 + 128),
                (ItemParam *)(v3 + 128));
              if ( *(_BYTE *)(((unsigned __int64)delete_num >> 3) + 0x7FFF8000) != 0
                && (char)(((unsigned __int8)delete_num & 7) + 3) >= *(_BYTE *)(((unsigned __int64)delete_num >> 3)
                                                                             + 0x7FFF8000) )
              {
                __asan_report_load4(delete_num);
              }
              v12 = *delete_num;
              v13 = Item::getItemId(m);
              PlayerItemComp::logMaterialDeleteReturn(this, v13, v12, return_item_map);
              common::milog::MiLogStream::create(
                &v56,
                &common::milog::MiLogDefault::default_log_obj_,
                1u,
                "./src/player/item/player_item_comp.cpp",
                "checkMaterialDelete",
                9746);
              v14 = common::milog::MiLogStream::operator<<<char [37],(char *[37])0>(
                      &v56,
                      (const char (*)[37])"[MATERIAL_DELETE] delete materia_id:");
              v15 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                      v14,
                      (const unsigned int *)(v3 + 128));
              v16 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v15, (const char (*)[8])" count:");
              v17 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v16, delete_num);
              v18 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(
                      v17,
                      (const char (*)[13])" return_map:");
              common::milog::MiLogStream::operator<<<unsigned int,unsigned int>(v18, return_item_map);
              common::milog::MiLogStream::~MiLogStream(&v56);
            }
            std::pair<unsigned int,std::unordered_map<unsigned int,unsigned int>>::~pair(&__in);
          }
          std::shared_ptr<Material>::~shared_ptr((std::shared_ptr<Material> *const)(v3 + 96));
          std::_Rb_tree_const_iterator<unsigned long>::operator++(&__for_end);
        }
      }
    }
    __gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int>>::operator++(&__for_end_0);
  }
  SubItemReason::SubItemReason((SubItemReason *const)(v3 + 64), ACTION_REASON_MATERIAL_DELETE_RETURN);
  if ( PlayerItemComp::subItemBatch(this, (const std::vector<ItemParam> *)(v3 + 160), (const SubItemReason *)(v3 + 64)) )
  {
    common::milog::MiLogStream::create(
      &v56,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkMaterialDelete",
      9754);
    v19 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(&v56, (const char (*)[31])off_2639BEC0);
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v19, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v56);
  }
  else
  {
    *(_DWORD *)(v3 + 48) = -1;
    __for_range_1 = material_id_vec;
    __for_begin_1._M_current = std::vector<unsigned int>::begin(material_id_vec)._M_current;
    __for_end_0._M_current = std::vector<unsigned int>::end(__for_range_1)._M_current;
    while ( 1 )
    {
      p_for_end_0 = &__for_end_0;
      if ( !__gnu_cxx::operator!=<unsigned int const*,std::vector<unsigned int>>(&__for_begin_1, &__for_end_0) )
        break;
      v21 = (unsigned int *)__gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int>>::operator*(&__for_begin_1);
      v22 = v21;
      if ( *(_BYTE *)(((unsigned __int64)v21 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v21 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v21 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v21);
      }
      material_id_0 = *v22;
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)(v3 + 128));
      v23 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
      delete_config_ptr_0 = data::MaterialExcelConfigMgrBase::findMaterialDeleteExcelConfig(
                              &v23->design_config.txt_config_mgr.material_config_mgr,
                              material_id_0);
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 128));
      if ( delete_config_ptr_0 )
      {
        set_ptr_0 = ItemStore::getItemGuidSetByItemId(&this->pack_store_, material_id_0);
        if ( set_ptr_0 )
        {
          __for_range_2 = set_ptr_0;
          __for_begin._M_node = std::set<unsigned long>::begin(set_ptr_0)._M_node;
          __for_end._M_node = std::set<unsigned long>::end(__for_range_2)._M_node;
          while ( std::operator!=(&__for_begin, &__for_end) )
          {
            v24 = (unsigned __int64 *)std::_Rb_tree_const_iterator<unsigned long>::operator*(&__for_begin);
            if ( *(_BYTE *)(((unsigned __int64)v24 >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            guid_0 = *v24;
            ItemStore::findItem<Material>((ItemStore *const)(v3 + 128), (uint64_t)&this->pack_store_, guid_0);
            if ( !std::operator==<Material>((const std::shared_ptr<Material> *)(v3 + 128), 0LL) )
            {
              v25 = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
              __b = Material::getNextDeleteTime(v25);
              v26 = std::min<unsigned int>((const unsigned int *)(v3 + 48), &__b);
              v27 = v26;
              if ( *(_BYTE *)(((unsigned __int64)v26 >> 3) + 0x7FFF8000) != 0
                && (char)(((unsigned __int8)v26 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v26 >> 3) + 0x7FFF8000) )
              {
                __asan_report_load4(v26);
              }
              *(_DWORD *)(v3 + 48) = *v27;
            }
            std::shared_ptr<Material>::~shared_ptr((std::shared_ptr<Material> *const)(v3 + 128));
            std::_Rb_tree_const_iterator<unsigned long>::operator++(&__for_begin);
          }
        }
      }
      __gnu_cxx::__normal_iterator<unsigned int const*,std::vector<unsigned int>>::operator++(&__for_begin_1);
    }
    if ( std::numeric_limits<unsigned int>::max() != *(_DWORD *)(v3 + 48) && now < *(_DWORD *)(v3 + 48) )
    {
      if ( *(_BYTE *)(((unsigned __int64)&this->next_check_material_delete_time_ >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&this->next_check_material_delete_time_ >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&this->next_check_material_delete_time_);
      }
      if ( this->next_check_material_delete_time_ > *(_DWORD *)(v3 + 48) || !this->next_check_material_delete_time_ )
      {
        common::tools::MiTimer::cancel(&this->check_material_delete_timer_);
        v29 = *(_DWORD *)(v3 + 48);
        v30 = *(_BYTE *)(((unsigned __int64)&this->next_check_material_delete_time_ >> 3) + 0x7FFF8000);
        if ( v30 != 0 && v30 <= 3 )
        {
          LOBYTE(p_for_end_0) = v30 != 0;
          __asan_report_store4(
            &this->next_check_material_delete_time_,
            p_for_end_0,
            &this->next_check_material_delete_time_);
        }
        this->next_check_material_delete_time_ = v29;
        if ( PlayerUnixTimer::startS(
               &this->check_material_delete_timer_,
               this->next_check_material_delete_time_ - now,
               0,
               "./src/player/item/player_item_comp.cpp",
               "checkMaterialDelete",
               9790) )
        {
          common::milog::MiLogStream::create(
            &v56,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "checkMaterialDelete",
            9792);
          v31 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
                  &v56,
                  (const char (*)[21])" start timer failed.");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          operator<<(v31, this->player_);
          common::milog::MiLogStream::~MiLogStream(&v56);
        }
        common::milog::MiLogStream::create(
          &v55,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "checkMaterialDelete",
          9794);
        v32 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
                &v55,
                (const char (*)[45])"[MATERIAL_DELETE] next material delete time:");
        if ( *(_BYTE *)(((unsigned __int64)&this->next_check_material_delete_time_ >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&this->next_check_material_delete_time_ >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&this->next_check_material_delete_time_);
        }
        common::tools::TimeUtils::getStrByTime[abi:cxx11]((std::string *)&v56, this->next_check_material_delete_time_);
        common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(v32, (const std::string *)&v56);
        std::string::~string(&v56);
        common::milog::MiLogStream::~MiLogStream(&v55);
      }
    }
    if ( !std::vector<ItemParam>::empty((const std::vector<ItemParam> *const)(v3 + 160)) )
    {
      proto::MaterialDeleteUpdateNotify::MaterialDeleteUpdateNotify((proto::MaterialDeleteUpdateNotify *const)(v3 + 224));
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      Player::sendProto(this->player_, (const google::protobuf::Message *)(v3 + 224));
      proto::MaterialDeleteUpdateNotify::~MaterialDeleteUpdateNotify((proto::MaterialDeleteUpdateNotify *const)(v3 + 224));
    }
  }
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 160));
  if ( v58 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8018) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8020) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8020) = -168430091;
  }
};

// Line 9807: range 0000000017D17D20-0000000017D17E77
void __cdecl PlayerItemComp::onCheckMaterialDeleteTimer(PlayerItemComp *const this, uint64_t now_ms)
{
  uint32_t Now; // edx
  common::milog::MiLogStream *v3; // rbx
  common::milog::MiLogStream v4; // [rsp+10h] [rbp-50h] BYREF
  std::string val; // [rsp+30h] [rbp-30h] BYREF

  if ( *(_BYTE *)(((unsigned __int64)&this->next_check_material_delete_time_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->next_check_material_delete_time_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_store4(&this->next_check_material_delete_time_, now_ms, &this->next_check_material_delete_time_);
  }
  this->next_check_material_delete_time_ = 0;
  Now = common::tools::TimeUtils::getNow();
  PlayerItemComp::checkAllMaterialDelete(this, Now);
  common::milog::MiLogStream::create(
    &v4,
    &common::milog::MiLogDefault::default_log_obj_,
    1u,
    "./src/player/item/player_item_comp.cpp",
    "onCheckMaterialDeleteTimer",
    9810);
  v3 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(
         &v4,
         (const char (*)[44])"[MATERIAL_DELETE] now material delete time:");
  if ( *(_BYTE *)(((unsigned __int64)&this->next_check_material_delete_time_ >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&this->next_check_material_delete_time_ >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&this->next_check_material_delete_time_);
  }
  common::tools::TimeUtils::getStrByTime[abi:cxx11](&val, this->next_check_material_delete_time_);
  common::milog::MiLogStream::operator<<<std::string,(std::string*)0>(v3, &val);
  std::string::~string(&val);
  common::milog::MiLogStream::~MiLogStream(&v4);
};

// Line 9814: range 0000000017D17E78-0000000017D186CF
void __cdecl PlayerItemComp::takeMaterialDeleteReturnItem(
        PlayerItemComp *const this,
        proto::MaterialDeleteReturnType type)
{
  unsigned __int64 v2; // r13
  __int64 v3; // rax
  _DWORD *v4; // r12
  uint32_t Now; // edx
  std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v6; // rax
  std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v7; // rax
  std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::pointer v8; // rax
  uint32_t *v9; // rdx
  std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::pointer v10; // rdx
  unsigned int *p_second; // rax
  unsigned int second; // r14d
  std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::pointer v13; // rsi
  unsigned int *v14; // rax
  unsigned int *v15; // rdx
  char v16; // cl
  std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> v17; // rax
  std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v18; // rax
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *v19; // rax
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type v20; // r14d
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *v21; // rsi
  unsigned int *v22; // rax
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *v23; // rdx
  char v24; // cl
  common::milog::MiLogStream *v25; // rcx
  int v26; // r14d
  std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v27; // rax
  const google::protobuf::Map<unsigned int,unsigned int> *v28; // rax
  std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v29; // rax
  const google::protobuf::Map<unsigned int,unsigned int> *v30; // rax
  Player *player; // r14
  std::unordered_map<unsigned int,unsigned int>::iterator __for_end; // [rsp+10h] [rbp-190h] BYREF
  std::unordered_map<unsigned int,unsigned int> *delete_material_map; // [rsp+18h] [rbp-188h]
  google::protobuf::Map<unsigned int,unsigned int> *proto_delete_map; // [rsp+20h] [rbp-180h]
  google::protobuf::Map<unsigned int,unsigned int> *proto_return_map; // [rsp+28h] [rbp-178h]
  std::unordered_map<unsigned int,unsigned int> *__for_range; // [rsp+30h] [rbp-170h]
  std::pair<unsigned int const,unsigned int> *__in; // [rsp+38h] [rbp-168h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *item_id; // [rsp+40h] [rbp-160h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *num; // [rsp+48h] [rbp-158h]
  common::milog::MiLogStream v42; // [rsp+50h] [rbp-150h] BYREF
  char v43[304]; // [rsp+70h] [rbp-130h] BYREF

  v2 = (unsigned __int64)v43;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_2(256LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "5 32 8 9 iter:9825 64 16 15 notify_ptr:9822 96 16 15 item_param:9844 128 24 19 item_param_vec:98"
                        "40 192 24 18 action_reason:9851";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::takeMaterialDeleteReturnItem;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -218959360;
  v4[536862722] = -219021312;
  v4[536862723] = -219021312;
  v4[536862724] = -234881024;
  v4[536862725] = -218959118;
  v4[536862726] = -218103808;
  v4[536862727] = -202116109;
  Now = common::tools::TimeUtils::getNow();
  PlayerItemComp::checkAllMaterialDelete(this, Now);
  if ( !MaterialDeleteReturnRecord::empty(&this->material_delete_return_record_) )
  {
    delete_material_map = &this->material_delete_return_record_.delete_material_map;
    common::tools::perf::make_shared<proto::MaterialDeleteReturnNotify>();
    v6 = std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 64));
    proto::MaterialDeleteReturnNotify::set_type(v6, type);
    v7 = std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 64));
    proto_delete_map = proto::MaterialDeleteReturnNotify::mutable_delete_material_map(v7);
    *(std::unordered_map<unsigned int,unsigned int>::iterator *)(v2 + 32) = std::unordered_map<unsigned int,unsigned int>::begin(&this->material_delete_return_record_.delete_material_map);
    while ( 1 )
    {
      __for_end._M_cur = std::unordered_map<unsigned int,unsigned int>::end(delete_material_map)._M_cur;
      if ( !std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(
              (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)(v2 + 32),
              &__for_end) )
        break;
      v8 = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator->((const std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)(v2 + 32));
      v9 = (uint32_t *)v8;
      if ( *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v8 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v8 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v8);
      }
      if ( type == PlayerItemComp::getMaterialDeleteReturnType(this, *v9) )
      {
        v10 = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator->((const std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)(v2 + 32));
        p_second = &v10->second;
        if ( *(_BYTE *)(((unsigned __int64)p_second >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)p_second & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_second >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(p_second);
        }
        second = v10->second;
        v13 = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator->((const std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)(v2 + 32));
        v14 = google::protobuf::Map<unsigned int,unsigned int>::operator[](
                proto_delete_map,
                (const google::protobuf::Map<unsigned int,unsigned int>::key_type *)v13);
        v15 = v14;
        v16 = *(_BYTE *)(((unsigned __int64)v14 >> 3) + 0x7FFF8000);
        if ( v16 != 0 && (char)(((unsigned __int8)v14 & 7) + 3) >= v16 )
        {
          LOBYTE(v13) = v16 != 0;
          __asan_report_store4(v14, v13, v14);
        }
        *v15 = second;
        v17._M_cur = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++(
                       (std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)(v2 + 32),
                       0)._M_cur;
        std::unordered_map<unsigned int,unsigned int>::erase(delete_material_map, v17);
      }
      else
      {
        std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++(
          (std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)(v2 + 32),
          0);
      }
    }
    if ( type )
      goto LABEL_34;
    v18 = std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 64));
    proto_return_map = proto::MaterialDeleteReturnNotify::mutable_return_item_map(v18);
    std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v2 + 128));
    __for_range = &this->material_delete_return_record_.return_item_map;
    *(std::unordered_map<unsigned int,unsigned int>::iterator *)(v2 + 32) = std::unordered_map<unsigned int,unsigned int>::begin(&this->material_delete_return_record_.return_item_map);
    __for_end._M_cur = std::unordered_map<unsigned int,unsigned int>::end(__for_range)._M_cur;
    while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(
              (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,unsigned int>,false> *)(v2 + 32),
              &__for_end) )
    {
      __in = std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*((const std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)(v2 + 32));
      item_id = std::get<0ul,unsigned int const,unsigned int>(__in);
      v19 = std::get<1ul,unsigned int const,unsigned int>(__in);
      num = v19;
      if ( *(_BYTE *)(((unsigned __int64)v19 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v19 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v19 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v19);
      }
      v20 = *num;
      v21 = item_id;
      v22 = google::protobuf::Map<unsigned int,unsigned int>::operator[](proto_return_map, item_id);
      v23 = v22;
      v24 = *(_BYTE *)(((unsigned __int64)v22 >> 3) + 0x7FFF8000);
      if ( v24 != 0 && (char)(((unsigned __int8)v22 & 7) + 3) >= v24 )
      {
        LOBYTE(v21) = v24 != 0;
        __asan_report_store4(v22, v21, v22);
      }
      *v23 = v20;
      *(_DWORD *)(v2 + 96) = 0;
      *(_DWORD *)(v2 + 100) = 0;
      *(_DWORD *)(v2 + 104) = 0;
      *(_DWORD *)(v2 + 108) = 0;
      if ( *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)item_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(item_id);
      }
      *(_DWORD *)(v2 + 96) = *item_id;
      if ( *(_BYTE *)(((unsigned __int64)num >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)num & 7) + 3) >= *(_BYTE *)(((unsigned __int64)num >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(num);
      }
      *(_DWORD *)(v2 + 100) = *num;
      std::vector<ItemParam>::emplace_back<ItemParam&>(
        (std::vector<ItemParam> *const)(v2 + 128),
        (ItemParam *)(v2 + 96),
        (ItemParam *)(v2 + 96));
      std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++((std::__detail::_Node_iterator<std::pair<unsigned int const,unsigned int>,false,false> *const)(v2 + 32));
    }
    ActionReason::ActionReason(
      (ActionReason *const)(v2 + 192),
      ACTION_REASON_MATERIAL_DELETE_RETURN,
      ITEM_LIMIT_UNLIMITED);
    if ( PlayerItemComp::addItemBatch(
           this,
           (const std::vector<ItemParam> *)(v2 + 128),
           (const ActionReason *)(v2 + 192),
           0LL) )
    {
      common::milog::MiLogStream::create(
        &v42,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "takeMaterialDeleteReturnItem",
        9854);
      v25 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(&v42, (const char (*)[31])off_2639BEC0);
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      operator<<(v25, this->player_);
      common::milog::MiLogStream::~MiLogStream(&v42);
      v26 = 0;
    }
    else
    {
      std::unordered_map<unsigned int,unsigned int>::clear(&this->material_delete_return_record_.return_item_map);
      v26 = 1;
    }
    std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v2 + 128));
    if ( v26 == 1 )
    {
LABEL_34:
      v27 = std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 64));
      v28 = proto::MaterialDeleteReturnNotify::delete_material_map(v27);
      if ( !google::protobuf::Map<unsigned int,unsigned int>::empty(v28)
        || (v29 = std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto::MaterialDeleteReturnNotify,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 64)),
            v30 = proto::MaterialDeleteReturnNotify::return_item_map(v29),
            !google::protobuf::Map<unsigned int,unsigned int>::empty(v30)) )
      {
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        player = this->player_;
        std::dynamic_pointer_cast<google::protobuf::Message const,proto::MaterialDeleteReturnNotify>((const std::shared_ptr<proto::MaterialDeleteReturnNotify> *)(v2 + 96));
        Player::sendMessage(player, (common::minet::ConstMessagePtr *)(v2 + 96), 0LL);
        std::shared_ptr<google::protobuf::Message const>::~shared_ptr((std::shared_ptr<const google::protobuf::Message> *const)(v2 + 96));
      }
    }
    std::shared_ptr<proto::MaterialDeleteReturnNotify>::~shared_ptr((std::shared_ptr<proto::MaterialDeleteReturnNotify> *const)(v2 + 64));
  }
  if ( v43 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8018) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 9867: range 0000000017D186D0-0000000017D1894E
_BOOL8 __fastcall PlayerItemComp::getMaterialDeleteReturnType(PlayerItemComp *const this, uint32_t material_id)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rcx
  _BOOL8 result; // rax
  const data::MaterialExcelConfig *material_config_ptr; // [rsp+18h] [rbp-98h]
  std::shared_ptr<Config> v11; // [rsp+20h] [rbp-90h] BYREF
  common::milog::MiLogStream v12; // [rsp+30h] [rbp-80h] BYREF
  char v13[96]; // [rsp+50h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v13;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 16 material_id:9866";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::getMaterialDeleteReturnType;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = material_id;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v11);
  v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v11);
  material_config_ptr = data::MaterialExcelConfigMgrBase::findMaterialExcelConfig(
                          &v5->design_config.txt_config_mgr.material_config_mgr,
                          *(_DWORD *)(v2 + 32));
  std::shared_ptr<Config>::~shared_ptr(&v11);
  if ( material_config_ptr )
  {
    if ( *(_BYTE *)(((unsigned __int64)&material_config_ptr->material_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)material_config_ptr + 76) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&material_config_ptr->material_type >> 3)
                                                                         + 0x7FFF8000) )
    {
      __asan_report_load4(&material_config_ptr->material_type);
    }
    result = material_config_ptr->material_type == MATERIAL_HOME_SEED;
  }
  else
  {
    common::milog::MiLogStream::create(
      &v12,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "getMaterialDeleteReturnType",
      9871);
    v6 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
           &v12,
           (const char (*)[45])"findMaterialExcelConfig failed, material_id:");
    v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, (const unsigned int *)(v2 + 32));
    v8 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v7, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v8, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v12);
    result = 0LL;
  }
  if ( v13 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 9883: range 0000000017D18950-0000000017D18E2F
int32_t __cdecl PlayerItemComp::logMaterialDeleteReturn(
        PlayerItemComp *const this,
        uint32_t material_id,
        uint32_t delete_num,
        const std::unordered_map<unsigned int,unsigned int> *return_item_map)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  _DWORD *v6; // r13
  PlayerBasicComp *BasicComp; // rax
  std::__shared_ptr_access<proto_log::PlayerLogBodyMaterialDeleteReturn,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  std::pair<unsigned int const,unsigned int> *v9; // rax
  std::pair<unsigned int const,unsigned int> *v10; // rdx
  std::__shared_ptr_access<proto_log::PlayerLogBodyMaterialDeleteReturn,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v11; // rax
  Player *player; // r14
  int32_t result; // eax
  std::string v14; // [rsp+0h] [rbp-130h]
  const std::unordered_map<unsigned int,unsigned int> *return_item_mapa; // [rsp+8h] [rbp-128h]
  google::protobuf::uint32 delete_numa; // [rsp+10h] [rbp-120h]
  google::protobuf::uint32 material_ida; // [rsp+14h] [rbp-11Ch]
  PlayerItemComp *thisa; // [rsp+18h] [rbp-118h]
  std::unordered_map<unsigned int,unsigned int>::const_iterator __for_begin; // [rsp+20h] [rbp-110h] BYREF
  std::unordered_map<unsigned int,unsigned int>::const_iterator __for_end; // [rsp+28h] [rbp-108h] BYREF
  proto_log::LogItemParam *delete_item_log; // [rsp+30h] [rbp-100h]
  const std::unordered_map<unsigned int,unsigned int> *__for_range; // [rsp+38h] [rbp-F8h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *item_id; // [rsp+40h] [rbp-F0h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *num; // [rsp+48h] [rbp-E8h]
  proto_log::LogItemParam *item; // [rsp+50h] [rbp-E0h]
  std::pair<unsigned int const,unsigned int> __in; // [rsp+58h] [rbp-D8h] BYREF
  std::shared_ptr<google::protobuf::Message> p_body_ptr; // [rsp+60h] [rbp-D0h] BYREF
  std::shared_ptr<google::protobuf::Message> p_body_ext_ptr; // [rsp+70h] [rbp-C0h] BYREF
  std::string v29; // [rsp+80h] [rbp-B0h] BYREF
  char v30[144]; // [rsp+A0h] [rbp-90h] BYREF

  *(&v14._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  HIDWORD(v14._anon_0._M_allocated_capacity) = material_id;
  *(_DWORD *)v14._anon_0._M_local_buf = delete_num;
  v14._M_string_length = (std::string::size_type)return_item_map;
  v4 = (unsigned __int64)v30;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(96LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "2 48 1 11 holder:9884 64 16 12 log_ptr:9886";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::logMaterialDeleteReturn;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234753551;
  v6[536862722] = -202178560;
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  BasicComp = Player::getBasicComp(this->player_);
  PlayerBasicComp::getNextTransNo[abi:cxx11](&v29, BasicComp);
  StatLogUtils::ContextHolder::ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 48), 0x3F0u, v14);
  std::string::~string(&v29);
  common::tools::perf::make_shared<proto_log::PlayerLogBodyMaterialDeleteReturn>();
  v8 = std::__shared_ptr_access<proto_log::PlayerLogBodyMaterialDeleteReturn,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyMaterialDeleteReturn,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
  delete_item_log = proto_log::PlayerLogBodyMaterialDeleteReturn::add_delete_material_list(v8);
  proto_log::LogItemParam::set_item_id(delete_item_log, material_ida);
  proto_log::LogItemParam::set_count(delete_item_log, delete_numa);
  __for_range = return_item_mapa;
  __for_begin._M_cur = std::unordered_map<unsigned int,unsigned int>::begin(return_item_mapa)._M_cur;
  __for_end._M_cur = std::unordered_map<unsigned int,unsigned int>::end(return_item_mapa)._M_cur;
  while ( std::__detail::operator!=<std::pair<unsigned int const,unsigned int>,false>(&__for_begin, &__for_end) )
  {
    v9 = (std::pair<unsigned int const,unsigned int> *)std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator*(&__for_begin);
    v10 = v9;
    if ( ((unsigned __int8)v9 & 7) >= *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000)
      && *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000) != 0
      || *(_BYTE *)((((unsigned __int64)&v9->second + 3) >> 3) + 0x7FFF8000) != 0
      && (((unsigned __int8)v9 + 7) & 7) >= *(_BYTE *)((((unsigned __int64)&v9->second + 3) >> 3) + 0x7FFF8000) )
    {
      __asan_report_load_n(v9, 8LL);
    }
    __in = *v10;
    item_id = std::get<0ul,unsigned int const,unsigned int>(&__in);
    num = std::get<1ul,unsigned int const,unsigned int>(&__in);
    v11 = std::__shared_ptr_access<proto_log::PlayerLogBodyMaterialDeleteReturn,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<proto_log::PlayerLogBodyMaterialDeleteReturn,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v4 + 64));
    item = proto_log::PlayerLogBodyMaterialDeleteReturn::add_return_item_list(v11);
    if ( *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)item_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_id >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(item_id);
    }
    proto_log::LogItemParam::set_item_id(item, *item_id);
    if ( *(_BYTE *)(((unsigned __int64)num >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)num & 7) + 3) >= *(_BYTE *)(((unsigned __int64)num >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(num);
    }
    proto_log::LogItemParam::set_count(item, *num);
    std::__detail::_Node_const_iterator<std::pair<unsigned int const,unsigned int>,false,false>::operator++(&__for_begin);
  }
  if ( *(_BYTE *)(((unsigned __int64)&thisa->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  player = thisa->player_;
  std::shared_ptr<google::protobuf::Message>::shared_ptr(&p_body_ext_ptr, 0LL);
  std::shared_ptr<google::protobuf::Message>::shared_ptr<proto_log::PlayerLogBodyMaterialDeleteReturn,void>(
    &p_body_ptr,
    (const std::shared_ptr<proto_log::PlayerLogBodyMaterialDeleteReturn> *)(v4 + 64));
  Player::printStatLog(player, &p_body_ptr, &p_body_ext_ptr, 0xEu);
  std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ptr);
  std::shared_ptr<google::protobuf::Message>::~shared_ptr(&p_body_ext_ptr);
  std::shared_ptr<proto_log::PlayerLogBodyMaterialDeleteReturn>::~shared_ptr((std::shared_ptr<proto_log::PlayerLogBodyMaterialDeleteReturn> *const)(v4 + 64));
  StatLogUtils::ContextHolder::~ContextHolder((StatLogUtils::ContextHolder *const)(v4 + 48));
  result = 0;
  if ( v30 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 9902: range 0000000017D18E30-0000000017D19094
void __fastcall PlayerItemComp::addWeaponLevelupNum(PlayerItemComp *const this, uint32_t old_level, uint32_t new_level)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r13
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rcx
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v9; // rax
  common::milog::MiLogStream v11; // [rsp+10h] [rbp-A0h] BYREF
  char v12[128]; // [rsp+30h] [rbp-80h] BYREF

  v3 = (unsigned __int64)v12;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "2 48 4 10 level:9908 64 4 14 new_level:9901";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::addWeaponLevelupNum;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -202116348;
  *(_DWORD *)(v3 + 64) = new_level;
  if ( *(_DWORD *)(v3 + 64) <= 0x64u )
  {
    for ( *(_DWORD *)(v3 + 48) = old_level + 1; *(_DWORD *)(v3 + 48) <= *(_DWORD *)(v3 + 64); ++*(_DWORD *)(v3 + 48) )
    {
      v9 = std::unordered_map<unsigned int,unsigned int>::operator[](
             &this->weapon_levelup_num_map_,
             (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v3 + 48));
      if ( *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v9 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v9);
      }
      ++*v9;
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v11,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "addWeaponLevelupNum",
      9905);
    v6 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(&v11, (const char (*)[12])" new_level:");
    v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, (const unsigned int *)(v3 + 64));
    v8 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v7, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v8, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v11);
  }
  if ( v12 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 9915: range 0000000017D19096-0000000017D1916C
uint32_t __fastcall PlayerItemComp::getWeaponLevelupNum(const PlayerItemComp *const this, uint32_t level)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  uint32_t result; // eax
  char v6[96]; // [rsp+10h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v6;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 10 level:9914";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::getWeaponLevelupNum;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = level;
  result = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
             &this->weapon_levelup_num_map_,
             (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v2 + 32),
             0);
  if ( v6 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 9920: range 0000000017D1916E-0000000017D193D2
void __fastcall PlayerItemComp::addWeaponPromoteLevelupNum(
        PlayerItemComp *const this,
        uint32_t old_promote_level,
        uint32_t new_promote_level)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r13
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rcx
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v9; // rax
  common::milog::MiLogStream v11; // [rsp+10h] [rbp-A0h] BYREF
  char v12[128]; // [rsp+30h] [rbp-80h] BYREF

  v3 = (unsigned __int64)v12;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "2 48 4 18 promote_level:9926 64 4 22 new_promote_level:9919";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::addWeaponPromoteLevelupNum;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -202116348;
  *(_DWORD *)(v3 + 64) = new_promote_level;
  if ( *(_DWORD *)(v3 + 64) <= 0xAu )
  {
    for ( *(_DWORD *)(v3 + 48) = old_promote_level + 1; *(_DWORD *)(v3 + 48) <= *(_DWORD *)(v3 + 64); ++*(_DWORD *)(v3 + 48) )
    {
      v9 = std::unordered_map<unsigned int,unsigned int>::operator[](
             &this->weapon_promote_levelup_num_map_,
             (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v3 + 48));
      if ( *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v9 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v9 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v9);
      }
      ++*v9;
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v11,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "addWeaponPromoteLevelupNum",
      9923);
    v6 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(
           &v11,
           (const char (*)[20])" new_promote_level:");
    v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, (const unsigned int *)(v3 + 64));
    v8 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v7, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v8, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v11);
  }
  if ( v12 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 9933: range 0000000017D193D4-0000000017D194AA
uint32_t __fastcall PlayerItemComp::getWeaponPromoteLevelupNum(
        const PlayerItemComp *const this,
        uint32_t promote_level)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  uint32_t result; // eax
  char v6[96]; // [rsp+10h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v6;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 18 promote_level:9932";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::getWeaponPromoteLevelupNum;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = promote_level;
  result = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
             &this->weapon_promote_levelup_num_map_,
             (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v2 + 32),
             0);
  if ( v6 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 9938: range 0000000017D194AC-0000000017D19756
void __fastcall PlayerItemComp::addReliquaryLevelupNum(
        PlayerItemComp *const this,
        uint32_t rank_level,
        uint32_t old_level,
        uint32_t new_level)
{
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // r13
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rcx
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v12; // rax
  std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::mapped_type *levelup_num_map; // [rsp+28h] [rbp-A8h]
  common::milog::MiLogStream v16; // [rsp+30h] [rbp-A0h] BYREF
  char v17[128]; // [rsp+50h] [rbp-80h] BYREF

  v4 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_1(96LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "3 32 4 10 level:9945 48 4 15 rank_level:9937 64 4 14 new_level:9937";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::addReliquaryLevelupNum;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556924;
  v6[536862722] = -202116348;
  *(_DWORD *)(v4 + 48) = rank_level;
  *(_DWORD *)(v4 + 64) = new_level;
  if ( *(_DWORD *)(v4 + 48) <= 0xAu && *(_DWORD *)(v4 + 64) <= 0x64u )
  {
    levelup_num_map = std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::operator[](
                        &this->reliquary_levelup_num_map_,
                        (const std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::key_type *)(v4 + 48));
    for ( *(_DWORD *)(v4 + 32) = old_level + 1; *(_DWORD *)(v4 + 32) <= *(_DWORD *)(v4 + 64); ++*(_DWORD *)(v4 + 32) )
    {
      v12 = std::unordered_map<unsigned int,unsigned int>::operator[](
              levelup_num_map,
              (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v4 + 32));
      if ( *(_BYTE *)(((unsigned __int64)v12 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v12 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v12 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v12);
      }
      ++*v12;
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v16,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "addReliquaryLevelupNum",
      9941);
    v7 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(&v16, (const char (*)[12])"rank_level:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v4 + 48));
    v9 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v8, (const char (*)[12])" new_level:");
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 64));
    v11 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v10, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v11, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v16);
  }
  if ( v17 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 9952: range 0000000017D19758-0000000017D198D4
uint32_t __fastcall PlayerItemComp::getReliquaryLevelupNum(
        const PlayerItemComp *const this,
        uint32_t rank_level,
        uint32_t level)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  uint32_t result; // eax
  std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int> >,false,false>::pointer v7; // rax
  std::__detail::_Node_iterator_base<std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int> >,false> __y; // [rsp+18h] [rbp-88h] BYREF
  char v10[128]; // [rsp+20h] [rbp-80h] BYREF

  v3 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "3 32 4 15 rank_level:9951 48 4 10 level:9951 64 8 9 iter:9953";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::getReliquaryLevelupNum;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556924;
  v5[536862722] = -202116352;
  *(_DWORD *)(v3 + 32) = rank_level;
  *(_DWORD *)(v3 + 48) = level;
  *(std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::const_iterator *)(v3 + 64) = std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::find(&this->reliquary_levelup_num_map_, (const std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::key_type *)(v3 + 32));
  __y._M_cur = std::unordered_map<unsigned int,std::unordered_map<unsigned int,unsigned int>>::end(&this->reliquary_levelup_num_map_)._M_cur;
  if ( std::__detail::operator==<std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int>>,false>(
         (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int> >,false> *)(v3 + 64),
         &__y) )
  {
    result = 0;
  }
  else
  {
    v7 = std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int>>,false,false>::operator->((const std::__detail::_Node_const_iterator<std::pair<unsigned int const,std::unordered_map<unsigned int,unsigned int> >,false,false> *const)(v3 + 64));
    result = common::tools::MiscUtils::findMapWithDefaultValue<std::unordered_map<unsigned int,unsigned int>>(
               &v7->second,
               (const std::unordered_map<unsigned int,unsigned int>::key_type *)(v3 + 48),
               0);
  }
  if ( v10 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 9963: range 0000000017D198D6-0000000017D19E62
PlayerItemComp *__fastcall PlayerItemComp::createItem(
        PlayerItemComp *const this,
        __int64 item_type,
        uint32_t item_id,
        uint64_t guid,
        uint64_t a5)
{
  unsigned __int64 v5; // r12
  __int64 v6; // rax
  _DWORD *v7; // r13
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  PlayerBasicComp *BasicComp; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  Item *v18; // rax
  int v21; // [rsp+8h] [rbp-108h]
  std::shared_ptr<Material> __r; // [rsp+20h] [rbp-F0h] BYREF
  std::shared_ptr<Material> v24; // [rsp+30h] [rbp-E0h] BYREF
  std::shared_ptr<Reliquary> v25; // [rsp+40h] [rbp-D0h] BYREF
  std::shared_ptr<Weapon> v26; // [rsp+50h] [rbp-C0h] BYREF
  std::shared_ptr<Furniture> v27; // [rsp+60h] [rbp-B0h] BYREF
  common::milog::MiLogStream v28; // [rsp+70h] [rbp-A0h] BYREF
  char v29[128]; // [rsp+90h] [rbp-80h] BYREF

  v21 = guid;
  v5 = (unsigned __int64)v29;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_1(96LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "3 32 4 14 item_type:9962 48 4 12 item_id:9962 64 16 13 item_ptr:9964";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::createItem;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556924;
  v7[536862722] = -202178560;
  *(_DWORD *)(v5 + 32) = item_id;
  *(_DWORD *)(v5 + 48) = v21;
  *(_QWORD *)(v5 + 64) = 0LL;
  *(_QWORD *)(v5 + 72) = 0LL;
  switch ( *(_DWORD *)(v5 + 32) )
  {
    case 1:
      common::tools::perf::make_shared<Material,unsigned int &,unsigned int &>(
        (unsigned int *)&__r,
        (unsigned int *)(v5 + 32),
        (unsigned int *)(v5 + 48),
        (unsigned int *)(v5 + 32));
      std::shared_ptr<Item>::operator=<Material>((std::shared_ptr<Item> *const)(v5 + 64), &__r);
      std::shared_ptr<Material>::~shared_ptr(&__r);
      break;
    case 2:
      common::tools::perf::make_shared<Material,unsigned int &,unsigned int &>(
        (unsigned int *)&v24,
        (unsigned int *)(v5 + 32),
        (unsigned int *)(v5 + 48),
        (unsigned int *)(v5 + 32));
      std::shared_ptr<Item>::operator=<Material>((std::shared_ptr<Item> *const)(v5 + 64), &v24);
      std::shared_ptr<Material>::~shared_ptr(&v24);
      break;
    case 3:
      common::tools::perf::make_shared<Reliquary,unsigned int &,unsigned int &>(
        (unsigned int *)&v25,
        (unsigned int *)(v5 + 32),
        (unsigned int *)(v5 + 48),
        (unsigned int *)(v5 + 32));
      std::shared_ptr<Item>::operator=<Reliquary>((std::shared_ptr<Item> *const)(v5 + 64), &v25);
      std::shared_ptr<Reliquary>::~shared_ptr(&v25);
      break;
    case 4:
      common::tools::perf::make_shared<Weapon,unsigned int &,unsigned int &>(
        (unsigned int *)&v26,
        (unsigned int *)(v5 + 32),
        (unsigned int *)(v5 + 48),
        (unsigned int *)(v5 + 32));
      std::shared_ptr<Item>::operator=<Weapon>((std::shared_ptr<Item> *const)(v5 + 64), &v26);
      std::shared_ptr<Weapon>::~shared_ptr(&v26);
      break;
    case 6:
      common::tools::perf::make_shared<Furniture,unsigned int &,unsigned int &>(
        (unsigned int *)&v27,
        (unsigned int *)(v5 + 32),
        (unsigned int *)(v5 + 48),
        (unsigned int *)(v5 + 32));
      std::shared_ptr<Item>::operator=<Furniture>((std::shared_ptr<Item> *const)(v5 + 64), &v27);
      std::shared_ptr<Furniture>::~shared_ptr(&v27);
      break;
    default:
      common::milog::MiLogStream::create(
        &v28,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "createItem",
        9995);
      v8 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(
             &v28,
             (const char (*)[18])"unkown item type:");
      v9 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v8, (const unsigned int *)(v5 + 32));
      v10 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v9, (const char (*)[10])" item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v10, (const unsigned int *)(v5 + 48));
      common::milog::MiLogStream::~MiLogStream(&v28);
      break;
  }
  if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v5 + 64), 0LL) )
  {
    common::milog::MiLogStream::create(
      &v28,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "createItem",
      10002);
    v11 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
            &v28,
            (const char (*)[30])"createItem failed, item_type:");
    v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v5 + 32));
    v13 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v12, (const char (*)[10])" item_id:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v5 + 48));
    common::milog::MiLogStream::~MiLogStream(&v28);
    std::shared_ptr<Item>::shared_ptr((std::shared_ptr<Item> *const)this, 0LL);
  }
  else
  {
    if ( !a5 )
    {
      if ( *(_BYTE *)(((unsigned __int64)(item_type + 24) >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      BasicComp = Player::getBasicComp(*(Player *const *)(item_type + 24));
      a5 = PlayerBasicComp::genGuid(BasicComp, GUID_ITEM);
    }
    if ( a5 )
    {
      v18 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v5 + 64));
      Item::setGuid(v18, a5);
      std::shared_ptr<Item>::shared_ptr((std::shared_ptr<Item> *const)this, (std::shared_ptr<Item> *)(v5 + 64));
    }
    else
    {
      common::milog::MiLogStream::create(
        &v28,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "createItem",
        10012);
      v15 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
              &v28,
              (const char (*)[27])"genGuid failed, item_type:");
      v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, (const unsigned int *)(v5 + 32));
      v17 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v16, (const char (*)[10])" item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, (const unsigned int *)(v5 + 48));
      common::milog::MiLogStream::~MiLogStream(&v28);
      std::shared_ptr<Item>::shared_ptr((std::shared_ptr<Item> *const)this, 0LL);
    }
  }
  std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v5 + 64));
  if ( v29 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v5 >> 3) + 0x7FFF8008) = -168430091;
  }
  return this;
};

// Line 10022: range 0000000017D19E64-0000000017D1A117
std::vector<std::shared_ptr<Item>> *__cdecl PlayerItemComp::createItem(
        std::vector<std::shared_ptr<Item>> *retstr,
        PlayerItemComp *const this,
        const ItemParam *item_param)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  std::initializer_list<ItemParam>::size_type v6; // rdx
  std::allocator<ItemParam> __a; // [rsp+2Fh] [rbp-A1h] BYREF
  std::initializer_list<ItemParam> __l; // [rsp+30h] [rbp-A0h] BYREF
  char v11[144]; // [rsp+40h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v11;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 24 20 item_param_vec:10023";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::createItem;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -218103808;
  v5[536862722] = -202116109;
  if ( ((unsigned __int8)item_param & 7) >= *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000)
    && *(_BYTE *)(((unsigned __int64)item_param >> 3) + 0x7FFF8000) != 0
    || *(_BYTE *)((((unsigned __int64)&item_param->promote_level + 3) >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)item_param + 15) & 7) >= *(_BYTE *)((((unsigned __int64)&item_param->promote_level + 3) >> 3)
                                                            + 0x7FFF8000) )
  {
    __asan_report_load_n(item_param, 16LL);
  }
  v6 = *(_QWORD *)&item_param->level;
  __l._M_array = *(std::initializer_list<ItemParam>::iterator *)&item_param->item_id;
  __l._M_len = v6;
  std::allocator<ItemParam>::allocator(&__a);
  std::vector<ItemParam>::vector(
    (std::vector<ItemParam> *const)(v3 + 32),
    (std::initializer_list<ItemParam>)__PAIR128__(1LL, &__l),
    &__a);
  std::allocator<ItemParam>::~allocator(&__a);
  if ( *(char *)(((unsigned __int64)retstr >> 3) + 0x7FFF8000) < 0
    || *(_BYTE *)((((unsigned __int64)&retstr->_M_impl._M_end_of_storage + 7) >> 3) + 0x7FFF8000) != 0
    && (((unsigned __int8)retstr + 23) & 7) >= *(_BYTE *)((((unsigned __int64)&retstr->_M_impl._M_end_of_storage + 7) >> 3)
                                                        + 0x7FFF8000) )
  {
    __asan_report_store_n(retstr, 24LL);
  }
  PlayerItemComp::createItemBatch(retstr, this, (const std::vector<ItemParam> *)(v3 + 32));
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 32));
  if ( v11 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return retstr;
};

// Line 10029: range 0000000017D1A118-0000000017D1B658
std::vector<std::shared_ptr<Item>> *__cdecl PlayerItemComp::createItemBatch(
        std::vector<std::shared_ptr<Item>> *retstr,
        PlayerItemComp *const this,
        const std::vector<ItemParam> *item_param_vec)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  const ItemParam *v6; // rax
  common::milog::MiLogStream *v7; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  common::milog::MiLogStream *v9; // rax
  unsigned int v10; // eax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  _BOOL4 v16; // r14d
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  int v22; // r14d
  Material *v23; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v24; // rax
  unsigned __int64 v25; // rdx
  unsigned int (__fastcall *v26)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, Player *, __int64); // r8
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // rax
  common::milog::MiLogStream *v30; // rax
  common::milog::MiLogStream *v31; // rax
  ConstValueExcelConfigMgr *p_const_value_config_mgr; // rcx
  common::milog::MiLogStream *v33; // rax
  common::milog::MiLogStream *v34; // rax
  common::milog::MiLogStream *v35; // rax
  common::milog::MiLogStream *v36; // rax
  common::milog::MiLogStream *v37; // rax
  common::milog::MiLogStream *v38; // rax
  common::milog::MiLogStream *v39; // rax
  common::milog::MiLogStream *v40; // rax
  common::milog::MiLogStream *v41; // r14
  common::milog::MiLogStream *v42; // rax
  common::milog::MiLogStream *v43; // rax
  common::milog::MiLogStream *v44; // rax
  common::milog::MiLogStream *v45; // rax
  common::milog::MiLogStream *v46; // rax
  int v47; // r14d
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v48; // rax
  unsigned __int64 v49; // rdx
  unsigned int (__fastcall *v50)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, Player *, __int64); // r8
  common::milog::MiLogStream *v51; // rax
  common::milog::MiLogStream *v52; // rax
  common::milog::MiLogStream *v53; // rax
  common::milog::MiLogStream *v54; // rax
  common::milog::MiLogStream *v55; // rax
  Weapon *v56; // rcx
  Weapon *v57; // rcx
  common::milog::MiLogStream *v58; // rax
  common::milog::MiLogStream *v59; // rax
  common::milog::MiLogStream *v60; // rax
  common::milog::MiLogStream *v61; // rax
  common::milog::MiLogStream *v62; // rax
  _BOOL4 v63; // r14d
  common::milog::MiLogStream *v64; // rax
  common::milog::MiLogStream *v65; // rax
  common::milog::MiLogStream *v66; // rax
  common::milog::MiLogStream *v67; // rax
  common::milog::MiLogStream *v68; // rax
  int v69; // r14d
  Furniture *v70; // rax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v71; // rax
  unsigned __int64 v72; // rdx
  unsigned int (__fastcall *v73)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, Player *, __int64); // r8
  common::milog::MiLogStream *v74; // rax
  common::milog::MiLogStream *v75; // rax
  common::milog::MiLogStream *v76; // rax
  common::milog::MiLogStream *v77; // rax
  common::milog::MiLogStream *v78; // rax
  common::milog::MiLogStream *v79; // rax
  common::milog::MiLogStream *v80; // rax
  common::milog::MiLogStream *v81; // rax
  unsigned int val; // [rsp+2Ch] [rbp-204h] BYREF
  unsigned int Uid; // [rsp+30h] [rbp-200h] BYREF
  uint32_t idx; // [rsp+34h] [rbp-1FCh]
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+38h] [rbp-1F8h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+40h] [rbp-1F0h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+48h] [rbp-1E8h]
  const ItemParam *item_param; // [rsp+50h] [rbp-1E0h]
  const data::ItemConfig *item_config_ptr; // [rsp+58h] [rbp-1D8h]
  std::shared_ptr<Config> v92; // [rsp+60h] [rbp-1D0h] BYREF
  std::shared_ptr<Config> v93; // [rsp+70h] [rbp-1C0h] BYREF
  common::milog::MiLogStream v94; // [rsp+80h] [rbp-1B0h] BYREF
  common::milog::MiLogStream v95; // [rsp+A0h] [rbp-190h] BYREF
  common::milog::MiLogStream v96; // [rsp+C0h] [rbp-170h] BYREF
  common::milog::MiLogStream v97; // [rsp+E0h] [rbp-150h] BYREF
  char v98[304]; // [rsp+100h] [rbp-130h] BYREF

  v3 = (unsigned __int64)v98;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(256LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "9 32 4 13 item_id:10034 48 4 11 count:10035 64 4 15 item_type:10051 80 4 16 hard_limit:10093 96 "
                        "16 14 item_ptr:10058 128 16 18 material_ptr:10067 160 16 14 item_ptr:10102 192 16 14 item_ptr:10"
                        "141 224 16 19 furniture_ptr:10150";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::createItemBatch;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556924;
  v5[536862722] = -234556924;
  v5[536862723] = -219021312;
  v5[536862724] = -219021312;
  v5[536862725] = -219021312;
  v5[536862726] = -219021312;
  v5[536862727] = -202178560;
  std::vector<std::shared_ptr<Item>>::vector(retstr);
  __for_range = item_param_vec;
  __for_begin._M_current = std::vector<ItemParam>::begin(item_param_vec)._M_current;
  __for_end._M_current = std::vector<ItemParam>::end(item_param_vec)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
  {
    v6 = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
    item_param = v6;
    if ( *(_BYTE *)(((unsigned __int64)v6 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v6 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v6 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v6);
    }
    *(_DWORD *)(v3 + 32) = item_param->item_id;
    if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&item_param->count);
    }
    *(_DWORD *)(v3 + 48) = item_param->count;
    if ( !*(_DWORD *)(v3 + 48) )
    {
      common::milog::MiLogStream::create(
        &v94,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "createItemBatch",
        10039);
      v7 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
             &v94,
             (const char (*)[40])"createItem failed, count is 0, item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v3 + 32));
      common::milog::MiLogStream::~MiLogStream(&v94);
      std::vector<std::shared_ptr<Item>>::clear(retstr);
      break;
    }
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v92);
    v8 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v92);
    item_config_ptr = ItemExcelConfigMgr::findItemConfig(
                        &v8->design_config.txt_config_mgr.item_config_mgr,
                        *(_DWORD *)(v3 + 32));
    std::shared_ptr<Config>::~shared_ptr(&v92);
    if ( !item_config_ptr )
    {
      common::milog::MiLogStream::create(
        &v95,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "createItemBatch",
        10047);
      v9 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
             &v95,
             (const char (*)[35])"findItemBaseConfig fails, item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v3 + 32));
      common::milog::MiLogStream::~MiLogStream(&v95);
      std::vector<std::shared_ptr<Item>>::clear(retstr);
      break;
    }
    if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                     + 0x7FFF8000) )
    {
      __asan_report_load4(&item_config_ptr->item_type);
    }
    *(_DWORD *)(v3 + 64) = item_config_ptr->item_type;
    v10 = *(_DWORD *)(v3 + 64);
    if ( v10 == 6 )
    {
      PlayerItemComp::createItem(
        (PlayerItemComp *const)(v3 + 192),
        (__int64)this,
        *(_DWORD *)(v3 + 64),
        *(unsigned int *)(v3 + 32),
        0LL);
      if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v3 + 192), 0LL) )
      {
        common::milog::MiLogStream::create(
          &v97,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "createItemBatch",
          10144);
        v58 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                &v97,
                (const char (*)[30])"createItem failed, item_type:");
        v59 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v58,
                (const unsigned int *)(v3 + 64));
        v60 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v59, (const char (*)[10])" item_id:");
        v61 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v60,
                (const unsigned int *)(v3 + 32));
        v62 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v61, (const char (*)[7])"count:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v62, (const unsigned int *)(v3 + 48));
        common::milog::MiLogStream::~MiLogStream(&v97);
        std::vector<std::shared_ptr<Item>>::clear(retstr);
        v63 = 0;
      }
      else
      {
        std::dynamic_pointer_cast<Furniture,Item>((const std::shared_ptr<Item> *)(v3 + 224));
        if ( std::operator==<Furniture>((const std::shared_ptr<Furniture> *)(v3 + 224), 0LL) )
        {
          common::milog::MiLogStream::create(
            &v97,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "createItemBatch",
            10153);
          v64 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                  &v97,
                  (const char (*)[40])"dynamic_pointer_cast failed, item_type:");
          v65 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v64,
                  (const unsigned int *)(v3 + 64));
          v66 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v65, (const char (*)[10])" item_id:");
          v67 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v66,
                  (const unsigned int *)(v3 + 32));
          v68 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v67, (const char (*)[8])" count:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v68, (const unsigned int *)(v3 + 48));
          common::milog::MiLogStream::~MiLogStream(&v97);
          std::vector<std::shared_ptr<Item>>::clear(retstr);
          v69 = 0;
        }
        else
        {
          v70 = std::__shared_ptr_access<Furniture,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Furniture,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 224));
          Furniture::setCount(v70, *(_DWORD *)(v3 + 48));
          v71 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 192));
          if ( *(_BYTE *)(((unsigned __int64)v71 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v72 = (unsigned __int64)(v71->_vptr_Item + 6);
          if ( *(_BYTE *)((v72 >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          v73 = *(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, Player *, __int64))v72;
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          if ( v73(v71, this->player_, 1LL) )
          {
            common::milog::MiLogStream::create(
              &v97,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "createItemBatch",
              10163);
            v74 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                    &v97,
                    (const char (*)[29])"item init failed, item_type:");
            v75 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v74,
                    (const unsigned int *)(v3 + 64));
            v76 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v75, (const char (*)[10])" item_id:");
            v77 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v76,
                    (const unsigned int *)(v3 + 32));
            v78 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v77, (const char (*)[8])" count:");
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v78, (const unsigned int *)(v3 + 48));
            common::milog::MiLogStream::~MiLogStream(&v97);
            std::vector<std::shared_ptr<Item>>::clear(retstr);
            v69 = 0;
          }
          else
          {
            std::vector<std::shared_ptr<Item>>::emplace_back<std::shared_ptr<Item>&>(
              retstr,
              (std::shared_ptr<Item> *)(v3 + 192),
              (std::shared_ptr<Item> *)(v3 + 192));
            v69 = 1;
          }
        }
        std::shared_ptr<Furniture>::~shared_ptr((std::shared_ptr<Furniture> *const)(v3 + 224));
        v63 = v69 == 1;
      }
      std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v3 + 192));
      if ( !v63 )
        break;
    }
    else
    {
      if ( v10 > 6 )
        goto LABEL_91;
      if ( v10 > 2 )
      {
        if ( v10 - 3 > 1 )
        {
LABEL_91:
          common::milog::MiLogStream::create(
            &v97,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "createItemBatch",
            10174);
          v79 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                  &v97,
                  (const char (*)[30])"createItem failed, item_type:");
          v80 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v79,
                  (const unsigned int *)(v3 + 64));
          v81 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v80, (const char (*)[10])" item_id:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v81, (const unsigned int *)(v3 + 32));
          common::milog::MiLogStream::~MiLogStream(&v97);
          std::vector<std::shared_ptr<Item>>::clear(retstr);
          break;
        }
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)&v93);
        p_const_value_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v93)->design_config.txt_config_mgr.const_value_config_mgr;
        if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                         + 0x7FFF8000) )
        {
          __asan_report_load4(&item_config_ptr->item_type);
        }
        *(_DWORD *)(v3 + 80) = ConstValueExcelConfigMgr::getItemHardLimitByItemType(
                                 p_const_value_config_mgr,
                                 item_config_ptr->item_type);
        std::shared_ptr<Config>::~shared_ptr(&v93);
        if ( *(_DWORD *)(v3 + 48) > *(_DWORD *)(v3 + 80) )
        {
          common::milog::MiLogStream::create(
            &v96,
            &common::milog::MiLogDefault::default_log_obj_,
            4u,
            "./src/player/item/player_item_comp.cpp",
            "createItemBatch",
            10096);
          v33 = common::milog::MiLogStream::operator<<<char [42],(char *[42])0>(
                  &v96,
                  (const char (*)[42])"cannot create too many equips, item_type:");
          v34 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v33,
                  (const unsigned int *)(v3 + 64));
          v35 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v34, (const char (*)[8])" count:");
          v36 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v35,
                  (const unsigned int *)(v3 + 48));
          v37 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v36, (const char (*)[13])" hard_limit:");
          v38 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v37,
                  (const unsigned int *)(v3 + 80));
          v39 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(
                  v38,
                  (const char (*)[16])" going to lost ");
          val = *(_DWORD *)(v3 + 48) - *(_DWORD *)(v3 + 80);
          v40 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v39, &val);
          v41 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(
                  v40,
                  (const char (*)[14])" equips. uid:");
          if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
            __asan_report_load8();
          Uid = Player::getUid(this->player_);
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v41, &Uid);
          common::milog::MiLogStream::~MiLogStream(&v96);
          *(_DWORD *)(v3 + 48) = *(_DWORD *)(v3 + 80);
        }
        for ( idx = 0; idx < *(_DWORD *)(v3 + 48); ++idx )
        {
          PlayerItemComp::createItem(
            (PlayerItemComp *const)(v3 + 160),
            (__int64)this,
            *(_DWORD *)(v3 + 64),
            *(unsigned int *)(v3 + 32),
            0LL);
          if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v3 + 160), 0LL) )
          {
            common::milog::MiLogStream::create(
              &v97,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "createItemBatch",
              10105);
            v42 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                    &v97,
                    (const char (*)[30])"createItem failed, item_type:");
            v43 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v42,
                    (const unsigned int *)(v3 + 64));
            v44 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v43, (const char (*)[10])" item_id:");
            v45 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v44,
                    (const unsigned int *)(v3 + 32));
            v46 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v45, (const char (*)[8])" count:");
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v46, (const unsigned int *)(v3 + 48));
            common::milog::MiLogStream::~MiLogStream(&v97);
            std::vector<std::shared_ptr<Item>>::clear(retstr);
            v47 = 0;
          }
          else
          {
            v48 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 160));
            if ( *(_BYTE *)(((unsigned __int64)v48 >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            v49 = (unsigned __int64)(v48->_vptr_Item + 6);
            if ( *(_BYTE *)((v49 >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            v50 = *(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, Player *, __int64))v49;
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            if ( v50(v48, this->player_, 1LL) )
            {
              common::milog::MiLogStream::create(
                &v97,
                &common::milog::MiLogDefault::default_log_obj_,
                3u,
                "./src/player/item/player_item_comp.cpp",
                "createItemBatch",
                10113);
              v51 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                      &v97,
                      (const char (*)[29])"item init failed, item_type:");
              v52 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                      v51,
                      (const unsigned int *)(v3 + 64));
              v53 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(
                      v52,
                      (const char (*)[10])" item_id:");
              v54 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                      v53,
                      (const unsigned int *)(v3 + 32));
              v55 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v54, (const char (*)[8])" count:");
              common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v55,
                (const unsigned int *)(v3 + 48));
              common::milog::MiLogStream::~MiLogStream(&v97);
              std::vector<std::shared_ptr<Item>>::clear(retstr);
              v47 = 0;
            }
            else
            {
              if ( *(_DWORD *)(v3 + 64) == 4 )
              {
                std::dynamic_pointer_cast<Weapon,Item>((const std::shared_ptr<Item> *)(v3 + 224));
                if ( std::operator!=<Weapon>(0LL, (const std::shared_ptr<Weapon> *)(v3 + 224)) )
                {
                  if ( *(_BYTE *)(((unsigned __int64)&item_param->level >> 3) + 0x7FFF8000) != 0
                    && (char)((((_BYTE)item_param + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->level >> 3)
                                                                             + 0x7FFF8000) )
                  {
                    __asan_report_load4(&item_param->level);
                  }
                  if ( item_param->level )
                  {
                    v56 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 224));
                    if ( *(_BYTE *)(((unsigned __int64)&item_param->level >> 3) + 0x7FFF8000) != 0
                      && (char)((((_BYTE)item_param + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->level >> 3)
                                                                               + 0x7FFF8000) )
                    {
                      __asan_report_load4(&item_param->level);
                    }
                    Weapon::setLevel(v56, item_param->level);
                  }
                  if ( *(_BYTE *)(((unsigned __int64)&item_param->promote_level >> 3) + 0x7FFF8000) != 0
                    && (char)((((_BYTE)item_param + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->promote_level >> 3)
                                                                              + 0x7FFF8000) )
                  {
                    __asan_report_load4(&item_param->promote_level);
                  }
                  if ( item_param->promote_level )
                  {
                    v57 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 224));
                    if ( *(_BYTE *)(((unsigned __int64)&item_param->promote_level >> 3) + 0x7FFF8000) != 0
                      && (char)((((_BYTE)item_param + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->promote_level >> 3)
                                                                                + 0x7FFF8000) )
                    {
                      __asan_report_load4(&item_param->promote_level);
                    }
                    Weapon::setPromoteLevel(v57, item_param->promote_level);
                  }
                }
                std::shared_ptr<Weapon>::~shared_ptr((std::shared_ptr<Weapon> *const)(v3 + 224));
              }
              std::vector<std::shared_ptr<Item>>::emplace_back<std::shared_ptr<Item>&>(
                retstr,
                (std::shared_ptr<Item> *)(v3 + 160),
                (std::shared_ptr<Item> *)(v3 + 160));
              v47 = 1;
            }
          }
          std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v3 + 160));
          if ( v47 != 1 )
            goto LABEL_93;
        }
      }
      else
      {
        if ( !v10 )
          goto LABEL_91;
        PlayerItemComp::createItem(
          (PlayerItemComp *const)(v3 + 96),
          (__int64)this,
          *(_DWORD *)(v3 + 64),
          *(unsigned int *)(v3 + 32),
          0LL);
        if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v3 + 96), 0LL) )
        {
          common::milog::MiLogStream::create(
            &v97,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "createItemBatch",
            10061);
          v11 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                  &v97,
                  (const char (*)[30])"createItem failed, item_type:");
          v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v11,
                  (const unsigned int *)(v3 + 64));
          v13 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v12, (const char (*)[10])" item_id:");
          v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v13,
                  (const unsigned int *)(v3 + 32));
          v15 = common::milog::MiLogStream::operator<<<char [7],(char *[7])0>(v14, (const char (*)[7])"count:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, (const unsigned int *)(v3 + 48));
          common::milog::MiLogStream::~MiLogStream(&v97);
          std::vector<std::shared_ptr<Item>>::clear(retstr);
          v16 = 0;
        }
        else
        {
          std::dynamic_pointer_cast<Material,Item>((const std::shared_ptr<Item> *)(v3 + 128));
          if ( std::operator==<Material>((const std::shared_ptr<Material> *)(v3 + 128), 0LL) )
          {
            common::milog::MiLogStream::create(
              &v97,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "createItemBatch",
              10070);
            v17 = common::milog::MiLogStream::operator<<<char [40],(char *[40])0>(
                    &v97,
                    (const char (*)[40])"dynamic_pointer_cast failed, item_type:");
            v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v17,
                    (const unsigned int *)(v3 + 64));
            v19 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v18, (const char (*)[10])" item_id:");
            v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v19,
                    (const unsigned int *)(v3 + 32));
            v21 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v20, (const char (*)[8])" count:");
            common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, (const unsigned int *)(v3 + 48));
            common::milog::MiLogStream::~MiLogStream(&v97);
            std::vector<std::shared_ptr<Item>>::clear(retstr);
            v22 = 0;
          }
          else
          {
            v23 = std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Material,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 128));
            Material::setCount(v23, *(_DWORD *)(v3 + 48));
            v24 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
            if ( *(_BYTE *)(((unsigned __int64)v24 >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            v25 = (unsigned __int64)(v24->_vptr_Item + 6);
            if ( *(_BYTE *)((v25 >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            v26 = *(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *, Player *, __int64))v25;
            if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
              __asan_report_load8();
            if ( v26(v24, this->player_, 1LL) )
            {
              common::milog::MiLogStream::create(
                &v97,
                &common::milog::MiLogDefault::default_log_obj_,
                3u,
                "./src/player/item/player_item_comp.cpp",
                "createItemBatch",
                10080);
              v27 = common::milog::MiLogStream::operator<<<char [29],(char *[29])0>(
                      &v97,
                      (const char (*)[29])"item init failed, item_type:");
              v28 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                      v27,
                      (const unsigned int *)(v3 + 64));
              v29 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(
                      v28,
                      (const char (*)[10])" item_id:");
              v30 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                      v29,
                      (const unsigned int *)(v3 + 32));
              v31 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v30, (const char (*)[8])" count:");
              common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v31,
                (const unsigned int *)(v3 + 48));
              common::milog::MiLogStream::~MiLogStream(&v97);
              std::vector<std::shared_ptr<Item>>::clear(retstr);
              v22 = 0;
            }
            else
            {
              std::vector<std::shared_ptr<Item>>::emplace_back<std::shared_ptr<Item>&>(
                retstr,
                (std::shared_ptr<Item> *)(v3 + 96),
                (std::shared_ptr<Item> *)(v3 + 96));
              v22 = 1;
            }
          }
          std::shared_ptr<Material>::~shared_ptr((std::shared_ptr<Material> *const)(v3 + 128));
          v16 = v22 == 1;
        }
        std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v3 + 96));
        if ( !v16 )
          break;
      }
    }
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
  }
LABEL_93:
  if ( v98 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8018) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return retstr;
};

// Line 10186: range 0000000017D1B65A-0000000017D1BC40
EquipPtr __cdecl PlayerItemComp::createTrialEquip(PlayerItemComp *const this, const ItemParam *item_param)
{
  const ItemParam *v2; // rdx
  unsigned __int64 v3; // r12
  __int64 v4; // rax
  _DWORD *v5; // r13
  common::milog::MiLogStream *v6; // rax
  EquipPtr result; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  const ItemParam *item_parama; // [rsp+8h] [rbp-E8h]
  const data::ItemConfig *item_config_ptr; // [rsp+28h] [rbp-C8h]
  common::milog::MiLogStream v20; // [rsp+30h] [rbp-C0h] BYREF
  char v21[160]; // [rsp+50h] [rbp-A0h] BYREF

  item_parama = v2;
  v3 = (unsigned __int64)v21;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(128LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "4 48 4 13 item_id:10187 64 4 11 count:10188 80 4 15 item_type:10201 96 16 14 item_ptr:10208";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::createTrialEquip;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -234556924;
  v5[536862723] = -202178560;
  if ( *(_BYTE *)(((unsigned __int64)item_parama >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)item_parama & 7) + 3) >= *(_BYTE *)(((unsigned __int64)item_parama >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(item_parama);
  }
  *(_DWORD *)(v3 + 48) = item_parama->item_id;
  if ( *(_BYTE *)(((unsigned __int64)&item_parama->count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)item_parama + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_parama->count >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&item_parama->count);
  }
  *(_DWORD *)(v3 + 64) = item_parama->count;
  if ( *(_DWORD *)(v3 + 64) == 1 )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)(v3 + 96));
    v8 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
    item_config_ptr = ItemExcelConfigMgr::findItemConfig(
                        &v8->design_config.txt_config_mgr.item_config_mgr,
                        *(_DWORD *)(v3 + 48));
    std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 96));
    if ( item_config_ptr )
    {
      if ( *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)item_config_ptr + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_config_ptr->item_type >> 3)
                                                                       + 0x7FFF8000) )
      {
        __asan_report_load4(&item_config_ptr->item_type);
      }
      *(_DWORD *)(v3 + 80) = item_config_ptr->item_type;
      if ( (unsigned int)(*(_DWORD *)(v3 + 80) - 3) > 1 )
      {
        common::milog::MiLogStream::create(
          &v20,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "createTrialEquip",
          10221);
        v15 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                &v20,
                (const char (*)[30])"createItem failed, item_type:");
        v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v15,
                (const unsigned int *)(v3 + 80));
        v17 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v16, (const char (*)[10])" item_id:");
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, (const unsigned int *)(v3 + 48));
        common::milog::MiLogStream::~MiLogStream(&v20);
        std::shared_ptr<Equip>::shared_ptr((std::shared_ptr<Equip> *const)this, 0LL);
      }
      else
      {
        PlayerItemComp::createItem(
          (PlayerItemComp *const)(v3 + 96),
          (__int64)item_param,
          *(_DWORD *)(v3 + 80),
          *(unsigned int *)(v3 + 48),
          0LL);
        if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v3 + 96), 0LL) )
        {
          common::milog::MiLogStream::create(
            &v20,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "createTrialEquip",
            10211);
          v10 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                  &v20,
                  (const char (*)[30])"createItem failed, item_type:");
          v11 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v10,
                  (const unsigned int *)(v3 + 80));
          v12 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v11, (const char (*)[10])" item_id:");
          v13 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                  v12,
                  (const unsigned int *)(v3 + 48));
          v14 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v13, (const char (*)[8])" count:");
          common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v14, (const unsigned int *)(v3 + 64));
          common::milog::MiLogStream::~MiLogStream(&v20);
          std::shared_ptr<Equip>::shared_ptr((std::shared_ptr<Equip> *const)this, 0LL);
        }
        else
        {
          if ( *(_WORD *)(((unsigned __int64)this >> 3) + 0x7FFF8000) )
            __asan_report_store16(this);
          std::dynamic_pointer_cast<Equip,Item>((const std::shared_ptr<Item> *)this);
        }
        std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v3 + 96));
      }
    }
    else
    {
      common::milog::MiLogStream::create(
        &v20,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "createTrialEquip",
        10198);
      v9 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
             &v20,
             (const char (*)[35])"findItemBaseConfig fails, item_id:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v3 + 48));
      common::milog::MiLogStream::~MiLogStream(&v20);
      std::shared_ptr<Equip>::shared_ptr((std::shared_ptr<Equip> *const)this, 0LL);
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v20,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "createTrialEquip",
      10191);
    v6 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
           &v20,
           (const char (*)[31])"equip count is not 1, item_id:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, (const unsigned int *)(v3 + 48));
    common::milog::MiLogStream::~MiLogStream(&v20);
    std::shared_ptr<Equip>::shared_ptr((std::shared_ptr<Equip> *const)this, 0LL);
  }
  if ( v21 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    result._M_refcount._M_pi = (std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2> *)0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
  }
  result._M_ptr = (std::__shared_ptr<Equip,(__gnu_cxx::_Lock_policy)2>::element_type *)this;
  return result;
};

// Line 10231: range 0000000017D1BC42-0000000017D1BE0E
std::map<unsigned int,ItemParam> *__cdecl PlayerItemComp::mergeItemParam(
        std::map<unsigned int,ItemParam> *retstr,
        const std::vector<ItemParam> *item_param_vec)
{
  const ItemParam *v2; // rax
  uint32_t item_id; // ebx
  const ItemParam *v4; // rsi
  std::map<unsigned int,ItemParam>::mapped_type *v5; // rax
  std::map<unsigned int,ItemParam>::mapped_type *v6; // rdx
  char v7; // cl
  std::map<unsigned int,ItemParam>::mapped_type *v8; // rax
  uint32_t count; // esi
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+10h] [rbp-30h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+18h] [rbp-28h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+20h] [rbp-20h]
  const ItemParam *item_param; // [rsp+28h] [rbp-18h]

  std::map<unsigned int,ItemParam>::map(retstr);
  __for_range = item_param_vec;
  __for_begin._M_current = std::vector<ItemParam>::begin(item_param_vec)._M_current;
  __for_end._M_current = std::vector<ItemParam>::end(item_param_vec)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
  {
    v2 = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
    item_param = v2;
    if ( *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v2 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v2);
    }
    item_id = item_param->item_id;
    v4 = item_param;
    v5 = std::map<unsigned int,ItemParam>::operator[](retstr, &item_param->item_id);
    v6 = v5;
    v7 = *(_BYTE *)(((unsigned __int64)v5 >> 3) + 0x7FFF8000);
    if ( v7 != 0 && (char)(((unsigned __int8)v5 & 7) + 3) >= v7 )
    {
      LOBYTE(v4) = v7 != 0;
      __asan_report_store4(v5, v4, v5);
    }
    v6->item_id = item_id;
    v8 = std::map<unsigned int,ItemParam>::operator[](retstr, &item_param->item_id);
    if ( *(_BYTE *)(((unsigned __int64)&v8->count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)v8 + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&v8->count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&v8->count);
    }
    count = v8->count;
    if ( *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)item_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&item_param->count >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(&item_param->count);
    }
    v8->count = count + item_param->count;
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
  }
  return retstr;
};

// Line 10243: range 0000000017D1BE10-0000000017D1C429
std::vector<std::shared_ptr<Item>> *__cdecl PlayerItemComp::createItemBatch(
        std::vector<std::shared_ptr<Item>> *retstr,
        PlayerItemComp *const this,
        const std::vector<proto::EquipParam> *param_vec)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  int v8; // r14d
  const std::shared_ptr<Item> *M_current; // r15
  const std::shared_ptr<Item> *v10; // r14
  const std::shared_ptr<Item> *v11; // rsi
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  int v15; // r14d
  Weapon *v16; // r14
  uint32_t v17; // eax
  Weapon *v18; // r14
  uint32_t v19; // eax
  std::vector<proto::EquipParam>::const_iterator __for_begin; // [rsp+20h] [rbp-150h] BYREF
  std::vector<proto::EquipParam>::const_iterator __for_end; // [rsp+28h] [rbp-148h] BYREF
  std::vector<std::shared_ptr<Item>>::iterator __for_begin_0; // [rsp+30h] [rbp-140h] BYREF
  std::vector<std::shared_ptr<Item>>::iterator __for_end_0; // [rsp+38h] [rbp-138h] BYREF
  const std::vector<proto::EquipParam> *__for_range; // [rsp+40h] [rbp-130h]
  const proto::EquipParam *equip_param; // [rsp+48h] [rbp-128h]
  std::vector<std::shared_ptr<Item>> *__for_range_0; // [rsp+50h] [rbp-120h]
  std::shared_ptr<Item> *item_ptr; // [rsp+58h] [rbp-118h]
  common::milog::MiLogStream v31; // [rsp+60h] [rbp-110h] BYREF
  char v32[240]; // [rsp+80h] [rbp-F0h] BYREF

  v3 = (unsigned __int64)v32;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(192LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "4 48 4 13 item_id:10247 64 16 11 param:10248 96 16 16 weapon_ptr:10268 128 24 14 item_vec:10251";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::createItemBatch;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -219021312;
  v5[536862723] = -219021312;
  v5[536862724] = -218103808;
  v5[536862725] = -202116109;
  std::vector<std::shared_ptr<Item>>::vector(retstr);
  __for_range = param_vec;
  __for_begin._M_current = std::vector<proto::EquipParam>::begin(param_vec)._M_current;
  __for_end._M_current = std::vector<proto::EquipParam>::end(param_vec)._M_current;
  while ( __gnu_cxx::operator!=<proto::EquipParam const*,std::vector<proto::EquipParam>>(&__for_begin, &__for_end) )
  {
    equip_param = __gnu_cxx::__normal_iterator<proto::EquipParam const*,std::vector<proto::EquipParam>>::operator*(&__for_begin);
    *(_DWORD *)(v3 + 48) = proto::EquipParam::item_id(equip_param);
    *(_DWORD *)(v3 + 64) = 0;
    *(_DWORD *)(v3 + 68) = 0;
    *(_DWORD *)(v3 + 72) = 0;
    *(_DWORD *)(v3 + 76) = 0;
    *(_DWORD *)(v3 + 64) = *(_DWORD *)(v3 + 48);
    *(_DWORD *)(v3 + 68) = proto::EquipParam::item_num(equip_param);
    PlayerItemComp::createItem((std::vector<std::shared_ptr<Item>> *)(v3 + 128), this, (const ItemParam *)(v3 + 64));
    if ( std::vector<std::shared_ptr<Item>>::empty((const std::vector<std::shared_ptr<Item>> *const)(v3 + 128)) )
    {
      common::milog::MiLogStream::create(
        &v31,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "createItemBatch",
        10254);
      v6 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(&v31, (const char (*)[12])"createItem ");
      v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, (const unsigned int *)(v3 + 48));
      common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v7, (const char (*)[8])" failed");
      common::milog::MiLogStream::~MiLogStream(&v31);
      std::vector<std::shared_ptr<Item>>::clear(retstr);
      v8 = 0;
    }
    else
    {
      M_current = std::vector<std::shared_ptr<Item>>::cend((const std::vector<std::shared_ptr<Item>> *const)(v3 + 128))._M_current;
      v10 = std::vector<std::shared_ptr<Item>>::cbegin((const std::vector<std::shared_ptr<Item>> *const)(v3 + 128))._M_current;
      v11 = std::vector<std::shared_ptr<Item>>::cend(retstr)._M_current;
      std::vector<std::shared_ptr<Item>>::insert<__gnu_cxx::__normal_iterator<std::shared_ptr<Item> const*,std::vector<std::shared_ptr<Item>>>,void>(
        retstr,
        (std::vector<std::shared_ptr<Item>>::const_iterator)v11,
        (__gnu_cxx::__normal_iterator<const std::shared_ptr<Item>*,std::vector<std::shared_ptr<Item>> >)v10,
        (__gnu_cxx::__normal_iterator<const std::shared_ptr<Item>*,std::vector<std::shared_ptr<Item>> >)M_current);
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)(v3 + 96));
      v12 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
      LOBYTE(v10) = ItemExcelConfigMgr::getItemType(
                      &v12->design_config.txt_config_mgr.item_config_mgr,
                      *(_DWORD *)(v3 + 48)) != ITEM_WEAPON;
      std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v3 + 96));
      if ( (_BYTE)v10 )
      {
        v8 = 1;
      }
      else
      {
        __for_range_0 = (std::vector<std::shared_ptr<Item>> *)(v3 + 128);
        __for_begin_0._M_current = std::vector<std::shared_ptr<Item>>::begin((std::vector<std::shared_ptr<Item>> *const)(v3 + 128))._M_current;
        __for_end_0._M_current = std::vector<std::shared_ptr<Item>>::end(__for_range_0)._M_current;
        while ( __gnu_cxx::operator!=<std::shared_ptr<Item> *,std::vector<std::shared_ptr<Item>>>(
                  &__for_begin_0,
                  &__for_end_0) )
        {
          item_ptr = __gnu_cxx::__normal_iterator<std::shared_ptr<Item> *,std::vector<std::shared_ptr<Item>>>::operator*(&__for_begin_0);
          std::dynamic_pointer_cast<Weapon,Item>((const std::shared_ptr<Item> *)(v3 + 96));
          if ( std::operator==<Weapon>((const std::shared_ptr<Weapon> *)(v3 + 96), 0LL) )
          {
            common::milog::MiLogStream::create(
              &v31,
              &common::milog::MiLogDefault::default_log_obj_,
              3u,
              "./src/player/item/player_item_comp.cpp",
              "createItemBatch",
              10271);
            v13 = common::milog::MiLogStream::operator<<<char [35],(char *[35])0>(
                    &v31,
                    (const char (*)[35])"std::dynamic_pointer_cast<Weapon> ");
            v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                    v13,
                    (const unsigned int *)(v3 + 48));
            common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v14, (const char (*)[8])" failed");
            common::milog::MiLogStream::~MiLogStream(&v31);
            std::vector<std::shared_ptr<Item>>::clear(retstr);
            v15 = 0;
          }
          else
          {
            if ( proto::EquipParam::item_level(equip_param) )
            {
              v16 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
              v17 = proto::EquipParam::item_level(equip_param);
              Weapon::setLevel(v16, v17);
            }
            if ( proto::EquipParam::promote_level(equip_param) )
            {
              v18 = std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Weapon,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v3 + 96));
              v19 = proto::EquipParam::promote_level(equip_param);
              Weapon::setPromoteLevel(v18, v19);
            }
            v15 = 1;
          }
          std::shared_ptr<Weapon>::~shared_ptr((std::shared_ptr<Weapon> *const)(v3 + 96));
          if ( v15 != 1 )
          {
            v8 = 0;
            goto LABEL_23;
          }
          __gnu_cxx::__normal_iterator<std::shared_ptr<Item> *,std::vector<std::shared_ptr<Item>>>::operator++(&__for_begin_0);
        }
        v8 = 2;
      }
    }
LABEL_23:
    std::vector<std::shared_ptr<Item>>::~vector((std::vector<std::shared_ptr<Item>> *const)(v3 + 128));
    if ( !v8 )
      break;
    __gnu_cxx::__normal_iterator<proto::EquipParam const*,std::vector<proto::EquipParam>>::operator++(&__for_begin);
  }
  if ( v32 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return retstr;
};

// Line 10291: range 0000000017D1C67E-0000000017D1DCF4
__int64 __fastcall PlayerItemComp::generateReliquaryMainPropId(PlayerItemComp *const this, uint32_t reliquary_id)
{
  unsigned __int64 v2; // r14
  __int64 v3; // rax
  _DWORD *v4; // r12
  common::milog::MiLogStream *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rcx
  unsigned int v10; // r13d
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  common::milog::MiLogStream *v19; // rax
  common::milog::MiLogStream *v20; // rax
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v23; // rax
  bool isReliquaryGuaranteeClosed; // r13
  common::milog::MiLogStream *v25; // rax
  common::milog::MiLogStream *v26; // rax
  common::milog::MiLogStream *v27; // rax
  char *v28; // rsi
  uint32_t v29; // ecx
  char v30; // al
  __int64 v31; // rdx
  unsigned int v32; // edx
  uint32_t v33; // ecx
  char v34; // dl
  __int64 v35; // rsi
  __int64 v36; // rdx
  uint32_t guarantee_count; // ecx
  uint32_t v38; // ecx
  __int64 v39; // rdx
  unsigned int max_guarantee_count; // edx
  uint32_t v41; // ecx
  char v42; // dl
  __int64 v43; // rsi
  __int64 v44; // rdx
  common::milog::MiLogStream *v45; // rax
  common::milog::MiLogStream *v46; // rax
  common::milog::MiLogStream *v47; // rax
  common::milog::MiLogStream *v48; // rax
  common::milog::MiLogStream *v49; // rax
  common::milog::MiLogStream *v50; // rax
  common::milog::MiLogStream *v51; // rax
  common::milog::MiLogStream *v52; // rax
  common::milog::MiLogStream *v53; // rax
  common::milog::MiLogStream *v54; // rax
  common::milog::MiLogStream *v55; // rax
  common::milog::MiLogStream *v56; // rax
  common::milog::MiLogStream *v57; // rax
  common::milog::MiLogStream *v58; // rcx
  __int64 v59; // rsi
  uint32_t v60; // ecx
  char v61; // dl
  __int64 v62; // rdx
  __int64 v63; // rsi
  uint32_t v64; // ecx
  char v65; // dl
  __int64 v66; // rdx
  uint32_t main_prop_depot_id; // ecx
  PlayerItemComp::generateReliquaryMainPropId::TriggeredMainPropData *v68; // rax
  PlayerItemComp::generateReliquaryMainPropId::TriggeredMainPropData *v70; // rax
  PlayerItemComp::generateReliquaryMainPropId::TriggeredMainPropData *v71; // rdx
  common::milog::MiLogStream *v72; // rax
  common::milog::MiLogStream *v73; // rax
  common::milog::MiLogStream *v74; // rax
  common::milog::MiLogStream *v75; // rax
  common::milog::MiLogStream *v76; // rax
  common::milog::MiLogStream *v77; // rax
  common::milog::MiLogStream *v78; // rcx
  __int64 v79; // rdx
  common::milog::MiLogStream *v80; // rax
  common::milog::MiLogStream *v81; // rax
  common::milog::MiLogStream *v82; // rax
  common::milog::MiLogStream *v83; // rax
  common::milog::MiLogStream *v84; // rax
  common::milog::MiLogStream *v85; // rax
  unsigned int v86; // edx
  uint32_t v87; // ecx
  char v88; // dl
  __int64 v89; // rsi
  __int64 v90; // rdx
  common::milog::MiLogStream *v91; // rax
  common::milog::MiLogStream *v92; // rax
  common::milog::MiLogStream *v93; // r13
  bool has_value; // al
  common::milog::MiLogStream *v95; // rax
  common::milog::MiLogStream *v96; // rax
  __int64 result; // rax
  std::unordered_map<unsigned int,data::ReliquaryMainPropGuaranteeExcelConfig>::const_iterator __for_begin; // [rsp+10h] [rbp-1C0h] BYREF
  std::unordered_map<unsigned int,data::ReliquaryMainPropGuaranteeExcelConfig>::const_iterator __for_end; // [rsp+18h] [rbp-1B8h] BYREF
  const ReliquaryExcelConfigMgr *reliquary_config_mgr; // [rsp+20h] [rbp-1B0h]
  const data::ReliquaryExcelConfig *reliquary_config_ptr; // [rsp+28h] [rbp-1A8h]
  const data::ReliquarySetExcelConfig *reliquary_set_config_ptr; // [rsp+30h] [rbp-1A0h]
  ReliquaryGuaranteeDepot *guarantee_depot; // [rsp+38h] [rbp-198h]
  const std::unordered_map<unsigned int,data::ReliquaryMainPropGuaranteeExcelConfig> *__for_range; // [rsp+40h] [rbp-190h]
  ReliquaryMainPropGuaranteeData *guarantee_data_ptr; // [rsp+48h] [rbp-188h]
  const data::ReliquaryMainPropGuaranteeExcelConfig *guarantee_config_ptr; // [rsp+50h] [rbp-180h]
  const std::pair<unsigned int const,data::ReliquaryMainPropGuaranteeExcelConfig> *v107; // [rsp+58h] [rbp-178h]
  std::tuple_element<0,const std::pair<unsigned int const,data::ReliquaryMainPropGuaranteeExcelConfig> >::type *main_prop_id; // [rsp+60h] [rbp-170h]
  std::tuple_element<1,const std::pair<unsigned int const,data::ReliquaryMainPropGuaranteeExcelConfig> >::type *guarantee_config; // [rsp+68h] [rbp-168h]
  ReliquaryMainPropGuaranteeData *guarantee_data; // [rsp+70h] [rbp-160h]
  const ReliquaryMainPropGuaranteeData *old_guarantee_data_ptr; // [rsp+78h] [rbp-158h]
  common::milog::MiLogStream v112; // [rsp+80h] [rbp-150h] BYREF
  char v113[304]; // [rsp+A0h] [rbp-130h] BYREF

  v2 = (unsigned __int64)v113;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_2(256LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "8 32 4 26 default_main_prop_id:10294 48 4 22 reliquary_set_id:10313 64 4 24 guarantee_depot_id:1"
                        "0325 80 4 25 result_main_prop_id:10395 96 4 18 reliquary_id:10290 112 12 24 cur_main_prop_data:1"
                        "0384 144 16 31 result_main_prop_data_opt:10358 176 48 41 result_main_prop_guarantee_data_map:10357";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::generateReliquaryMainPropId;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234556924;
  v4[536862722] = -234556924;
  v4[536862723] = 61956;
  v4[536862723] = 0x4000000;
  v4[536862724] = 62194;
  v4[536862725] = 62194;
  v4[536862727] = -202116109;
  *(_DWORD *)(v2 + 96) = reliquary_id;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)(v2 + 144));
  reliquary_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 144))->design_config.txt_config_mgr.reliquary_config_mgr;
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v2 + 144));
  *(_DWORD *)(v2 + 32) = ReliquaryExcelConfigMgr::generateMainPropId(reliquary_config_mgr, *(_DWORD *)(v2 + 96));
  reliquary_config_ptr = data::ReliquaryExcelConfigMgrBase::findReliquaryExcelConfig(
                           reliquary_config_mgr,
                           *(_DWORD *)(v2 + 96));
  if ( !reliquary_config_ptr )
  {
    common::milog::MiLogStream::create(
      &v112,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "generateReliquaryMainPropId",
      10298);
    v5 = common::milog::MiLogStream::operator<<<char [47],(char *[47])0>(
           &v112,
           (const char (*)[47])"findReliquaryExcelConfig failed, reliquary_id:");
    v6 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, (const unsigned int *)(v2 + 96));
    v7 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
           v6,
           (const char (*)[30])" return default_main_prop_id:");
    v8 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v2 + 32));
    v9 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v8, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
LABEL_29:
    operator<<(v9, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v112);
    v10 = *(_DWORD *)(v2 + 32);
    goto LABEL_112;
  }
  if ( !common::tools::MiscUtils::isContains<std::unordered_set<unsigned int> const,unsigned int>(
          &reliquary_config_mgr->guaranteed_main_prop_depot_id_set,
          &reliquary_config_ptr->main_prop_depot_id) )
  {
    v10 = *(_DWORD *)(v2 + 32);
    goto LABEL_112;
  }
  if ( *(_BYTE *)(((unsigned __int64)&reliquary_config_ptr->rank_level >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&reliquary_config_ptr->rank_level >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&reliquary_config_ptr->rank_level);
  }
  if ( reliquary_config_ptr->rank_level <= 4 )
  {
    v10 = *(_DWORD *)(v2 + 32);
    goto LABEL_112;
  }
  if ( *(_BYTE *)(((unsigned __int64)&reliquary_config_ptr->set_id >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&reliquary_config_ptr->set_id >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&reliquary_config_ptr->set_id);
  }
  *(_DWORD *)(v2 + 48) = reliquary_config_ptr->set_id;
  if ( !*(_DWORD *)(v2 + 48) )
  {
    v10 = *(_DWORD *)(v2 + 32);
    goto LABEL_112;
  }
  reliquary_set_config_ptr = data::ReliquaryExcelConfigMgrBase::findReliquarySetExcelConfig(
                               reliquary_config_mgr,
                               *(_DWORD *)(v2 + 48));
  if ( !reliquary_set_config_ptr )
  {
    common::milog::MiLogStream::create(
      &v112,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "generateReliquaryMainPropId",
      10321);
    v11 = common::milog::MiLogStream::operator<<<char [50],(char *[50])0>(
            &v112,
            (const char (*)[50])"findReliquarySetExcelConfig failed, reliquary_id:");
    v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v2 + 96));
    v13 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(v12, (const char (*)[19])" reliquary_set_id:");
    v14 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v2 + 48));
    v15 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
            v14,
            (const char (*)[30])" return default_main_prop_id:");
    v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, (const unsigned int *)(v2 + 32));
    v9 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v16, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    goto LABEL_29;
  }
  if ( *(_BYTE *)(((unsigned __int64)&reliquary_set_config_ptr->guarantee_depot_id >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)reliquary_set_config_ptr + 76) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reliquary_set_config_ptr->guarantee_depot_id >> 3)
                                                                            + 0x7FFF8000) )
  {
    __asan_report_load4(&reliquary_set_config_ptr->guarantee_depot_id);
  }
  *(_DWORD *)(v2 + 64) = reliquary_set_config_ptr->guarantee_depot_id;
  if ( !*(_DWORD *)(v2 + 64) )
  {
    v10 = *(_DWORD *)(v2 + 32);
    goto LABEL_112;
  }
  if ( *(_DWORD *)(v2 + 64) > 2u )
  {
    common::milog::MiLogStream::create(
      &v112,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "generateReliquaryMainPropId",
      10332);
    v17 = common::milog::MiLogStream::operator<<<char [28],(char *[28])0>(
            &v112,
            (const char (*)[28])"invalid guarantee_depot_id:");
    v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, (const unsigned int *)(v2 + 64));
    v19 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v18, (const char (*)[15])" reliquary_id:");
    v20 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v19, (const unsigned int *)(v2 + 96));
    v21 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
            v20,
            (const char (*)[30])" return default_main_prop_id:");
    v22 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v21, (const unsigned int *)(v2 + 32));
    v9 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v22, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    goto LABEL_29;
  }
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)(v2 + 144));
  v23 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v2 + 144));
  isReliquaryGuaranteeClosed = FeatureSwitchMgr::isReliquaryGuaranteeClosed(&v23->feature_switch_mgr);
  std::shared_ptr<Config>::~shared_ptr((std::shared_ptr<Config> *const)(v2 + 144));
  if ( isReliquaryGuaranteeClosed )
  {
    common::milog::MiLogStream::create(
      &v112,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "generateReliquaryMainPropId",
      10338);
    v25 = common::milog::MiLogStream::operator<<<char [58],(char *[58])0>(
            &v112,
            (const char (*)[58])"[FEATURE_SWITCH] ReliquaryGuarantee closed, reliquary_id:");
    v26 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v25, (const unsigned int *)(v2 + 96));
    v27 = common::milog::MiLogStream::operator<<<char [23],(char *[23])0>(
            v26,
            (const char (*)[23])" default_main_prop_id:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, (const unsigned int *)(v2 + 32));
    common::milog::MiLogStream::~MiLogStream(&v112);
    v10 = *(_DWORD *)(v2 + 32);
    goto LABEL_112;
  }
  v28 = (char *)(v2 + 64);
  guarantee_depot = std::map<unsigned int,ReliquaryGuaranteeDepot>::operator[](
                      &this->reliquary_guarantee_depot_map_,
                      (const std::map<unsigned int,ReliquaryGuaranteeDepot>::key_type *)(v2 + 64));
  v29 = *(_DWORD *)(v2 + 64);
  v30 = *(_BYTE *)(((unsigned __int64)guarantee_depot >> 3) + 0x7FFF8000);
  if ( v30 != 0 && v30 <= 3 )
  {
    LOBYTE(v28) = v30 != 0;
    __asan_report_store4(guarantee_depot, v28, guarantee_depot);
  }
  guarantee_depot->guarantee_depot_id = v29;
  std::map<unsigned int,ReliquaryMainPropGuaranteeData>::map((std::map<unsigned int,ReliquaryMainPropGuaranteeData> *const)(v2 + 176));
  *(_QWORD *)(v2 + 144) = 0LL;
  *(_QWORD *)(v2 + 152) = 0LL;
  __for_range = &reliquary_config_mgr->reliquary_main_prop_guarantee_excel_config_map;
  __for_begin._M_cur = std::unordered_map<unsigned int,data::ReliquaryMainPropGuaranteeExcelConfig>::begin(&reliquary_config_mgr->reliquary_main_prop_guarantee_excel_config_map)._M_cur;
  __for_end._M_cur = std::unordered_map<unsigned int,data::ReliquaryMainPropGuaranteeExcelConfig>::end(&reliquary_config_mgr->reliquary_main_prop_guarantee_excel_config_map)._M_cur;
  while ( std::__detail::operator!=<std::pair<unsigned int const,data::ReliquaryMainPropGuaranteeExcelConfig>,false>(
            &__for_begin,
            &__for_end) )
  {
    v107 = std::__detail::_Node_const_iterator<std::pair<unsigned int const,data::ReliquaryMainPropGuaranteeExcelConfig>,false,false>::operator*(&__for_begin);
    main_prop_id = std::get<0ul,unsigned int const,data::ReliquaryMainPropGuaranteeExcelConfig>(v107);
    guarantee_config = (std::tuple_element<1,const std::pair<unsigned int const,data::ReliquaryMainPropGuaranteeExcelConfig> >::type *)std::get<1ul,unsigned int const,data::ReliquaryMainPropGuaranteeExcelConfig>(v107);
    guarantee_data = std::map<unsigned int,ReliquaryMainPropGuaranteeData>::operator[](
                       (std::map<unsigned int,ReliquaryMainPropGuaranteeData> *const)(v2 + 176),
                       main_prop_id);
    old_guarantee_data_ptr = common::tools::MiscUtils::findMapValuePointer<std::map<unsigned int,ReliquaryMainPropGuaranteeData>>(
                               &guarantee_depot->main_prop_guarantee_data_map,
                               main_prop_id);
    if ( old_guarantee_data_ptr )
    {
      if ( *(_BYTE *)(((unsigned __int64)&old_guarantee_data_ptr->guarantee_count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)old_guarantee_data_ptr + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&old_guarantee_data_ptr->guarantee_count >> 3)
                                                                             + 0x7FFF8000) )
      {
        __asan_report_load4(&old_guarantee_data_ptr->guarantee_count);
      }
      guarantee_count = old_guarantee_data_ptr->guarantee_count;
      if ( *(_BYTE *)(((unsigned __int64)&guarantee_config->min_guarantee_count >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&guarantee_config->min_guarantee_count >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&guarantee_config->min_guarantee_count);
      }
      if ( guarantee_count < guarantee_config->min_guarantee_count )
        goto LABEL_54;
      v38 = old_guarantee_data_ptr->guarantee_count;
      if ( *(_BYTE *)(((unsigned __int64)&guarantee_config->max_guarantee_count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)guarantee_config + 52) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&guarantee_config->max_guarantee_count >> 3)
                                                                        + 0x7FFF8000) )
      {
        __asan_report_load4(&guarantee_config->max_guarantee_count);
      }
      if ( v38 <= guarantee_config->max_guarantee_count )
      {
        v59 = ((unsigned __int8)old_guarantee_data_ptr & 7u) + 3;
        if ( *(_BYTE *)(((unsigned __int64)old_guarantee_data_ptr >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)old_guarantee_data_ptr & 7) + 3) >= *(_BYTE *)(((unsigned __int64)old_guarantee_data_ptr >> 3)
                                                                                   + 0x7FFF8000) )
        {
          __asan_report_load4(old_guarantee_data_ptr);
        }
        v60 = old_guarantee_data_ptr->miss_count + 1;
        v61 = *(_BYTE *)(((unsigned __int64)guarantee_data >> 3) + 0x7FFF8000);
        LOBYTE(v59) = v61 != 0;
        v62 = (v61 != 0) & (unsigned __int8)((char)(((unsigned __int8)guarantee_data & 7) + 3) >= v61);
        if ( (_BYTE)v62 )
          __asan_report_store4(guarantee_data, v59, v62);
        guarantee_data->miss_count = v60;
        v63 = (((_BYTE)old_guarantee_data_ptr + 4) & 7u) + 3;
        if ( *(_BYTE *)(((unsigned __int64)&old_guarantee_data_ptr->guarantee_count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)old_guarantee_data_ptr + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&old_guarantee_data_ptr->guarantee_count >> 3)
                                                                               + 0x7FFF8000) )
        {
          __asan_report_load4(&old_guarantee_data_ptr->guarantee_count);
        }
        v64 = old_guarantee_data_ptr->guarantee_count;
        v65 = *(_BYTE *)(((unsigned __int64)&guarantee_data->guarantee_count >> 3) + 0x7FFF8000);
        LOBYTE(v63) = v65 != 0;
        v66 = (v65 != 0) & (unsigned __int8)((char)((((_BYTE)guarantee_data + 4) & 7) + 3) >= v65);
        if ( (_BYTE)v66 )
          __asan_report_store4(&guarantee_data->guarantee_count, v63, v66);
        guarantee_data->guarantee_count = v64;
        if ( *(_BYTE *)(((unsigned __int64)&guarantee_config->main_prop_depot_id >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)guarantee_config + 12) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&guarantee_config->main_prop_depot_id >> 3)
                                                                          + 0x7FFF8000) )
        {
          __asan_report_load4(&guarantee_config->main_prop_depot_id);
        }
        main_prop_depot_id = guarantee_config->main_prop_depot_id;
        if ( *(_BYTE *)(((unsigned __int64)&reliquary_config_ptr->main_prop_depot_id >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)reliquary_config_ptr + 84) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&reliquary_config_ptr->main_prop_depot_id >> 3)
                                                                              + 0x7FFF8000) )
        {
          __asan_report_load4(&reliquary_config_ptr->main_prop_depot_id);
        }
        if ( main_prop_depot_id == reliquary_config_ptr->main_prop_depot_id
          && old_guarantee_data_ptr->miss_count >= old_guarantee_data_ptr->guarantee_count )
        {
          *(_DWORD *)(v2 + 112) = 0;
          *(_DWORD *)(v2 + 116) = 0;
          *(_DWORD *)(v2 + 120) = 0;
          if ( *(_BYTE *)(((unsigned __int64)main_prop_id >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)main_prop_id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)main_prop_id >> 3)
                                                                           + 0x7FFF8000) )
          {
            __asan_report_load4(main_prop_id);
          }
          *(_DWORD *)(v2 + 112) = *main_prop_id;
          *(_DWORD *)(v2 + 116) = old_guarantee_data_ptr->guarantee_count;
          *(_DWORD *)(v2 + 120) = old_guarantee_data_ptr->miss_count - old_guarantee_data_ptr->guarantee_count;
          if ( !std::optional<PlayerItemComp::generateReliquaryMainPropId(unsigned int)::TriggeredMainPropData>::has_value((const std::optional<PlayerItemComp::generateReliquaryMainPropId(uint32_t)::TriggeredMainPropData> *const)(v2 + 144))
            || (v68 = std::optional<PlayerItemComp::generateReliquaryMainPropId(unsigned int)::TriggeredMainPropData>::value((std::optional<PlayerItemComp::generateReliquaryMainPropId(uint32_t)::TriggeredMainPropData> *const)(v2 + 144)),
                PlayerItemComp::generateReliquaryMainPropId(unsigned int)::TriggeredMainPropData::isBetterThan(
                  (const PlayerItemComp::generateReliquaryMainPropId::TriggeredMainPropData *const)(v2 + 112),
                  v68)) )
          {
            std::optional_PlayerItemComp::generateReliquaryMainPropId_uint32_t_::TriggeredMainPropData_::operator__PlayerItemComp::generateReliquaryMainPropId_uint32_t_::TriggeredMainPropData__(
              (std::optional<PlayerItemComp::generateReliquaryMainPropId(uint32_t)::TriggeredMainPropData> *const)(v2 + 144),
              (PlayerItemComp::generateReliquaryMainPropId::TriggeredMainPropData *)(v2 + 112));
          }
        }
      }
      else
      {
LABEL_54:
        v39 = (*(_BYTE *)(((unsigned __int64)guarantee_data >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((unsigned __int8)guarantee_data & 7) + 3) >= *(_BYTE *)(((unsigned __int64)guarantee_data >> 3) + 0x7FFF8000));
        if ( (_BYTE)v39 )
          __asan_report_store4(guarantee_data, ((unsigned __int8)guarantee_data & 7u) + 3, v39);
        guarantee_data->miss_count = 1;
        if ( *(_BYTE *)(((unsigned __int64)&guarantee_config->max_guarantee_count >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)guarantee_config + 52) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&guarantee_config->max_guarantee_count >> 3)
                                                                          + 0x7FFF8000) )
        {
          __asan_report_load4(&guarantee_config->max_guarantee_count);
        }
        max_guarantee_count = guarantee_config->max_guarantee_count;
        if ( *(_BYTE *)(((unsigned __int64)&guarantee_config->min_guarantee_count >> 3) + 0x7FFF8000) != 0
          && *(_BYTE *)(((unsigned __int64)&guarantee_config->min_guarantee_count >> 3) + 0x7FFF8000) <= 3 )
        {
          __asan_report_load4(&guarantee_config->min_guarantee_count);
        }
        v43 = max_guarantee_count;
        v41 = common::tools::RandomUtils::rand<unsigned int>(guarantee_config->min_guarantee_count, max_guarantee_count);
        v42 = *(_BYTE *)(((unsigned __int64)&guarantee_data->guarantee_count >> 3) + 0x7FFF8000);
        LOBYTE(v43) = v42 != 0;
        v44 = (v42 != 0) & (unsigned __int8)((char)((((_BYTE)guarantee_data + 4) & 7) + 3) >= v42);
        if ( (_BYTE)v44 )
          __asan_report_store4(&guarantee_data->guarantee_count, v43, v44);
        guarantee_data->guarantee_count = v41;
        common::milog::MiLogStream::create(
          &v112,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "generateReliquaryMainPropId",
          10373);
        v45 = common::milog::MiLogStream::operator<<<char [109],(char *[109])0>(
                &v112,
                (const char (*)[109])off_2639D320);
        v46 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v45, main_prop_id);
        v47 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(
                v46,
                (const char (*)[17])" old_miss_count:");
        v48 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v47,
                (const unsigned int *)old_guarantee_data_ptr);
        v49 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
                v48,
                (const char (*)[22])" old_guarantee_count:");
        v50 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v49,
                &old_guarantee_data_ptr->guarantee_count);
        v51 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v50, (const char (*)[9])" range:(");
        v52 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v51,
                &guarantee_config->min_guarantee_count);
        v53 = common::milog::MiLogStream::operator<<<char [2],(char *[2])0>(v52, (const char (*)[2])",");
        v54 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v53,
                &guarantee_config->max_guarantee_count);
        v55 = common::milog::MiLogStream::operator<<<char [2],(char *[2])0>(v54, (const char (*)[2])")");
        v56 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
                v55,
                (const char (*)[22])" new_guarantee_count:");
        v57 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v56,
                &guarantee_data->guarantee_count);
        v58 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v57, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v58, this->player_);
        common::milog::MiLogStream::~MiLogStream(&v112);
      }
    }
    else
    {
      v31 = (*(_BYTE *)(((unsigned __int64)guarantee_data >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((unsigned __int8)guarantee_data & 7) + 3) >= *(_BYTE *)(((unsigned __int64)guarantee_data >> 3) + 0x7FFF8000));
      if ( (_BYTE)v31 )
        __asan_report_store4(guarantee_data, ((unsigned __int8)guarantee_data & 7u) + 3, v31);
      guarantee_data->miss_count = 1;
      if ( *(_BYTE *)(((unsigned __int64)&guarantee_config->max_guarantee_count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)guarantee_config + 52) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&guarantee_config->max_guarantee_count >> 3)
                                                                        + 0x7FFF8000) )
      {
        __asan_report_load4(&guarantee_config->max_guarantee_count);
      }
      v32 = guarantee_config->max_guarantee_count;
      if ( *(_BYTE *)(((unsigned __int64)&guarantee_config->min_guarantee_count >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&guarantee_config->min_guarantee_count >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&guarantee_config->min_guarantee_count);
      }
      v35 = v32;
      v33 = common::tools::RandomUtils::rand<unsigned int>(guarantee_config->min_guarantee_count, v32);
      v34 = *(_BYTE *)(((unsigned __int64)&guarantee_data->guarantee_count >> 3) + 0x7FFF8000);
      LOBYTE(v35) = v34 != 0;
      v36 = (v34 != 0) & (unsigned __int8)((char)((((_BYTE)guarantee_data + 4) & 7) + 3) >= v34);
      if ( (_BYTE)v36 )
        __asan_report_store4(&guarantee_data->guarantee_count, v35, v36);
      guarantee_data->guarantee_count = v33;
    }
    std::__detail::_Node_const_iterator<std::pair<unsigned int const,data::ReliquaryMainPropGuaranteeExcelConfig>,false,false>::operator++(&__for_begin);
  }
  *(_DWORD *)(v2 + 80) = *(_DWORD *)(v2 + 32);
  if ( std::optional<PlayerItemComp::generateReliquaryMainPropId(unsigned int)::TriggeredMainPropData>::has_value((const std::optional<PlayerItemComp::generateReliquaryMainPropId(uint32_t)::TriggeredMainPropData> *const)(v2 + 144)) )
  {
    v70 = std::optional<PlayerItemComp::generateReliquaryMainPropId(unsigned int)::TriggeredMainPropData>::value((std::optional<PlayerItemComp::generateReliquaryMainPropId(uint32_t)::TriggeredMainPropData> *const)(v2 + 144));
    v71 = v70;
    if ( *(_BYTE *)(((unsigned __int64)v70 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v70 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v70 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v70);
    }
    *(_DWORD *)(v2 + 80) = v71->main_prop_id;
  }
  guarantee_data_ptr = common::tools::MiscUtils::findMapValuePointer<std::map<unsigned int,ReliquaryMainPropGuaranteeData>>(
                         (std::map<unsigned int,ReliquaryMainPropGuaranteeData> *)(v2 + 176),
                         (const std::map<unsigned int,ReliquaryMainPropGuaranteeData>::key_type *)(v2 + 80));
  if ( guarantee_data_ptr )
  {
    v79 = (*(_BYTE *)(((unsigned __int64)guarantee_data_ptr >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((unsigned __int8)guarantee_data_ptr & 7) + 3) >= *(_BYTE *)(((unsigned __int64)guarantee_data_ptr >> 3) + 0x7FFF8000));
    if ( (_BYTE)v79 )
      __asan_report_store4(guarantee_data_ptr, ((unsigned __int8)guarantee_data_ptr & 7u) + 3, v79);
    guarantee_data_ptr->miss_count = 0;
    if ( std::optional<PlayerItemComp::generateReliquaryMainPropId(unsigned int)::TriggeredMainPropData>::has_value((const std::optional<PlayerItemComp::generateReliquaryMainPropId(uint32_t)::TriggeredMainPropData> *const)(v2 + 144)) )
    {
      guarantee_config_ptr = data::ReliquaryExcelConfigMgrBase::findReliquaryMainPropGuaranteeExcelConfig(
                               reliquary_config_mgr,
                               *(_DWORD *)(v2 + 80));
      if ( !guarantee_config_ptr )
      {
        common::milog::MiLogStream::create(
          &v112,
          &common::milog::MiLogDefault::default_log_obj_,
          4u,
          "./src/player/item/player_item_comp.cpp",
          "generateReliquaryMainPropId",
          10415);
        v80 = common::milog::MiLogStream::operator<<<char [69],(char *[69])0>(
                &v112,
                (const char (*)[69])"findReliquaryMainPropGuaranteeExcelConfig fail! result_main_prop_id:");
        v81 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v80,
                (const unsigned int *)(v2 + 80));
        v82 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v81, (const char (*)[15])" reliquary_id:");
        v83 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v82,
                (const unsigned int *)(v2 + 96));
        v84 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
                v83,
                (const char (*)[30])" return default_main_prop_id:");
        v85 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v84,
                (const unsigned int *)(v2 + 32));
        v78 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v85, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        goto LABEL_95;
      }
      if ( *(_BYTE *)(((unsigned __int64)&guarantee_config_ptr->max_guarantee_count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)guarantee_config_ptr + 52) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&guarantee_config_ptr->max_guarantee_count >> 3)
                                                                            + 0x7FFF8000) )
      {
        __asan_report_load4(&guarantee_config_ptr->max_guarantee_count);
      }
      v86 = guarantee_config_ptr->max_guarantee_count;
      if ( *(_BYTE *)(((unsigned __int64)&guarantee_config_ptr->min_guarantee_count >> 3) + 0x7FFF8000) != 0
        && *(_BYTE *)(((unsigned __int64)&guarantee_config_ptr->min_guarantee_count >> 3) + 0x7FFF8000) <= 3 )
      {
        __asan_report_load4(&guarantee_config_ptr->min_guarantee_count);
      }
      v89 = v86;
      v87 = common::tools::RandomUtils::rand<unsigned int>(guarantee_config_ptr->min_guarantee_count, v86);
      v88 = *(_BYTE *)(((unsigned __int64)&guarantee_data_ptr->guarantee_count >> 3) + 0x7FFF8000);
      LOBYTE(v89) = v88 != 0;
      v90 = (v88 != 0) & (unsigned __int8)((char)((((_BYTE)guarantee_data_ptr + 4) & 7) + 3) >= v88);
      if ( (_BYTE)v90 )
        __asan_report_store4(&guarantee_data_ptr->guarantee_count, v89, v90);
      guarantee_data_ptr->guarantee_count = v87;
    }
    std::map<unsigned int,ReliquaryMainPropGuaranteeData>::swap(
      &guarantee_depot->main_prop_guarantee_data_map,
      (std::map<unsigned int,ReliquaryMainPropGuaranteeData> *)(v2 + 176));
    common::milog::MiLogStream::create(
      &v112,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "generateReliquaryMainPropId",
      10422);
    v91 = common::milog::MiLogStream::operator<<<char [33],(char *[33])0>(
            &v112,
            (const char (*)[33])"ReliquaryGuarantee reliquary_id:");
    v92 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v91, (const unsigned int *)(v2 + 96));
    v93 = common::milog::MiLogStream::operator<<<char [18],(char *[18])0>(v92, (const char (*)[18])" is_by_guarantee:");
    has_value = std::optional<PlayerItemComp::generateReliquaryMainPropId(unsigned int)::TriggeredMainPropData>::has_value((const std::optional<PlayerItemComp::generateReliquaryMainPropId(uint32_t)::TriggeredMainPropData> *const)(v2 + 144));
    v95 = common::milog::MiLogStream::operator<<(v93, has_value);
    v96 = common::milog::MiLogStream::operator<<<char [22],(char *[22])0>(
            v95,
            (const char (*)[22])" result_main_prop_id:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v96, (const unsigned int *)(v2 + 80));
    common::milog::MiLogStream::~MiLogStream(&v112);
    v10 = *(_DWORD *)(v2 + 80);
    goto LABEL_111;
  }
  common::milog::MiLogStream::create(
    &v112,
    &common::milog::MiLogDefault::default_log_obj_,
    4u,
    "./src/player/item/player_item_comp.cpp",
    "generateReliquaryMainPropId",
    10404);
  v72 = common::milog::MiLogStream::operator<<<char [47],(char *[47])0>(
          &v112,
          (const char (*)[47])"guarantee_data not found! result_main_prop_id:");
  v73 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v72, (const unsigned int *)(v2 + 80));
  v74 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v73, (const char (*)[15])" reliquary_id:");
  v75 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v74, (const unsigned int *)(v2 + 96));
  v76 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(
          v75,
          (const char (*)[30])" return default_main_prop_id:");
  v77 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v76, (const unsigned int *)(v2 + 32));
  v78 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v77, (const char (*)[9])" player:");
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
LABEL_95:
  operator<<(v78, this->player_);
  common::milog::MiLogStream::~MiLogStream(&v112);
  v10 = *(_DWORD *)(v2 + 32);
LABEL_111:
  std::map<unsigned int,ReliquaryMainPropGuaranteeData>::~map((std::map<unsigned int,ReliquaryMainPropGuaranteeData> *const)(v2 + 176));
LABEL_112:
  result = v10;
  if ( v113 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8010) = 0LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF801C) = 0;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 10346: range 0000000017D1C42A-0000000017D1C614
bool __cdecl PlayerItemComp::generateReliquaryMainPropId(unsigned int)::TriggeredMainPropData::isBetterThan(
        const PlayerItemComp::generateReliquaryMainPropId::TriggeredMainPropData *const this,
        const PlayerItemComp::generateReliquaryMainPropId::TriggeredMainPropData *rhs)
{
  uint32_t delta_guarantee_count; // ecx
  uint32_t guarantee_count; // ecx
  uint32_t main_prop_id; // ecx

  if ( *(_BYTE *)(((unsigned __int64)&this->delta_guarantee_count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->delta_guarantee_count >> 3)
                                                       + 0x7FFF8000) )
  {
    __asan_report_load4(&this->delta_guarantee_count);
  }
  delta_guarantee_count = this->delta_guarantee_count;
  if ( *(_BYTE *)(((unsigned __int64)&rhs->delta_guarantee_count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)rhs + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&rhs->delta_guarantee_count >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&rhs->delta_guarantee_count);
  }
  if ( delta_guarantee_count != rhs->delta_guarantee_count )
    return this->delta_guarantee_count > rhs->delta_guarantee_count;
  if ( *(_BYTE *)(((unsigned __int64)&this->guarantee_count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)this + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&this->guarantee_count >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&this->guarantee_count);
  }
  guarantee_count = this->guarantee_count;
  if ( *(_BYTE *)(((unsigned __int64)&rhs->guarantee_count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)rhs + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&rhs->guarantee_count >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&rhs->guarantee_count);
  }
  if ( guarantee_count != rhs->guarantee_count )
    return this->guarantee_count > rhs->guarantee_count;
  if ( *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)this & 7) + 3) >= *(_BYTE *)(((unsigned __int64)this >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(this);
  }
  main_prop_id = this->main_prop_id;
  if ( *(_BYTE *)(((unsigned __int64)rhs >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)rhs & 7) + 3) >= *(_BYTE *)(((unsigned __int64)rhs >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(rhs);
  }
  return main_prop_id != rhs->main_prop_id && this->main_prop_id < rhs->main_prop_id;
};

// Line 10427: range 0000000017D1DCF6-0000000017D1DDE1
void __fastcall PlayerItemComp::clearReliquaryGuaranteeDepotByGm(
        PlayerItemComp *const this,
        uint32_t guarantee_depot_id)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  char v5[96]; // [rsp+10h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v5;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 24 guarantee_depot_id:10426";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::clearReliquaryGuaranteeDepotByGm;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = guarantee_depot_id;
  if ( *(_DWORD *)(v2 + 32) )
    std::map<unsigned int,ReliquaryGuaranteeDepot>::erase(
      &this->reliquary_guarantee_depot_map_,
      (const std::map<unsigned int,ReliquaryGuaranteeDepot>::key_type *)(v2 + 32));
  else
    std::map<unsigned int,ReliquaryGuaranteeDepot>::clear(&this->reliquary_guarantee_depot_map_);
  if ( v5 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 10439: range 0000000017D1DDE2-0000000017D1DEFB
ReliquaryGuaranteeDepot *__fastcall PlayerItemComp::getReliquaryGuaranteeDepotByGm(
        PlayerItemComp *const this,
        uint32_t guarantee_depot_id)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  char *v5; // rsi
  uint32_t v6; // ecx
  char v7; // al
  ReliquaryGuaranteeDepot *result; // rax
  std::map<unsigned int,ReliquaryGuaranteeDepot>::mapped_type *guarantee_depot; // [rsp+18h] [rbp-68h]
  char v10[96]; // [rsp+20h] [rbp-60h] BYREF

  v2 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_0(64LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "1 32 4 24 guarantee_depot_id:10438";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::getReliquaryGuaranteeDepotByGm;
  v4 = v2 >> 3;
  *(_DWORD *)(v4 + 2147450880) = -235802127;
  *(_DWORD *)(v4 + 2147450884) = -202116348;
  *(_DWORD *)(v2 + 32) = guarantee_depot_id;
  v5 = (char *)(v2 + 32);
  guarantee_depot = std::map<unsigned int,ReliquaryGuaranteeDepot>::operator[](
                      &this->reliquary_guarantee_depot_map_,
                      (const std::map<unsigned int,ReliquaryGuaranteeDepot>::key_type *)(v2 + 32));
  v6 = *(_DWORD *)(v2 + 32);
  v7 = *(_BYTE *)(((unsigned __int64)guarantee_depot >> 3) + 0x7FFF8000);
  if ( v7 != 0 && v7 <= 3 )
  {
    LOBYTE(v5) = v7 != 0;
    __asan_report_store4(guarantee_depot, v5, guarantee_depot);
  }
  guarantee_depot->guarantee_depot_id = v6;
  result = guarantee_depot;
  if ( v10 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 10447: range 0000000017D1DEFC-0000000017D1E3D4
int32_t __cdecl PlayerItemComp::destroyItemAndReturnMaterial(
        PlayerItemComp *const this,
        const std::vector<long unsigned int> *guid_vec,
        const std::vector<unsigned int> *count_vec,
        std::vector<ItemParam> *add_item_param_rlt_vec)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rdx
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rdx
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // r14
  int32_t v14; // r14d
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  int32_t result; // eax
  unsigned int val; // [rsp+2Ch] [rbp-154h] BYREF
  common::milog::MiLogStream v23; // [rsp+30h] [rbp-150h] BYREF
  char v24[304]; // [rsp+50h] [rbp-130h] BYREF

  v4 = (unsigned __int64)v24;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(256LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "4 48 4 9 ret:10452 64 24 24 add_item_param_vec:10449 128 24 24 sub_item_param_vec:10450 192 24 1"
                        "8 sub_guid_vec:10451";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::destroyItemAndReturnMaterial;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556943;
  v6[536862722] = -234881024;
  v6[536862723] = -218959118;
  v6[536862724] = -234881024;
  v6[536862725] = -218959118;
  v6[536862726] = -218103808;
  v6[536862727] = -202116109;
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 64));
  std::vector<ItemParam>::vector((std::vector<ItemParam> *const)(v4 + 128));
  std::vector<unsigned long>::vector((std::vector<long unsigned int> *const)(v4 + 192));
  *(_DWORD *)(v4 + 48) = PlayerItemComp::validDestroyMaterial(
                           this,
                           guid_vec,
                           count_vec,
                           (std::vector<ItemParam> *)(v4 + 64),
                           (std::vector<ItemParam> *)(v4 + 128),
                           (std::vector<long unsigned int> *)(v4 + 192));
  if ( *(_DWORD *)(v4 + 48) )
  {
    common::milog::MiLogStream::create(
      &v23,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "destroyItemAndReturnMaterial",
      10455);
    v7 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(&v23, (const char (*)[44])byte_2639D7E0);
    v8 = common::milog::MiLogStream::operator<<<int,(int *)0>(v7, (const int *)(v4 + 48));
    v9 = common::milog::MiLogStream::operator<<<char [11],(char *[11])0>(v8, (const char (*)[11])" guid_vec:");
    v10 = common::milog::MiLogStream::operator<<<unsigned long>(v9, guid_vec);
    v11 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v10, (const char (*)[12])" count_vec:");
    v12 = common::milog::MiLogStream::operator<<<unsigned int>(v11, count_vec);
    v13 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v12, (const char (*)[6])" uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
LABEL_7:
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, &val);
    common::milog::MiLogStream::~MiLogStream(&v23);
    v14 = *(_DWORD *)(v4 + 48);
    goto LABEL_13;
  }
  *(_DWORD *)(v4 + 48) = PlayerItemComp::DestroyMaterial(
                           this,
                           (const std::vector<ItemParam> *)(v4 + 128),
                           (const std::vector<long unsigned int> *)(v4 + 192));
  if ( *(_DWORD *)(v4 + 48) )
  {
    common::milog::MiLogStream::create(
      &v23,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "destroyItemAndReturnMaterial",
      10464);
    v15 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(&v23, (const char (*)[26])byte_2639D8C0);
    v16 = common::milog::MiLogStream::operator<<<int,(int *)0>(v15, (const int *)(v4 + 48));
    v17 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
            v16,
            (const char (*)[21])" sub_item_param_vec:");
    v18 = common::milog::MiLogStream::operator<<<ItemParam>(v17, (const std::vector<ItemParam> *)(v4 + 128));
    v13 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v18, (const char (*)[6])" uid:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    goto LABEL_7;
  }
  PlayerItemComp::returnMaterial(this, (const std::vector<ItemParam> *)(v4 + 64), add_item_param_rlt_vec);
  v14 = 0;
LABEL_13:
  std::vector<unsigned long>::~vector((std::vector<long unsigned int> *const)(v4 + 192));
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 128));
  std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v4 + 64));
  result = v14;
  if ( v24 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 10478: range 0000000017D1E3D6-0000000017D1E4F7
int32_t __cdecl PlayerItemComp::DestroyMaterial(
        PlayerItemComp *const this,
        const std::vector<ItemParam> *sub_item_param_vec,
        const std::vector<long unsigned int> *sub_guid_vec)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  unsigned __int64 v5; // r12
  int32_t result; // eax
  int ret; // [rsp+2Ch] [rbp-64h]
  int reta; // [rsp+2Ch] [rbp-64h]
  char v10[96]; // [rsp+30h] [rbp-60h] BYREF

  v3 = (unsigned __int64)v10;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_0(64LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "1 32 8 16 sub_reason:10479";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::DestroyMaterial;
  v5 = v3 >> 3;
  *(_DWORD *)(v5 + 2147450880) = -235802127;
  *(_DWORD *)(v5 + 2147450884) = -202116352;
  SubItemReason::SubItemReason((SubItemReason *const)(v3 + 32), ACTION_REASON_DESTROY_MATERIAL);
  ret = PlayerItemComp::subItemBatch(this, sub_item_param_vec, (const SubItemReason *)(v3 + 32));
  if ( ret )
  {
    result = ret;
  }
  else
  {
    reta = PlayerItemComp::subItemBatch(this, sub_guid_vec, (const SubItemReason *)(v3 + 32));
    if ( reta )
      result = reta;
    else
      result = 0;
  }
  if ( v10 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 10492: range 0000000017D1E4F8-0000000017D1EBA8
void __cdecl PlayerItemComp::returnMaterial(
        PlayerItemComp *const this,
        const std::vector<ItemParam> *add_item_param_vec,
        std::vector<ItemParam> *add_item_param_rlt_vec)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  std::initializer_list<ItemParam>::size_type v6; // rdx
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // rax
  common::milog::MiLogStream *v16; // rax
  common::milog::MiLogStream *v17; // rax
  common::milog::MiLogStream *v18; // rax
  ItemParam *__last; // [rsp+8h] [rbp-188h]
  common::milog::MiLogStream *__first; // [rsp+10h] [rbp-180h]
  ItemParam *__firstb; // [rsp+10h] [rbp-180h]
  common::milog::MiLogStream *__firsta; // [rsp+10h] [rbp-180h]
  std::allocator<ItemParam> __a; // [rsp+3Bh] [rbp-155h] BYREF
  unsigned int val; // [rsp+3Ch] [rbp-154h] BYREF
  std::vector<ItemParam>::const_iterator __for_begin; // [rsp+40h] [rbp-150h] BYREF
  std::vector<ItemParam>::const_iterator __for_end; // [rsp+48h] [rbp-148h] BYREF
  __gnu_cxx::__normal_iterator<ItemParam*,std::vector<ItemParam> > __i; // [rsp+50h] [rbp-140h] BYREF
  __gnu_cxx::__normal_iterator<const ItemParam*,std::vector<ItemParam> > __position; // [rsp+58h] [rbp-138h] BYREF
  const std::vector<ItemParam> *__for_range; // [rsp+60h] [rbp-130h]
  const ItemParam *param; // [rsp+68h] [rbp-128h]
  std::initializer_list<ItemParam> __l; // [rsp+70h] [rbp-120h] BYREF
  common::milog::MiLogStream v33; // [rsp+80h] [rbp-110h] BYREF
  char v34[240]; // [rsp+A0h] [rbp-F0h] BYREF

  v3 = (unsigned __int64)v34;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(192LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "3 48 4 9 ret:10499 64 24 19 action_reason:10496 128 24 20 item_param_vec:10503";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::returnMaterial;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -234881024;
  v5[536862723] = -218959118;
  v5[536862724] = -218103808;
  v5[536862725] = -202116109;
  __for_range = add_item_param_vec;
  __for_begin._M_current = std::vector<ItemParam>::begin(add_item_param_vec)._M_current;
  __for_end._M_current = std::vector<ItemParam>::end(add_item_param_vec)._M_current;
  while ( __gnu_cxx::operator!=<ItemParam const*,std::vector<ItemParam>>(&__for_begin, &__for_end) )
  {
    param = __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator*(&__for_begin);
    ActionReason::ActionReason(
      (ActionReason *const)(v3 + 64),
      ACTION_REASON_DESTROY_MATERIAL,
      ITEM_LIMIT_DESTROY_RETURN_MATERIAL);
    *(_BYTE *)(v3 + 78) = 0;
    *(_DWORD *)(v3 + 48) = PlayerItemComp::checkAddItem(this, param, (const ActionReason *)(v3 + 64));
    if ( *(_DWORD *)(v3 + 48) )
    {
      if ( ((unsigned __int8)param & 7) >= *(_BYTE *)(((unsigned __int64)param >> 3) + 0x7FFF8000)
        && *(_BYTE *)(((unsigned __int64)param >> 3) + 0x7FFF8000) != 0
        || *(_BYTE *)((((unsigned __int64)&param->promote_level + 3) >> 3) + 0x7FFF8000) != 0
        && (((unsigned __int8)param + 15) & 7) >= *(_BYTE *)((((unsigned __int64)&param->promote_level + 3) >> 3)
                                                           + 0x7FFF8000) )
      {
        __asan_report_load_n(param, 16LL);
      }
      v6 = *(_QWORD *)&param->level;
      __l._M_array = *(std::initializer_list<ItemParam>::iterator *)&param->item_id;
      __l._M_len = v6;
      std::allocator<ItemParam>::allocator(&__a);
      std::vector<ItemParam>::vector(
        (std::vector<ItemParam> *const)(v3 + 128),
        (std::initializer_list<ItemParam>)__PAIR128__(1LL, &__l),
        &__a);
      std::allocator<ItemParam>::~allocator(&__a);
      *(_DWORD *)(v3 + 48) = PlayerItemComp::addMaterialBatchWithStackLimit(
                               this,
                               (std::vector<ItemParam> *)(v3 + 128),
                               (const ActionReason *)(v3 + 64),
                               0LL);
      if ( *(_DWORD *)(v3 + 48) )
      {
        common::milog::MiLogStream::create(
          &v33,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "returnMaterial",
          10507);
        v7 = common::milog::MiLogStream::operator<<<char [65],(char *[65])0>(&v33, (const char (*)[65])byte_2639DA00);
        v8 = common::milog::MiLogStream::operator<<<int,(int *)0>(v7, (const int *)(v3 + 48));
        v9 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v8, (const char (*)[10])" item_id:");
        v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, &param->item_id);
        v11 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v10, (const char (*)[8])" count:");
        v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &param->count);
        __first = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v12, (const char (*)[6])" uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(__first, &val);
        common::milog::MiLogStream::~MiLogStream(&v33);
      }
      else
      {
        __last = std::vector<ItemParam>::end((std::vector<ItemParam> *const)(v3 + 128))._M_current;
        __firstb = std::vector<ItemParam>::begin((std::vector<ItemParam> *const)(v3 + 128))._M_current;
        __i._M_current = std::vector<ItemParam>::end(add_item_param_rlt_vec)._M_current;
        __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::__normal_iterator<ItemParam*>(
          &__position,
          &__i);
        std::vector<ItemParam>::insert<__gnu_cxx::__normal_iterator<ItemParam*,std::vector<ItemParam>>,void>(
          add_item_param_rlt_vec,
          __position,
          (__gnu_cxx::__normal_iterator<ItemParam*,std::vector<ItemParam> >)__firstb,
          (__gnu_cxx::__normal_iterator<ItemParam*,std::vector<ItemParam> >)__last);
      }
      std::vector<ItemParam>::~vector((std::vector<ItemParam> *const)(v3 + 128));
    }
    else
    {
      *(_DWORD *)(v3 + 48) = PlayerItemComp::addItem(this, param, (const ActionReason *)(v3 + 64), 0LL);
      if ( *(_DWORD *)(v3 + 48) )
      {
        common::milog::MiLogStream::create(
          &v33,
          &common::milog::MiLogDefault::default_log_obj_,
          1u,
          "./src/player/item/player_item_comp.cpp",
          "returnMaterial",
          10522);
        v13 = common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(&v33, (const char (*)[26])byte_2639DA80);
        v14 = common::milog::MiLogStream::operator<<<int,(int *)0>(v13, (const int *)(v3 + 48));
        v15 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(v14, (const char (*)[10])" item_id:");
        v16 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v15, &param->item_id);
        v17 = common::milog::MiLogStream::operator<<<char [8],(char *[8])0>(v16, (const char (*)[8])" count:");
        v18 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v17, &param->count);
        __firsta = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v18, (const char (*)[6])" uid:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        val = Player::getUid(this->player_);
        common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(__firsta, &val);
        common::milog::MiLogStream::~MiLogStream(&v33);
      }
      else
      {
        std::vector<ItemParam>::push_back(add_item_param_rlt_vec, param);
      }
    }
    __gnu_cxx::__normal_iterator<ItemParam const*,std::vector<ItemParam>>::operator++(&__for_begin);
  }
  if ( v34 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0LL;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 10536: range 0000000017D1EBAA-0000000017D1F6F3
int32_t __cdecl PlayerItemComp::validDestroyMaterial(
        PlayerItemComp *const this,
        const std::vector<long unsigned int> *guid_vec,
        const std::vector<unsigned int> *count_vec,
        std::vector<ItemParam> *add_item_param_vec,
        std::vector<ItemParam> *sub_item_param_vec,
        std::vector<long unsigned int> *sub_guid_vec)
{
  int v6; // r14d
  unsigned __int64 v7; // r13
  __int64 v8; // rax
  _DWORD *v9; // r12
  std::vector<long unsigned int>::size_type v10; // r15
  common::milog::MiLogStream *v11; // r15
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // r15
  common::milog::MiLogStream *v14; // rax
  common::milog::MiLogStream *v15; // r15
  std::vector<long unsigned int>::size_type v16; // r15
  std::vector<unsigned int>::size_type v17; // r15
  std::vector<long unsigned int>::const_reference v18; // rax
  std::vector<unsigned int>::const_reference v19; // rax
  _DWORD *v20; // rdx
  common::milog::MiLogStream *v21; // rax
  common::milog::MiLogStream *v22; // rax
  common::milog::MiLogStream *v23; // r14
  int v24; // r15d
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v25; // rax
  unsigned __int64 v26; // rdx
  common::milog::MiLogStream *v27; // rax
  common::milog::MiLogStream *v28; // rax
  common::milog::MiLogStream *v29; // r14
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v30; // rax
  unsigned __int64 v31; // rdx
  common::milog::MiLogStream *v32; // rax
  uint32_t v33; // r15d
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v34; // rax
  unsigned __int64 v35; // rdx
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v36; // rax
  unsigned __int64 v37; // rdx
  char v38; // al
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v39; // rax
  int32_t result; // eax
  unsigned int v45; // [rsp+40h] [rbp-170h] BYREF
  unsigned int val; // [rsp+44h] [rbp-16Ch] BYREF
  uint32_t i; // [rsp+48h] [rbp-168h]
  int ret_0; // [rsp+4Ch] [rbp-164h]
  int ret_1; // [rsp+50h] [rbp-160h]
  int ret; // [rsp+54h] [rbp-15Ch]
  std::map<unsigned int,unsigned int>::iterator __for_begin; // [rsp+58h] [rbp-158h] BYREF
  std::map<unsigned int,unsigned int> *__for_range; // [rsp+60h] [rbp-150h]
  std::pair<unsigned int const,unsigned int> *__in; // [rsp+68h] [rbp-148h]
  std::tuple_element<0,std::pair<unsigned int const,unsigned int> >::type *id; // [rsp+70h] [rbp-140h]
  std::tuple_element<1,std::pair<unsigned int const,unsigned int> >::type *count; // [rsp+78h] [rbp-138h]
  common::milog::MiLogStream v56; // [rsp+80h] [rbp-130h] BYREF
  char v57[272]; // [rsp+A0h] [rbp-110h] BYREF

  v7 = (unsigned __int64)v57;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v8 = __asan_stack_malloc_2(224LL);
    if ( v8 )
      v7 = v8;
  }
  *(_QWORD *)v7 = 1102416563LL;
  *(_QWORD *)(v7 + 8) = "5 32 4 11 count:10553 48 8 10 guid:10552 80 16 14 item_ptr:10561 112 16 11 param:10610 144 48 34"
                        " return_material_id_count_map:10543";
  *(_QWORD *)(v7 + 16) = PlayerItemComp::validDestroyMaterial;
  v9 = (_DWORD *)(v7 >> 3);
  v9[536862720] = -235802127;
  v9[536862721] = 61956;
  v9[536862721] = -234881024;
  v9[536862722] = 62194;
  v9[536862723] = 62194;
  v9[536862724] = 62194;
  v9[536862726] = -202116109;
  v10 = std::vector<unsigned long>::size(guid_vec);
  if ( v10 != std::vector<unsigned int>::size(count_vec) )
  {
    common::milog::MiLogStream::create(
      &v56,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "validDestroyMaterial",
      10539);
    v11 = common::milog::MiLogStream::operator<<<char [95],(char *[95])0>(&v56, (const char (*)[95])byte_2639DBA0);
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, &val);
    v13 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(v12, (const char (*)[16])" guid_vec.size:");
    __for_begin._M_node = (std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int> >::_Base_ptr)std::vector<unsigned long>::size(guid_vec);
    v14 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
            v13,
            (const unsigned __int64 *)&__for_begin);
    v15 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v14, (const char (*)[17])" count_vec.size:");
    *(_QWORD *)(v7 + 48) = std::vector<unsigned int>::size(count_vec);
    common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(v15, (const unsigned __int64 *)(v7 + 48));
    common::milog::MiLogStream::~MiLogStream(&v56);
  }
  std::map<unsigned int,unsigned int>::map((std::map<unsigned int,unsigned int> *const)(v7 + 144));
  for ( i = 0; ; ++i )
  {
    v16 = i;
    if ( v16 >= std::vector<unsigned long>::size(guid_vec) )
      break;
    v17 = i;
    if ( v17 >= std::vector<unsigned int>::size(count_vec) )
    {
      v6 = -1;
      goto LABEL_68;
    }
    v18 = std::vector<unsigned long>::operator[](guid_vec, i);
    if ( *(_BYTE *)(((unsigned __int64)v18 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    *(_QWORD *)(v7 + 48) = *v18;
    v19 = std::vector<unsigned int>::operator[](count_vec, i);
    v20 = v19;
    if ( *(_BYTE *)(((unsigned __int64)v19 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v19 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v19 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v19);
    }
    *(_DWORD *)(v7 + 32) = *v20;
    if ( !*(_DWORD *)(v7 + 32) )
    {
      v6 = 647;
      goto LABEL_68;
    }
    PlayerItemComp::findItemInPack((PlayerItemComp *const)(v7 + 80), (uint64_t)this);
    if ( std::operator==<Item>((const std::shared_ptr<Item> *)(v7 + 80), 0LL) )
    {
      common::milog::MiLogStream::create(
        &v56,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "validDestroyMaterial",
        10564);
      v21 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(&v56, (const char (*)[27])byte_2639DCA0);
      v22 = common::milog::MiLogStream::operator<<<unsigned long,(unsigned long *)0>(
              v21,
              (const unsigned __int64 *)(v7 + 48));
      v23 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v22, (const char (*)[6])" uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
LABEL_21:
      val = Player::getUid(this->player_);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v23, &val);
      common::milog::MiLogStream::~MiLogStream(&v56);
      v6 = -1;
      v24 = 0;
      goto LABEL_52;
    }
    v25 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 80));
    if ( *(_BYTE *)(((unsigned __int64)v25 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v26 = (unsigned __int64)(v25->_vptr_Item + 8);
    if ( *(_BYTE *)((v26 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    if ( (*(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v26)(v25) < *(_DWORD *)(v7 + 32) )
    {
      common::milog::MiLogStream::create(
        &v56,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "validDestroyMaterial",
        10571);
      v27 = common::milog::MiLogStream::operator<<<char [44],(char *[44])0>(&v56, (const char (*)[44])byte_2639DCE0);
      v28 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v27, (const unsigned int *)(v7 + 32));
      v29 = common::milog::MiLogStream::operator<<<char [17],(char *[17])0>(v28, (const char (*)[17])byte_2639DD40);
      v30 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 80));
      if ( *(_BYTE *)(((unsigned __int64)v30 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v31 = (unsigned __int64)(v30->_vptr_Item + 8);
      if ( *(_BYTE *)((v31 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v45 = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v31)(v30);
      v32 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v29, &v45);
      v23 = common::milog::MiLogStream::operator<<<char [6],(char *[6])0>(v32, (const char (*)[6])" uid:");
      if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      goto LABEL_21;
    }
    v33 = *(_DWORD *)(v7 + 32);
    std::shared_ptr<Item>::shared_ptr(
      (std::shared_ptr<Item> *const)(v7 + 112),
      (const std::shared_ptr<Item> *)(v7 + 80));
    ret = PlayerItemComp::calcItemReturnMaterial(
            this,
            (ItemPtr *)(v7 + 112),
            v33,
            (std::map<unsigned int,unsigned int> *)(v7 + 144));
    std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v7 + 112));
    if ( ret )
    {
      v6 = ret;
      v24 = 0;
    }
    else
    {
      v34 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 80));
      if ( *(_BYTE *)(((unsigned __int64)v34 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v35 = (unsigned __int64)(v34->_vptr_Item + 9);
      if ( *(_BYTE *)((v35 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      if ( (*(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v35)(v34) == 3 )
        goto LABEL_46;
      v36 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 80));
      if ( *(_BYTE *)(((unsigned __int64)v36 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      v37 = (unsigned __int64)(v36->_vptr_Item + 9);
      if ( *(_BYTE *)((v37 >> 3) + 0x7FFF8000) )
        __asan_report_load8();
      if ( (*(unsigned int (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v37)(v36) == 4 )
LABEL_46:
        v38 = 1;
      else
        v38 = 0;
      if ( v38 )
      {
        std::vector<unsigned long>::emplace_back<unsigned long &>(
          sub_guid_vec,
          (unsigned __int64 *)(v7 + 48),
          (unsigned __int64 *)(v7 + 48));
      }
      else
      {
        *(_QWORD *)(v7 + 112) = 0LL;
        *(_QWORD *)(v7 + 120) = 0LL;
        v39 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)(v7 + 80));
        *(_DWORD *)(v7 + 112) = Item::getItemId(v39);
        *(_DWORD *)(v7 + 116) = *(_DWORD *)(v7 + 32);
        std::vector<ItemParam>::emplace_back<ItemParam&>(
          sub_item_param_vec,
          (ItemParam *)(v7 + 112),
          (ItemParam *)(v7 + 112));
      }
      v24 = 1;
    }
LABEL_52:
    std::shared_ptr<Item>::~shared_ptr((std::shared_ptr<Item> *const)(v7 + 80));
    if ( v24 != 1 )
      goto LABEL_68;
  }
  if ( !std::vector<ItemParam>::empty(sub_item_param_vec)
    && (ret_0 = PlayerItemComp::checkSubItemBatch(this, sub_item_param_vec)) != 0 )
  {
    v6 = ret_0;
  }
  else if ( !std::vector<unsigned long>::empty(sub_guid_vec)
         && (ret_1 = PlayerItemComp::checkSubItemBatch(this, sub_guid_vec)) != 0 )
  {
    v6 = ret_1;
  }
  else
  {
    __for_range = (std::map<unsigned int,unsigned int> *)(v7 + 144);
    __for_begin._M_node = std::map<unsigned int,unsigned int>::begin((std::map<unsigned int,unsigned int> *const)(v7 + 144))._M_node;
    *(std::map<unsigned int,unsigned int>::iterator *)(v7 + 48) = std::map<unsigned int,unsigned int>::end(__for_range);
    while ( std::operator!=(
              &__for_begin,
              (const std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int> >::_Self *)(v7 + 48)) )
    {
      __in = std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int>>::operator*(&__for_begin);
      id = std::get<0ul,unsigned int const,unsigned int>(__in);
      count = std::get<1ul,unsigned int const,unsigned int>(__in);
      *(_QWORD *)(v7 + 112) = 0LL;
      *(_QWORD *)(v7 + 120) = 0LL;
      if ( *(_BYTE *)(((unsigned __int64)id >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)id & 7) + 3) >= *(_BYTE *)(((unsigned __int64)id >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(id);
      }
      *(_DWORD *)(v7 + 112) = *id;
      if ( *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)count >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(count);
      }
      *(_DWORD *)(v7 + 116) = *count;
      std::vector<ItemParam>::emplace_back<ItemParam&>(
        add_item_param_vec,
        (ItemParam *)(v7 + 112),
        (ItemParam *)(v7 + 112));
      std::_Rb_tree_iterator<std::pair<unsigned int const,unsigned int>>::operator++(&__for_begin);
    }
    v6 = 0;
  }
LABEL_68:
  std::map<unsigned int,unsigned int>::~map((std::map<unsigned int,unsigned int> *const)(v7 + 144));
  result = v6;
  if ( v57 == (char *)v7 )
  {
    *(_QWORD *)((v7 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v7 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v7 >> 3) + 0x7FFF8010) = 0;
    *(_DWORD *)((v7 >> 3) + 0x7FFF8018) = 0;
  }
  else
  {
    *(_QWORD *)v7 = 1172321806LL;
    *(_QWORD *)((v7 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v7 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v7 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v7 >> 3) + 0x7FFF8018) = -168430091;
  }
  return result;
};

// Line 10618: range 0000000017D1F6F4-0000000017D1FB97
int32_t __cdecl PlayerItemComp::calcItemReturnMaterial(
        PlayerItemComp *const this,
        ItemPtr *p_item_ptr,
        uint32_t return_multi,
        std::map<unsigned int,unsigned int> *return_material_id_count_map)
{
  unsigned __int64 v4; // r13
  __int64 v5; // rax
  _DWORD *v6; // r12
  common::milog::MiLogStream *v7; // r14
  int v8; // r14d
  std::vector<unsigned int>::size_type v9; // r14
  std::vector<unsigned int>::reference v10; // rax
  unsigned int *v11; // rdx
  unsigned int v12; // r14d
  const std::map<unsigned int,unsigned int>::key_type *v13; // rdx
  std::map<unsigned int,unsigned int>::mapped_type *v14; // rax
  unsigned int *v15; // rdx
  SelectType v16; // r14d
  const std::map<unsigned int,unsigned int>::key_type *v17; // rsi
  std::map<unsigned int,unsigned int>::mapped_type *v18; // rax
  SelectType *v19; // rdx
  char v20; // cl
  int32_t result; // eax
  unsigned int val; // [rsp+24h] [rbp-10Ch] BYREF
  uint32_t i; // [rsp+28h] [rbp-108h]
  int ret; // [rsp+2Ch] [rbp-104h]
  std::shared_ptr<Item> v27; // [rsp+30h] [rbp-100h] BYREF
  common::milog::MiLogStream v28; // [rsp+40h] [rbp-F0h] BYREF
  char v29[208]; // [rsp+60h] [rbp-D0h] BYREF

  v4 = (unsigned __int64)v29;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_2(160LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "2 32 24 19 return_id_vec:10619 96 24 22 return_count_vec:10619";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::calcItemReturnMaterial;
  v6 = (_DWORD *)(v4 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234881024;
  v6[536862722] = -218959118;
  v6[536862723] = -218103808;
  v6[536862724] = -202116109;
  std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v4 + 32));
  std::vector<unsigned int>::vector((std::vector<unsigned int> *const)(v4 + 96));
  std::shared_ptr<Item>::shared_ptr(&v27, p_item_ptr);
  ret = PlayerItemComp::getDestroyReturnMaterial(
          this,
          &v27,
          (std::vector<unsigned int> *)(v4 + 32),
          (std::vector<unsigned int> *)(v4 + 96));
  std::shared_ptr<Item>::~shared_ptr(&v27);
  if ( ret )
  {
    common::milog::MiLogStream::create(
      &v28,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "calcItemReturnMaterial",
      10623);
    v7 = common::milog::MiLogStream::operator<<<char [38],(char *[38])0>(&v28, (const char (*)[38])byte_2639DE00);
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    val = Player::getUid(this->player_);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, &val);
    common::milog::MiLogStream::~MiLogStream(&v28);
    v8 = ret;
  }
  else
  {
    v9 = std::vector<unsigned int>::size((const std::vector<unsigned int> *const)(v4 + 32));
    if ( v9 == std::vector<unsigned int>::size((const std::vector<unsigned int> *const)(v4 + 96)) )
    {
      for ( i = 0; i < std::vector<unsigned int>::size((const std::vector<unsigned int> *const)(v4 + 96)); ++i )
      {
        if ( i >= std::vector<unsigned int>::size((const std::vector<unsigned int> *const)(v4 + 32)) )
        {
          v8 = -1;
          goto LABEL_22;
        }
        v10 = std::vector<unsigned int>::operator[]((std::vector<unsigned int> *const)(v4 + 96), i);
        v11 = v10;
        if ( *(_BYTE *)(((unsigned __int64)v10 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v10 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v10 >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(v10);
        }
        v12 = SAFE_MULTIPLY<unsigned int,unsigned int>(*v11, return_multi);
        v13 = std::vector<unsigned int>::operator[]((std::vector<unsigned int> *const)(v4 + 32), i);
        v14 = std::map<unsigned int,unsigned int>::operator[](return_material_id_count_map, v13);
        v15 = v14;
        if ( *(_BYTE *)(((unsigned __int64)v14 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v14 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v14 >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(v14);
        }
        v16 = SAFE_ADD<unsigned int,unsigned int>(*v15, v12);
        v17 = std::vector<unsigned int>::operator[]((std::vector<unsigned int> *const)(v4 + 32), i);
        v18 = std::map<unsigned int,unsigned int>::operator[](return_material_id_count_map, v17);
        v19 = v18;
        v20 = *(_BYTE *)(((unsigned __int64)v18 >> 3) + 0x7FFF8000);
        if ( v20 != 0 && (char)(((unsigned __int8)v18 & 7) + 3) >= v20 )
        {
          LOBYTE(v17) = v20 != 0;
          __asan_report_store4(v18, v17, v18);
        }
        *v19 = v16;
      }
      v8 = 0;
    }
    else
    {
      v8 = -1;
    }
  }
LABEL_22:
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v4 + 96));
  std::vector<unsigned int>::~vector((std::vector<unsigned int> *const)(v4 + 32));
  result = v8;
  if ( v29 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = 0;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v4 >> 3) + 0x7FFF8010) = -168430091;
  }
  return result;
};

// Line 10644: range 0000000017DB6423-0000000017DB66B7
__int64 __fastcall getReturnMaterial<data::MaterialExcelConfig const*>(
        uint32_t item_id,
        std::vector<unsigned int> *return_id_vec,
        std::vector<unsigned int> *return_count_vec,
        std::function<const data::MaterialExcelConfig* const(unsigned int)> *p_getConfFunc)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  unsigned __int64 v6; // r12
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  common::milog::MiLogStream *v9; // rax
  const data::MaterialExcelConfig *conf_ptr; // [rsp+28h] [rbp-88h]
  common::milog::MiLogStream v13; // [rsp+30h] [rbp-80h] BYREF
  char v14[96]; // [rsp+50h] [rbp-60h] BYREF

  v4 = (unsigned __int64)v14;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_0(64LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 4 13 item_id:10644";
  *(_QWORD *)(v4 + 16) = getReturnMaterial<data::MaterialExcelConfig const*>;
  v6 = v4 >> 3;
  *(_DWORD *)(v6 + 2147450880) = -235802127;
  *(_DWORD *)(v6 + 2147450884) = -202116348;
  *(_DWORD *)(v4 + 32) = item_id;
  conf_ptr = std::function<data::MaterialExcelConfig const* const ()(unsigned int)>::operator()(
               p_getConfFunc,
               *(_DWORD *)(v4 + 32));
  if ( conf_ptr )
  {
    if ( *(_BYTE *)(((unsigned __int64)&conf_ptr->destroy_rule >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&conf_ptr->destroy_rule >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&conf_ptr->destroy_rule);
    }
    if ( conf_ptr->destroy_rule == DESTROY_RETURN_MATERIAL )
    {
      std::vector<unsigned int>::operator=(return_id_vec, &conf_ptr->destroy_return_material);
      std::vector<unsigned int>::operator=(return_count_vec, &conf_ptr->destroy_return_material_count);
      result = 0LL;
    }
    else
    {
      common::milog::MiLogStream::create(
        &v13,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "getReturnMaterial",
        10655);
      v9 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(&v13, (const char (*)[30])byte_263A46A0);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 32));
      common::milog::MiLogStream::~MiLogStream(&v13);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v13,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "getReturnMaterial",
      10650);
    v7 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(&v13, (const char (*)[36])byte_263A4640);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v4 + 32));
    common::milog::MiLogStream::~MiLogStream(&v13);
    result = 0xFFFFFFFFLL;
  }
  if ( v14 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 10644: range 0000000017DB66B8-0000000017DB694C
__int64 __fastcall getReturnMaterial<data::ReliquaryExcelConfig const*>(
        uint32_t item_id,
        std::vector<unsigned int> *return_id_vec,
        std::vector<unsigned int> *return_count_vec,
        std::function<const data::ReliquaryExcelConfig* const(unsigned int)> *p_getConfFunc)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  unsigned __int64 v6; // r12
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  common::milog::MiLogStream *v9; // rax
  const data::ReliquaryExcelConfig *conf_ptr; // [rsp+28h] [rbp-88h]
  common::milog::MiLogStream v13; // [rsp+30h] [rbp-80h] BYREF
  char v14[96]; // [rsp+50h] [rbp-60h] BYREF

  v4 = (unsigned __int64)v14;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_0(64LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 4 13 item_id:10644";
  *(_QWORD *)(v4 + 16) = getReturnMaterial<data::ReliquaryExcelConfig const*>;
  v6 = v4 >> 3;
  *(_DWORD *)(v6 + 2147450880) = -235802127;
  *(_DWORD *)(v6 + 2147450884) = -202116348;
  *(_DWORD *)(v4 + 32) = item_id;
  conf_ptr = std::function<data::ReliquaryExcelConfig const* const ()(unsigned int)>::operator()(
               p_getConfFunc,
               *(_DWORD *)(v4 + 32));
  if ( conf_ptr )
  {
    if ( *(_BYTE *)(((unsigned __int64)&conf_ptr->destroy_rule >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&conf_ptr->destroy_rule >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&conf_ptr->destroy_rule);
    }
    if ( conf_ptr->destroy_rule == DESTROY_RETURN_MATERIAL )
    {
      std::vector<unsigned int>::operator=(return_id_vec, &conf_ptr->destroy_return_material);
      std::vector<unsigned int>::operator=(return_count_vec, &conf_ptr->destroy_return_material_count);
      result = 0LL;
    }
    else
    {
      common::milog::MiLogStream::create(
        &v13,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "getReturnMaterial",
        10655);
      v9 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(&v13, (const char (*)[30])byte_263A46A0);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 32));
      common::milog::MiLogStream::~MiLogStream(&v13);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v13,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "getReturnMaterial",
      10650);
    v7 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(&v13, (const char (*)[36])byte_263A4640);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v4 + 32));
    common::milog::MiLogStream::~MiLogStream(&v13);
    result = 0xFFFFFFFFLL;
  }
  if ( v14 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 10644: range 0000000017DB694D-0000000017DB6BE9
__int64 __fastcall getReturnMaterial<data::WeaponExcelConfig const*>(
        uint32_t item_id,
        std::vector<unsigned int> *return_id_vec,
        std::vector<unsigned int> *return_count_vec,
        std::function<const data::WeaponExcelConfig* const(unsigned int)> *p_getConfFunc)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  unsigned __int64 v6; // r12
  common::milog::MiLogStream *v7; // rax
  __int64 result; // rax
  common::milog::MiLogStream *v9; // rax
  const data::WeaponExcelConfig *conf_ptr; // [rsp+28h] [rbp-88h]
  common::milog::MiLogStream v13; // [rsp+30h] [rbp-80h] BYREF
  char v14[96]; // [rsp+50h] [rbp-60h] BYREF

  v4 = (unsigned __int64)v14;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_0(64LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 4 13 item_id:10644";
  *(_QWORD *)(v4 + 16) = getReturnMaterial<data::WeaponExcelConfig const*>;
  v6 = v4 >> 3;
  *(_DWORD *)(v6 + 2147450880) = -235802127;
  *(_DWORD *)(v6 + 2147450884) = -202116348;
  *(_DWORD *)(v4 + 32) = item_id;
  conf_ptr = std::function<data::WeaponExcelConfig const* const ()(unsigned int)>::operator()(
               p_getConfFunc,
               *(_DWORD *)(v4 + 32));
  if ( conf_ptr )
  {
    if ( *(_BYTE *)(((unsigned __int64)&conf_ptr->destroy_rule >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)conf_ptr - 60) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&conf_ptr->destroy_rule >> 3)
                                                              + 0x7FFF8000) )
    {
      __asan_report_load4(&conf_ptr->destroy_rule);
    }
    if ( conf_ptr->destroy_rule == DESTROY_RETURN_MATERIAL )
    {
      std::vector<unsigned int>::operator=(return_id_vec, &conf_ptr->destroy_return_material);
      std::vector<unsigned int>::operator=(return_count_vec, &conf_ptr->destroy_return_material_count);
      result = 0LL;
    }
    else
    {
      common::milog::MiLogStream::create(
        &v13,
        &common::milog::MiLogDefault::default_log_obj_,
        1u,
        "./src/player/item/player_item_comp.cpp",
        "getReturnMaterial",
        10655);
      v9 = common::milog::MiLogStream::operator<<<char [30],(char *[30])0>(&v13, (const char (*)[30])byte_263A46A0);
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v4 + 32));
      common::milog::MiLogStream::~MiLogStream(&v13);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v13,
      &common::milog::MiLogDefault::default_log_obj_,
      1u,
      "./src/player/item/player_item_comp.cpp",
      "getReturnMaterial",
      10650);
    v7 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(&v13, (const char (*)[36])byte_263A4640);
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v7, (const unsigned int *)(v4 + 32));
    common::milog::MiLogStream::~MiLogStream(&v13);
    result = 0xFFFFFFFFLL;
  }
  if ( v14 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 10666: range 0000000017D1FD2A-0000000017D1FF1A
int32_t __cdecl PlayerItemComp::getDestroyReturnMaterial(
        PlayerItemComp *const this,
        ItemPtr *p_item_ptr,
        std::vector<unsigned int> *return_id_vec,
        std::vector<unsigned int> *return_count_vec)
{
  int32_t v4; // ebx
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  unsigned __int64 v6; // rdx
  PlayerItemComp::getDestroyReturnMaterial::<lambda(uint32_t)> v7; // si
  int v8; // eax
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  uint32_t v10; // edi
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v11; // rax
  uint32_t v12; // edi
  std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v13; // rax
  uint32_t ItemId; // edi
  std::function<const data::MaterialExcelConfig* const(unsigned int)> p_getConfFunc; // [rsp+30h] [rbp-30h] BYREF

  if ( !std::operator==<Item>(p_item_ptr, 0LL) )
  {
    v5 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)p_item_ptr);
    if ( *(_BYTE *)(((unsigned __int64)v5 >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    v6 = (unsigned __int64)(v5->_vptr_Item + 9);
    v7.gap0[0] = *(_BYTE *)((v6 >> 3) + 0x7FFF8000);
    if ( v7.gap0[0] )
      __asan_report_load8();
    v8 = (*(__int64 (__fastcall **)(std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *))v6)(v5);
    if ( v8 == 4 )
    {
      std::function<data::WeaponExcelConfig const* const ()(unsigned int)>::function<PlayerItemComp::getDestroyReturnMaterial(std::shared_ptr<Item>,std::vector<unsigned int> &,std::vector<unsigned int> &)::{lambda(unsigned int)#3},void,void>(
        (std::function<const data::WeaponExcelConfig* const(unsigned int)> *const)&p_getConfFunc,
        v7);
      v13 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)p_item_ptr);
      ItemId = Item::getItemId(v13);
      v4 = getReturnMaterial<data::WeaponExcelConfig const*>(
             ItemId,
             return_id_vec,
             return_count_vec,
             (std::function<const data::WeaponExcelConfig* const(unsigned int)> *)&p_getConfFunc);
      std::function<data::WeaponExcelConfig const* const ()(unsigned int)>::~function((std::function<const data::WeaponExcelConfig* const(unsigned int)> *const)&p_getConfFunc);
      return v4;
    }
    if ( v8 <= 4 )
    {
      if ( v8 == 2 )
      {
        std::function<data::MaterialExcelConfig const* const ()(unsigned int)>::function<PlayerItemComp::getDestroyReturnMaterial(std::shared_ptr<Item>,std::vector<unsigned int> &,std::vector<unsigned int> &)::{lambda(unsigned int)#1},void,void>(
          &p_getConfFunc,
          v7);
        v9 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)p_item_ptr);
        v10 = Item::getItemId(v9);
        v4 = getReturnMaterial<data::MaterialExcelConfig const*>(v10, return_id_vec, return_count_vec, &p_getConfFunc);
        std::function<data::MaterialExcelConfig const* const ()(unsigned int)>::~function(&p_getConfFunc);
        return v4;
      }
      if ( v8 == 3 )
      {
        std::function<data::ReliquaryExcelConfig const* const ()(unsigned int)>::function<PlayerItemComp::getDestroyReturnMaterial(std::shared_ptr<Item>,std::vector<unsigned int> &,std::vector<unsigned int> &)::{lambda(unsigned int)#2},void,void>(
          (std::function<const data::ReliquaryExcelConfig* const(unsigned int)> *const)&p_getConfFunc,
          v7);
        v11 = std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Item,(__gnu_cxx::_Lock_policy)2,false,false> *const)p_item_ptr);
        v12 = Item::getItemId(v11);
        v4 = getReturnMaterial<data::ReliquaryExcelConfig const*>(
               v12,
               return_id_vec,
               return_count_vec,
               (std::function<const data::ReliquaryExcelConfig* const(unsigned int)> *)&p_getConfFunc);
        std::function<data::ReliquaryExcelConfig const* const ()(unsigned int)>::~function((std::function<const data::ReliquaryExcelConfig* const(unsigned int)> *const)&p_getConfFunc);
        return v4;
      }
    }
    return -1;
  }
  return -1;
};

// Line 10673: range 0000000017D1FB98-0000000017D1FC1C
const data::MaterialExcelConfig *__cdecl PlayerItemComp::getDestroyReturnMaterial(std::shared_ptr<Item>,std::vector<unsigned int> &,std::vector<unsigned int> &)::{lambda(unsigned int)#1}::operator()(
        const PlayerItemComp::getDestroyReturnMaterial::<lambda(uint32_t)> *const __closure,
        uint32_t id)
{
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v2; // rax
  const data::MaterialExcelConfig *MaterialExcelConfig; // rbx
  std::shared_ptr<Config> v5[2]; // [rsp+10h] [rbp-20h] BYREF

  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)v5);
  v2 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)v5);
  MaterialExcelConfig = data::MaterialExcelConfigMgrBase::findMaterialExcelConfig(
                          &v2->design_config.txt_config_mgr.material_config_mgr,
                          id);
  std::shared_ptr<Config>::~shared_ptr(v5);
  return MaterialExcelConfig;
};

// Line 10676: range 0000000017D1FC1E-0000000017D1FCA2
const data::ReliquaryExcelConfig *__cdecl PlayerItemComp::getDestroyReturnMaterial(std::shared_ptr<Item>,std::vector<unsigned int> &,std::vector<unsigned int> &)::{lambda(unsigned int)#2}::operator()(
        const PlayerItemComp::getDestroyReturnMaterial::<lambda(uint32_t)> *const __closure,
        uint32_t id)
{
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v2; // rax
  const data::ReliquaryExcelConfig *ReliquaryExcelConfig; // rbx
  std::shared_ptr<Config> v5[2]; // [rsp+10h] [rbp-20h] BYREF

  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)v5);
  v2 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)v5);
  ReliquaryExcelConfig = data::ReliquaryExcelConfigMgrBase::findReliquaryExcelConfig(
                           &v2->design_config.txt_config_mgr.reliquary_config_mgr,
                           id);
  std::shared_ptr<Config>::~shared_ptr(v5);
  return ReliquaryExcelConfig;
};

// Line 10679: range 0000000017D1FCA4-0000000017D1FD28
const data::WeaponExcelConfig *__cdecl PlayerItemComp::getDestroyReturnMaterial(std::shared_ptr<Item>,std::vector<unsigned int> &,std::vector<unsigned int> &)::{lambda(unsigned int)#3}::operator()(
        const PlayerItemComp::getDestroyReturnMaterial::<lambda(uint32_t)> *const __closure,
        uint32_t id)
{
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v2; // rax
  const data::WeaponExcelConfig *WeaponExcelConfig; // rbx
  std::shared_ptr<Config> v5[2]; // [rsp+10h] [rbp-20h] BYREF

  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)v5);
  v2 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)v5);
  WeaponExcelConfig = data::WeaponExcelConfigMgrBase::findWeaponExcelConfig(
                        &v2->design_config.txt_config_mgr.weapon_config_mgr,
                        id);
  std::shared_ptr<Config>::~shared_ptr(v5);
  return WeaponExcelConfig;
};

// Line 10686: range 0000000017D1FF1C-0000000017D20139
__int64 __fastcall PlayerItemComp::isReliquarySuitActive(
        PlayerItemComp *const this,
        uint32_t reliquary_suit_id,
        uint32_t level)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  unsigned int v5; // r12d
  _DWORD *v6; // r13
  std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int> >,std::equal_to<std::pair<unsigned int,unsigned int> >,std::allocator<std::pair<const std::pair<unsigned int,unsigned int>,std::set<data::EquipType> > > >::mapped_type *v7; // rax
  std::set<data::EquipType>::size_type v8; // r14
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  __int64 result; // rax
  std::pair<unsigned int,unsigned int> value; // [rsp+18h] [rbp-A8h] BYREF
  std::shared_ptr<Config> v13; // [rsp+20h] [rbp-A0h] BYREF
  char v14[144]; // [rsp+30h] [rbp-90h] BYREF

  v3 = (unsigned __int64)v14;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  v5 = v3 + 96;
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "2 48 4 23 reliquary_suit_id:10685 64 4 11 level:10685";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::isReliquarySuitActive;
  v6 = (_DWORD *)(v3 >> 3);
  v6[536862720] = -235802127;
  v6[536862721] = -234556943;
  v6[536862722] = -202116348;
  *(_DWORD *)(v3 + 48) = reliquary_suit_id;
  *(_DWORD *)(v3 + 64) = level;
  value = std::make_pair<unsigned int &,unsigned int &>((unsigned int *)(v3 + 48), (unsigned int *)(v3 + 64));
  if ( !common::tools::MiscUtils::isContains<std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int>>,std::equal_to<std::pair<unsigned int,unsigned int>>,std::allocator<std::pair<std::pair<unsigned int,unsigned int> const,std::set<data::EquipType>>>>,std::pair<unsigned int,unsigned int>>(
          &this->reliquary_set_map_,
          &value) )
  {
    v5 = 0;
  }
  else
  {
    value = std::make_pair<unsigned int &,unsigned int &>((unsigned int *)(v3 + 48), (unsigned int *)(v3 + 64));
    v7 = std::unordered_map<std::pair<unsigned int,unsigned int>,std::set<data::EquipType>,boost::hash<std::pair<unsigned int,unsigned int>>,std::equal_to<std::pair<unsigned int,unsigned int>>,std::allocator<std::pair<std::pair<unsigned int,unsigned int> const,std::set<data::EquipType>>>>::operator[](
           &this->reliquary_set_map_,
           &value);
    v8 = std::set<data::EquipType>::size(v7);
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v13);
    v9 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v13);
    LOBYTE(v5) = v8 >= ReliquaryExcelConfigMgr::getSuitActiveNeedEquipTypeNum(
                         &v9->design_config.txt_config_mgr.reliquary_config_mgr,
                         *(_DWORD *)(v3 + 48),
                         *(_DWORD *)(v3 + 64));
    std::shared_ptr<Config>::~shared_ptr(&v13);
  }
  result = v5;
  if ( v14 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
  return result;
};

// Line 10695: range 0000000017D2013A-0000000017D2084F
std::pair<unsigned int,unsigned int> __cdecl PlayerItemComp::getUseConfigSelectIdAndCount(
        PlayerItemComp *const this,
        const data::ItemUseConfig *use_config,
        uint32_t option_idx)
{
  unsigned __int64 v3; // r13
  __int64 v4; // rax
  _DWORD *v5; // r12
  std::pair<unsigned int,unsigned int> v6; // r14
  const std::string *v7; // rax
  bool v8; // r14
  uint32_t v9; // eax
  const std::string *v10; // rax
  bool v11; // r14
  const std::string *v12; // rax
  const std::string *v13; // rax
  std::pair<unsigned int,unsigned int> v14; // rax
  std::allocator<char> __a; // [rsp+2Bh] [rbp-135h] BYREF
  uint32_t idx; // [rsp+2Ch] [rbp-134h]
  common::milog::MiLogStream v18; // [rsp+30h] [rbp-130h] BYREF
  char v19[272]; // [rsp+50h] [rbp-110h] BYREF

  v3 = (unsigned __int64)v19;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_2(224LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "5 32 4 13 item_id:10726 48 4 16 item_count:10727 64 8 12 result:10696 96 24 25 select_id_count_v"
                        "ec:10702 160 24 15 split_vec:10713";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::getUseConfigSelectIdAndCount;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556924;
  v5[536862722] = -218959360;
  v5[536862723] = -234881024;
  v5[536862724] = -218959118;
  v5[536862725] = -218103808;
  v5[536862726] = -202116109;
  *(_QWORD *)(v3 + 64) = 0LL;
  if ( std::vector<std::string>::empty(&use_config->use_param) )
  {
    common::milog::MiLogStream::create(
      &v18,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "getUseConfigSelectIdAndCount",
      10699);
    common::milog::MiLogStream::operator<<<char [26],(char *[26])0>(&v18, (const char (*)[26])byte_2639DF60);
    common::milog::MiLogStream::~MiLogStream(&v18);
    v6 = *(std::pair<unsigned int,unsigned int> *)(v3 + 64);
  }
  else
  {
    std::vector<std::string>::vector((std::vector<std::string> *const)(v3 + 96));
    std::allocator<char>::allocator(&__a);
    std::string::basic_string<std::allocator<char>>((std::string *const)&v18, ",", &__a);
    v7 = std::vector<std::string>::operator[](&use_config->use_param, 0LL);
    v8 = common::tools::StringUtils::splitToList(
           v7,
           (const std::string *)&v18,
           (std::vector<std::string> *)(v3 + 96),
           1) != 0;
    std::string::~string(&v18);
    std::allocator<char>::~allocator(&__a);
    if ( v8 )
    {
      common::milog::MiLogStream::create(
        &v18,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "getUseConfigSelectIdAndCount",
        10705);
      common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(&v18, (const char (*)[19])"splitToList failed");
      common::milog::MiLogStream::~MiLogStream(&v18);
      v6 = *(std::pair<unsigned int,unsigned int> *)(v3 + 64);
    }
    else
    {
      if ( option_idx )
        v9 = option_idx - 1;
      else
        v9 = 0;
      idx = v9;
      if ( v9 + 1 <= std::vector<std::string>::size((const std::vector<std::string> *const)(v3 + 96)) )
      {
        std::vector<std::string>::vector((std::vector<std::string> *const)(v3 + 160));
        std::allocator<char>::allocator(&__a);
        std::string::basic_string<std::allocator<char>>((std::string *const)&v18, ":", &__a);
        v10 = std::vector<std::string>::operator[]((std::vector<std::string> *const)(v3 + 96), idx);
        v11 = common::tools::StringUtils::split(
                v10,
                (const std::string *)&v18,
                (std::vector<std::string> *)(v3 + 160),
                0) != 0;
        std::string::~string(&v18);
        std::allocator<char>::~allocator(&__a);
        if ( v11 )
        {
          common::milog::MiLogStream::create(
            &v18,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "getUseConfigSelectIdAndCount",
            10718);
          common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(&v18, (const char (*)[12])"split fails");
          common::milog::MiLogStream::~MiLogStream(&v18);
          v6 = *(std::pair<unsigned int,unsigned int> *)(v3 + 64);
        }
        else if ( std::vector<std::string>::size((const std::vector<std::string> *const)(v3 + 160)) == 2 )
        {
          *(_DWORD *)(v3 + 32) = 0;
          *(_DWORD *)(v3 + 48) = 0;
          v12 = std::vector<std::string>::operator[]((std::vector<std::string> *const)(v3 + 160), 0LL);
          if ( common::tools::StringUtils::strToNum<unsigned int>(v12, (unsigned int *)(v3 + 32), 1) )
          {
            common::milog::MiLogStream::create(
              &v18,
              &common::milog::MiLogDefault::default_log_obj_,
              4u,
              "./src/player/item/player_item_comp.cpp",
              "getUseConfigSelectIdAndCount",
              10730);
            common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(&v18, (const char (*)[16])"strToNum failed");
            common::milog::MiLogStream::~MiLogStream(&v18);
            v6 = *(std::pair<unsigned int,unsigned int> *)(v3 + 64);
          }
          else
          {
            v13 = std::vector<std::string>::operator[]((std::vector<std::string> *const)(v3 + 160), 1uLL);
            if ( common::tools::StringUtils::strToNum<unsigned int>(v13, (unsigned int *)(v3 + 48), 1) )
            {
              common::milog::MiLogStream::create(
                &v18,
                &common::milog::MiLogDefault::default_log_obj_,
                4u,
                "./src/player/item/player_item_comp.cpp",
                "getUseConfigSelectIdAndCount",
                10735);
              common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(
                &v18,
                (const char (*)[16])"strToNum failed");
              common::milog::MiLogStream::~MiLogStream(&v18);
            }
            else
            {
              *(_DWORD *)(v3 + 64) = *(_DWORD *)(v3 + 32);
              *(_DWORD *)(v3 + 68) = *(_DWORD *)(v3 + 48);
            }
            v6 = *(std::pair<unsigned int,unsigned int> *)(v3 + 64);
          }
        }
        else
        {
          common::milog::MiLogStream::create(
            &v18,
            &common::milog::MiLogDefault::default_log_obj_,
            3u,
            "./src/player/item/player_item_comp.cpp",
            "getUseConfigSelectIdAndCount",
            10723);
          common::milog::MiLogStream::operator<<<char [34],(char *[34])0>(
            &v18,
            (const char (*)[34])"split_vec size not equal 2, fails");
          common::milog::MiLogStream::~MiLogStream(&v18);
          v6 = *(std::pair<unsigned int,unsigned int> *)(v3 + 64);
        }
        std::vector<std::string>::~vector((std::vector<std::string> *const)(v3 + 160));
      }
      else
      {
        v6 = *(std::pair<unsigned int,unsigned int> *)(v3 + 64);
      }
    }
    std::vector<std::string>::~vector((std::vector<std::string> *const)(v3 + 96));
  }
  v14 = v6;
  if ( v19 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8018) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8018) = -168430091;
  }
  return v14;
};

// Line 10745: range 0000000017D20A30-0000000017D20E6E
bool __cdecl PlayerItemComp::isShopGoodsNeedRefresh(
        const PlayerItemComp *const this,
        const data::ShopGoodsExcelConfig *shop_goods_config,
        uint32_t last_record_time,
        uint32_t now)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  unsigned __int64 v6; // r13
  bool result; // al
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  data::ShopRefreshType refresh_type; // eax
  __int64 v10; // r12
  const unsigned int *v11; // rax
  _DWORD *v12; // rdx
  __int64 v13; // r12
  const unsigned int *v14; // rax
  _DWORD *v15; // rdx
  uint32_t *v16; // rax
  uint32_t *v17; // rdx
  time_t v18; // rdx
  __int64 v19; // r14
  unsigned int __b; // [rsp+20h] [rbp-90h] BYREF
  uint32_t time_offset_sec; // [rsp+24h] [rbp-8Ch]
  uint32_t refresh_day_count; // [rsp+28h] [rbp-88h]
  uint32_t begin_time_day; // [rsp+2Ch] [rbp-84h]
  std::shared_ptr<Config> v26; // [rsp+30h] [rbp-80h] BYREF
  char v27[112]; // [rsp+40h] [rbp-70h] BYREF

  v4 = (unsigned __int64)v27;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_0(64LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 12 19 get_cycle_num:10763";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::isShopGoodsNeedRefresh;
  v6 = v4 >> 3;
  *(_DWORD *)(v6 + 2147450880) = -235802127;
  *(_DWORD *)(v6 + 2147450884) = -202177536;
  if ( *(_BYTE *)(((unsigned __int64)&shop_goods_config->begin_timestamp >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&shop_goods_config->begin_timestamp >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&shop_goods_config->begin_timestamp);
  }
  if ( last_record_time < shop_goods_config->begin_timestamp )
  {
    result = 1;
    goto LABEL_26;
  }
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v26);
  v8 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v26);
  time_offset_sec = ConstValueExcelConfigMgr::getTimeOffsetSec(&v8->design_config.txt_config_mgr.const_value_config_mgr);
  std::shared_ptr<Config>::~shared_ptr(&v26);
  if ( *(_BYTE *)(((unsigned __int64)&shop_goods_config->refresh_type >> 3) + 0x7FFF8000) != 0
    && *(_BYTE *)(((unsigned __int64)&shop_goods_config->refresh_type >> 3) + 0x7FFF8000) <= 3 )
  {
    __asan_report_load4(&shop_goods_config->refresh_type);
  }
  refresh_type = shop_goods_config->refresh_type;
  if ( refresh_type == SHOP_REFRESH_DAILY )
  {
    __b = 1;
    v16 = (uint32_t *)std::max<unsigned int>(&__b, &shop_goods_config->refresh_param);
    v17 = v16;
    if ( *(_BYTE *)(((unsigned __int64)v16 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v16 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v16 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v16);
    }
    refresh_day_count = *v17;
    v18 = time_offset_sec;
    if ( *(_BYTE *)(((unsigned __int64)&shop_goods_config->begin_timestamp >> 3) + 0x7FFF8000) != 0
      && *(_BYTE *)(((unsigned __int64)&shop_goods_config->begin_timestamp >> 3) + 0x7FFF8000) <= 3 )
    {
      __asan_report_load4(&shop_goods_config->begin_timestamp);
    }
    begin_time_day = common::tools::TimeUtils::getTimeDay(shop_goods_config->begin_timestamp, v18);
    *(_DWORD *)(v4 + 32) = refresh_day_count;
    *(_DWORD *)(v4 + 36) = time_offset_sec;
    *(_DWORD *)(v4 + 40) = begin_time_day;
    v19 = PlayerItemComp::isShopGoodsNeedRefresh(data::ShopGoodsExcelConfig const&,unsigned int,unsigned int)const::{lambda(unsigned int)#1}::operator()(
            (const PlayerItemComp::isShopGoodsNeedRefresh::<lambda(uint32_t)> *const)(v4 + 32),
            last_record_time);
    result = v19 != PlayerItemComp::isShopGoodsNeedRefresh(data::ShopGoodsExcelConfig const&,unsigned int,unsigned int)const::{lambda(unsigned int)#1}::operator()(
                      (const PlayerItemComp::isShopGoodsNeedRefresh::<lambda(uint32_t)> *const)(v4 + 32),
                      now);
  }
  else
  {
    if ( refresh_type > SHOP_REFRESH_DAILY )
      goto LABEL_25;
    if ( refresh_type != SHOP_REFRESH_WEEKLY )
    {
      if ( refresh_type == SHOP_REFRESH_MONTHLY )
      {
        v10 = time_offset_sec;
        __b = 1;
        v11 = std::max<unsigned int>(&shop_goods_config->refresh_param, &__b);
        v12 = v11;
        if ( *(_BYTE *)(((unsigned __int64)v11 >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)v11 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v11 >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(v11);
        }
        result = !common::tools::TimeUtils::isSameMonth(last_record_time, now, v10 + 86400LL * (unsigned int)(*v12 - 1));
        goto LABEL_26;
      }
LABEL_25:
      result = 0;
      goto LABEL_26;
    }
    v13 = time_offset_sec;
    __b = 1;
    v14 = std::max<unsigned int>(&shop_goods_config->refresh_param, &__b);
    v15 = v14;
    if ( *(_BYTE *)(((unsigned __int64)v14 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v14 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v14 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v14);
    }
    result = !common::tools::TimeUtils::isSameWeek(last_record_time, now, v13 + 86400LL * (unsigned int)(*v15 - 1));
  }
LABEL_26:
  if ( v27 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 10763: range 0000000017D20850-0000000017D20A2F
__int64 __cdecl PlayerItemComp::isShopGoodsNeedRefresh(data::ShopGoodsExcelConfig const&,unsigned int,unsigned int)const::{lambda(unsigned int)#1}::operator()(
        const PlayerItemComp::isShopGoodsNeedRefresh::<lambda(uint32_t)> *const __closure,
        uint32_t timestamp)
{
  time_t v2; // rcx
  time_t TimeDay; // rcx
  time_t v5; // rcx

  if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)__closure & 7) + 3) >= *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(__closure);
  }
  if ( __closure->__refresh_day_count )
  {
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__time_offset_sec >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)__closure + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&__closure->__time_offset_sec >> 3)
                                                              + 0x7FFF8000) )
    {
      __asan_report_load4(&__closure->__time_offset_sec);
    }
    TimeDay = common::tools::TimeUtils::getTimeDay(timestamp, __closure->__time_offset_sec);
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__begin_time_day >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)__closure + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&__closure->__begin_time_day >> 3)
                                                              + 0x7FFF8000) )
    {
      __asan_report_load4(&__closure->__begin_time_day);
    }
    v5 = TimeDay - __closure->__begin_time_day;
    if ( *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)__closure & 7) + 3) >= *(_BYTE *)(((unsigned __int64)__closure >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(__closure);
    }
    return v5 / __closure->__refresh_day_count;
  }
  else
  {
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__time_offset_sec >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)__closure + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&__closure->__time_offset_sec >> 3)
                                                              + 0x7FFF8000) )
    {
      __asan_report_load4(&__closure->__time_offset_sec);
    }
    v2 = common::tools::TimeUtils::getTimeDay(timestamp, __closure->__time_offset_sec);
    if ( *(_BYTE *)(((unsigned __int64)&__closure->__begin_time_day >> 3) + 0x7FFF8000) != 0
      && (char)((((_BYTE)__closure + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&__closure->__begin_time_day >> 3)
                                                              + 0x7FFF8000) )
    {
      __asan_report_load4(&__closure->__begin_time_day);
    }
    return v2 - __closure->__begin_time_day;
  }
};

// Line 10782: range 0000000017D20E70-0000000017D21E33
__int64 __fastcall PlayerItemComp::checkShopGoodsOutput(
        PlayerItemComp *const this,
        uint32_t goods_id,
        uint32_t buy_count,
        uint32_t now,
        uint32_t buy_limit)
{
  unsigned __int64 v5; // r13
  __int64 v6; // rax
  _DWORD *v7; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  common::milog::MiLogStream *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rcx
  __int64 result; // rax
  std::__detail::_Node_iterator<std::pair<unsigned int const,ShopGoodsOutputRecord>,false,false>::pointer v15; // rax
  uint32_t *p_buy_count; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v17; // rax
  bool v18; // al
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v19; // rax
  char v20; // r14
  Json::Value_0 *v21; // rax
  Json::Value_0 *v22; // rax
  Json::Value_0 *v23; // rax
  Json::Value_0 *v24; // rax
  Json::Value_0 *v25; // rax
  Json::Value_0 *v26; // rax
  Json::Value_0 *v27; // rax
  Json::Value_0 *v28; // rax
  Json::Value_0 *v29; // rax
  Json::Value_0 *v30; // rax
  Json::Value_0 *v31; // rax
  Json::Value_0 *v32; // rax
  common::milog::MiLogStream *v33; // rax
  common::milog::MiLogStream *v34; // rax
  common::milog::MiLogStream *v35; // rax
  common::milog::MiLogStream *v36; // rax
  common::milog::MiLogStream *v37; // rax
  common::milog::MiLogStream *v38; // rax
  common::milog::MiLogStream *v39; // rax
  common::milog::MiLogStream *v40; // rax
  common::milog::MiLogStream *v41; // rax
  common::milog::MiLogStream *v42; // rax
  common::milog::MiLogStream *v43; // rax
  common::milog::MiLogStream *v44; // rax
  common::milog::MiLogStream *v45; // rax
  common::milog::MiLogStream *v46; // rax
  common::milog::MiLogStream *v47; // rax
  common::milog::MiLogStream *v48; // rax
  common::milog::MiLogStream *v49; // rcx
  const ItemLimitExcelConfigMgr *p_item_limit_config_mgr; // [rsp+8h] [rbp-208h]
  char v51; // [rsp+14h] [rbp-1FCh]
  char v52; // [rsp+15h] [rbp-1FBh]
  char v53; // [rsp+16h] [rbp-1FAh]
  char v54; // [rsp+17h] [rbp-1F9h]
  std::allocator<unsigned int> __a; // [rsp+31h] [rbp-1DFh] BYREF
  bool is_buy_count_refreshed; // [rsp+32h] [rbp-1DEh]
  bool is_forbid_output; // [rsp+33h] [rbp-1DDh]
  _DWORD __l[5]; // [rsp+34h] [rbp-1DCh] BYREF
  const ShopGoodsOutputRecord *record; // [rsp+48h] [rbp-1C8h]
  std::shared_ptr<Config> v63; // [rsp+50h] [rbp-1C0h] BYREF
  std::shared_ptr<Config> v64; // [rsp+60h] [rbp-1B0h] BYREF
  std::vector<unsigned int> p_param_vec; // [rsp+70h] [rbp-1A0h] BYREF
  common::milog::MiLogStream v66; // [rsp+90h] [rbp-180h] BYREF
  Json::Value_0 other; // [rsp+B0h] [rbp-160h] BYREF
  char v68[304]; // [rsp+E0h] [rbp-130h] BYREF

  v5 = (unsigned __int64)v68;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v6 = __asan_stack_malloc_2(256LL);
    if ( v6 )
      v5 = v6;
  }
  *(_QWORD *)v5 = 1102416563LL;
  *(_QWORD *)(v5 + 8) = "8 48 4 19 old_buy_count:10795 64 4 22 last_record_time:10796 80 4 19 new_buy_count:10808 96 4 14"
                        " goods_id:10781 112 4 15 buy_count:10781 128 4 15 buy_limit:10781 144 8 10 iter:10799 176 40 10 jval:10827";
  *(_QWORD *)(v5 + 16) = PlayerItemComp::checkShopGoodsOutput;
  v7 = (_DWORD *)(v5 >> 3);
  v7[536862720] = -235802127;
  v7[536862721] = -234556943;
  v7[536862722] = -234556924;
  v7[536862723] = -234556924;
  v7[536862724] = 61956;
  v7[536862724] = -234881024;
  v7[536862725] = 62194;
  v7[536862726] = -218103808;
  v7[536862727] = -202116109;
  *(_DWORD *)(v5 + 96) = goods_id;
  *(_DWORD *)(v5 + 112) = buy_count;
  *(_DWORD *)(v5 + 128) = buy_limit;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v64);
  v8 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v64);
  *(_QWORD *)&__l[3] = data::ShopExcelConfigMgrBase::findShopGoodsExcelConfig(
                         &v8->design_config.txt_config_mgr.shop_config_mgr,
                         *(_DWORD *)(v5 + 96));
  std::shared_ptr<Config>::~shared_ptr(&v64);
  if ( *(_QWORD *)&__l[3] )
  {
    if ( *(_DWORD *)(v5 + 128) )
    {
      *(_DWORD *)(v5 + 48) = 0;
      *(_DWORD *)(v5 + 64) = 0;
      is_buy_count_refreshed = 0;
      *(std::unordered_map<unsigned int,ShopGoodsOutputRecord>::iterator *)(v5 + 144) = std::unordered_map<unsigned int,ShopGoodsOutputRecord>::find(
                                                                                          &this->shop_goods_output_record_map_,
                                                                                          (const std::unordered_map<unsigned int,ShopGoodsOutputRecord>::key_type *)(v5 + 96));
      *(std::unordered_map<unsigned int,ShopGoodsOutputRecord>::iterator *)&__l[1] = std::unordered_map<unsigned int,ShopGoodsOutputRecord>::end(&this->shop_goods_output_record_map_);
      if ( std::__detail::operator!=<std::pair<unsigned int const,ShopGoodsOutputRecord>,false>(
             (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,ShopGoodsOutputRecord>,false> *)(v5 + 144),
             (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,ShopGoodsOutputRecord>,false> *)&__l[1]) )
      {
        v15 = std::__detail::_Node_iterator<std::pair<unsigned int const,ShopGoodsOutputRecord>,false,false>::operator->((const std::__detail::_Node_iterator<std::pair<unsigned int const,ShopGoodsOutputRecord>,false,false> *const)(v5 + 144));
        record = &v15->second;
        p_buy_count = &v15->second.buy_count;
        if ( *(_BYTE *)(((unsigned __int64)p_buy_count >> 3) + 0x7FFF8000) != 0
          && (char)(((unsigned __int8)p_buy_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_buy_count >> 3)
                                                                        + 0x7FFF8000) )
        {
          __asan_report_load4(p_buy_count);
        }
        *(_DWORD *)(v5 + 48) = record->buy_count;
        if ( *(_BYTE *)(((unsigned __int64)&record->last_record_time >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)record + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&record->last_record_time >> 3)
                                                               + 0x7FFF8000) )
        {
          __asan_report_load4(&record->last_record_time);
        }
        *(_DWORD *)(v5 + 64) = record->last_record_time;
        is_buy_count_refreshed = PlayerItemComp::isShopGoodsNeedRefresh(
                                   this,
                                   *(const data::ShopGoodsExcelConfig **)&__l[3],
                                   *(_DWORD *)(v5 + 64),
                                   now);
      }
      *(_DWORD *)(v5 + 80) = *(_DWORD *)(v5 + 112);
      if ( !is_buy_count_refreshed )
        *(_DWORD *)(v5 + 80) = SAFE_ADD<unsigned int,unsigned int>(*(_DWORD *)(v5 + 80), *(_DWORD *)(v5 + 48));
      else
        std::unordered_map<unsigned int,ShopGoodsOutputRecord>::erase(
          &this->shop_goods_output_record_map_,
          *(std::unordered_map<unsigned int,ShopGoodsOutputRecord>::iterator *)(v5 + 144));
      if ( *(_DWORD *)(v5 + 80) > *(_DWORD *)(v5 + 128) )
      {
        v54 = 0;
        v18 = 0;
        if ( SAFE_MULTIPLY<unsigned int,unsigned int>(*(_DWORD *)(v5 + 128), 2u) < *(_DWORD *)(v5 + 80) )
        {
          ServiceBox::findService<GameserverService>();
          GameserverService::getConfig((GameserverService *const)&v64);
          v54 = 1;
          v17 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v64);
          if ( ConstValueExcelConfigMgr::getIsShopGoodsOutputCanForbid(&v17->design_config.txt_config_mgr.const_value_config_mgr) )
            v18 = 1;
        }
        is_forbid_output = v18;
        if ( v54 )
          std::shared_ptr<Config>::~shared_ptr(&v64);
        v53 = 0;
        v52 = 0;
        v51 = 0;
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)&v63);
        v19 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v63);
        if ( !ConstValueExcelConfigMgr::getIsShopGoodsOutputCanAlarm(&v19->design_config.txt_config_mgr.const_value_config_mgr) )
          goto LABEL_30;
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)&v64);
        v53 = 1;
        p_item_limit_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v64)->design_config.txt_config_mgr.item_limit_config_mgr;
        __l[0] = *(_DWORD *)(v5 + 96);
        std::allocator<unsigned int>::allocator(&__a);
        v52 = 1;
        std::vector<unsigned int>::vector(
          &p_param_vec,
          (std::initializer_list<unsigned int>)__PAIR128__(1LL, __l),
          &__a);
        v51 = 1;
        if ( !ItemLimitExcelConfigMgr::isInItemLimitWhiteList(
                p_item_limit_config_mgr,
                ITEM_LIMIT_WHITE_GOODS_ID,
                &p_param_vec) )
          v20 = 1;
        else
LABEL_30:
          v20 = 0;
        if ( v51 )
          std::vector<unsigned int>::~vector(&p_param_vec);
        if ( v52 )
          std::allocator<unsigned int>::~allocator(&__a);
        if ( v53 )
          std::shared_ptr<Config>::~shared_ptr(&v64);
        std::shared_ptr<Config>::~shared_ptr(&v63);
        if ( v20 )
        {
          Json::Value::Value(v5 + 176, 0LL);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v5 + 96));
          v21 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "goods_id");
          Json::Value::operator=(v21, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v5 + 48));
          v22 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "old_buy_count");
          Json::Value::operator=(v22, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v5 + 64));
          v23 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "last_record_time");
          Json::Value::operator=(v23, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v5 + 112));
          v24 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "buy_count");
          Json::Value::operator=(v24, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v5 + 80));
          v25 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "new_buy_count");
          Json::Value::operator=(v25, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v5 + 128));
          v26 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "goods_buy_limit");
          Json::Value::operator=(v26, &other);
          Json::Value::~Value(&other);
          if ( *(_BYTE *)(((unsigned __int64)(*(_QWORD *)&__l[3] + 176LL) >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)(*(_QWORD *)&__l[3] + 176LL) >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(*(_QWORD *)&__l[3] + 176LL);
          }
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(*(_QWORD *)&__l[3] + 176LL));
          v27 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "goods_begin_time");
          Json::Value::operator=(v27, &other);
          Json::Value::~Value(&other);
          if ( *(_BYTE *)(((unsigned __int64)(*(_QWORD *)&__l[3] + 180LL) >> 3) + 0x7FFF8000) != 0
            && (char)(((LOBYTE(__l[3]) - 76) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)(*(_QWORD *)&__l[3] + 180LL) >> 3)
                                                                   + 0x7FFF8000) )
          {
            __asan_report_load4(*(_QWORD *)&__l[3] + 180LL);
          }
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(*(_QWORD *)&__l[3] + 180LL));
          v28 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "goods_end_time");
          Json::Value::operator=(v28, &other);
          Json::Value::~Value(&other);
          if ( *(_BYTE *)(((unsigned __int64)(*(_QWORD *)&__l[3] + 96LL) >> 3) + 0x7FFF8000) != 0
            && *(_BYTE *)(((unsigned __int64)(*(_QWORD *)&__l[3] + 96LL) >> 3) + 0x7FFF8000) <= 3 )
          {
            __asan_report_load4(*(_QWORD *)&__l[3] + 96LL);
          }
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(*(_QWORD *)&__l[3] + 96LL));
          v29 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "goods_refresh_type");
          Json::Value::operator=(v29, &other);
          Json::Value::~Value(&other);
          if ( *(_BYTE *)(((unsigned __int64)(*(_QWORD *)&__l[3] + 100LL) >> 3) + 0x7FFF8000) != 0
            && (char)(((LOBYTE(__l[3]) + 100) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)(*(_QWORD *)&__l[3] + 100LL) >> 3)
                                                                    + 0x7FFF8000) )
          {
            __asan_report_load4(*(_QWORD *)&__l[3] + 100LL);
          }
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(*(_QWORD *)&__l[3] + 100LL));
          v30 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "goods_refresh_param");
          Json::Value::operator=(v30, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, is_forbid_output);
          v31 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "is_forbid_output");
          Json::Value::operator=(v31, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, "shop_goods");
          v32 = Json::Value::operator[]((Json::Value_0 *const)(v5 + 176), "type");
          Json::Value::operator=(v32, &other);
          Json::Value::~Value(&other);
          PlayerItemComp::asyncSendAlarmToPlatform(this, (Json::Value *)(v5 + 176));
          Json::Value::~Value((Json::Value_0 *const)(v5 + 176));
        }
        common::milog::MiLogStream::create(
          &v66,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkShopGoodsOutput",
          10843);
        v33 = common::milog::MiLogStream::operator<<<char [10],(char *[10])0>(&v66, (const char (*)[10])"goods_id:");
        v34 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v33,
                (const unsigned int *)(v5 + 96));
        v35 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(
                v34,
                (const char (*)[16])" old_buy_count:");
        v36 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v35,
                (const unsigned int *)(v5 + 48));
        v37 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(
                v36,
                (const char (*)[19])" last_record_time:");
        v38 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v37,
                (const unsigned int *)(v5 + 64));
        v39 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v38, (const char (*)[13])" begin_time:");
        v40 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v39,
                (const unsigned int *)(*(_QWORD *)&__l[3] + 176LL));
        v41 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v40, (const char (*)[12])" buy_count:");
        v42 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v41,
                (const unsigned int *)(v5 + 112));
        v43 = common::milog::MiLogStream::operator<<<char [16],(char *[16])0>(
                v42,
                (const char (*)[16])" new_buy_count:");
        v44 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v43,
                (const unsigned int *)(v5 + 80));
        v45 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v44, (const char (*)[12])" is_forbid:");
        v46 = common::milog::MiLogStream::operator<<(v45, is_forbid_output);
        v47 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v46, (const char (*)[12])" buy_limit:");
        v48 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v47,
                (const unsigned int *)(v5 + 128));
        v49 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v48, (const char (*)[9])" player:");
        if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
          __asan_report_load8();
        operator<<(v49, this->player_);
        common::milog::MiLogStream::~MiLogStream(&v66);
        if ( is_forbid_output )
          result = 0xFFFFFFFFLL;
        else
          result = 0LL;
      }
      else
      {
        result = 0LL;
      }
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v66,
      &common::milog::MiLogDefault::default_log_obj_,
      4u,
      "./src/player/item/player_item_comp.cpp",
      "checkShopGoodsOutput",
      10786);
    v9 = common::milog::MiLogStream::operator<<<char [41],(char *[41])0>(
           &v66,
           (const char (*)[41])"findShopGoodsExcelConfig fail, goods_id:");
    v10 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v9, (const unsigned int *)(v5 + 96));
    v11 = common::milog::MiLogStream::operator<<<char [12],(char *[12])0>(v10, (const char (*)[12])" buy_count:");
    v12 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v11, (const unsigned int *)(v5 + 112));
    v13 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v12, (const char (*)[9])" player:");
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    operator<<(v13, this->player_);
    common::milog::MiLogStream::~MiLogStream(&v66);
    result = 0xFFFFFFFFLL;
  }
  if ( v68 == (char *)v5 )
  {
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8018) = 0LL;
  }
  else
  {
    *(_QWORD *)v5 = 1172321806LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v5 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 10854: range 0000000017D21E34-0000000017D22036
void __fastcall PlayerItemComp::recordShopGoodsOutput(
        PlayerItemComp *const this,
        uint32_t goods_id,
        uint32_t buy_count,
        uint32_t now)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  unsigned __int64 v6; // r12
  std::unordered_map<unsigned int,ShopGoodsOutputRecord>::mapped_type *v7; // rax
  uint32_t v8; // ecx
  char v9; // dl
  char *v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rdx
  SelectType v13; // ecx
  char v14; // dl
  __int64 v15; // rsi
  __int64 v16; // rdx
  ShopGoodsOutputRecord *record; // [rsp+28h] [rbp-68h]
  char v20[96]; // [rsp+30h] [rbp-60h] BYREF

  v4 = (unsigned __int64)v20;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v5 = __asan_stack_malloc_0(64LL);
    if ( v5 )
      v4 = v5;
  }
  *(_QWORD *)v4 = 1102416563LL;
  *(_QWORD *)(v4 + 8) = "1 32 4 14 goods_id:10853";
  *(_QWORD *)(v4 + 16) = PlayerItemComp::recordShopGoodsOutput;
  v6 = v4 >> 3;
  *(_DWORD *)(v6 + 2147450880) = -235802127;
  *(_DWORD *)(v6 + 2147450884) = -202116348;
  *(_DWORD *)(v4 + 32) = goods_id;
  v10 = (char *)(v4 + 32);
  v7 = std::unordered_map<unsigned int,ShopGoodsOutputRecord>::operator[](
         &this->shop_goods_output_record_map_,
         (const std::unordered_map<unsigned int,ShopGoodsOutputRecord>::key_type *)(v4 + 32));
  record = v7;
  v8 = *(_DWORD *)(v4 + 32);
  v9 = *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000);
  LOBYTE(v10) = v9 != 0;
  v11 = (v9 != 0) & (unsigned __int8)((char)(((unsigned __int8)v7 & 7) + 3) >= v9);
  if ( (_BYTE)v11 )
    __asan_report_store4(v7, v10, v11);
  record->goods_id = v8;
  v12 = (*(_BYTE *)(((unsigned __int64)&record->last_record_time >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)record + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&record->last_record_time >> 3) + 0x7FFF8000));
  if ( (_BYTE)v12 )
    __asan_report_store4(&record->last_record_time, (((_BYTE)record + 4) & 7u) + 3, v12);
  record->last_record_time = now;
  if ( *(_BYTE *)(((unsigned __int64)&record->buy_count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)record + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&record->buy_count >> 3) + 0x7FFF8000) )
  {
    __asan_report_load4(&record->buy_count);
  }
  v15 = buy_count;
  v13 = SAFE_ADD<unsigned int,unsigned int>(record->buy_count, buy_count);
  v14 = *(_BYTE *)(((unsigned __int64)&record->buy_count >> 3) + 0x7FFF8000);
  LOBYTE(v15) = v14 != 0;
  v16 = (v14 != 0) & (unsigned __int8)((char)((((_BYTE)record + 8) & 7) + 3) >= v14);
  if ( (_BYTE)v16 )
    __asan_report_store4(&record->buy_count, v15, v16);
  record->buy_count = v13;
  if ( v20 == (char *)v4 )
  {
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0LL;
  }
  else
  {
    *(_QWORD *)v4 = 1172321806LL;
    *(_QWORD *)((v4 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
  }
};

// Line 10863: range 0000000017D22038-0000000017D23107
int32_t __cdecl PlayerItemComp::checkDropBonus(PlayerItemComp *const this, const DropBonusParam *drop_bonus_param)
{
  unsigned __int64 v2; // r13
  __int64 v3; // rax
  _DWORD *v4; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  int v6; // eax
  int32_t result; // eax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v9; // rax
  common::milog::MiLogStream *v10; // rax
  common::milog::MiLogStream *v11; // rax
  common::milog::MiLogStream *v12; // rax
  common::milog::MiLogStream *v13; // rax
  common::milog::MiLogStream *v14; // rax
  std::__detail::_Node_iterator<std::pair<unsigned int const,SingleBonusRecord>,false,false>::pointer v15; // rdx
  uint32_t *p_bonus_count; // rax
  std::__detail::_Node_iterator<std::pair<unsigned int const,SingleBonusRecord>,false,false>::pointer v17; // rdx
  SingleBonusRecord *p_second; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v19; // rax
  bool v20; // al
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v21; // rax
  bool v22; // al
  bool v23; // al
  bool v24; // r14
  Json::Value_0 *v25; // rax
  Json::Value_0 *v26; // rax
  Json::Value_0 *v27; // rax
  Json::Value_0 *v28; // rax
  Json::Value_0 *v29; // rax
  Json::Value_0 *v30; // rax
  Json::Value_0 *v31; // rax
  Json::Value_0 *v32; // rax
  Json::Value_0 *v33; // rax
  Json::Value_0 *v34; // rax
  common::milog::MiLogStream *v35; // rax
  common::milog::MiLogStream *v36; // rax
  common::milog::MiLogStream *v37; // rax
  common::milog::MiLogStream *v38; // rax
  common::milog::MiLogStream *v39; // rax
  common::milog::MiLogStream *v40; // rax
  common::milog::MiLogStream *v41; // rax
  common::milog::MiLogStream *v42; // rax
  common::milog::MiLogStream *v43; // rax
  common::milog::MiLogStream *v44; // rax
  common::milog::MiLogStream *v45; // rax
  common::milog::MiLogStream *v46; // rax
  common::milog::MiLogStream *v47; // rax
  common::milog::MiLogStream *v48; // rax
  common::milog::MiLogStream *v49; // rax
  common::milog::MiLogStream *v50; // rax
  common::milog::MiLogStream *v51; // rax
  char v52; // [rsp+8h] [rbp-228h]
  char v53; // [rsp+8h] [rbp-228h]
  const ItemLimitExcelConfigMgr *p_item_limit_config_mgr; // [rsp+8h] [rbp-228h]
  std::allocator<unsigned int> __a; // [rsp+2Ch] [rbp-204h] BYREF
  bool is_united_limit_forbid; // [rsp+2Dh] [rbp-203h]
  bool is_detached_limit_forbid; // [rsp+2Eh] [rbp-202h]
  bool is_forbid_output; // [rsp+2Fh] [rbp-201h]
  std::unordered_map<unsigned int,SingleBonusRecord> *bonus_map; // [rsp+30h] [rbp-200h]
  std::__detail::_Node_iterator_base<std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> >,false> __y; // [rsp+38h] [rbp-1F8h] BYREF
  std::shared_ptr<Config> v61; // [rsp+40h] [rbp-1F0h] BYREF
  std::vector<unsigned int> p_param_vec; // [rsp+50h] [rbp-1E0h] BYREF
  common::milog::MiLogStream v63; // [rsp+70h] [rbp-1C0h] BYREF
  Json::Value_0 other; // [rsp+90h] [rbp-1A0h] BYREF
  char v65[368]; // [rsp+C0h] [rbp-170h] BYREF

  v2 = (unsigned __int64)v65;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_3(320LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "11 48 4 17 source_type:10864 64 4 16 drop_count:10865 80 4 15 config_id:10866 96 4 29 bonus_coun"
                        "t_daily_limit:10868 112 4 26 detached_bonus_limit:10870 128 4 21 old_bonus_count:10908 144 4 23 "
                        "last_refresh_time:10909 160 4 21 new_bonus_count:10922 176 8 10 iter:10910 208 8 24 single_recor"
                        "d_iter:10914 240 40 10 jval:10937";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::checkDropBonus;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234556943;
  v4[536862722] = -234556924;
  v4[536862723] = -234556924;
  v4[536862724] = -234556924;
  v4[536862725] = 61956;
  v4[536862725] = -234881024;
  v4[536862726] = 62194;
  v4[536862726] = -234881024;
  v4[536862727] = 62194;
  v4[536862728] = -218103808;
  v4[536862729] = -202116109;
  if ( *(_BYTE *)(((unsigned __int64)drop_bonus_param >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)drop_bonus_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)drop_bonus_param >> 3)
                                                                       + 0x7FFF8000) )
  {
    __asan_report_load4(drop_bonus_param);
  }
  *(_DWORD *)(v2 + 48) = drop_bonus_param->source_type;
  if ( *(_BYTE *)(((unsigned __int64)&drop_bonus_param->drop_count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)drop_bonus_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&drop_bonus_param->drop_count >> 3)
                                                                   + 0x7FFF8000) )
  {
    __asan_report_load4(&drop_bonus_param->drop_count);
  }
  *(_DWORD *)(v2 + 64) = drop_bonus_param->drop_count;
  if ( *(_BYTE *)(((unsigned __int64)&drop_bonus_param->config_id >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)drop_bonus_param + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&drop_bonus_param->config_id >> 3)
                                                                   + 0x7FFF8000) )
  {
    __asan_report_load4(&drop_bonus_param->config_id);
  }
  *(_DWORD *)(v2 + 80) = drop_bonus_param->config_id;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v61);
  v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v61);
  *(_DWORD *)(v2 + 96) = ItemLimitExcelConfigMgr::getBonusCountDailyLimit(&v5->design_config.txt_config_mgr.item_limit_config_mgr);
  std::shared_ptr<Config>::~shared_ptr(&v61);
  *(_DWORD *)(v2 + 112) = 0;
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 == 2 )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v61);
    v9 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v61);
    *(_DWORD *)(v2 + 112) = OpActivityExcelConfigMgr::getDailyBonusCountLimit(
                              &v9->design_config.txt_config_mgr.op_activity_config_mgr,
                              *(_DWORD *)(v2 + 80));
    std::shared_ptr<Config>::~shared_ptr(&v61);
  }
  else
  {
    if ( v6 > 2 )
      goto LABEL_18;
    if ( !v6 )
    {
      result = 0;
      goto LABEL_54;
    }
    if ( v6 != 1 )
    {
LABEL_18:
      common::milog::MiLogStream::create(
        &v63,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkDropBonus",
        10889);
      v10 = common::milog::MiLogStream::operator<<<char [31],(char *[31])0>(
              &v63,
              (const char (*)[31])"unsupported bonus_source_type:");
      common::milog::MiLogStream::operator<<<data::BonusSourceType,(data::BonusSourceType*)0>(
        v10,
        (const data::BonusSourceType *)(v2 + 48));
      common::milog::MiLogStream::~MiLogStream(&v63);
      result = -1;
      goto LABEL_54;
    }
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)&v61);
    v8 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v61);
    *(_DWORD *)(v2 + 112) = ReunionExcelConfigMgr::getDailyBonusCountLimit(
                              &v8->design_config.txt_config_mgr.reunion_config_mgr,
                              *(_DWORD *)(v2 + 80));
    std::shared_ptr<Config>::~shared_ptr(&v61);
  }
  if ( *(_DWORD *)(v2 + 112) )
  {
    if ( *(_DWORD *)(v2 + 64) > 1u )
    {
      PlayerItemComp::tryRefreshBonusRecord(this, *(data::BonusSourceType *)(v2 + 48), *(_DWORD *)(v2 + 80));
      *(_DWORD *)(v2 + 128) = 0;
      *(_DWORD *)(v2 + 144) = 0;
      *(std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::iterator *)(v2 + 176) = std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::find(&this->bonus_record_map_, (const std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::key_type *)(v2 + 48));
      __y._M_cur = std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::end(&this->bonus_record_map_)._M_cur;
      if ( std::__detail::operator!=<std::pair<data::BonusSourceType const,std::unordered_map<unsigned int,SingleBonusRecord>>,false>(
             (const std::__detail::_Node_iterator_base<std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> >,false> *)(v2 + 176),
             &__y) )
      {
        bonus_map = &std::__detail::_Node_iterator<std::pair<data::BonusSourceType const,std::unordered_map<unsigned int,SingleBonusRecord>>,false,false>::operator->((const std::__detail::_Node_iterator<std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> >,false,false> *const)(v2 + 176))->second;
        *(std::unordered_map<unsigned int,SingleBonusRecord>::iterator *)(v2 + 208) = std::unordered_map<unsigned int,SingleBonusRecord>::find(
                                                                                        bonus_map,
                                                                                        (const std::unordered_map<unsigned int,SingleBonusRecord>::key_type *)(v2 + 80));
        __y._M_cur = (std::__detail::_Node_iterator_base<std::pair<const data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord> >,false>::__node_type *)std::unordered_map<unsigned int,SingleBonusRecord>::end(bonus_map)._M_cur;
        if ( std::__detail::operator!=<std::pair<unsigned int const,SingleBonusRecord>,false>(
               (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,SingleBonusRecord>,false> *)(v2 + 208),
               (const std::__detail::_Node_iterator_base<std::pair<unsigned int const,SingleBonusRecord>,false> *)&__y) )
        {
          v15 = std::__detail::_Node_iterator<std::pair<unsigned int const,SingleBonusRecord>,false,false>::operator->((const std::__detail::_Node_iterator<std::pair<unsigned int const,SingleBonusRecord>,false,false> *const)(v2 + 208));
          p_bonus_count = &v15->second.bonus_count;
          if ( *(_BYTE *)(((unsigned __int64)p_bonus_count >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)p_bonus_count & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_bonus_count >> 3)
                                                                            + 0x7FFF8000) )
          {
            __asan_report_load4(p_bonus_count);
          }
          *(_DWORD *)(v2 + 128) = v15->second.bonus_count;
          v17 = std::__detail::_Node_iterator<std::pair<unsigned int const,SingleBonusRecord>,false,false>::operator->((const std::__detail::_Node_iterator<std::pair<unsigned int const,SingleBonusRecord>,false,false> *const)(v2 + 208));
          p_second = &v17->second;
          if ( *(_BYTE *)(((unsigned __int64)p_second >> 3) + 0x7FFF8000) != 0
            && (char)(((unsigned __int8)p_second & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_second >> 3) + 0x7FFF8000) )
          {
            __asan_report_load4(p_second);
          }
          *(_DWORD *)(v2 + 144) = v17->second.last_refresh_time;
        }
      }
      *(_DWORD *)(v2 + 160) = *(_DWORD *)(v2 + 128);
      *(_DWORD *)(v2 + 160) = SAFE_ADD<unsigned int,unsigned int>(*(_DWORD *)(v2 + 160), *(_DWORD *)(v2 + 64) - 1);
      if ( *(_DWORD *)(v2 + 160) > *(_DWORD *)(v2 + 96) || *(_DWORD *)(v2 + 160) > *(_DWORD *)(v2 + 112) )
      {
        v52 = 0;
        v20 = 0;
        if ( SAFE_MULTIPLY<unsigned int,unsigned int>(*(_DWORD *)(v2 + 96), 2u) < *(_DWORD *)(v2 + 160) )
        {
          ServiceBox::findService<GameserverService>();
          GameserverService::getConfig((GameserverService *const)&v61);
          v52 = 1;
          v19 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v61);
          if ( ItemLimitExcelConfigMgr::getIsUnitedBonusLimitCanForbid(&v19->design_config.txt_config_mgr.item_limit_config_mgr) )
            v20 = 1;
        }
        is_united_limit_forbid = v20;
        if ( v52 )
          std::shared_ptr<Config>::~shared_ptr(&v61);
        v53 = 0;
        v22 = 0;
        if ( SAFE_MULTIPLY<unsigned int,unsigned int>(*(_DWORD *)(v2 + 112), 2u) < *(_DWORD *)(v2 + 160) )
        {
          ServiceBox::findService<GameserverService>();
          GameserverService::getConfig((GameserverService *const)&v61);
          v53 = 1;
          v21 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v61);
          if ( ItemLimitExcelConfigMgr::getIsDetachedBonusLimitCanForbid(&v21->design_config.txt_config_mgr.item_limit_config_mgr) )
            v22 = 1;
        }
        is_detached_limit_forbid = v22;
        if ( v53 )
          std::shared_ptr<Config>::~shared_ptr(&v61);
        v23 = is_united_limit_forbid || is_detached_limit_forbid;
        is_forbid_output = v23;
        ServiceBox::findService<GameserverService>();
        GameserverService::getConfig((GameserverService *const)&v61);
        p_item_limit_config_mgr = &std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v61)->design_config.txt_config_mgr.item_limit_config_mgr;
        LODWORD(__y._M_cur) = *(_DWORD *)(v2 + 48);
        HIDWORD(__y._M_cur) = *(_DWORD *)(v2 + 80);
        std::allocator<unsigned int>::allocator(&__a);
        std::vector<unsigned int>::vector(
          &p_param_vec,
          (std::initializer_list<unsigned int>)__PAIR128__(2LL, &__y),
          &__a);
        v24 = !ItemLimitExcelConfigMgr::isInItemLimitWhiteList(
                 p_item_limit_config_mgr,
                 ITEM_LIMIT_WHITE_BONUS_EXTRA_DROP,
                 &p_param_vec);
        std::vector<unsigned int>::~vector(&p_param_vec);
        std::allocator<unsigned int>::~allocator(&__a);
        std::shared_ptr<Config>::~shared_ptr(&v61);
        if ( v24 )
        {
          Json::Value::Value(v2 + 240, 0LL);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v2 + 48));
          v25 = Json::Value::operator[]((Json::Value_0 *const)(v2 + 240), "source_type");
          Json::Value::operator=(v25, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v2 + 80));
          v26 = Json::Value::operator[]((Json::Value_0 *const)(v2 + 240), "config_id");
          Json::Value::operator=(v26, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, "bonus");
          v27 = Json::Value::operator[]((Json::Value_0 *const)(v2 + 240), "type");
          Json::Value::operator=(v27, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v2 + 144));
          v28 = Json::Value::operator[]((Json::Value_0 *const)(v2 + 240), "last_refresh_time");
          Json::Value::operator=(v28, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v2 + 64));
          v29 = Json::Value::operator[]((Json::Value_0 *const)(v2 + 240), "drop_count");
          Json::Value::operator=(v29, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v2 + 128));
          v30 = Json::Value::operator[]((Json::Value_0 *const)(v2 + 240), "old_bonus_count");
          Json::Value::operator=(v30, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v2 + 160));
          v31 = Json::Value::operator[]((Json::Value_0 *const)(v2 + 240), "new_bonus_count");
          Json::Value::operator=(v31, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v2 + 96));
          v32 = Json::Value::operator[]((Json::Value_0 *const)(v2 + 240), "bonus_count_daily_limit");
          Json::Value::operator=(v32, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, *(_DWORD *)(v2 + 112));
          v33 = Json::Value::operator[]((Json::Value_0 *const)(v2 + 240), "detached_bonus_limit");
          Json::Value::operator=(v33, &other);
          Json::Value::~Value(&other);
          Json::Value::Value((Json::Value *)&other, is_forbid_output);
          v34 = Json::Value::operator[]((Json::Value_0 *const)(v2 + 240), "is_forbid_output");
          Json::Value::operator=(v34, &other);
          Json::Value::~Value(&other);
          PlayerItemComp::asyncSendAlarmToPlatform(this, (Json::Value *)(v2 + 240));
          Json::Value::~Value((Json::Value_0 *const)(v2 + 240));
        }
        common::milog::MiLogStream::create(
          &v63,
          &common::milog::MiLogDefault::default_log_obj_,
          3u,
          "./src/player/item/player_item_comp.cpp",
          "checkDropBonus",
          10952);
        v35 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(&v63, (const char (*)[13])"source_type:");
        v36 = common::milog::MiLogStream::operator<<<data::BonusSourceType,(data::BonusSourceType*)0>(
                v35,
                (const data::BonusSourceType *)(v2 + 48));
        v37 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v36, (const char (*)[13])", config_id:");
        v38 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v37,
                (const unsigned int *)(v2 + 80));
        v39 = common::milog::MiLogStream::operator<<<char [21],(char *[21])0>(
                v38,
                (const char (*)[21])", last_refresh_time:");
        v40 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v39,
                (const unsigned int *)(v2 + 144));
        v41 = common::milog::MiLogStream::operator<<<char [14],(char *[14])0>(v40, (const char (*)[14])", drop_count:");
        v42 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v41,
                (const unsigned int *)(v2 + 64));
        v43 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(
                v42,
                (const char (*)[19])", old_bonus_count:");
        v44 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v43,
                (const unsigned int *)(v2 + 128));
        v45 = common::milog::MiLogStream::operator<<<char [19],(char *[19])0>(
                v44,
                (const char (*)[19])", new_bonus_count:");
        v46 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v45,
                (const unsigned int *)(v2 + 160));
        v47 = common::milog::MiLogStream::operator<<<char [27],(char *[27])0>(
                v46,
                (const char (*)[27])", bonus_count_daily_limit:");
        v48 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v47,
                (const unsigned int *)(v2 + 96));
        v49 = common::milog::MiLogStream::operator<<<char [24],(char *[24])0>(
                v48,
                (const char (*)[24])", detached_bonus_limit:");
        v50 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(
                v49,
                (const unsigned int *)(v2 + 112));
        v51 = common::milog::MiLogStream::operator<<<char [20],(char *[20])0>(
                v50,
                (const char (*)[20])", is_forbid_output:");
        common::milog::MiLogStream::operator<<(v51, is_forbid_output);
        common::milog::MiLogStream::~MiLogStream(&v63);
        if ( is_forbid_output )
          result = 698;
        else
          result = 0;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      common::milog::MiLogStream::create(
        &v63,
        &common::milog::MiLogDefault::default_log_obj_,
        3u,
        "./src/player/item/player_item_comp.cpp",
        "checkDropBonus",
        10901);
      v14 = common::milog::MiLogStream::operator<<<char [48],(char *[48])0>(&v63, (const char (*)[48])off_2639E980);
      common::milog::MiLogStream::operator<<<data::BonusSourceType,(data::BonusSourceType*)0>(
        v14,
        (const data::BonusSourceType *)(v2 + 48));
      common::milog::MiLogStream::~MiLogStream(&v63);
      result = -1;
    }
  }
  else
  {
    common::milog::MiLogStream::create(
      &v63,
      &common::milog::MiLogDefault::default_log_obj_,
      3u,
      "./src/player/item/player_item_comp.cpp",
      "checkDropBonus",
      10895);
    v11 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
            &v63,
            (const char (*)[45])"bonus source_type have no bonus, souce_type:");
    v12 = common::milog::MiLogStream::operator<<<data::BonusSourceType,(data::BonusSourceType*)0>(
            v11,
            (const data::BonusSourceType *)(v2 + 48));
    v13 = common::milog::MiLogStream::operator<<<char [13],(char *[13])0>(v12, (const char (*)[13])", config_id:");
    common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v13, (const unsigned int *)(v2 + 80));
    common::milog::MiLogStream::~MiLogStream(&v63);
    result = -1;
  }
LABEL_54:
  if ( v65 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8010) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8018) = 0LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8020) = 0LL;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8008) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8010) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8018) = 0xF5F5F5F5F5F5F5F5LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8020) = 0xF5F5F5F5F5F5F5F5LL;
  }
  return result;
};

// Line 10965: range 0000000017D23108-0000000017D234DD
void __cdecl PlayerItemComp::recordDropBonus(PlayerItemComp *const this, const DropBonusParam *drop_bonus_param)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  _DWORD *v4; // r13
  common::milog::MiLogStream *v5; // rax
  std::unordered_map<unsigned int,SingleBonusRecord> *v6; // rax
  std::unordered_map<unsigned int,SingleBonusRecord>::mapped_type *v7; // rax
  uint32_t Now; // edi
  __int64 v9; // rdx
  unsigned int v10; // ecx
  SelectType v11; // ecx
  char v12; // dl
  __int64 v13; // rsi
  __int64 v14; // rdx
  SingleBonusRecord *single_bonus_record; // [rsp+18h] [rbp-A8h]
  common::milog::MiLogStream v16; // [rsp+20h] [rbp-A0h] BYREF
  char v17[128]; // [rsp+40h] [rbp-80h] BYREF

  v2 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v3 = __asan_stack_malloc_1(96LL);
    if ( v3 )
      v2 = v3;
  }
  *(_QWORD *)v2 = 1102416563LL;
  *(_QWORD *)(v2 + 8) = "3 32 4 17 source_type:10966 48 4 16 drop_count:10967 64 4 15 config_id:10968";
  *(_QWORD *)(v2 + 16) = PlayerItemComp::recordDropBonus;
  v4 = (_DWORD *)(v2 >> 3);
  v4[536862720] = -235802127;
  v4[536862721] = -234556924;
  v4[536862722] = -202116348;
  if ( *(_BYTE *)(((unsigned __int64)drop_bonus_param >> 3) + 0x7FFF8000) != 0
    && (char)(((unsigned __int8)drop_bonus_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)drop_bonus_param >> 3)
                                                                       + 0x7FFF8000) )
  {
    __asan_report_load4(drop_bonus_param);
  }
  *(_DWORD *)(v2 + 32) = drop_bonus_param->source_type;
  if ( *(_BYTE *)(((unsigned __int64)&drop_bonus_param->drop_count >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)drop_bonus_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&drop_bonus_param->drop_count >> 3)
                                                                   + 0x7FFF8000) )
  {
    __asan_report_load4(&drop_bonus_param->drop_count);
  }
  *(_DWORD *)(v2 + 48) = drop_bonus_param->drop_count;
  if ( *(_BYTE *)(((unsigned __int64)&drop_bonus_param->config_id >> 3) + 0x7FFF8000) != 0
    && (char)((((_BYTE)drop_bonus_param + 8) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&drop_bonus_param->config_id >> 3)
                                                                   + 0x7FFF8000) )
  {
    __asan_report_load4(&drop_bonus_param->config_id);
  }
  *(_DWORD *)(v2 + 64) = drop_bonus_param->config_id;
  if ( *(_DWORD *)(v2 + 32) )
  {
    if ( *(_DWORD *)(v2 + 48) > 1u )
    {
      v6 = std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::operator[](
             &this->bonus_record_map_,
             (const std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::key_type *)(v2 + 32));
      v7 = std::unordered_map<unsigned int,SingleBonusRecord>::operator[](
             v6,
             (const std::unordered_map<unsigned int,SingleBonusRecord>::key_type *)(v2 + 64));
      single_bonus_record = v7;
      if ( *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)v7 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v7 >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(v7);
      }
      if ( !single_bonus_record->last_refresh_time )
      {
        Now = common::tools::TimeUtils::getNow();
        v9 = (*(_BYTE *)(((unsigned __int64)single_bonus_record >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((unsigned __int8)single_bonus_record & 7) + 3) >= *(_BYTE *)(((unsigned __int64)single_bonus_record >> 3) + 0x7FFF8000));
        if ( (_BYTE)v9 )
        {
          Now = (unsigned int)single_bonus_record;
          __asan_report_store4(single_bonus_record, ((unsigned __int8)single_bonus_record & 7u) + 3, v9);
        }
        single_bonus_record->last_refresh_time = Now;
      }
      v10 = *(_DWORD *)(v2 + 48) - 1;
      if ( *(_BYTE *)(((unsigned __int64)&single_bonus_record->bonus_count >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)single_bonus_record + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&single_bonus_record->bonus_count >> 3)
                                                                          + 0x7FFF8000) )
      {
        __asan_report_load4(&single_bonus_record->bonus_count);
      }
      v13 = v10;
      v11 = SAFE_ADD<unsigned int,unsigned int>(single_bonus_record->bonus_count, v10);
      v12 = *(_BYTE *)(((unsigned __int64)&single_bonus_record->bonus_count >> 3) + 0x7FFF8000);
      LOBYTE(v13) = v12 != 0;
      v14 = (v12 != 0) & (unsigned __int8)((char)((((_BYTE)single_bonus_record + 4) & 7) + 3) >= v12);
      if ( (_BYTE)v14 )
        __asan_report_store4(&single_bonus_record->bonus_count, v13, v14);
      single_bonus_record->bonus_count = v11;
    }
    else
    {
      common::milog::MiLogStream::create(
        &v16,
        &common::milog::MiLogDefault::default_log_obj_,
        4u,
        "./src/player/item/player_item_comp.cpp",
        "recordDropBonus",
        10975);
      v5 = common::milog::MiLogStream::operator<<<char [36],(char *[36])0>(
             &v16,
             (const char (*)[36])"drop_count less than 1, drop_count:");
      common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v5, (const unsigned int *)(v2 + 48));
      common::milog::MiLogStream::~MiLogStream(&v16);
    }
  }
  if ( v17 == (char *)v2 )
  {
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v2 = 1172321806LL;
    *(_QWORD *)((v2 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v2 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 10990: range 0000000017D234DE-0000000017D237D6
void __fastcall PlayerItemComp::tryRefreshBonusRecord(
        PlayerItemComp *const this,
        data::BonusSourceType source_type,
        uint32_t source_config_id)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  _DWORD *v5; // r12
  std::unordered_map<unsigned int,SingleBonusRecord> *v6; // rax
  std::unordered_map<unsigned int,SingleBonusRecord> *v7; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v8; // rax
  time_t v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rdx
  uint32_t now; // [rsp+10h] [rbp-A0h]
  uint32_t time_offset; // [rsp+14h] [rbp-9Ch]
  SingleBonusRecord *single_bonus_record; // [rsp+18h] [rbp-98h]
  std::shared_ptr<Config> v16; // [rsp+20h] [rbp-90h] BYREF
  char v17[128]; // [rsp+30h] [rbp-80h] BYREF

  v3 = (unsigned __int64)v17;
  if ( _asan_option_detect_stack_use_after_return )
  {
    v4 = __asan_stack_malloc_1(96LL);
    if ( v4 )
      v3 = v4;
  }
  *(_QWORD *)v3 = 1102416563LL;
  *(_QWORD *)(v3 + 8) = "2 48 4 17 source_type:10989 64 4 22 source_config_id:10989";
  *(_QWORD *)(v3 + 16) = PlayerItemComp::tryRefreshBonusRecord;
  v5 = (_DWORD *)(v3 >> 3);
  v5[536862720] = -235802127;
  v5[536862721] = -234556943;
  v5[536862722] = -202116348;
  *(_DWORD *)(v3 + 48) = source_type;
  *(_DWORD *)(v3 + 64) = source_config_id;
  if ( common::tools::MiscUtils::isContains<std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>,data::BonusSourceType>(
         &this->bonus_record_map_,
         (const data::BonusSourceType *)(v3 + 48)) )
  {
    v6 = std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::operator[](
           &this->bonus_record_map_,
           (const std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::key_type *)(v3 + 48));
    if ( common::tools::MiscUtils::isContains<std::unordered_map<unsigned int,SingleBonusRecord>,unsigned int>(
           v6,
           (const unsigned int *)(v3 + 64)) )
    {
      v7 = std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::operator[](
             &this->bonus_record_map_,
             (const std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::key_type *)(v3 + 48));
      single_bonus_record = std::unordered_map<unsigned int,SingleBonusRecord>::operator[](
                              v7,
                              (const std::unordered_map<unsigned int,SingleBonusRecord>::key_type *)(v3 + 64));
      now = common::tools::TimeUtils::getNow();
      ServiceBox::findService<GameserverService>();
      GameserverService::getConfig((GameserverService *const)&v16);
      v8 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v16);
      time_offset = ConstValueExcelConfigMgr::getTimeOffsetSec(&v8->design_config.txt_config_mgr.const_value_config_mgr);
      std::shared_ptr<Config>::~shared_ptr(&v16);
      v9 = time_offset;
      if ( *(_BYTE *)(((unsigned __int64)single_bonus_record >> 3) + 0x7FFF8000) != 0
        && (char)(((unsigned __int8)single_bonus_record & 7) + 3) >= *(_BYTE *)(((unsigned __int64)single_bonus_record >> 3)
                                                                              + 0x7FFF8000) )
      {
        __asan_report_load4(single_bonus_record);
      }
      if ( !common::tools::TimeUtils::isSameDay(now, single_bonus_record->last_refresh_time, v9) )
      {
        v10 = (*(_BYTE *)(((unsigned __int64)single_bonus_record >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((unsigned __int8)single_bonus_record & 7) + 3) >= *(_BYTE *)(((unsigned __int64)single_bonus_record >> 3) + 0x7FFF8000));
        if ( (_BYTE)v10 )
          __asan_report_store4(single_bonus_record, ((unsigned __int8)single_bonus_record & 7u) + 3, v10);
        single_bonus_record->last_refresh_time = now;
        v11 = (*(_BYTE *)(((unsigned __int64)&single_bonus_record->bonus_count >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)single_bonus_record + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&single_bonus_record->bonus_count >> 3) + 0x7FFF8000));
        if ( (_BYTE)v11 )
          __asan_report_store4(&single_bonus_record->bonus_count, (((_BYTE)single_bonus_record + 4) & 7u) + 3, v11);
        single_bonus_record->bonus_count = 0;
      }
    }
  }
  if ( v17 == (char *)v3 )
  {
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = 0;
  }
  else
  {
    *(_QWORD *)v3 = 1172321806LL;
    *(_QWORD *)((v3 >> 3) + 0x7FFF8000) = 0xF5F5F5F5F5F5F5F5LL;
    *(_DWORD *)((v3 >> 3) + 0x7FFF8008) = -168430091;
  }
};

// Line 11012: range 0000000017D237D8-0000000017D23A26
void __cdecl PlayerItemComp::buildDropBonusParam(
        PlayerItemComp *const this,
        DropBonusParam *drop_bonus_param,
        proto::ResinCostType resin_cost_type,
        uint32_t drop_count,
        uint32_t schedule_id)
{
  __int64 v5; // rsi
  __int64 v6; // rdx
  __int64 v7; // rsi
  __int64 v8; // rdx
  PlayerReunionComp *ReunionComp; // rax
  uint32_t CurReunionPrivilgeId; // ecx
  char v11; // dl
  __int64 v12; // rdx
  __int64 v13; // rsi
  __int64 v14; // rdx
  __int64 v15; // rdx
  PlayerOpActivityComp *OpActivityComp; // rax
  uint32_t CurActivityIdByScheduleId; // ecx
  char v18; // dl
  __int64 v19; // rsi
  __int64 v20; // rdx

  if ( resin_cost_type == RESIN_COST_TYPE_REUNION_PRIVILEGE )
  {
    v5 = ((unsigned __int8)drop_bonus_param & 7u) + 3;
    v6 = (*(_BYTE *)(((unsigned __int64)drop_bonus_param >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((unsigned __int8)drop_bonus_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)drop_bonus_param >> 3) + 0x7FFF8000));
    if ( (_BYTE)v6 )
      __asan_report_store4(drop_bonus_param, v5, v6);
    drop_bonus_param->source_type = 1;
    v7 = (((_BYTE)drop_bonus_param + 4) & 7u) + 3;
    v8 = (*(_BYTE *)(((unsigned __int64)&drop_bonus_param->drop_count >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)drop_bonus_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&drop_bonus_param->drop_count >> 3) + 0x7FFF8000));
    if ( (_BYTE)v8 )
      __asan_report_store4(&drop_bonus_param->drop_count, v7, v8);
    drop_bonus_param->drop_count = drop_count;
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    ReunionComp = Player::getReunionComp(this->player_);
    CurReunionPrivilgeId = PlayerReunionComp::getCurReunionPrivilgeId(ReunionComp);
    v11 = *(_BYTE *)(((unsigned __int64)&drop_bonus_param->config_id >> 3) + 0x7FFF8000);
    LOBYTE(v7) = v11 != 0;
    v12 = (v11 != 0) & (unsigned __int8)((char)((((_BYTE)drop_bonus_param + 8) & 7) + 3) >= v11);
    if ( (_BYTE)v12 )
      __asan_report_store4(&drop_bonus_param->config_id, v7, v12);
    drop_bonus_param->config_id = CurReunionPrivilgeId;
  }
  else if ( resin_cost_type == RESIN_COST_TYPE_OP_ACTIVITY )
  {
    v13 = ((unsigned __int8)drop_bonus_param & 7u) + 3;
    v14 = (*(_BYTE *)(((unsigned __int64)drop_bonus_param >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)(((unsigned __int8)drop_bonus_param & 7) + 3) >= *(_BYTE *)(((unsigned __int64)drop_bonus_param >> 3) + 0x7FFF8000));
    if ( (_BYTE)v14 )
      __asan_report_store4(drop_bonus_param, v13, v14);
    drop_bonus_param->source_type = 2;
    v15 = (*(_BYTE *)(((unsigned __int64)&drop_bonus_param->drop_count >> 3) + 0x7FFF8000) != 0) & (unsigned __int8)((char)((((_BYTE)drop_bonus_param + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&drop_bonus_param->drop_count >> 3) + 0x7FFF8000));
    if ( (_BYTE)v15 )
      __asan_report_store4(&drop_bonus_param->drop_count, (((_BYTE)drop_bonus_param + 4) & 7u) + 3, v15);
    drop_bonus_param->drop_count = drop_count;
    if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
      __asan_report_load8();
    OpActivityComp = Player::getOpActivityComp(this->player_);
    v19 = schedule_id;
    CurActivityIdByScheduleId = PlayerOpActivityComp::getCurActivityIdByScheduleId(OpActivityComp, schedule_id);
    v18 = *(_BYTE *)(((unsigned __int64)&drop_bonus_param->config_id >> 3) + 0x7FFF8000);
    LOBYTE(v19) = v18 != 0;
    v20 = (v18 != 0) & (unsigned __int8)((char)((((_BYTE)drop_bonus_param + 8) & 7) + 3) >= v18);
    if ( (_BYTE)v20 )
      __asan_report_store4(&drop_bonus_param->config_id, v19, v20);
    drop_bonus_param->config_id = CurActivityIdByScheduleId;
  }
};

// Line 11036: range 0000000017D23A28-0000000017D23B39
void __cdecl PlayerItemComp::clearOutputControlRecordsByYaceAndGm(PlayerItemComp *const this)
{
  common::milog::MiLogStream *v1; // rcx
  common::milog::MiLogStream v2; // [rsp+10h] [rbp-30h] BYREF

  common::milog::MiLogStream::create(
    &v2,
    &common::milog::MiLogDefault::default_log_obj_,
    1u,
    "./src/player/item/player_item_comp.cpp",
    "clearOutputControlRecordsByYaceAndGm",
    11037);
  v1 = common::milog::MiLogStream::operator<<<char [45],(char *[45])0>(
         &v2,
         (const char (*)[45])"clearOutputControlRecordsByYaceAndGm player:");
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  operator<<(v1, this->player_);
  common::milog::MiLogStream::~MiLogStream(&v2);
  std::unordered_map<data::ItemLimitType,ItemLimitRecord>::clear(&this->item_limit_record_map_);
  std::map<data::OutputControlType,OutputControlRecord>::clear(&this->output_control_record_map_);
  std::unordered_map<unsigned int,ShopGoodsOutputRecord>::clear(&this->shop_goods_output_record_map_);
  std::unordered_map<data::BonusSourceType,std::unordered_map<unsigned int,SingleBonusRecord>>::clear(&this->bonus_record_map_);
  std::unordered_map<data::NewActivityType,ActivityOutputControlRecord>::clear(&this->activity_output_control_record_map_);
};

// Line 11047: range 0000000017D23B3A-0000000017D23C5D
bool __cdecl PlayerItemComp::isCanForbidItemOutput(
        const PlayerItemComp *const this,
        data::ItemLimitType limit_type,
        const ItemIndexKey *item_index_key)
{
  char v3; // r12
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v4; // rax
  std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::element_type *v5; // rax
  bool v6; // r13
  std::shared_ptr<Config> v9; // [rsp+20h] [rbp-40h] BYREF
  std::shared_ptr<Config> v10[3]; // [rsp+30h] [rbp-30h] BYREF

  v3 = 0;
  ServiceBox::findService<GameserverService>();
  GameserverService::getConfig((GameserverService *const)&v9);
  v4 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)&v9);
  v6 = 1;
  if ( !ConstValueExcelConfigMgr::getIsOutputLimitCanForbid(&v4->design_config.txt_config_mgr.const_value_config_mgr) )
  {
    ServiceBox::findService<GameserverService>();
    GameserverService::getConfig((GameserverService *const)v10);
    v3 = 1;
    v5 = std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false>::operator->((const std::__shared_ptr_access<Config,(__gnu_cxx::_Lock_policy)2,false,false> *const)v10);
    if ( !ItemLimitExcelConfigMgr::isCanForbidOutputItemLimitConfig(
            &v5->design_config.txt_config_mgr.item_limit_config_mgr,
            limit_type,
            item_index_key) )
      v6 = 0;
  }
  if ( v3 )
    std::shared_ptr<Config>::~shared_ptr(v10);
  std::shared_ptr<Config>::~shared_ptr(&v9);
  return v6;
};

// Line 11054: range 0000000017D23C5E-0000000017D23F2E
int32_t __cdecl PlayerItemComp::checkReliquaryFilterState(
        const PlayerItemComp *const this,
        const std::map<unsigned int,unsigned int> *filter_state_map)
{
  const std::pair<unsigned int const,unsigned int> *v2; // rax
  unsigned int first; // eax
  common::milog::MiLogStream *v4; // rax
  common::milog::MiLogStream *v5; // rax
  common::milog::MiLogStream *v6; // rax
  common::milog::MiLogStream *v7; // rax
  common::milog::MiLogStream *v8; // rcx
  bool ret; // [rsp+1Fh] [rbp-51h]
  std::map<unsigned int,unsigned int>::const_iterator __for_begin; // [rsp+20h] [rbp-50h] BYREF
  std::map<unsigned int,unsigned int>::const_iterator __for_end; // [rsp+28h] [rbp-48h] BYREF
  const std::map<unsigned int,unsigned int> *__for_range; // [rsp+30h] [rbp-40h]
  const std::pair<unsigned int const,unsigned int> *iter; // [rsp+38h] [rbp-38h]
  common::milog::MiLogStream v15; // [rsp+40h] [rbp-30h] BYREF

  __for_range = filter_state_map;
  __for_begin._M_node = std::map<unsigned int,unsigned int>::begin(filter_state_map)._M_node;
  __for_end._M_node = std::map<unsigned int,unsigned int>::end(filter_state_map)._M_node;
  while ( 1 )
  {
    if ( !std::operator!=(&__for_begin, &__for_end) )
      return 0;
    v2 = std::_Rb_tree_const_iterator<std::pair<unsigned int const,unsigned int>>::operator*(&__for_begin);
    iter = v2;
    ret = 0;
    if ( *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)v2 & 7) + 3) >= *(_BYTE *)(((unsigned __int64)v2 >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(v2);
    }
    first = iter->first;
    if ( iter->first == 3 )
    {
      if ( *(_BYTE *)(((unsigned __int64)&iter->second >> 3) + 0x7FFF8000) != 0
        && (char)((((_BYTE)iter + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&iter->second >> 3) + 0x7FFF8000) )
      {
        __asan_report_load4(&iter->second);
      }
      ret = proto::ReliquaryFilterWearedState_IsValid(iter->second);
    }
    else if ( first <= 3 )
    {
      if ( first == 1 )
      {
        if ( *(_BYTE *)(((unsigned __int64)&iter->second >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)iter + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&iter->second >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(&iter->second);
        }
        ret = proto::ReliquaryFilterLockState_IsValid(iter->second);
      }
      else if ( first == 2 )
      {
        if ( *(_BYTE *)(((unsigned __int64)&iter->second >> 3) + 0x7FFF8000) != 0
          && (char)((((_BYTE)iter + 4) & 7) + 3) >= *(_BYTE *)(((unsigned __int64)&iter->second >> 3) + 0x7FFF8000) )
        {
          __asan_report_load4(&iter->second);
        }
        ret = proto::ReliquaryFilterLevelState_IsValid(iter->second);
      }
    }
    if ( !ret )
      break;
    std::_Rb_tree_const_iterator<std::pair<unsigned int const,unsigned int>>::operator++(&__for_begin);
  }
  common::milog::MiLogStream::create(
    &v15,
    &common::milog::MiLogDefault::default_log_obj_,
    3u,
    "./src/player/item/player_item_comp.cpp",
    "checkReliquaryFilterState",
    11074);
  v4 = common::milog::MiLogStream::operator<<<char [49],(char *[49])0>(
         &v15,
         (const char (*)[49])"check reliquary filter enum invalid, filter_key:");
  v5 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v4, (const unsigned int *)iter);
  v6 = common::milog::MiLogStream::operator<<<char [15],(char *[15])0>(v5, (const char (*)[15])" filter_value:");
  v7 = common::milog::MiLogStream::operator<<<unsigned int,(unsigned int *)0>(v6, &iter->second);
  v8 = common::milog::MiLogStream::operator<<<char [9],(char *[9])0>(v7, (const char (*)[9])" player:");
  if ( *(_BYTE *)(((unsigned __int64)&this->player_ >> 3) + 0x7FFF8000) )
    __asan_report_load8();
  operator<<(v8, this->player_);
  common::milog::MiLogStream::~MiLogStream(&v15);
  return -1;
};

// Line 11083: range 0000000017D23F30-0000000017D24056
void __cdecl PlayerItemComp::resetReliquaryFilterState(
        PlayerItemComp *const this,
        const std::map<unsigned int,unsigned int> *filter_state_map)
{
  unsigned int *p_second; // rax
  unsigned int second; // ebx
  const std::pair<unsigned int const,unsigned int> *v4; // rsi
  std::unordered_map<unsigned int,unsigned int>::mapped_type *v5; // rax
  unsigned int *v6; // rdx
  char v7; // cl
  std::map<unsigned int,unsigned int>::const_iterator __for_begin; // [rsp+10h] [rbp-30h] BYREF
  std::map<unsigned int,unsigned int>::const_iterator __for_end; // [rsp+18h] [rbp-28h] BYREF
  const std::map<unsigned int,unsigned int> *__for_range; // [rsp+20h] [rbp-20h]
  const std::pair<unsigned int const,unsigned int> *iter; // [rsp+28h] [rbp-18h]

  std::unordered_map<unsigned int,unsigned int>::clear(&this->reliquary_filter_state_map_);
  __for_range = filter_state_map;
  __for_begin._M_node = std::map<unsigned int,unsigned int>::begin(filter_state_map)._M_node;
  __for_end._M_node = std::map<unsigned int,unsigned int>::end(filter_state_map)._M_node;
  while ( std::operator!=(&__for_begin, &__for_end) )
  {
    iter = std::_Rb_tree_const_iterator<std::pair<unsigned int const,unsigned int>>::operator*(&__for_begin);
    p_second = &iter->second;
    if ( *(_BYTE *)(((unsigned __int64)p_second >> 3) + 0x7FFF8000) != 0
      && (char)(((unsigned __int8)p_second & 7) + 3) >= *(_BYTE *)(((unsigned __int64)p_second >> 3) + 0x7FFF8000) )
    {
      __asan_report_load4(p_second);
    }
    second = iter->second;
    v4 = iter;
    v5 = std::unordered_map<unsigned int,unsigned int>::operator[](
           &this->reliquary_filter_state_map_,
           (const std::unordered_map<unsigned int,unsigned int>::key_type *)iter);
    v6 = v5;
    v7 = *(_BYTE *)(((unsigned __int64)v5 >> 3) + 0x7FFF8000);
    if ( v7 != 0 && (char)(((unsigned __int8)v5 & 7) + 3) >= v7 )
    {
      LOBYTE(v4) = v7 != 0;
      __asan_report_store4(v5, v4, v5);
    }
    *v6 = second;
    std::_Rb_tree_const_iterator<std::pair<unsigned int const,unsigned int>>::operator++(&__for_begin);
  }
};
