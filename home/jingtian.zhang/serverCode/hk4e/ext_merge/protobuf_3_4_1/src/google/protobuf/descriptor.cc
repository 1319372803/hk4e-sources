// File: /home/jingtian.zhang/serverCode/hk4e/ext_merge/protobuf_3_4_1/src/google/protobuf/descriptor.cc

// Line 220: range 000000000C8F4820-000000000C8F48A9
const char *__fastcall google::protobuf::FileDescriptor::SyntaxName(
        google::protobuf::FileDescriptor *this,
        google::protobuf::FileDescriptor::Syntax a2)
{
  google::protobuf::internal::LogMessage_0 *v2; // rax
  google::protobuf::internal::LogFinisher v4; // [rsp+1h] [rbp-49h] BYREF
  google::protobuf::internal::LogMessage_0 v5; // [rsp+2h] [rbp-48h] BYREF

  switch ( (_DWORD)this )
  {
    case 2:
      return "proto2";
    case 3:
      return "proto3";
    case 0:
      return "unknown";
  }
  google::protobuf::internal::LogMessage::LogMessage(&v5, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 228);
  v2 = google::protobuf::internal::LogMessage::operator<<(&v5, "can't reach here.");
  google::protobuf::internal::LogFinisher::operator=(&v4, v2);
  google::protobuf::internal::LogMessage::~LogMessage(&v5);
  return 0LL;
};

// Line 228: range 000000000C72D470-000000000C72D47D
void __fastcall __noreturn google::protobuf::FileDescriptor::SyntaxName(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 251: range 000000000C8F4620-000000000C8F47AA
char **__fastcall google::protobuf::`anonymous namespace'::ToCamelCase(char **a1, _QWORD *a2, char a3)
{
  __int64 v4; // rsi
  unsigned __int64 i; // rbp
  char *v6; // r13
  char *v7; // rax
  unsigned __int64 v8; // r15
  char v9; // bl
  unsigned __int64 v10; // rdx
  char *v11; // rax
  char v12; // al
  unsigned __int64 v14; // rdx
  char *v15; // rax
  char *v16; // [rsp+0h] [rbp-48h]
  char v17; // [rsp+Bh] [rbp-3Dh]

  a1[1] = 0LL;
  v17 = a3 ^ 1;
  *((_BYTE *)a1 + 16) = 0;
  v4 = a2[1];
  *a1 = (char *)(a1 + 2);
  v16 = (char *)(a1 + 2);
  std::string::reserve(a1, v4);
  for ( i = 0LL; a2[1] > i; ++i )
  {
    while ( 1 )
    {
      v9 = *(_BYTE *)(*a2 + i);
      if ( v9 != 95 )
        break;
      v17 = 1;
      if ( a2[1] <= ++i )
        goto LABEL_14;
    }
    v6 = a1[1];
    v7 = *a1;
    v8 = (unsigned __int64)(v6 + 1);
    if ( v17 )
    {
      if ( (unsigned __int8)(v9 - 97) < 0x1Au )
        v9 -= 32;
      if ( v16 == v7 )
        v10 = 15LL;
      else
        v10 = (unsigned __int64)a1[2];
      if ( v10 < v8 )
      {
        std::string::_M_mutate(a1, a1[1], 0LL, 0LL, 1LL);
        v7 = *a1;
      }
      v6[(_QWORD)v7] = v9;
      v11 = *a1;
      a1[1] = (char *)v8;
      v17 = 0;
      v6[(_QWORD)v11 + 1] = 0;
    }
    else
    {
      if ( v16 == v7 )
        v14 = 15LL;
      else
        v14 = (unsigned __int64)a1[2];
      if ( v14 < v8 )
      {
        std::string::_M_mutate(a1, a1[1], 0LL, 0LL, 1LL);
        v7 = *a1;
      }
      v6[(_QWORD)v7] = v9;
      v15 = *a1;
      a1[1] = (char *)v8;
      v6[(_QWORD)v15 + 1] = 0;
    }
  }
LABEL_14:
  if ( a3 && a1[1] )
  {
    v12 = **a1;
    if ( (unsigned __int8)(v12 - 65) < 0x1Au )
      v12 += 32;
    **a1 = v12;
  }
  return a1;
};

// Line 406: range 000000000C8F3250-000000000C8F3292
std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator __fastcall std::_Hashtable<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::Descriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::Descriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
        const std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *const this,
        const std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *__k)
{
  std::__detail::_Node_iterator_base<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,true>::__node_type **v2; // rax
  std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator result; // rax

  v2 = (std::__detail::_Node_iterator_base<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,true>::__node_type **)std::_Hashtable<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::Descriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::Descriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(this, (__k->second + 0xFFFF * (__int64)__k->first) % this->_M_bucket_count, __k, __k->second + 0xFFFF * (__int64)__k->first);
  if ( !v2 )
    return 0LL;
  result._M_cur = *v2;
  if ( !result._M_cur )
    return 0LL;
  return result;
};

// Line 406: range 000000000C8F3310-000000000C8F3352
std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator __fastcall std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
        const std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *const this,
        const std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *__k)
{
  std::__detail::_Node_iterator_base<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,true>::__node_type **v2; // rax
  std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator result; // rax

  v2 = (std::__detail::_Node_iterator_base<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,true>::__node_type **)std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(this, (__k->second + 0xFFFF * (__int64)__k->first) % this->_M_bucket_count, __k, __k->second + 0xFFFF * (__int64)__k->first);
  if ( !v2 )
    return 0LL;
  result._M_cur = *v2;
  if ( !result._M_cur )
    return 0LL;
  return result;
};

// Line 406: range 000000000C8F3360-000000000C8F33A2
std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::iterator __fastcall std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
        std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *const this,
        const std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *__k)
{
  std::__detail::_Node_iterator_base<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,true>::__node_type **v2; // rax
  std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::iterator result; // rax

  v2 = (std::__detail::_Node_iterator_base<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,true>::__node_type **)std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(this, (__k->second + 0xFFFF * (__int64)__k->first) % this->_M_bucket_count, __k, __k->second + 0xFFFF * (__int64)__k->first);
  if ( !v2 )
    return 0LL;
  result._M_cur = *v2;
  if ( !result._M_cur )
    return 0LL;
  return result;
};

// Line 477: range 000000000C8F78F0-000000000C8F7921
void __cdecl google::protobuf::`anonymous namespace'::DeleteAllowedProto3Extendee()
{
  std::set<std::string> *v0; // rbp

  v0 = google::protobuf::`anonymous namespace'::allowed_proto3_extendees_;
  if ( google::protobuf::`anonymous namespace'::allowed_proto3_extendees_ )
  {
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_erase(
      &google::protobuf::`anonymous namespace'::allowed_proto3_extendees_->_M_t,
      (std::_Rb_tree<std::string,std::string,std::_Identity<std::string >,std::less<std::string >,std::allocator<std::string > >::_Link_type)google::protobuf::`anonymous namespace'::allowed_proto3_extendees_->_M_t._M_impl._M_header._M_parent);
    operator delete(v0, 0x30uLL);
  }
};

// Line 481: range 000000000C8F8C80-000000000C8F8FCD
__int64 __fastcall google::protobuf::`anonymous namespace'::InitAllowedProto3Extendee(
        google::protobuf::_anonymous_namespace_ *this)
{
  const char *v1; // r13
  char *v2; // r14
  std::forward_iterator_tag v3; // cl
  std::set<std::string> *v4; // r15
  std::forward_iterator_tag v5; // cl
  __int64 v6; // rax
  __int64 v7; // rax
  size_t v8; // r12
  __int64 v9; // rax
  std::set<std::string> *v11; // [rsp+8h] [rbp-E0h]
  std::string v12; // [rsp+10h] [rbp-D8h] BYREF
  std::string v13; // [rsp+30h] [rbp-B8h] BYREF
  std::string __v; // [rsp+50h] [rbp-98h] BYREF
  __int64 v15[7]; // [rsp+78h] [rbp-70h] BYREF
  char v16; // [rsp+B0h] [rbp-38h] BYREF

  v1 = "FileOptions";
  v2 = (char *)v15;
  v15[0] = (__int64)"MessageOptions";
  v4 = (std::set<std::string> *)operator new(0x30uLL);
  v4->_M_t._M_impl._M_header._M_color = _S_red;
  v4->_M_t._M_impl._M_header._M_parent = 0LL;
  google::protobuf::`anonymous namespace'::allowed_proto3_extendees_ = v4;
  v4->_M_t._M_impl._M_header._M_left = &v4->_M_t._M_impl._M_header;
  v4->_M_t._M_impl._M_header._M_right = &v4->_M_t._M_impl._M_header;
  v4->_M_t._M_impl._M_node_count = 0LL;
  v15[1] = (__int64)"FieldOptions";
  v15[2] = (__int64)"EnumOptions";
  v15[3] = (__int64)"EnumValueOptions";
  v15[4] = (__int64)"ServiceOptions";
  v15[5] = (__int64)"MethodOptions";
  v15[6] = (__int64)"OneofOptions";
  while ( 1 )
  {
    v13._M_dataplus._M_p = v13._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&v13, "google.protobuf.", "", v3);
    v8 = strlen(v1);
    if ( v8 > 0x3FFFFFFFFFFFFFFFLL - v13._M_string_length )
      std::__throw_length_error("basic_string::append");
    v9 = std::string::_M_append(&v13, v1, v8);
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    if ( *(_QWORD *)v9 == v9 + 16 )
    {
      __v._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v9 + 16));
    }
    else
    {
      __v._M_dataplus._M_p = *(std::string::pointer *)v9;
      __v._anon_0._M_allocated_capacity = *(_QWORD *)(v9 + 16);
    }
    __v._M_string_length = *(_QWORD *)(v9 + 8);
    *(_QWORD *)v9 = v9 + 16;
    *(_QWORD *)(v9 + 8) = 0LL;
    *(_BYTE *)(v9 + 16) = 0;
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v4->_M_t,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v13._M_dataplus._M_p != &v13._anon_0 )
      operator delete(v13._M_dataplus._M_p);
    v12._M_dataplus._M_p = v12._anon_0._M_local_buf;
    v11 = google::protobuf::`anonymous namespace'::allowed_proto3_extendees_;
    std::string::_M_construct<char const*>(&v12, "proto", "", v5);
    if ( v12._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v12._M_string_length == 4611686018427387902LL )
      std::__throw_length_error("basic_string::append");
    v6 = std::string::_M_append(&v12, "2.", 2LL);
    v13._M_dataplus._M_p = v13._anon_0._M_local_buf;
    if ( *(_QWORD *)v6 == v6 + 16 )
    {
      v13._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v6 + 16));
    }
    else
    {
      v13._M_dataplus._M_p = *(std::string::pointer *)v6;
      v13._anon_0._M_allocated_capacity = *(_QWORD *)(v6 + 16);
    }
    v13._M_string_length = *(_QWORD *)(v6 + 8);
    *(_QWORD *)(v6 + 8) = 0LL;
    *(_BYTE *)(v6 + 16) = 0;
    *(_QWORD *)v6 = v6 + 16;
    if ( v8 > 0x3FFFFFFFFFFFFFFFLL - v13._M_string_length )
      std::__throw_length_error("basic_string::append");
    v7 = std::string::_M_append(&v13, v1, v8);
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    if ( *(_QWORD *)v7 == v7 + 16 )
    {
      __v._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v7 + 16));
    }
    else
    {
      __v._M_dataplus._M_p = *(std::string::pointer *)v7;
      __v._anon_0._M_allocated_capacity = *(_QWORD *)(v7 + 16);
    }
    __v._M_string_length = *(_QWORD *)(v7 + 8);
    *(_QWORD *)v7 = v7 + 16;
    *(_QWORD *)(v7 + 8) = 0LL;
    *(_BYTE *)(v7 + 16) = 0;
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v11->_M_t,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v13._M_dataplus._M_p != &v13._anon_0 )
      operator delete(v13._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v12._M_dataplus._M_p != &v12._anon_0 )
      operator delete(v12._M_dataplus._M_p);
    if ( v2 == &v16 )
      break;
    v4 = google::protobuf::`anonymous namespace'::allowed_proto3_extendees_;
    v1 = *(const char **)v2;
    v2 += 8;
  }
  return google::protobuf::internal::OnShutdown(
           (google::protobuf::internal *)google::protobuf::`anonymous namespace'::DeleteAllowedProto3Extendee,
           (void (*)(void))&__v);
};

// Line 773: range 000000000C8F7960-000000000C8F7CFB
std::_Rb_tree_header *__fastcall google::protobuf::DescriptorPool::Tables::Tables(
        google::protobuf::DescriptorPool::Tables *this)
{
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type *p_M_single_bucket; // r13
  std::_Hashtable<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::allocator<const google::protobuf::Descriptor*>,std::__detail::_Identity,std::equal_to<const google::protobuf::Descriptor*>,google::protobuf::hash<const google::protobuf::Descriptor*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true> >::__bucket_type *v3; // rax
  std::__detail::_Prime_rehash_policy *p_M_rehash_policy; // rdi
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *bkt; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v6; // rbx
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type *buckets; // r13
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *v8; // rax
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v9; // rbx
  std::_Rb_tree_header *result; // rax

  p_M_single_bucket = &this->symbols_by_name_._M_h._M_single_bucket;
  this->known_bad_files_._M_h._M_buckets = &this->known_bad_files_._M_h._M_single_bucket;
  this->known_bad_symbols_._M_h._M_buckets = &this->known_bad_symbols_._M_h._M_single_bucket;
  v3 = &this->extensions_loaded_from_db_._M_h._M_single_bucket;
  p_M_rehash_policy = &this->symbols_by_name_._M_h._M_rehash_policy;
  p_M_rehash_policy[-22]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-21]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-21]._M_next_resize = 0LL;
  p_M_rehash_policy[-20]._M_next_resize = 1LL;
  *(_QWORD *)&p_M_rehash_policy[-19]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-19]._M_next_resize = 0LL;
  p_M_rehash_policy[-18]._M_max_load_factor = 1.0;
  p_M_rehash_policy[-18]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-17]._M_max_load_factor = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-16]._M_max_load_factor = 1LL;
  p_M_rehash_policy[-16]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-15]._M_max_load_factor = 0LL;
  LODWORD(p_M_rehash_policy[-15]._M_next_resize) = 1065353216;
  *(_QWORD *)&p_M_rehash_policy[-14]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-14]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-13]._M_max_load_factor = v3;
  p_M_rehash_policy[-13]._M_next_resize = 1LL;
  *(_QWORD *)&p_M_rehash_policy[-12]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-12]._M_next_resize = 0LL;
  p_M_rehash_policy[-11]._M_max_load_factor = 1.0;
  p_M_rehash_policy[-11]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-10]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-10]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-9]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-9]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-8]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-8]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-7]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-7]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-6]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-6]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-5]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-5]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-4]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-4]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-3]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-3]._M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[-2]._M_max_load_factor = p_M_single_bucket;
  p_M_rehash_policy[-2]._M_next_resize = 1LL;
  *(_QWORD *)&p_M_rehash_policy[-1]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-1]._M_next_resize = 0LL;
  p_M_rehash_policy->_M_max_load_factor = 1.0;
  p_M_rehash_policy->_M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[1]._M_max_load_factor = 0LL;
  bkt = (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)std::__detail::_Prime_rehash_policy::_M_next_bkt(p_M_rehash_policy, 3uLL);
  v6 = (std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type)bkt;
  if ( (unsigned __int64)bkt > this->symbols_by_name_._M_h._M_bucket_count )
  {
    if ( bkt == (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)1 )
      this->symbols_by_name_._M_h._M_single_bucket = 0LL;
    else
      p_M_single_bucket = std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::pair const<void const*,char const*>,google::protobuf::FieldDescriptor const*>,true>>>::_M_allocate_buckets(
                            bkt,
                            3uLL);
    this->symbols_by_name_._M_h._M_buckets = p_M_single_bucket;
    this->symbols_by_name_._M_h._M_bucket_count = v6;
  }
  buckets = &this->files_by_name_._M_h._M_single_bucket;
  this->files_by_name_._M_h._M_bucket_count = 1LL;
  this->files_by_name_._M_h._M_buckets = &this->files_by_name_._M_h._M_single_bucket;
  this->files_by_name_._M_h._M_before_begin._M_nxt = 0LL;
  this->files_by_name_._M_h._M_element_count = 0LL;
  this->files_by_name_._M_h._M_rehash_policy._M_max_load_factor = 1.0;
  this->files_by_name_._M_h._M_rehash_policy._M_next_resize = 0LL;
  this->files_by_name_._M_h._M_single_bucket = 0LL;
  v8 = (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)std::__detail::_Prime_rehash_policy::_M_next_bkt(&this->files_by_name_._M_h._M_rehash_policy, 3uLL);
  v9 = (std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type)v8;
  if ( (unsigned __int64)v8 > this->files_by_name_._M_h._M_bucket_count )
  {
    if ( v8 == (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)1 )
      this->files_by_name_._M_h._M_single_bucket = 0LL;
    else
      buckets = std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::pair const<void const*,char const*>,google::protobuf::FieldDescriptor const*>,true>>>::_M_allocate_buckets(
                  v8,
                  3uLL);
    this->files_by_name_._M_h._M_buckets = buckets;
    this->files_by_name_._M_h._M_bucket_count = v9;
  }
  result = &this->extensions_._M_t._M_impl.std::_Rb_tree_header;
  this->extensions_._M_t._M_impl._M_header._M_color = _S_red;
  this->extensions_._M_t._M_impl._M_header._M_parent = 0LL;
  this->extensions_._M_t._M_impl._M_header._M_left = &this->extensions_._M_t._M_impl._M_header;
  this->extensions_._M_t._M_impl._M_header._M_right = &this->extensions_._M_t._M_impl._M_header;
  this->extensions_._M_t._M_impl._M_node_count = 0LL;
  this->checkpoints_._M_impl._M_start = 0LL;
  this->checkpoints_._M_impl._M_finish = 0LL;
  this->checkpoints_._M_impl._M_end_of_storage = 0LL;
  this->symbols_after_checkpoint_._M_impl._M_start = 0LL;
  this->symbols_after_checkpoint_._M_impl._M_finish = 0LL;
  this->symbols_after_checkpoint_._M_impl._M_end_of_storage = 0LL;
  this->files_after_checkpoint_._M_impl._M_start = 0LL;
  this->files_after_checkpoint_._M_impl._M_finish = 0LL;
  this->files_after_checkpoint_._M_impl._M_end_of_storage = 0LL;
  this->extensions_after_checkpoint_._M_impl._M_start = 0LL;
  this->extensions_after_checkpoint_._M_impl._M_finish = 0LL;
  this->extensions_after_checkpoint_._M_impl._M_end_of_storage = 0LL;
  return result;
};

// Line 782: range 000000000C8F7F20-000000000C8F8184
void __fastcall google::protobuf::DescriptorPool::Tables::~Tables(google::protobuf::DescriptorPool::Tables *const this)
{
  std::_Vector_base<google::protobuf::Message*>::pointer M_finish; // r12
  std::_Vector_base<google::protobuf::Message*>::pointer M_start; // rbp
  google::protobuf::Message **v4; // rax
  void **v5; // rdx
  unsigned __int64 v6; // rbp
  void *v7; // rdi
  std::string **v8; // rax
  google::protobuf::FileDescriptorTables **v9; // rax
  std::_Vector_base<google::protobuf::GoogleOnceDynamic*>::pointer v10; // r12
  void **v11; // rbp
  google::protobuf::GoogleOnceDynamic **v12; // rax
  std::_Vector_base<std::pair<const google::protobuf::Descriptor*,int>>::pointer v13; // rdi
  std::_Vector_base<char const*>::pointer v14; // rdi
  std::_Vector_base<char const*>::pointer v15; // rdi
  std::_Vector_base<google::protobuf::DescriptorPool::Tables::CheckPoint>::pointer v16; // rdi
  std::_Vector_base<void*>::pointer v17; // rdi
  std::_Vector_base<google::protobuf::FileDescriptorTables*>::pointer v18; // rdi
  std::_Vector_base<google::protobuf::GoogleOnceDynamic*>::pointer v19; // rdi
  std::_Vector_base<google::protobuf::Message*>::pointer v20; // rdi
  std::_Vector_base<std::string*>::pointer v21; // rdi
  std::string *v22; // r12
  std::_Vector_base<std::string>::pointer v23; // rbp

  M_finish = this->messages_._M_impl._M_finish;
  M_start = this->messages_._M_impl._M_start;
  if ( M_finish != M_start )
  {
    do
    {
      if ( *M_start )
        (*((void (__fastcall **)(google::protobuf::Message *))(*M_start)->_vptr_MessageLite + 1))(*M_start);
      ++M_start;
    }
    while ( M_finish != M_start );
    v4 = this->messages_._M_impl._M_start;
    if ( this->messages_._M_impl._M_finish != v4 )
      this->messages_._M_impl._M_finish = v4;
  }
  v5 = this->allocations_._M_impl._M_start;
  v6 = 0LL;
  if ( this->allocations_._M_impl._M_finish != v5 )
  {
    do
    {
      v7 = v5[v6++];
      operator delete(v7);
      v5 = this->allocations_._M_impl._M_start;
    }
    while ( this->allocations_._M_impl._M_finish - v5 > v6 );
  }
  google::protobuf::STLDeleteContainerPointers<__gnu_cxx::__normal_iterator<std::string **,std::vector<std::string *>>>(
    (__gnu_cxx::__normal_iterator<std::string**,std::vector<std::string*> >)this->strings_._M_impl._M_start,
    (__gnu_cxx::__normal_iterator<std::string**,std::vector<std::string*> >)this->strings_._M_impl._M_finish);
  v8 = this->strings_._M_impl._M_start;
  if ( v8 != this->strings_._M_impl._M_finish )
    this->strings_._M_impl._M_finish = v8;
  google::protobuf::STLDeleteContainerPointers<__gnu_cxx::__normal_iterator<google::protobuf::FileDescriptorTables **,std::vector<google::protobuf::FileDescriptorTables *>>>(
    (__gnu_cxx::__normal_iterator<google::protobuf::FileDescriptorTables**,std::vector<google::protobuf::FileDescriptorTables*> >)this->file_tables_._M_impl._M_start,
    (__gnu_cxx::__normal_iterator<google::protobuf::FileDescriptorTables**,std::vector<google::protobuf::FileDescriptorTables*> >)this->file_tables_._M_impl._M_finish);
  v9 = this->file_tables_._M_impl._M_start;
  if ( v9 != this->file_tables_._M_impl._M_finish )
    this->file_tables_._M_impl._M_finish = v9;
  v10 = this->once_dynamics_._M_impl._M_finish;
  v11 = (void **)this->once_dynamics_._M_impl._M_start;
  if ( v10 != (std::_Vector_base<google::protobuf::GoogleOnceDynamic*>::pointer)v11 )
  {
    do
    {
      if ( *v11 )
        operator delete(*v11, 8uLL);
      ++v11;
    }
    while ( v10 != (std::_Vector_base<google::protobuf::GoogleOnceDynamic*>::pointer)v11 );
    v12 = this->once_dynamics_._M_impl._M_start;
    if ( v12 != this->once_dynamics_._M_impl._M_finish )
      this->once_dynamics_._M_impl._M_finish = v12;
  }
  v13 = this->extensions_after_checkpoint_._M_impl._M_start;
  if ( v13 )
    operator delete(v13);
  v14 = this->files_after_checkpoint_._M_impl._M_start;
  if ( v14 )
    operator delete(v14);
  v15 = this->symbols_after_checkpoint_._M_impl._M_start;
  if ( v15 )
    operator delete(v15);
  v16 = this->checkpoints_._M_impl._M_start;
  if ( v16 )
    operator delete(v16);
  std::_Rb_tree<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::less<std::pair<google::protobuf::Descriptor const*,int>>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>>::_M_erase(
    &this->extensions_._M_t,
    (std::_Rb_tree<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::less<std::pair<const google::protobuf::Descriptor*,int> >,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> > >::_Link_type)this->extensions_._M_t._M_impl._M_header._M_parent);
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::~_Hashtable(&this->files_by_name_._M_h);
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::~_Hashtable(&this->symbols_by_name_._M_h);
  v17 = this->allocations_._M_impl._M_start;
  if ( v17 )
    operator delete(v17);
  v18 = this->file_tables_._M_impl._M_start;
  if ( v18 )
    operator delete(v18);
  v19 = this->once_dynamics_._M_impl._M_start;
  if ( v19 )
    operator delete(v19);
  v20 = this->messages_._M_impl._M_start;
  if ( v20 )
    operator delete(v20);
  v21 = this->strings_._M_impl._M_start;
  if ( v21 )
    operator delete(v21);
  std::_Hashtable<google::protobuf::Descriptor const*,google::protobuf::Descriptor const*,std::allocator<google::protobuf::Descriptor const*>,std::__detail::_Identity,std::equal_to<google::protobuf::Descriptor const*>,google::protobuf::hash<google::protobuf::Descriptor const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::~_Hashtable(&this->extensions_loaded_from_db_._M_h);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::~_Hashtable(&this->known_bad_symbols_._M_h);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::~_Hashtable(&this->known_bad_files_._M_h);
  v22 = this->pending_files_._M_impl._M_finish;
  v23 = this->pending_files_._M_impl._M_start;
  if ( v22 != this->pending_files_._M_impl._M_start )
  {
    do
    {
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v23->_M_dataplus._M_p != &v23->_anon_0 )
        operator delete(v23->_M_dataplus._M_p);
      ++v23;
    }
    while ( v22 != v23 );
    v23 = this->pending_files_._M_impl._M_start;
  }
  if ( v23 )
    operator delete(v23);
};

// Line 795: range 000000000C8F6650-000000000C8F68C8
void __fastcall google::protobuf::FileDescriptorTables::FileDescriptorTables(
        google::protobuf::FileDescriptorTables *this)
{
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type *p_M_single_bucket; // r12
  std::__detail::_Prime_rehash_policy *p_M_rehash_policy; // rdi
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *bkt; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v5; // rbx
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type *buckets; // r12
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *v7; // rax
  std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v8; // rbx
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type *v9; // r12
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *v10; // rax
  std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v11; // rbx

  p_M_single_bucket = &this->symbols_by_parent_._M_h._M_single_bucket;
  p_M_rehash_policy = &this->symbols_by_parent_._M_h._M_rehash_policy;
  *(_QWORD *)&p_M_rehash_policy[-2]._M_max_load_factor = p_M_single_bucket;
  p_M_rehash_policy[-2]._M_next_resize = 1LL;
  *(_QWORD *)&p_M_rehash_policy[-1]._M_max_load_factor = 0LL;
  p_M_rehash_policy[-1]._M_next_resize = 0LL;
  p_M_rehash_policy->_M_max_load_factor = 1.0;
  p_M_rehash_policy->_M_next_resize = 0LL;
  *(_QWORD *)&p_M_rehash_policy[1]._M_max_load_factor = 0LL;
  bkt = (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)std::__detail::_Prime_rehash_policy::_M_next_bkt(p_M_rehash_policy, 3uLL);
  v5 = (std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type)bkt;
  if ( (unsigned __int64)bkt > this->symbols_by_parent_._M_h._M_bucket_count )
  {
    if ( bkt == (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)1 )
      this->symbols_by_parent_._M_h._M_single_bucket = 0LL;
    else
      p_M_single_bucket = std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::pair const<void const*,char const*>,google::protobuf::FieldDescriptor const*>,true>>>::_M_allocate_buckets(
                            bkt,
                            3uLL);
    this->symbols_by_parent_._M_h._M_buckets = p_M_single_bucket;
    this->symbols_by_parent_._M_h._M_bucket_count = v5;
  }
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_Hashtable(&this->fields_by_lowercase_name_);
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_Hashtable(&this->fields_by_camelcase_name_);
  buckets = &this->fields_by_number_._M_h._M_single_bucket;
  this->fields_by_number_._M_h._M_bucket_count = 1LL;
  this->fields_by_number_._M_h._M_buckets = &this->fields_by_number_._M_h._M_single_bucket;
  this->fields_by_number_._M_h._M_before_begin._M_nxt = 0LL;
  this->fields_by_number_._M_h._M_element_count = 0LL;
  this->fields_by_number_._M_h._M_rehash_policy._M_max_load_factor = 1.0;
  this->fields_by_number_._M_h._M_rehash_policy._M_next_resize = 0LL;
  this->fields_by_number_._M_h._M_single_bucket = 0LL;
  v7 = (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)std::__detail::_Prime_rehash_policy::_M_next_bkt(&this->fields_by_number_._M_h._M_rehash_policy, 3uLL);
  v8 = (std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type)v7;
  if ( (unsigned __int64)v7 > this->fields_by_number_._M_h._M_bucket_count )
  {
    if ( v7 == (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)1 )
      this->fields_by_number_._M_h._M_single_bucket = 0LL;
    else
      buckets = std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::pair const<void const*,char const*>,google::protobuf::FieldDescriptor const*>,true>>>::_M_allocate_buckets(
                  v7,
                  3uLL);
    this->fields_by_number_._M_h._M_buckets = buckets;
    this->fields_by_number_._M_h._M_bucket_count = v8;
  }
  std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_Hashtable(&this->enum_values_by_number_);
  std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_Hashtable(&this->unknown_enum_values_by_number_);
  v9 = &this->locations_by_path_._M_h._M_single_bucket;
  this->locations_by_path_once_.state_ = 0LL;
  this->locations_by_path_._M_h._M_buckets = &this->locations_by_path_._M_h._M_single_bucket;
  this->locations_by_path_._M_h._M_bucket_count = 1LL;
  this->locations_by_path_._M_h._M_before_begin._M_nxt = 0LL;
  this->locations_by_path_._M_h._M_element_count = 0LL;
  this->locations_by_path_._M_h._M_rehash_policy._M_max_load_factor = 1.0;
  this->locations_by_path_._M_h._M_rehash_policy._M_next_resize = 0LL;
  this->locations_by_path_._M_h._M_single_bucket = 0LL;
  v10 = (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)std::__detail::_Prime_rehash_policy::_M_next_bkt(&this->locations_by_path_._M_h._M_rehash_policy, 0LL);
  v11 = (std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type)v10;
  if ( (unsigned __int64)v10 > this->locations_by_path_._M_h._M_bucket_count )
  {
    if ( v10 == (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)1 )
      this->locations_by_path_._M_h._M_single_bucket = 0LL;
    else
      v9 = std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::pair const<void const*,char const*>,google::protobuf::FieldDescriptor const*>,true>>>::_M_allocate_buckets(
             v10,
             0LL);
    this->locations_by_path_._M_h._M_buckets = v9;
    this->locations_by_path_._M_h._M_bucket_count = v11;
  }
  google::protobuf::internal::Mutex::Mutex(&this->unknown_enum_values_mu_);
};

// Line 805: range 000000000C8F65C0-000000000C8F6616
void __fastcall google::protobuf::FileDescriptorTables::~FileDescriptorTables(
        google::protobuf::FileDescriptorTables *const this)
{
  google::protobuf::internal::Mutex::~Mutex(&this->unknown_enum_values_mu_);
  std::_Hashtable<std::string,std::pair<std::string const,google::protobuf::SourceCodeInfo_Location const*>,std::allocator<std::pair<std::string const,google::protobuf::SourceCodeInfo_Location const*>>,std::__detail::_Select1st,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::~_Hashtable(&this->locations_by_path_._M_h);
  std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::~_Hashtable(&this->unknown_enum_values_by_number_._M_h);
  std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::~_Hashtable(&this->enum_values_by_number_._M_h);
  std::_Hashtable<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::Descriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::Descriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::~_Hashtable(&this->fields_by_number_._M_h);
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::~_Hashtable(&this->fields_by_camelcase_name_._M_h);
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::~_Hashtable(&this->fields_by_lowercase_name_._M_h);
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::~_Hashtable(&this->symbols_by_parent_._M_h);
};

// Line 812: range 000000000C8F6620-000000000C8F664E
void __cdecl google::protobuf::`anonymous namespace'::DeleteFileDescriptorTables()
{
  google::protobuf::FileDescriptorTables *v0; // rbp

  v0 = google::protobuf::`anonymous namespace'::file_descriptor_tables_;
  if ( google::protobuf::`anonymous namespace'::file_descriptor_tables_ )
  {
    google::protobuf::FileDescriptorTables::~FileDescriptorTables(google::protobuf::`anonymous namespace'::file_descriptor_tables_);
    operator delete(v0, 0x198uLL);
  }
  google::protobuf::`anonymous namespace'::file_descriptor_tables_ = 0LL;
};

// Line 817: range 000000000C8F68D0-000000000C8F6907
__int64 __fastcall google::protobuf::`anonymous namespace'::InitFileDescriptorTables(
        google::protobuf::_anonymous_namespace_ *this,
        void (*a2)(void))
{
  google::protobuf::FileDescriptorTables *v2; // rbp

  v2 = (google::protobuf::FileDescriptorTables *)operator new(0x198uLL);
  google::protobuf::FileDescriptorTables::FileDescriptorTables(v2);
  google::protobuf::`anonymous namespace'::file_descriptor_tables_ = v2;
  return google::protobuf::internal::OnShutdown(
           (google::protobuf::internal *)google::protobuf::`anonymous namespace'::DeleteFileDescriptorTables,
           a2);
};

// Line 818: range 000000000C72D6D6-000000000C72D6E6
void __fastcall __noreturn google::protobuf::`anonymous namespace'::InitFileDescriptorTables()
{
  void *v0; // rbp
  struct _Unwind_Exception *v1; // r12

  operator delete(v0, 0x198uLL);
  _Unwind_Resume(v1);
};

// Line 834: range 000000000C8F8720-000000000C8F87D4
void __fastcall google::protobuf::DescriptorPool::Tables::AddCheckpoint(
        google::protobuf::DescriptorPool::Tables *const this)
{
  google::protobuf::DescriptorPool::Tables::CheckPoint *v1; // rdx
  signed __int64 v2; // rax
  std::vector<google::protobuf::DescriptorPool::Tables::CheckPoint> *p_checkpoints; // rdi
  google::protobuf::DescriptorPool::Tables::CheckPoint v4; // [rsp+0h] [rbp-28h] BYREF

  v2 = (char *)this->strings_._M_impl._M_finish - (char *)this->strings_._M_impl._M_start;
  p_checkpoints = &this->checkpoints_;
  v4.strings_before_checkpoint = v2 >> 3;
  v4.messages_before_checkpoint = ((char *)p_checkpoints[-11]._M_impl._M_end_of_storage
                                 - (char *)p_checkpoints[-11]._M_impl._M_finish) >> 3;
  v4.once_dynamics_before_checkpoint = ((char *)p_checkpoints[-10]._M_impl._M_end_of_storage
                                      - (char *)p_checkpoints[-10]._M_impl._M_finish) >> 3;
  v4.file_tables_before_checkpoint = ((char *)p_checkpoints[-9]._M_impl._M_end_of_storage
                                    - (char *)p_checkpoints[-9]._M_impl._M_finish) >> 3;
  v4.allocations_before_checkpoint = ((char *)p_checkpoints[-8]._M_impl._M_end_of_storage
                                    - (char *)p_checkpoints[-8]._M_impl._M_finish) >> 3;
  v4.pending_symbols_before_checkpoint = ((char *)p_checkpoints[1]._M_impl._M_finish
                                        - (char *)p_checkpoints[1]._M_impl._M_start) >> 3;
  v4.pending_files_before_checkpoint = ((char *)p_checkpoints[2]._M_impl._M_finish
                                      - (char *)p_checkpoints[2]._M_impl._M_start) >> 3;
  v4.pending_extensions_before_checkpoint = ((char *)p_checkpoints[3]._M_impl._M_finish
                                           - (char *)p_checkpoints[3]._M_impl._M_start) >> 4;
  std::vector<google::protobuf::DescriptorPool::Tables::CheckPoint>::emplace_back<google::protobuf::DescriptorPool::Tables::CheckPoint>(
    p_checkpoints,
    &v4,
    v1);
};

// Line 850: range 000000000C901070-000000000C90178F
void __fastcall google::protobuf::DescriptorPool::Tables::RollbackToLastCheckpoint(
        google::protobuf::DescriptorPool::Tables *const this)
{
  google::protobuf::`anonymous namespace'::SymbolsByNameMap *p_symbols_by_name; // r12
  std::_Vector_base<google::protobuf::DescriptorPool::Tables::CheckPoint>::pointer M_finish; // rbp
  std::_Vector_base<char const*>::pointer M_start; // rdx
  unsigned __int64 i; // r13
  const std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *v6; // r8
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v7; // rcx
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v8; // rdx
  __int64 j; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type M_bucket_count; // r14
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v11; // r15
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v12; // rax
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__node_base *v13; // rcx
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__bucket_type *M_buckets; // r8
  std::__detail::_Hash_node_base *M_nxt; // rdi
  google::protobuf::DescriptorPool::Tables **v16; // r9
  std::__detail::_Hash_node_base *v17; // rsi
  google::protobuf::DescriptorPool::Tables *v18; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v19; // rdx
  std::_Vector_base<char const*>::pointer v20; // rdx
  unsigned __int64 k; // r13
  const std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *v22; // r8
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v23; // rcx
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v24; // rdx
  __int64 m; // rax
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v26; // r14
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v27; // r15
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v28; // rax
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,const google::protobuf::FileDescriptor*>,true> > >::__node_base *v29; // rcx
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__bucket_type *v30; // r8
  std::__detail::_Hash_node_base *v31; // rdi
  google::protobuf::DescriptorPool::Tables **v32; // r9
  std::__detail::_Hash_node_base *v33; // rsi
  google::protobuf::DescriptorPool::Tables *v34; // rax
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v35; // rdx
  std::_Vector_base<std::pair<const google::protobuf::Descriptor*,int>>::pointer v36; // rsi
  std::_Rb_tree_header *v37; // r14
  unsigned __int64 pending_extensions_before_checkpoint; // r13
  std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::_Rb_tree_iterator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> > > v39; // rax
  std::_Rb_tree_iterator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >::_Base_ptr M_node; // r15
  const std::_Rb_tree_node_base *v41; // r12
  void *v42; // rax
  std::_Vector_base<char const*>::pointer v43; // rcx
  unsigned __int64 pending_symbols_before_checkpoint; // rsi
  unsigned __int64 v45; // rax
  const char **v46; // rax
  std::_Vector_base<char const*>::pointer v47; // rcx
  unsigned __int64 pending_files_before_checkpoint; // rsi
  unsigned __int64 v49; // rax
  const char **v50; // rax
  std::_Vector_base<std::pair<const google::protobuf::Descriptor*,int>>::pointer v51; // rdx
  unsigned __int64 v52; // rsi
  unsigned __int64 v53; // rax
  std::_Vector_base<google::protobuf::Message*>::pointer v54; // r13
  google::protobuf::Message **ii; // r12
  std::_Vector_base<google::protobuf::GoogleOnceDynamic*>::pointer v56; // r13
  void **jj; // r12
  std::_Vector_base<void*>::pointer v58; // rdx
  unsigned __int64 kk; // r12
  void *v60; // rdi
  std::_Vector_base<std::string*>::pointer v61; // rcx
  unsigned __int64 strings_before_checkpoint; // rsi
  unsigned __int64 v63; // rax
  std::string **v64; // rax
  std::_Vector_base<google::protobuf::Message*>::pointer v65; // rcx
  unsigned __int64 messages_before_checkpoint; // rsi
  unsigned __int64 v67; // rax
  google::protobuf::Message **v68; // rax
  std::_Vector_base<google::protobuf::GoogleOnceDynamic*>::pointer v69; // rcx
  unsigned __int64 once_dynamics_before_checkpoint; // rsi
  unsigned __int64 v71; // rax
  google::protobuf::GoogleOnceDynamic **v72; // rax
  std::_Vector_base<google::protobuf::FileDescriptorTables*>::pointer v73; // rcx
  unsigned __int64 file_tables_before_checkpoint; // rsi
  unsigned __int64 v75; // rax
  google::protobuf::FileDescriptorTables **v76; // rax
  std::_Vector_base<void*>::pointer v77; // rcx
  unsigned __int64 allocations_before_checkpoint; // rsi
  unsigned __int64 v79; // rax
  void **v80; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v81; // rdx
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v82; // rdx
  std::pair<const google::protobuf::Descriptor*,int> *v83; // rsi
  std::_Rb_tree_node_base *v84; // [rsp+0h] [rbp-48h]
  google::protobuf::`anonymous namespace'::ExtensionsGroupedByDescriptorMap *n; // [rsp+8h] [rbp-40h]

  p_symbols_by_name = &this->symbols_by_name_;
  M_finish = this->checkpoints_._M_impl._M_finish;
  M_start = this->symbols_after_checkpoint_._M_impl._M_start;
  for ( i = M_finish[-1].pending_symbols_before_checkpoint;
        this->symbols_after_checkpoint_._M_impl._M_finish - M_start > i;
        ++i )
  {
    v6 = &M_start[i];
    v7 = 0LL;
    v8 = *v6;
    for ( j = **(char **)v6; (_BYTE)j; j = *v8 )
    {
      ++v8;
      v7 = j + 5 * v7;
    }
    M_bucket_count = this->symbols_by_name_._M_h._M_bucket_count;
    v11 = v7 % M_bucket_count;
    v12 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
            &p_symbols_by_name->_M_h,
            v7 % M_bucket_count,
            v6,
            v7);
    v13 = v12;
    if ( !v12 )
      goto LABEL_10;
    M_buckets = this->symbols_by_name_._M_h._M_buckets;
    M_nxt = v12->_M_nxt;
    v16 = (google::protobuf::DescriptorPool::Tables **)&M_buckets[v11];
    v17 = v12->_M_nxt->_M_nxt;
    v18 = *v16;
    if ( v13 == (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__node_base *)*v16 )
    {
      if ( !v17 )
        goto LABEL_72;
      v81 = (std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type)v17[4]._M_nxt
          % M_bucket_count;
      if ( v11 != v81 )
      {
        M_buckets[v81] = v13;
        v18 = *v16;
LABEL_72:
        if ( v18 == (google::protobuf::DescriptorPool::Tables *)&this->symbols_by_name_._M_h._M_before_begin )
          this->symbols_by_name_._M_h._M_before_begin._M_nxt = v17;
        *v16 = 0LL;
        v17 = M_nxt->_M_nxt;
      }
    }
    else if ( v17 )
    {
      v19 = (std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type)v17[4]._M_nxt
          % M_bucket_count;
      if ( v11 != v19 )
      {
        M_buckets[v19] = v13;
        v17 = M_nxt->_M_nxt;
      }
    }
    v13->_M_nxt = v17;
    operator delete(M_nxt);
    --this->symbols_by_name_._M_h._M_element_count;
LABEL_10:
    M_start = this->symbols_after_checkpoint_._M_impl._M_start;
  }
  v20 = this->files_after_checkpoint_._M_impl._M_start;
  for ( k = M_finish[-1].pending_files_before_checkpoint; this->files_after_checkpoint_._M_impl._M_finish - v20 > k; ++k )
  {
    v22 = &v20[k];
    v23 = 0LL;
    v24 = *v22;
    for ( m = **(char **)v22; (_BYTE)m; m = *v24 )
    {
      ++v24;
      v23 = m + 5 * v23;
    }
    v26 = this->files_by_name_._M_h._M_bucket_count;
    v27 = v23 % v26;
    v28 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
            &this->files_by_name_._M_h,
            v23 % v26,
            v22,
            v23);
    v29 = v28;
    if ( !v28 )
      goto LABEL_20;
    v30 = this->files_by_name_._M_h._M_buckets;
    v31 = v28->_M_nxt;
    v32 = (google::protobuf::DescriptorPool::Tables **)&v30[v27];
    v33 = v28->_M_nxt->_M_nxt;
    v34 = *v32;
    if ( v29 == (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,const google::protobuf::FileDescriptor*>,true> > >::__node_base *)*v32 )
    {
      if ( !v33 )
        goto LABEL_78;
      v82 = (std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type)v33[3]._M_nxt
          % v26;
      if ( v27 != v82 )
      {
        v30[v82] = v29;
        v34 = *v32;
LABEL_78:
        if ( v34 == (google::protobuf::DescriptorPool::Tables *)&this->files_by_name_._M_h._M_before_begin )
          this->files_by_name_._M_h._M_before_begin._M_nxt = v33;
        *v32 = 0LL;
        v33 = v31->_M_nxt;
      }
    }
    else if ( v33 )
    {
      v35 = (std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type)v33[3]._M_nxt
          % v26;
      if ( v27 != v35 )
      {
        v30[v35] = v29;
        v33 = v31->_M_nxt;
      }
    }
    v29->_M_nxt = v33;
    operator delete(v31);
    --this->files_by_name_._M_h._M_element_count;
LABEL_20:
    v20 = this->files_after_checkpoint_._M_impl._M_start;
  }
  v36 = this->extensions_after_checkpoint_._M_impl._M_start;
  v37 = &this->extensions_._M_t._M_impl.std::_Rb_tree_header;
  pending_extensions_before_checkpoint = M_finish[-1].pending_extensions_before_checkpoint;
  for ( n = &this->extensions_;
        this->extensions_after_checkpoint_._M_impl._M_finish - v36 > pending_extensions_before_checkpoint;
        ++pending_extensions_before_checkpoint )
  {
    v39 = std::_Rb_tree<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::less<std::pair<google::protobuf::Descriptor const*,int>>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>>::equal_range(
            &n->_M_t,
            &v36[pending_extensions_before_checkpoint]);
    M_node = v39.second._M_node;
    v41 = v39.first._M_node;
    if ( v39.first._M_node == this->extensions_._M_t._M_impl._M_header._M_left
      && (std::_Rb_tree_header *)v39.second._M_node == v37 )
    {
      std::_Rb_tree<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::less<std::pair<google::protobuf::Descriptor const*,int>>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>>::_M_erase(
        &n->_M_t,
        (std::_Rb_tree<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::less<std::pair<const google::protobuf::Descriptor*,int> >,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> > >::_Link_type)this->extensions_._M_t._M_impl._M_header._M_parent);
      this->extensions_._M_t._M_impl._M_header._M_left = &v37->_M_header;
      this->extensions_._M_t._M_impl._M_header._M_parent = 0LL;
      this->extensions_._M_t._M_impl._M_header._M_right = &v37->_M_header;
      this->extensions_._M_t._M_impl._M_node_count = 0LL;
    }
    else if ( v39.second._M_node != v39.first._M_node )
    {
      do
      {
        v84 = (std::_Rb_tree_node_base *)v41;
        v41 = (const std::_Rb_tree_node_base *)std::_Rb_tree_increment(v41);
        v42 = (void *)std::_Rb_tree_rebalance_for_erase(v84, &this->extensions_._M_t._M_impl._M_header);
        operator delete(v42);
        --this->extensions_._M_t._M_impl._M_node_count;
      }
      while ( M_node != v41 );
    }
    v36 = this->extensions_after_checkpoint_._M_impl._M_start;
  }
  v43 = this->symbols_after_checkpoint_._M_impl._M_start;
  pending_symbols_before_checkpoint = M_finish[-1].pending_symbols_before_checkpoint;
  v45 = this->symbols_after_checkpoint_._M_impl._M_finish - v43;
  if ( pending_symbols_before_checkpoint > v45 )
  {
    std::vector<char const*>::_M_default_append(
      &this->symbols_after_checkpoint_,
      pending_symbols_before_checkpoint - v45);
  }
  else if ( pending_symbols_before_checkpoint < v45 )
  {
    v46 = &v43[pending_symbols_before_checkpoint];
    if ( this->symbols_after_checkpoint_._M_impl._M_finish != v46 )
      this->symbols_after_checkpoint_._M_impl._M_finish = v46;
  }
  v47 = this->files_after_checkpoint_._M_impl._M_start;
  pending_files_before_checkpoint = M_finish[-1].pending_files_before_checkpoint;
  v49 = this->files_after_checkpoint_._M_impl._M_finish - v47;
  if ( pending_files_before_checkpoint > v49 )
  {
    std::vector<char const*>::_M_default_append(&this->files_after_checkpoint_, pending_files_before_checkpoint - v49);
  }
  else if ( pending_files_before_checkpoint < v49 )
  {
    v50 = &v47[pending_files_before_checkpoint];
    if ( this->files_after_checkpoint_._M_impl._M_finish != v50 )
      this->files_after_checkpoint_._M_impl._M_finish = v50;
  }
  v51 = this->extensions_after_checkpoint_._M_impl._M_start;
  v52 = M_finish[-1].pending_extensions_before_checkpoint;
  v53 = this->extensions_after_checkpoint_._M_impl._M_finish - v51;
  if ( v52 > v53 )
  {
    std::vector<std::pair<google::protobuf::Descriptor const*,int>>::_M_default_append(
      &this->extensions_after_checkpoint_,
      v52 - v53);
  }
  else if ( v52 < v53 )
  {
    v83 = &v51[v52];
    if ( this->extensions_after_checkpoint_._M_impl._M_finish != v83 )
      this->extensions_after_checkpoint_._M_impl._M_finish = v83;
  }
  google::protobuf::STLDeleteContainerPointers<__gnu_cxx::__normal_iterator<std::string **,std::vector<std::string *>>>(
    (__gnu_cxx::__normal_iterator<std::string**,std::vector<std::string*> >)&this->strings_._M_impl._M_start[M_finish[-1].strings_before_checkpoint],
    (__gnu_cxx::__normal_iterator<std::string**,std::vector<std::string*> >)this->strings_._M_impl._M_finish);
  v54 = this->messages_._M_impl._M_finish;
  for ( ii = &this->messages_._M_impl._M_start[M_finish[-1].messages_before_checkpoint]; v54 != ii; ++ii )
  {
    if ( *ii )
      (*((void (__fastcall **)(google::protobuf::Message *))(*ii)->_vptr_MessageLite + 1))(*ii);
  }
  v56 = this->once_dynamics_._M_impl._M_finish;
  for ( jj = (void **)&this->once_dynamics_._M_impl._M_start[M_finish[-1].once_dynamics_before_checkpoint];
        v56 != (std::_Vector_base<google::protobuf::GoogleOnceDynamic*>::pointer)jj;
        ++jj )
  {
    if ( *jj )
      operator delete(*jj, 8uLL);
  }
  google::protobuf::STLDeleteContainerPointers<__gnu_cxx::__normal_iterator<google::protobuf::FileDescriptorTables **,std::vector<google::protobuf::FileDescriptorTables *>>>(
    (__gnu_cxx::__normal_iterator<google::protobuf::FileDescriptorTables**,std::vector<google::protobuf::FileDescriptorTables*> >)&this->file_tables_._M_impl._M_start[M_finish[-1].file_tables_before_checkpoint],
    (__gnu_cxx::__normal_iterator<google::protobuf::FileDescriptorTables**,std::vector<google::protobuf::FileDescriptorTables*> >)this->file_tables_._M_impl._M_finish);
  v58 = this->allocations_._M_impl._M_start;
  for ( kk = M_finish[-1].allocations_before_checkpoint;
        this->allocations_._M_impl._M_finish - v58 > kk;
        v58 = this->allocations_._M_impl._M_start )
  {
    v60 = v58[kk++];
    operator delete(v60);
  }
  v61 = this->strings_._M_impl._M_start;
  strings_before_checkpoint = M_finish[-1].strings_before_checkpoint;
  v63 = this->strings_._M_impl._M_finish - v61;
  if ( strings_before_checkpoint > v63 )
  {
    std::vector<std::string *>::_M_default_append(&this->strings_, strings_before_checkpoint - v63);
  }
  else if ( strings_before_checkpoint < v63 )
  {
    v64 = &v61[strings_before_checkpoint];
    if ( this->strings_._M_impl._M_finish != v64 )
      this->strings_._M_impl._M_finish = v64;
  }
  v65 = this->messages_._M_impl._M_start;
  messages_before_checkpoint = M_finish[-1].messages_before_checkpoint;
  v67 = this->messages_._M_impl._M_finish - v65;
  if ( messages_before_checkpoint > v67 )
  {
    std::vector<google::protobuf::Message *>::_M_default_append(&this->messages_, messages_before_checkpoint - v67);
  }
  else if ( messages_before_checkpoint < v67 )
  {
    v68 = &v65[messages_before_checkpoint];
    if ( this->messages_._M_impl._M_finish != v68 )
      this->messages_._M_impl._M_finish = v68;
  }
  v69 = this->once_dynamics_._M_impl._M_start;
  once_dynamics_before_checkpoint = M_finish[-1].once_dynamics_before_checkpoint;
  v71 = this->once_dynamics_._M_impl._M_finish - v69;
  if ( once_dynamics_before_checkpoint > v71 )
  {
    std::vector<google::protobuf::GoogleOnceDynamic *>::_M_default_append(
      &this->once_dynamics_,
      once_dynamics_before_checkpoint - v71);
  }
  else if ( once_dynamics_before_checkpoint < v71 )
  {
    v72 = &v69[once_dynamics_before_checkpoint];
    if ( this->once_dynamics_._M_impl._M_finish != v72 )
      this->once_dynamics_._M_impl._M_finish = v72;
  }
  v73 = this->file_tables_._M_impl._M_start;
  file_tables_before_checkpoint = M_finish[-1].file_tables_before_checkpoint;
  v75 = this->file_tables_._M_impl._M_finish - v73;
  if ( file_tables_before_checkpoint > v75 )
  {
    std::vector<google::protobuf::FileDescriptorTables *>::_M_default_append(
      &this->file_tables_,
      file_tables_before_checkpoint - v75);
  }
  else if ( file_tables_before_checkpoint < v75 )
  {
    v76 = &v73[file_tables_before_checkpoint];
    if ( this->file_tables_._M_impl._M_finish != v76 )
      this->file_tables_._M_impl._M_finish = v76;
  }
  v77 = this->allocations_._M_impl._M_start;
  allocations_before_checkpoint = M_finish[-1].allocations_before_checkpoint;
  v79 = this->allocations_._M_impl._M_finish - v77;
  if ( allocations_before_checkpoint > v79 )
  {
    std::vector<void *>::_M_default_append(&this->allocations_, allocations_before_checkpoint - v79);
  }
  else if ( allocations_before_checkpoint < v79 )
  {
    v80 = &v77[allocations_before_checkpoint];
    if ( this->allocations_._M_impl._M_finish != v80 )
      this->allocations_._M_impl._M_finish = v80;
  }
  --this->checkpoints_._M_impl._M_finish;
};

// Line 931: range 000000000C913240-000000000C9133FB
__int64 __fastcall google::protobuf::DescriptorPool::Tables::FindByNameHelper(
        __int64 a1,
        google::protobuf::DescriptorPool *a2,
        std::string *a3)
{
  google::protobuf::internal::Mutex *mutex; // r15
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type M_p; // rdx
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v7; // rcx
  __int64 v8; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v9; // rax
  std::__detail::_Hash_node_base *M_nxt; // rbx
  const google::protobuf::DescriptorPool *underlay; // rsi
  unsigned int v12; // eax
  std::string::pointer v14; // rdx
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v15; // rcx
  __int64 v16; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v17; // rax
  std::__detail::_Hash_node_base *v18; // rbx
  unsigned int v19; // [rsp+4h] [rbp-54h]
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *v20; // [rsp+8h] [rbp-50h]
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type __k[8]; // [rsp+18h] [rbp-40h] BYREF

  mutex = a2->mutex_;
  if ( a2->mutex_ )
    google::protobuf::internal::Mutex::Lock(a2->mutex_);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear((std::_Hashtable<std::string,std::string,std::allocator<std::string >,std::__detail::_Identity,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true> > *const)(a1 + 80));
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear((std::_Hashtable<std::string,std::string,std::allocator<std::string >,std::__detail::_Identity,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true> > *const)(a1 + 24));
  M_p = a3->_M_dataplus._M_p;
  v7 = 0LL;
  v20 = (std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *)(a1 + 312);
  v8 = *a3->_M_dataplus._M_p;
  for ( __k[0] = a3->_M_dataplus._M_p; (_BYTE)v8; v8 = *M_p )
  {
    ++M_p;
    v7 = v8 + 5 * v7;
  }
  v9 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         v20,
         v7 % *(_QWORD *)(a1 + 320),
         __k,
         v7);
  if ( v9 && v9->_M_nxt )
    M_nxt = v9->_M_nxt[2]._M_nxt;
  else
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
  v19 = (unsigned int)M_nxt;
  if ( !(_DWORD)M_nxt )
  {
    underlay = a2->underlay_;
    if ( underlay
      && (v12 = google::protobuf::DescriptorPool::Tables::FindByNameHelper(underlay->tables_.ptr_, underlay, a3)) != 0 )
    {
      v19 = v12;
    }
    else if ( (unsigned __int8)google::protobuf::DescriptorPool::TryFindSymbolInFallbackDatabase(a2, a3) )
    {
      v14 = a3->_M_dataplus._M_p;
      v15 = 0LL;
      v16 = *a3->_M_dataplus._M_p;
      for ( __k[0] = a3->_M_dataplus._M_p; (_BYTE)v16; v16 = *v14 )
      {
        ++v14;
        v15 = v16 + 5 * v15;
      }
      v17 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
              v20,
              v15 % *(_QWORD *)(a1 + 320),
              __k,
              v15);
      if ( v17 && v17->_M_nxt )
        v18 = v17->_M_nxt[2]._M_nxt;
      else
        LODWORD(v18) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
      v19 = (unsigned int)v18;
    }
  }
  if ( mutex )
    google::protobuf::internal::Mutex::Unlock(mutex);
  return v19;
};

// Line 1051: range 000000000C903A80-000000000C903C26
__int64 __fastcall google::protobuf::DescriptorPool::Tables::AddSymbol(
        __int64 a1,
        const char **a2,
        unsigned int a3,
        __int64 a4)
{
  const char *v4; // r8
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v5; // r12
  const char *v7; // rdx
  __int64 i; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v9; // r13
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v10; // rax
  __int64 v12; // rax
  __m128i si128; // xmm0
  unsigned __int64 v14; // rdx
  _QWORD *v15; // r15
  unsigned __int64 v16; // rsi
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v17; // rdx
  __int64 v18; // rsi
  _QWORD **v19; // rcx
  const char *v20; // rax
  __int64 v21; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__rehash_state __state; // [rsp+8h] [rbp-60h] BYREF
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type __k[2]; // [rsp+10h] [rbp-58h] BYREF
  __int64 v24; // [rsp+20h] [rbp-48h]

  v4 = (const char *)a3;
  v5 = 0LL;
  v7 = *a2;
  __k[1] = v4;
  __k[0] = v7;
  v24 = a4;
  for ( i = *v7; (_BYTE)i; i = *v7 )
  {
    ++v7;
    v5 = i + 5 * v5;
  }
  v9 = v5 % *(_QWORD *)(a1 + 320);
  v10 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
          (const std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *const)(a1 + 312),
          v9,
          __k,
          v5);
  if ( v10 && v10->_M_nxt )
    return 0LL;
  v12 = operator new(0x28uLL);
  si128 = _mm_load_si128((const __m128i *)__k);
  v14 = *(_QWORD *)(a1 + 336);
  *(_QWORD *)v12 = 0LL;
  v15 = (_QWORD *)v12;
  v16 = *(_QWORD *)(a1 + 320);
  *(__m128i *)(v12 + 8) = si128;
  *(_QWORD *)(v12 + 24) = v24;
  __state = *(_QWORD *)(a1 + 352);
  if ( (unsigned __int8)std::__detail::_Prime_rehash_policy::_M_need_rehash(
                          (std::__detail::_Prime_rehash_policy *)(a1 + 344),
                          v16,
                          v14,
                          1uLL) )
  {
    std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_rehash(
      (std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *const)(a1 + 312),
      v17,
      &__state);
    v17 = v5 % *(_QWORD *)(a1 + 320);
    v9 = v17;
  }
  v18 = *(_QWORD *)(a1 + 312);
  v15[4] = v5;
  v19 = (_QWORD **)(v18 + 8 * v9);
  if ( *v19 )
  {
    *v15 = **v19;
    **v19 = v15;
  }
  else
  {
    v21 = *(_QWORD *)(a1 + 328);
    *(_QWORD *)(a1 + 328) = v15;
    *v15 = v21;
    if ( v21 )
    {
      v17 = *(_QWORD *)(v21 + 32) % *(_QWORD *)(a1 + 320);
      *(_QWORD *)(v18 + 8 * v17) = v15;
    }
    *v19 = (_QWORD *)(a1 + 328);
  }
  v20 = *a2;
  ++*(_QWORD *)(a1 + 336);
  __k[0] = v20;
  std::vector<char const*>::emplace_back<char const*>(
    (std::vector<char const*> *const)(a1 + 496),
    __k,
    (const char **)v17);
  return 1LL;
};

// Line 1061: range 000000000C8F4920-000000000C8F4949
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall google::protobuf::FileDescriptorTables::AddAliasUnderParent(
        google::protobuf::FileDescriptorTables *const this,
        const void *parent,
        const std::string *name,
        std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type symbol)
{
  const char *M_p; // rax
  __int64 v5; // rdx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v7[2]; // [rsp+0h] [rbp-28h] BYREF

  M_p = name->_M_dataplus._M_p;
  v7[0].first = parent;
  v7[0].second = M_p;
  v7[1] = symbol;
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,true>>>>(
    &this->symbols_by_parent_._M_h,
    v7);
  return v5;
};

// Line 1066: range 000000000C907E80-000000000C90803B
__int64 __fastcall google::protobuf::DescriptorPool::Tables::AddFile(
        google::protobuf::DescriptorPool::Tables *this,
        google::protobuf::FileDescriptor *a2)
{
  const char *M_p; // r14
  __int64 v4; // rax
  const char *v5; // rdx
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v6; // r12
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v7; // rax
  std::__detail::_Hash_node_base *v9; // rax
  unsigned __int64 M_element_count; // rdx
  unsigned __int64 M_bucket_count; // rsi
  std::__detail::_Hash_node_base *v12; // r13
  char v13; // al
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v14; // rdx
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v15; // r8
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__bucket_type *M_buckets; // rsi
  std::__detail::_Hash_node_base ***v17; // rcx
  const std::string *name; // rax
  std::__detail::_Hash_node_base *M_nxt; // rax
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v20; // [rsp+8h] [rbp-60h]
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__rehash_state __state; // [rsp+18h] [rbp-50h] BYREF
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type __k[9]; // [rsp+20h] [rbp-48h] BYREF

  M_p = a2->name_->_M_dataplus._M_p;
  __k[1] = (std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type)a2;
  __k[0] = M_p;
  v4 = *M_p;
  if ( (_BYTE)v4 )
  {
    v5 = M_p;
    v6 = 0LL;
    do
    {
      ++v5;
      v6 = v4 + 5 * v6;
      v4 = *v5;
    }
    while ( (_BYTE)v4 );
  }
  else
  {
    v6 = 0LL;
  }
  v20 = v6 % this->files_by_name_._M_h._M_bucket_count;
  v7 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         &this->files_by_name_._M_h,
         v20,
         __k,
         v6);
  if ( v7 && v7->_M_nxt )
    return 0LL;
  v9 = (std::__detail::_Hash_node_base *)operator new(0x20uLL);
  M_element_count = this->files_by_name_._M_h._M_element_count;
  M_bucket_count = this->files_by_name_._M_h._M_bucket_count;
  v9[1]._M_nxt = (std::__detail::_Hash_node_base *)M_p;
  v12 = v9;
  v9->_M_nxt = 0LL;
  v9[2]._M_nxt = (std::__detail::_Hash_node_base *)a2;
  __state = this->files_by_name_._M_h._M_rehash_policy._M_next_resize;
  v13 = std::__detail::_Prime_rehash_policy::_M_need_rehash(
          &this->files_by_name_._M_h._M_rehash_policy,
          M_bucket_count,
          M_element_count,
          1uLL);
  v15 = v20;
  if ( v13 )
  {
    std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_rehash(
      &this->files_by_name_._M_h,
      v14,
      &__state);
    v14 = v6 % this->files_by_name_._M_h._M_bucket_count;
    v15 = v14;
  }
  M_buckets = this->files_by_name_._M_h._M_buckets;
  v12[3]._M_nxt = (std::__detail::_Hash_node_base *)v6;
  v17 = (std::__detail::_Hash_node_base ***)&M_buckets[v15];
  if ( *v17 )
  {
    v12->_M_nxt = **v17;
    **v17 = v12;
  }
  else
  {
    M_nxt = this->files_by_name_._M_h._M_before_begin._M_nxt;
    this->files_by_name_._M_h._M_before_begin._M_nxt = v12;
    v12->_M_nxt = M_nxt;
    if ( M_nxt )
    {
      v14 = (unsigned __int64)M_nxt[3]._M_nxt % this->files_by_name_._M_h._M_bucket_count;
      M_buckets[v14] = v12;
    }
    *v17 = &this->files_by_name_._M_h._M_before_begin._M_nxt;
  }
  name = a2->name_;
  ++this->files_by_name_._M_h._M_element_count;
  __k[0] = name->_M_dataplus._M_p;
  std::vector<char const*>::emplace_back<char const*>(&this->files_after_checkpoint_, __k, (const char **)v14);
  return 1LL;
};

// Line 1076: range 000000000C8F4950-000000000C8F49D4
void __fastcall google::protobuf::FileDescriptorTables::AddFieldByStylizedNames(
        google::protobuf::FileDescriptorTables *const this,
        const google::protobuf::FieldDescriptor *field)
{
  const void *extension_scope; // r12
  const char *M_p; // rax
  const char *v4; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v5; // [rsp+0h] [rbp-38h] BYREF
  const google::protobuf::FieldDescriptor *v6; // [rsp+10h] [rbp-28h]

  if ( field->is_extension_ )
  {
    extension_scope = field->extension_scope_;
    if ( !extension_scope )
      extension_scope = field->file_;
  }
  else
  {
    extension_scope = field->containing_type_;
  }
  M_p = field->lowercase_name_->_M_dataplus._M_p;
  v5.first = extension_scope;
  v6 = field;
  v5.second = M_p;
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,true>>>>(
    &this->fields_by_lowercase_name_._M_h,
    &v5);
  v4 = field->camelcase_name_->_M_dataplus._M_p;
  v5.first = extension_scope;
  v6 = field;
  v5.second = v4;
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,true>>>>(
    &this->fields_by_camelcase_name_._M_h,
    &v5);
};

// Line 1095: range 000000000C8F49E0-000000000C8F4A0E
bool __fastcall google::protobuf::FileDescriptorTables::AddFieldByNumber(
        google::protobuf::FileDescriptorTables *const this,
        const google::protobuf::FieldDescriptor *field)
{
  int number; // eax
  const google::protobuf::Descriptor *containing_type; // rdx
  bool v4; // dl
  const google::protobuf::Descriptor *v6; // [rsp+0h] [rbp-28h] BYREF
  int v7; // [rsp+8h] [rbp-20h]
  const google::protobuf::FieldDescriptor *fielda; // [rsp+10h] [rbp-18h]

  number = field->number_;
  containing_type = field->containing_type_;
  fielda = field;
  v6 = containing_type;
  v7 = number;
  std::_Hashtable<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::Descriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::Descriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,true>>>>(
    &this->fields_by_number_,
    &v6);
  return v4;
};

// Line 1101: range 000000000C8F4A10-000000000C8F4A3E
bool __fastcall google::protobuf::FileDescriptorTables::AddEnumValueByNumber(
        google::protobuf::FileDescriptorTables *const this,
        const google::protobuf::EnumValueDescriptor *value)
{
  int number; // eax
  const google::protobuf::EnumDescriptor *type; // rdx
  bool v4; // dl
  const google::protobuf::EnumDescriptor *v6; // [rsp+0h] [rbp-28h] BYREF
  int v7; // [rsp+8h] [rbp-20h]
  const google::protobuf::EnumValueDescriptor *valuea; // [rsp+10h] [rbp-18h]

  number = value->number_;
  type = value->type_;
  valuea = value;
  v6 = type;
  v7 = number;
  std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,true>>>>(
    &this->enum_values_by_number_,
    &v6);
  return v4;
};

// Line 1106: range 000000000C8F8250-000000000C8F8412
bool __fastcall google::protobuf::DescriptorPool::Tables::AddExtension(
        google::protobuf::DescriptorPool::Tables *const this,
        const google::protobuf::FieldDescriptor *field)
{
  std::_Rb_tree_header *v2; // r15
  int number; // r14d
  const google::protobuf::Descriptor *containing_type; // r13
  std::_Rb_tree_header *M_parent; // r12
  std::_Rb_tree_header *M_right; // rax
  char v7; // cl
  const google::protobuf::Descriptor *M_node_count; // rdx
  std::_Rb_tree_header *v9; // rcx
  bool result; // al
  _BOOL8 v11; // r8
  __int64 v12; // rax
  const std::pair<const google::protobuf::Descriptor*,int> *v13; // rcx
  std::pair<const google::protobuf::Descriptor*,int> *M_finish; // rsi
  const google::protobuf::Descriptor *first; // rdx
  std::pair<const google::protobuf::Descriptor*,int> *v16; // rsi
  std::_Rb_tree_header *v17; // rax
  bool v18; // [rsp+Ch] [rbp-4Ch]
  google::protobuf::`anonymous namespace'::DescriptorIntPair key; // [rsp+10h] [rbp-48h] BYREF

  v2 = &this->extensions_._M_t._M_impl.std::_Rb_tree_header;
  number = field->number_;
  containing_type = field->containing_type_;
  M_parent = (std::_Rb_tree_header *)this->extensions_._M_t._M_impl._M_header._M_parent;
  key.first = containing_type;
  key.second = number;
  if ( !M_parent )
  {
    M_parent = &this->extensions_._M_t._M_impl.std::_Rb_tree_header;
    if ( v2 == (std::_Rb_tree_header *)this->extensions_._M_t._M_impl._M_header._M_left )
    {
      LOBYTE(v11) = 1;
LABEL_16:
      v18 = v11;
      v12 = operator new(0x38uLL);
      *(_QWORD *)(v12 + 32) = containing_type;
      *(_DWORD *)(v12 + 40) = number;
      *(_QWORD *)(v12 + 48) = field;
      std::_Rb_tree_insert_and_rebalance(v18, (std::_Rb_tree_node_base *)v12, &M_parent->_M_header, &v2->_M_header);
      ++this->extensions_._M_t._M_impl._M_node_count;
      M_finish = this->extensions_after_checkpoint_._M_impl._M_finish;
      if ( M_finish == this->extensions_after_checkpoint_._M_impl._M_end_of_storage )
      {
        std::vector<std::pair<google::protobuf::Descriptor const*,int>>::_M_realloc_insert<std::pair<google::protobuf::Descriptor const*,int> const&>(
          &this->extensions_after_checkpoint_,
          (std::vector<std::pair<const google::protobuf::Descriptor*,int>>::iterator)M_finish,
          &key,
          v13);
        return 1;
      }
      else
      {
        first = key.first;
        v16 = M_finish + 1;
        v16[-1].second = key.second;
        result = 1;
        v16[-1].first = first;
        this->extensions_after_checkpoint_._M_impl._M_finish = v16;
      }
      return result;
    }
    goto LABEL_20;
  }
  while ( 1 )
  {
    M_node_count = (const google::protobuf::Descriptor *)M_parent->_M_node_count;
    if ( containing_type < M_node_count || containing_type == M_node_count && number < M_parent[1]._M_header._M_color )
      break;
    M_right = (std::_Rb_tree_header *)M_parent->_M_header._M_right;
    v7 = 0;
    if ( !M_right )
      goto LABEL_9;
LABEL_6:
    M_parent = M_right;
  }
  M_right = (std::_Rb_tree_header *)M_parent->_M_header._M_left;
  v7 = 1;
  if ( M_right )
    goto LABEL_6;
LABEL_9:
  if ( v7 )
  {
    if ( (std::_Rb_tree_header *)this->extensions_._M_t._M_impl._M_header._M_left != M_parent )
    {
LABEL_20:
      v17 = (std::_Rb_tree_header *)std::_Rb_tree_decrement(&M_parent->_M_header);
      M_node_count = (const google::protobuf::Descriptor *)v17->_M_node_count;
      if ( containing_type <= M_node_count )
      {
        v9 = M_parent;
        M_parent = v17;
        goto LABEL_11;
      }
LABEL_14:
      result = 0;
      if ( !M_parent )
        return result;
    }
LABEL_15:
    LOBYTE(v11) = 1;
    if ( v2 != M_parent && (unsigned __int64)containing_type >= M_parent->_M_node_count )
    {
      LOBYTE(v11) = 0;
      if ( containing_type == (const google::protobuf::Descriptor *)M_parent->_M_node_count )
        v11 = number < M_parent[1]._M_header._M_color;
    }
    goto LABEL_16;
  }
  v9 = M_parent;
  if ( containing_type > M_node_count )
    goto LABEL_15;
LABEL_11:
  result = 0;
  if ( containing_type == M_node_count && number > M_parent[1]._M_header._M_color )
  {
    M_parent = v9;
    goto LABEL_14;
  }
  return result;
};

// Line 1119: range 000000000C91ADD0-000000000C91AE2B
google::protobuf::FileDescriptor *__fastcall google::protobuf::DescriptorPool::Tables::Allocate<google::protobuf::FileDescriptor>(
        google::protobuf::DescriptorPool::Tables *const this)
{
  void *v1; // rax
  void *const *v2; // rcx
  std::_Vector_base<void*>::pointer M_finish; // rsi
  google::protobuf::FileDescriptor *result; // rax
  void *v5; // [rsp+8h] [rbp-10h] BYREF

  v1 = (void *)operator new(0xA0uLL);
  M_finish = this->allocations_._M_impl._M_finish;
  v5 = v1;
  if ( M_finish == this->allocations_._M_impl._M_end_of_storage )
  {
    std::vector<void *>::_M_realloc_insert<void * const&>(
      &this->allocations_,
      (std::vector<void*>::iterator)M_finish,
      &v5,
      v2);
    return (google::protobuf::FileDescriptor *)v5;
  }
  else
  {
    *M_finish = v1;
    result = (google::protobuf::FileDescriptor *)v5;
    ++this->allocations_._M_impl._M_finish;
  }
  return result;
};

// Line 1128: range 000000000C8FDDF0-000000000C8FDE82
std::string *__fastcall google::protobuf::DescriptorPool::Tables::AllocateString(
        std::vector<std::string*> *a1,
        __int64 a2)
{
  std::string *v3; // rax
  char *v4; // rsi
  std::string *v5; // rbp
  char *v6; // rdx
  std::forward_iterator_tag v7; // cl
  std::string *const *v8; // rcx
  _QWORD *M_finish; // rsi
  std::string *result; // rax
  std::string *v11; // [rsp+8h] [rbp-20h] BYREF

  v3 = (std::string *)operator new(0x20uLL);
  v4 = *(char **)a2;
  v5 = v3;
  v6 = (char *)(*(_QWORD *)a2 + *(_QWORD *)(a2 + 8));
  v3->_M_dataplus._M_p = v3->_anon_0._M_local_buf;
  std::string::_M_construct<char *>(v3, v4, v6, v7);
  v11 = v5;
  M_finish = a1[8]._M_impl._M_finish;
  if ( M_finish == a1[8]._M_impl._M_end_of_storage )
  {
    std::vector<std::string *>::_M_realloc_insert<std::string * const&>(
      a1 + 8,
      (std::vector<std::string*>::iterator)M_finish,
      &v11,
      v8);
    return v11;
  }
  else
  {
    *M_finish = v5;
    result = v11;
    a1[8]._M_impl._M_finish = (std::_Vector_base<std::string*>::pointer)(M_finish + 1);
  }
  return result;
};

// Line 1129: range 000000000C72E332-000000000C72E342
void __fastcall __noreturn google::protobuf::DescriptorPool::Tables::AllocateString()
{
  void *v0; // rbp
  struct _Unwind_Exception *v1; // r12

  operator delete(v0, 0x20uLL);
  _Unwind_Resume(v1);
};

// Line 1134: range 000000000C8F8420-000000000C8F848B
google::protobuf::GoogleOnceDynamic *__fastcall google::protobuf::DescriptorPool::Tables::AllocateOnceDynamic(
        google::protobuf::DescriptorPool::Tables *const this)
{
  google::protobuf::GoogleOnceDynamic *v1; // rax
  google::protobuf::GoogleOnceDynamic *const *v2; // rcx
  std::_Vector_base<google::protobuf::GoogleOnceDynamic*>::pointer M_finish; // rsi
  google::protobuf::GoogleOnceDynamic *v4; // rax
  google::protobuf::GoogleOnceDynamic *result; // [rsp+8h] [rbp-10h] BYREF

  v1 = (google::protobuf::GoogleOnceDynamic *)operator new(8uLL);
  M_finish = this->once_dynamics_._M_impl._M_finish;
  v1->state_ = 0LL;
  result = v1;
  if ( M_finish == this->once_dynamics_._M_impl._M_end_of_storage )
  {
    std::vector<google::protobuf::GoogleOnceDynamic *>::_M_realloc_insert<google::protobuf::GoogleOnceDynamic * const&>(
      &this->once_dynamics_,
      (std::vector<google::protobuf::GoogleOnceDynamic*>::iterator)M_finish,
      &result,
      v2);
    return result;
  }
  else
  {
    *M_finish = v1;
    v4 = result;
    this->once_dynamics_._M_impl._M_finish = M_finish + 1;
  }
  return v4;
};

// Line 1147: range 000000000C8F8490-000000000C8F850A
google::protobuf::FileDescriptorTables *__fastcall google::protobuf::DescriptorPool::Tables::AllocateFileTables(
        google::protobuf::DescriptorPool::Tables *this)
{
  google::protobuf::FileDescriptorTables *v1; // rbp
  google::protobuf::FileDescriptorTables *const *v2; // rcx
  std::_Vector_base<google::protobuf::FileDescriptorTables*>::pointer M_finish; // rsi
  google::protobuf::FileDescriptorTables *result; // rax
  google::protobuf::FileDescriptorTables *v5; // [rsp+8h] [rbp-20h] BYREF

  v1 = (google::protobuf::FileDescriptorTables *)operator new(0x198uLL);
  google::protobuf::FileDescriptorTables::FileDescriptorTables(v1);
  v5 = v1;
  M_finish = this->file_tables_._M_impl._M_finish;
  if ( M_finish == this->file_tables_._M_impl._M_end_of_storage )
  {
    std::vector<google::protobuf::FileDescriptorTables *>::_M_realloc_insert<google::protobuf::FileDescriptorTables * const&>(
      &this->file_tables_,
      (std::vector<google::protobuf::FileDescriptorTables*>::iterator)M_finish,
      &v5,
      v2);
    return v5;
  }
  else
  {
    *M_finish = v1;
    result = v5;
    this->file_tables_._M_impl._M_finish = M_finish + 1;
  }
  return result;
};

// Line 1148: range 000000000C72D9FC-000000000C72DA0C
void __fastcall __noreturn google::protobuf::DescriptorPool::Tables::AllocateFileTables()
{
  void *v0; // rbp
  struct _Unwind_Exception *v1; // r12

  operator delete(v0, 0x198uLL);
  _Unwind_Resume(v1);
};

// Line 1158: range 000000000C8F8510-000000000C8F8573
void *__fastcall google::protobuf::DescriptorPool::Tables::AllocateBytes(
        google::protobuf::DescriptorPool::Tables *const this,
        int size)
{
  void *v2; // rax
  void *const *v3; // rcx
  std::_Vector_base<void*>::pointer M_finish; // rsi
  void *v5; // rax
  void *result; // [rsp+0h] [rbp-10h] BYREF

  if ( !size )
    return 0LL;
  v2 = (void *)operator new(size);
  M_finish = this->allocations_._M_impl._M_finish;
  result = v2;
  if ( M_finish == this->allocations_._M_impl._M_end_of_storage )
  {
    std::vector<void *>::_M_realloc_insert<void * const&>(
      &this->allocations_,
      (std::vector<void*>::iterator)M_finish,
      &result,
      v3);
    return result;
  }
  else
  {
    *M_finish = v2;
    v5 = result;
    ++this->allocations_._M_impl._M_finish;
  }
  return v5;
};

// Line 1166: range 000000000C901EE0-000000000C902317
__int64 __fastcall google::protobuf::FileDescriptorTables::BuildLocationsByPath(_QWORD *a1)
{
  __int64 v1; // rax
  __int64 v2; // r13
  __int64 v3; // rbx
  __int64 v4; // rax
  google::protobuf::int32 *v5; // rbx
  google::protobuf::int32 *v6; // r15
  google::protobuf::int32 *v7; // rbp
  google::protobuf::int32 v8; // edi
  std::string::$CFBEC286C7F52157F7E59FC354047095 *p_anon_0; // r8
  __int64 v10; // rax
  __int64 v11; // rbx
  const std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *v12; // rdi
  std::string::pointer M_p; // rdx
  std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v14; // r12
  std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::size_type v15; // r15
  std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v16; // rax
  std::__detail::_Hash_node_base *M_nxt; // rax
  std::string *v18; // r8
  std::__detail::_Hash_node_base *v19; // rbp
  __int64 v20; // rax
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__node_base *v21; // rbp
  std::string::size_type M_string_length; // rax
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // rsi
  char v25; // al
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *v26; // rdx
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type *buckets; // r14
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__node_base *v28; // rsi
  unsigned __int64 v29; // rdi
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__node_base *v30; // rcx
  unsigned __int64 v31; // rdx
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type *v32; // rax
  void *v33; // rdi
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type *v34; // rcx
  _QWORD *v35; // rax
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *v37; // [rsp+8h] [rbp-A0h]
  std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *v38; // [rsp+8h] [rbp-A0h]
  int v39; // [rsp+10h] [rbp-98h]
  int v40; // [rsp+14h] [rbp-94h]
  std::string result; // [rsp+20h] [rbp-88h] BYREF
  google::protobuf::strings::AlphaNum a; // [rsp+40h] [rbp-68h] BYREF

  v1 = a1[1];
  v40 = *(_DWORD *)(v1 + 32);
  if ( v40 > 0 )
  {
    v39 = 0;
    while ( 1 )
    {
      v2 = *(_QWORD *)(*(_QWORD *)(v1 + 40) + 8LL * v39 + 8);
      result._anon_0._M_local_buf[0] = 0;
      result._M_dataplus._M_p = result._anon_0._M_local_buf;
      v3 = *(_QWORD *)(v2 + 32);
      v4 = *(int *)(v2 + 24);
      result._M_string_length = 0LL;
      if ( !v3 || (v5 = (google::protobuf::int32 *)(v3 + 8), v6 = &v5[v4], v5 == v6) )
      {
        p_anon_0 = &result._anon_0;
        v14 = 0LL;
        v11 = *a1;
        v12 = (const std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *)(*a1 + 344LL);
      }
      else
      {
        v7 = v5;
        while ( 1 )
        {
          v8 = *v7;
          a.piece_data_ = a.digits;
          a.piece_size_ = google::protobuf::FastInt32ToBufferLeft(v8, a.digits) - a.digits;
          google::protobuf::StrAppend(&result, &a);
          if ( v6 == ++v7 )
            break;
          if ( v5 != v7 )
          {
            if ( result._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
              std::__throw_length_error("basic_string::append");
            std::string::_M_append(&result, ",", 1LL);
          }
        }
        p_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)result._M_dataplus._M_p;
        v10 = *result._M_dataplus._M_p;
        v11 = *a1;
        v12 = (const std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *)(*a1 + 344LL);
        if ( (_BYTE)v10 )
        {
          M_p = result._M_dataplus._M_p;
          v14 = 0LL;
          do
          {
            ++M_p;
            v14 = v10 + 5 * v14;
            v10 = *M_p;
          }
          while ( (_BYTE)v10 );
        }
        else
        {
          v14 = 0LL;
        }
      }
      v37 = (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)p_anon_0;
      v15 = v14 % *(_QWORD *)(v11 + 352);
      v16 = std::_Hashtable<std::string,std::pair<std::string const,google::protobuf::SourceCodeInfo_Location const*>,std::allocator<std::pair<std::string const,google::protobuf::SourceCodeInfo_Location const*>>,std::__detail::_Select1st,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
              v12,
              v15,
              &result,
              v14);
      if ( v16 )
      {
        M_nxt = v16->_M_nxt;
        v18 = (std::string *)v37;
        v19 = M_nxt + 5;
        if ( M_nxt )
          goto LABEL_15;
      }
      v20 = operator new(0x38uLL);
      *(_QWORD *)v20 = 0LL;
      v21 = (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__node_base *)v20;
      *(_QWORD *)(v20 + 8) = v20 + 24;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)result._M_dataplus._M_p == &result._anon_0 )
      {
        *(__m128i *)(v20 + 24) = _mm_load_si128((const __m128i *)&result._anon_0);
      }
      else
      {
        *(_QWORD *)(v20 + 8) = result._M_dataplus._M_p;
        *(_QWORD *)(v20 + 24) = result._anon_0._M_allocated_capacity;
      }
      M_string_length = result._M_string_length;
      result._anon_0._M_local_buf[0] = 0;
      v21[5]._M_nxt = 0LL;
      v21[2]._M_nxt = (std::__detail::_Hash_node_base *)M_string_length;
      v23 = *(_QWORD *)(v11 + 368);
      result._M_dataplus._M_p = result._anon_0._M_local_buf;
      v24 = *(_QWORD *)(v11 + 352);
      result._M_string_length = 0LL;
      v25 = std::__detail::_Prime_rehash_policy::_M_need_rehash(
              (std::__detail::_Prime_rehash_policy *)(v11 + 376),
              v24,
              v23,
              1uLL);
      v38 = v26;
      if ( v25 )
      {
        if ( v26 == (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > > *)1 )
        {
          buckets = (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type *)(v11 + 392);
          *(_QWORD *)(v11 + 392) = 0LL;
        }
        else
        {
          buckets = std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::pair const<void const*,char const*>,google::protobuf::FieldDescriptor const*>,true>>>::_M_allocate_buckets(
                      v26,
                      v24);
        }
        v28 = *(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__node_base **)(v11 + 360);
        *(_QWORD *)(v11 + 360) = 0LL;
        if ( v28 )
        {
          v29 = 0LL;
          do
          {
            while ( 1 )
            {
              v30 = v28;
              v28 = v28->_M_nxt;
              v31 = (unsigned __int64)v30[6]._M_nxt % (unsigned __int64)v38;
              v32 = &buckets[v31];
              if ( !*v32 )
                break;
              v30->_M_nxt = (*v32)->_M_nxt;
              (*v32)->_M_nxt = v30;
LABEL_27:
              if ( !v28 )
                goto LABEL_31;
            }
            v30->_M_nxt = *(std::__detail::_Hash_node_base **)(v11 + 360);
            *(_QWORD *)(v11 + 360) = v30;
            *v32 = (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type)(v11 + 360);
            if ( !v30->_M_nxt )
            {
              v29 = v31;
              goto LABEL_27;
            }
            buckets[v29] = v30;
            v29 = v31;
          }
          while ( v28 );
        }
LABEL_31:
        v33 = *(void **)(v11 + 344);
        if ( v33 != (void *)(v11 + 392) )
          operator delete(v33);
        *(_QWORD *)(v11 + 344) = buckets;
        *(_QWORD *)(v11 + 352) = v38;
        v21[6]._M_nxt = (std::__detail::_Hash_node_base *)v14;
        v34 = &buckets[v14 % (unsigned __int64)v38];
        v35 = *v34;
        if ( !*v34 )
        {
LABEL_37:
          v21->_M_nxt = *(std::__detail::_Hash_node_base **)(v11 + 360);
          *(_QWORD *)(v11 + 360) = v21;
          if ( v21->_M_nxt )
            buckets[(unsigned __int64)v21->_M_nxt[6]._M_nxt % *(_QWORD *)(v11 + 352)] = v21;
          *v34 = (std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type)(v11 + 360);
          goto LABEL_35;
        }
      }
      else
      {
        buckets = *(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<char const* const,google::protobuf::Symbol>,true> > >::__bucket_type **)(v11 + 344);
        v21[6]._M_nxt = (std::__detail::_Hash_node_base *)v14;
        v34 = &buckets[v15];
        v35 = *v34;
        if ( !*v34 )
          goto LABEL_37;
      }
      v21->_M_nxt = *(std::__detail::_Hash_node_base **)v35;
      (*v34)->_M_nxt = v21;
LABEL_35:
      ++*(_QWORD *)(v11 + 368);
      v18 = (std::string *)result._M_dataplus._M_p;
      v19 = v21 + 5;
LABEL_15:
      v19->_M_nxt = (std::__detail::_Hash_node_base *)v2;
      if ( v18 != (std::string *)&result._anon_0 )
        operator delete(v18);
      v1 = (unsigned int)++v39;
      if ( v40 == v39 )
        return v1;
      v1 = a1[1];
    }
  }
  return v1;
};

// Line 1174: range 000000000C901860-000000000C901A3C
std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *__fastcall google::protobuf::FileDescriptorTables::GetSourceLocation(
        __int64 a1,
        google::protobuf::int32 **a2,
        __int64 a3)
{
  __int64 v4; // rax
  google::protobuf::int32 *v5; // r15
  google::protobuf::int32 *v6; // r12
  google::protobuf::int32 *v7; // rbp
  google::protobuf::int32 v8; // edi
  std::string::$CFBEC286C7F52157F7E59FC354047095 *p_anon_0; // rbp
  __int64 v10; // rax
  std::string::pointer M_p; // rdx
  std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v12; // rcx
  std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v13; // rax
  std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *M_nxt; // r12
  std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v16; // rax
  __int64 v17[2]; // [rsp+0h] [rbp-98h] BYREF
  std::string result; // [rsp+10h] [rbp-88h] BYREF
  google::protobuf::strings::AlphaNum a; // [rsp+30h] [rbp-68h] BYREF

  v4 = *(_QWORD *)(a1 + 336);
  v17[0] = a1;
  v17[1] = a3;
  if ( v4 != 2 )
  {
    a.piece_data_ = (const char *)&off_1A17BF68;
    a.piece_size_ = (size_t)google::protobuf::FileDescriptorTables::BuildLocationsByPath;
    a.digits[0] = 0;
    *(_QWORD *)&a.digits[8] = v17;
    google::protobuf::GoogleOnceInitImpl(
      (google::protobuf::ProtobufOnceType *)(a1 + 336),
      (google::protobuf::Closure *)&a);
    a.piece_data_ = (const char *)&off_1A17BF68;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&a);
  }
  v5 = a2[1];
  v6 = *a2;
  result._M_string_length = 0LL;
  result._M_dataplus._M_p = result._anon_0._M_local_buf;
  result._anon_0._M_local_buf[0] = 0;
  v7 = v6;
  if ( v5 == v6 )
  {
    v16 = std::_Hashtable<std::string,std::pair<std::string const,google::protobuf::SourceCodeInfo_Location const*>,std::allocator<std::pair<std::string const,google::protobuf::SourceCodeInfo_Location const*>>,std::__detail::_Select1st,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
            (const std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *const)(a1 + 344),
            0LL,
            &result,
            0LL);
    M_nxt = v16;
    if ( !v16 )
      return M_nxt;
    M_nxt = v16->_M_nxt;
    p_anon_0 = &result._anon_0;
    if ( !v16->_M_nxt )
      return M_nxt;
  }
  else
  {
    while ( 1 )
    {
      v8 = *v7;
      a.piece_data_ = a.digits;
      a.piece_size_ = google::protobuf::FastInt32ToBufferLeft(v8, a.digits) - a.digits;
      google::protobuf::StrAppend(&result, &a);
      if ( v5 == ++v7 )
        break;
      if ( v6 != v7 )
      {
        if ( result._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
          std::__throw_length_error("basic_string::append");
        std::string::_M_append(&result, ",", 1LL);
      }
    }
    p_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)result._M_dataplus._M_p;
    v10 = *result._M_dataplus._M_p;
    if ( (_BYTE)v10 )
    {
      M_p = result._M_dataplus._M_p;
      v12 = 0LL;
      do
      {
        ++M_p;
        v12 = v10 + 5 * v12;
        v10 = *M_p;
      }
      while ( (_BYTE)v10 );
    }
    else
    {
      v12 = 0LL;
    }
    v13 = std::_Hashtable<std::string,std::pair<std::string const,google::protobuf::SourceCodeInfo_Location const*>,std::allocator<std::pair<std::string const,google::protobuf::SourceCodeInfo_Location const*>>,std::__detail::_Select1st,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
            (const std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *const)(a1 + 344),
            v12 % *(_QWORD *)(a1 + 352),
            &result,
            v12);
    M_nxt = v13;
    if ( !v13 )
      goto LABEL_14;
    M_nxt = v13->_M_nxt;
    if ( !v13->_M_nxt )
      goto LABEL_14;
  }
  M_nxt = M_nxt[5]._M_nxt;
LABEL_14:
  if ( p_anon_0 != &result._anon_0 )
    operator delete(p_anon_0);
  return M_nxt;
};

// Line 1184: range 000000000C8F4A40-000000000C8F4A55
void __fastcall google::protobuf::DescriptorPool::ErrorCollector::~ErrorCollector(
        google::protobuf::DescriptorPool::ErrorCollector *const this)
{
  ;
};

// Line 1186: range 000000000C8F7D00-000000000C8F7D75
std::_Rb_tree_header *__fastcall google::protobuf::DescriptorPool::DescriptorPool(
        google::protobuf::DescriptorPool *this)
{
  google::protobuf::DescriptorPool::Tables *v1; // rbp
  std::_Rb_tree_header *result; // rax

  this->mutex_ = 0LL;
  this->fallback_database_ = 0LL;
  this->default_error_collector_ = 0LL;
  this->underlay_ = 0LL;
  v1 = (google::protobuf::DescriptorPool::Tables *)operator new(0x238uLL);
  google::protobuf::DescriptorPool::Tables::Tables(v1);
  result = &this->unused_import_track_files_._M_t._M_impl.std::_Rb_tree_header;
  this->tables_.ptr_ = v1;
  *(_DWORD *)&this->enforce_dependencies_ = 1;
  this->disallow_enforce_utf8_ = 0;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_color = _S_red;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_parent = 0LL;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_left = &this->unused_import_track_files_._M_t._M_impl._M_header;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_right = &this->unused_import_track_files_._M_t._M_impl._M_header;
  this->unused_import_track_files_._M_t._M_impl._M_node_count = 0LL;
  return result;
};

// Line 1191: range 000000000C72D97C-000000000C72D98C
void __fastcall __noreturn google::protobuf::DescriptorPool::DescriptorPool()
{
  void *v0; // rbp
  struct _Unwind_Exception *v1; // r12

  operator delete(v0, 0x238uLL);
  _Unwind_Resume(v1);
};

// Line 1198: range 000000000C8F7D80-000000000C8F7E18
std::_Rb_tree_header *__fastcall google::protobuf::DescriptorPool::DescriptorPool(
        google::protobuf::DescriptorPool *this,
        google::protobuf::DescriptorDatabase *a2,
        google::protobuf::DescriptorPool::ErrorCollector *a3)
{
  google::protobuf::internal::Mutex *v4; // rbp
  google::protobuf::DescriptorPool::Tables *v5; // rbp
  std::_Rb_tree_header *result; // rax

  v4 = (google::protobuf::internal::Mutex *)operator new(8uLL);
  google::protobuf::internal::Mutex::Mutex(v4);
  this->mutex_ = v4;
  this->fallback_database_ = a2;
  this->default_error_collector_ = a3;
  this->underlay_ = 0LL;
  v5 = (google::protobuf::DescriptorPool::Tables *)operator new(0x238uLL);
  google::protobuf::DescriptorPool::Tables::Tables(v5);
  result = &this->unused_import_track_files_._M_t._M_impl.std::_Rb_tree_header;
  this->tables_.ptr_ = v5;
  *(_DWORD *)&this->enforce_dependencies_ = 1;
  this->disallow_enforce_utf8_ = 0;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_color = _S_red;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_parent = 0LL;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_left = &this->unused_import_track_files_._M_t._M_impl._M_header;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_right = &this->unused_import_track_files_._M_t._M_impl._M_header;
  this->unused_import_track_files_._M_t._M_impl._M_node_count = 0LL;
  return result;
};

// Line 1200: range 000000000C72D992-000000000C72D9A2
void __fastcall __noreturn google::protobuf::DescriptorPool::DescriptorPool()
{
  void *v0; // rbp
  struct _Unwind_Exception *v1; // r12

  operator delete(v0, 8uLL);
  _Unwind_Resume(v1);
};

// Line 1212: range 000000000C8F7EA0-000000000C8F7F11
std::_Rb_tree_header *__fastcall google::protobuf::DescriptorPool::DescriptorPool(
        google::protobuf::DescriptorPool *this,
        const google::protobuf::DescriptorPool *a2)
{
  google::protobuf::DescriptorPool::Tables *v2; // rbp
  std::_Rb_tree_header *result; // rax

  this->mutex_ = 0LL;
  this->fallback_database_ = 0LL;
  this->default_error_collector_ = 0LL;
  this->underlay_ = a2;
  v2 = (google::protobuf::DescriptorPool::Tables *)operator new(0x238uLL);
  google::protobuf::DescriptorPool::Tables::Tables(v2);
  result = &this->unused_import_track_files_._M_t._M_impl.std::_Rb_tree_header;
  this->tables_.ptr_ = v2;
  *(_DWORD *)&this->enforce_dependencies_ = 1;
  this->disallow_enforce_utf8_ = 0;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_color = _S_red;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_parent = 0LL;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_left = &this->unused_import_track_files_._M_t._M_impl._M_header;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_right = &this->unused_import_track_files_._M_t._M_impl._M_header;
  this->unused_import_track_files_._M_t._M_impl._M_node_count = 0LL;
  return result;
};

// Line 1217: range 000000000C72D9E6-000000000C72D9F6
void __fastcall __noreturn google::protobuf::DescriptorPool::DescriptorPool()
{
  void *v0; // rbp
  struct _Unwind_Exception *v1; // r12

  operator delete(v0, 0x238uLL);
  _Unwind_Resume(v1);
};

// Line 1224: range 000000000C8F8190-000000000C8F81F6
void __fastcall google::protobuf::DescriptorPool::~DescriptorPool(google::protobuf::DescriptorPool *const this)
{
  google::protobuf::internal::Mutex *mutex; // rbp
  google::protobuf::DescriptorPool::Tables *ptr; // rbp

  mutex = this->mutex_;
  if ( this->mutex_ )
  {
    google::protobuf::internal::Mutex::~Mutex(this->mutex_);
    operator delete(mutex, 8uLL);
  }
  std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_erase(
    &this->unused_import_track_files_._M_t,
    (std::_Rb_tree<std::string,std::string,std::_Identity<std::string >,std::less<std::string >,std::allocator<std::string > >::_Link_type)this->unused_import_track_files_._M_t._M_impl._M_header._M_parent);
  ptr = this->tables_.ptr_;
  if ( ptr )
  {
    google::protobuf::DescriptorPool::Tables::~Tables(this->tables_.ptr_);
    operator delete(ptr, 0x238uLL);
  }
};

// Line 1232: range 000000000C8F4A60-000000000C8F4A64
void __fastcall google::protobuf::DescriptorPool::InternalDontEnforceDependencies(
        google::protobuf::DescriptorPool *const this)
{
  this->enforce_dependencies_ = 0;
};

// Line 1239: range 000000000C8F7930-000000000C8F795E
void __fastcall google::protobuf::DescriptorPool::ClearUnusedImportTrackFiles(
        google::protobuf::DescriptorPool *const this)
{
  std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_erase(
    &this->unused_import_track_files_._M_t,
    (std::_Rb_tree<std::string,std::string,std::_Identity<std::string >,std::less<std::string >,std::allocator<std::string > >::_Link_type)this->unused_import_track_files_._M_t._M_impl._M_header._M_parent);
  this->unused_import_track_files_._M_t._M_impl._M_header._M_parent = 0LL;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_left = &this->unused_import_track_files_._M_t._M_impl._M_header;
  this->unused_import_track_files_._M_t._M_impl._M_header._M_right = &this->unused_import_track_files_._M_t._M_impl._M_header;
  this->unused_import_track_files_._M_t._M_impl._M_node_count = 0LL;
};

// Line 1243: range 000000000C9017A0-000000000C901853
bool __fastcall google::protobuf::DescriptorPool::InternalIsFileLoaded(
        const google::protobuf::DescriptorPool *const this,
        const std::string *filename)
{
  google::protobuf::internal::Mutex *mutex; // r12
  google::protobuf::`anonymous namespace'::FilesByNameMap *p_files_by_name; // rdi
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v4; // rax
  bool v5; // r13
  google::protobuf::`anonymous namespace'::FilesByNameMap *v7; // rdi
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v8; // rax
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type __k[6]; // [rsp+8h] [rbp-30h] BYREF

  mutex = this->mutex_;
  if ( this->mutex_ )
  {
    google::protobuf::internal::Mutex::Lock(this->mutex_);
    p_files_by_name = &this->tables_.ptr_->files_by_name_;
    __k[0] = filename->_M_dataplus._M_p;
    v4._M_cur = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                  &p_files_by_name->_M_h,
                  __k)._M_cur;
    if ( v4._M_cur )
      v5 = *((_QWORD *)&v4._M_cur->_M_storage._M_storage.1 + 1) != 0LL;
    else
      v5 = 0;
    google::protobuf::internal::Mutex::Unlock(mutex);
    return v5;
  }
  v7 = &this->tables_.ptr_->files_by_name_;
  __k[0] = filename->_M_dataplus._M_p;
  v8._M_cur = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                &v7->_M_h,
                __k)._M_cur;
  if ( !v8._M_cur )
    return 0;
  return *((_QWORD *)&v8._M_cur->_M_storage._M_storage.1 + 1) != 0LL;
};

// Line 1258: range 000000000C8F8200-000000000C8F824B
void __cdecl google::protobuf::`anonymous namespace'::DeleteGeneratedPool()
{
  google::protobuf::DescriptorPool *v0; // rbp

  if ( google::protobuf::`anonymous namespace'::generated_database_ )
    (*((void (__fastcall **)(google::protobuf::EncodedDescriptorDatabase *))google::protobuf::`anonymous namespace'::generated_database_->_vptr_DescriptorDatabase
     + 1))(google::protobuf::`anonymous namespace'::generated_database_);
  v0 = google::protobuf::`anonymous namespace'::generated_pool_;
  google::protobuf::`anonymous namespace'::generated_database_ = 0LL;
  if ( google::protobuf::`anonymous namespace'::generated_pool_ )
  {
    google::protobuf::DescriptorPool::~DescriptorPool(google::protobuf::`anonymous namespace'::generated_pool_);
    operator delete(v0, 0x60uLL);
  }
  google::protobuf::`anonymous namespace'::generated_pool_ = 0LL;
};

// Line 1264: range 000000000C8F7E20-000000000C8F7E8D
__int64 __fastcall google::protobuf::`anonymous namespace'::InitGeneratedPool(
        google::protobuf::_anonymous_namespace_ *this)
{
  google::protobuf::EncodedDescriptorDatabase *v1; // rbp
  google::protobuf::DescriptorPool *v2; // rax
  void (*v3)(void); // rsi
  google::protobuf::DescriptorPool *v4; // rbp

  v1 = (google::protobuf::EncodedDescriptorDatabase *)operator new(0xB0uLL);
  google::protobuf::EncodedDescriptorDatabase::EncodedDescriptorDatabase(v1);
  google::protobuf::`anonymous namespace'::generated_database_ = v1;
  v2 = (google::protobuf::DescriptorPool *)operator new(0x60uLL);
  v3 = (void (*)(void))google::protobuf::`anonymous namespace'::generated_database_;
  v4 = v2;
  google::protobuf::DescriptorPool::DescriptorPool(
    v2,
    google::protobuf::`anonymous namespace'::generated_database_,
    0LL);
  google::protobuf::`anonymous namespace'::generated_pool_ = v4;
  *(_WORD *)&v4->enforce_dependencies_ = 256;
  return google::protobuf::internal::OnShutdown(
           (google::protobuf::internal *)google::protobuf::`anonymous namespace'::DeleteGeneratedPool,
           v3);
};

// Line 1265: range 000000000C72D9BC-000000000C72D9CC
void __fastcall __noreturn google::protobuf::`anonymous namespace'::InitGeneratedPool()
{
  void *v0; // rbp
  struct _Unwind_Exception *v1; // r12

  operator delete(v0, 0xB0uLL);
  _Unwind_Resume(v1);
};

// Line 1291: range 000000000C8F4AE0-000000000C8F4BBB
void __fastcall google::protobuf::DescriptorPool::InternalAddGeneratedFile(
        google::protobuf::DescriptorPool *this,
        const void *a2)
{
  google::protobuf::internal::LogMessage_0 *v2; // rax
  google::protobuf::internal::LogFinisher v3; // [rsp+Fh] [rbp-59h] BYREF
  google::protobuf::internal::LogMessage_0 closure; // [rsp+10h] [rbp-58h] BYREF

  if ( google::protobuf::`anonymous namespace'::generated_pool_init_ != 2 )
  {
    *(_QWORD *)&closure.level_ = off_1A16E058;
    LOBYTE(closure.line_) = 0;
    closure.filename_ = (const char *)google::protobuf::`anonymous namespace'::InitGeneratedPool;
    google::protobuf::GoogleOnceInitImpl(
      &google::protobuf::`anonymous namespace'::generated_pool_init_,
      (google::protobuf::Closure *)&closure);
    google::protobuf::internal::FunctionClosure0::~FunctionClosure0((google::protobuf::internal::FunctionClosure0 *const)&closure);
  }
  if ( !(unsigned __int8)google::protobuf::EncodedDescriptorDatabase::Add(
                           google::protobuf::`anonymous namespace'::generated_database_,
                           this,
                           (int)a2) )
  {
    google::protobuf::internal::LogMessage::LogMessage(
      &closure,
      LOGLEVEL_FATAL_0,
      "google/protobuf/descriptor.cc",
      1315);
    v2 = google::protobuf::internal::LogMessage::operator<<(
           &closure,
           "CHECK failed: generated_database_->Add(encoded_file_descriptor, size): ");
    google::protobuf::internal::LogFinisher::operator=(&v3, v2);
    google::protobuf::internal::LogMessage::~LogMessage(&closure);
  }
};

// Line 1325: range 000000000C912F50-000000000C913032
std::__detail::_Node_iterator_base<std::pair<char const* const,const google::protobuf::FileDescriptor*>,true>::__node_type *__fastcall google::protobuf::DescriptorPool::FindFileByName(
        google::protobuf::DescriptorPool *a1,
        std::string *a2)
{
  google::protobuf::internal::Mutex *mutex; // rbp
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v4; // rax
  std::__detail::_Node_iterator_base<std::pair<char const* const,const google::protobuf::FileDescriptor*>,true>::__node_type *M_cur; // r12
  const google::protobuf::DescriptorPool *underlay; // rdi
  const std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *p_M_h; // rdi
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v9; // rax
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type __k[6]; // [rsp+8h] [rbp-30h] BYREF

  mutex = a1->mutex_;
  if ( a1->mutex_ )
    google::protobuf::internal::Mutex::Lock(a1->mutex_);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear(&a1->tables_.ptr_->known_bad_symbols_._M_h);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear(&a1->tables_.ptr_->known_bad_files_._M_h);
  __k[0] = a2->_M_dataplus._M_p;
  v4._M_cur = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                &a1->tables_.ptr_->files_by_name_._M_h,
                __k)._M_cur;
  if ( !v4._M_cur
    || (M_cur = (std::__detail::_Node_iterator_base<std::pair<char const* const,const google::protobuf::FileDescriptor*>,true>::__node_type *)*((_QWORD *)&v4._M_cur->_M_storage._M_storage.1 + 1)) == 0LL )
  {
    underlay = a1->underlay_;
    if ( !underlay
      || (M_cur = (std::__detail::_Node_iterator_base<std::pair<char const* const,const google::protobuf::FileDescriptor*>,true>::__node_type *)google::protobuf::DescriptorPool::FindFileByName(underlay, a2)) == 0LL )
    {
      M_cur = 0LL;
      if ( (unsigned __int8)google::protobuf::DescriptorPool::TryFindFileInFallbackDatabase(a1, a2) )
      {
        p_M_h = &a1->tables_.ptr_->files_by_name_._M_h;
        __k[0] = a2->_M_dataplus._M_p;
        v9._M_cur = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                      p_M_h,
                      __k)._M_cur;
        M_cur = v9._M_cur;
        if ( v9._M_cur )
          M_cur = (std::__detail::_Node_iterator_base<std::pair<char const* const,const google::protobuf::FileDescriptor*>,true>::__node_type *)*((_QWORD *)&v9._M_cur->_M_storage._M_storage.1 + 1);
      }
    }
  }
  if ( mutex )
    google::protobuf::internal::Mutex::Unlock(mutex);
  return M_cur;
};

// Line 1362: range 000000000C913400-000000000C913426
const google::protobuf::Descriptor *__fastcall google::protobuf::DescriptorPool::FindMessageTypeByName(
        const google::protobuf::DescriptorPool *const this,
        const std::string *name)
{
  bool v2; // zf
  const google::protobuf::Descriptor *v3; // rdx
  const google::protobuf::Descriptor *result; // rax

  v2 = (unsigned int)google::protobuf::DescriptorPool::Tables::FindByNameHelper(
                       (__int64)this->tables_.ptr_,
                       (google::protobuf::DescriptorPool *)this,
                       (std::string *)name) == 1;
  result = 0LL;
  if ( v2 )
    return v3;
  return result;
};

// Line 1368: range 000000000C913430-000000000C913465
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::DescriptorPool::FindFieldByName(
        const google::protobuf::DescriptorPool *const this,
        const std::string *name)
{
  const google::protobuf::FieldDescriptor *v2; // rdx
  int v3; // r8d
  const google::protobuf::FieldDescriptor *result; // rax

  v3 = google::protobuf::DescriptorPool::Tables::FindByNameHelper(
         (__int64)this->tables_.ptr_,
         (google::protobuf::DescriptorPool *)this,
         (std::string *)name);
  result = 0LL;
  if ( v3 == 2 )
  {
    result = v2;
    if ( v2->is_extension_ )
      return 0LL;
  }
  return result;
};

// Line 1379: range 000000000C913470-000000000C9134A5
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::DescriptorPool::FindExtensionByName(
        const google::protobuf::DescriptorPool *const this,
        const std::string *name)
{
  const google::protobuf::FieldDescriptor *v2; // rdx
  int v3; // r8d
  const google::protobuf::FieldDescriptor *result; // rax

  v3 = google::protobuf::DescriptorPool::Tables::FindByNameHelper(
         (__int64)this->tables_.ptr_,
         (google::protobuf::DescriptorPool *)this,
         (std::string *)name);
  result = 0LL;
  if ( v3 == 2 )
  {
    result = v2;
    if ( !v2->is_extension_ )
      return 0LL;
  }
  return result;
};

// Line 1390: range 000000000C9134B0-000000000C9134D6
const google::protobuf::OneofDescriptor *__fastcall google::protobuf::DescriptorPool::FindOneofByName(
        const google::protobuf::DescriptorPool *const this,
        const std::string *name)
{
  bool v2; // zf
  const google::protobuf::OneofDescriptor *v3; // rdx
  const google::protobuf::OneofDescriptor *result; // rax

  v2 = (unsigned int)google::protobuf::DescriptorPool::Tables::FindByNameHelper(
                       (__int64)this->tables_.ptr_,
                       (google::protobuf::DescriptorPool *)this,
                       (std::string *)name) == 3;
  result = 0LL;
  if ( v2 )
    return v3;
  return result;
};

// Line 1396: range 000000000C9134E0-000000000C913506
const google::protobuf::EnumDescriptor *__fastcall google::protobuf::DescriptorPool::FindEnumTypeByName(
        const google::protobuf::DescriptorPool *const this,
        const std::string *name)
{
  bool v2; // zf
  const google::protobuf::EnumDescriptor *v3; // rdx
  const google::protobuf::EnumDescriptor *result; // rax

  v2 = (unsigned int)google::protobuf::DescriptorPool::Tables::FindByNameHelper(
                       (__int64)this->tables_.ptr_,
                       (google::protobuf::DescriptorPool *)this,
                       (std::string *)name) == 4;
  result = 0LL;
  if ( v2 )
    return v3;
  return result;
};

// Line 1402: range 000000000C913510-000000000C913536
const google::protobuf::EnumValueDescriptor *__fastcall google::protobuf::DescriptorPool::FindEnumValueByName(
        const google::protobuf::DescriptorPool *const this,
        const std::string *name)
{
  bool v2; // zf
  const google::protobuf::EnumValueDescriptor *v3; // rdx
  const google::protobuf::EnumValueDescriptor *result; // rax

  v2 = (unsigned int)google::protobuf::DescriptorPool::Tables::FindByNameHelper(
                       (__int64)this->tables_.ptr_,
                       (google::protobuf::DescriptorPool *)this,
                       (std::string *)name) == 5;
  result = 0LL;
  if ( v2 )
    return v3;
  return result;
};

// Line 1409: range 000000000C913540-000000000C913566
const google::protobuf::ServiceDescriptor *__fastcall google::protobuf::DescriptorPool::FindServiceByName(
        const google::protobuf::DescriptorPool *const this,
        const std::string *name)
{
  bool v2; // zf
  const google::protobuf::ServiceDescriptor *v3; // rdx
  const google::protobuf::ServiceDescriptor *result; // rax

  v2 = (unsigned int)google::protobuf::DescriptorPool::Tables::FindByNameHelper(
                       (__int64)this->tables_.ptr_,
                       (google::protobuf::DescriptorPool *)this,
                       (std::string *)name) == 6;
  result = 0LL;
  if ( v2 )
    return v3;
  return result;
};

// Line 1415: range 000000000C913570-000000000C913596
const google::protobuf::MethodDescriptor *__fastcall google::protobuf::DescriptorPool::FindMethodByName(
        const google::protobuf::DescriptorPool *const this,
        const std::string *name)
{
  bool v2; // zf
  const google::protobuf::MethodDescriptor *v3; // rdx
  const google::protobuf::MethodDescriptor *result; // rax

  v2 = (unsigned int)google::protobuf::DescriptorPool::Tables::FindByNameHelper(
                       (__int64)this->tables_.ptr_,
                       (google::protobuf::DescriptorPool *)this,
                       (std::string *)name) == 7;
  result = 0LL;
  if ( v2 )
    return v3;
  return result;
};

// Line 1421: range 000000000C916A60-000000000C916B5D
std::_Rb_tree_node_base::_Base_ptr __fastcall google::protobuf::DescriptorPool::FindExtensionByNumber(
        google::protobuf::DescriptorPool *this,
        const google::protobuf::Descriptor *a2,
        int a3)
{
  google::protobuf::internal::Mutex *mutex; // r14
  google::protobuf::DescriptorPool::Tables *ptr; // rbp
  std::_Rb_tree<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::less<std::pair<const google::protobuf::Descriptor*,int> >,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> > >::iterator v7; // rax
  std::_Rb_tree_node_base::_Base_ptr M_left; // r15
  google::protobuf::DescriptorPool *underlay; // rdi
  google::protobuf::DescriptorPool::Tables *v11; // rbx
  std::_Rb_tree<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::less<std::pair<const google::protobuf::Descriptor*,int> >,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> > >::iterator v12; // rax
  std::pair<const google::protobuf::Descriptor*,int> v13[4]; // [rsp+0h] [rbp-48h] BYREF

  mutex = this->mutex_;
  if ( this->mutex_ )
    google::protobuf::internal::Mutex::Lock(this->mutex_);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear(&this->tables_.ptr_->known_bad_symbols_._M_h);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear(&this->tables_.ptr_->known_bad_files_._M_h);
  ptr = this->tables_.ptr_;
  v13[0].first = a2;
  v13[0].second = a3;
  v7._M_node = std::_Rb_tree<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::less<std::pair<google::protobuf::Descriptor const*,int>>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>>::find(
                 &ptr->extensions_._M_t,
                 v13)._M_node;
  if ( (std::_Rb_tree_header *)v7._M_node == &ptr->extensions_._M_t._M_impl.std::_Rb_tree_header
    || (M_left = v7._M_node[1]._M_left) == 0LL )
  {
    underlay = (google::protobuf::DescriptorPool *)this->underlay_;
    if ( !underlay
      || (M_left = (std::_Rb_tree_node_base::_Base_ptr)google::protobuf::DescriptorPool::FindExtensionByNumber(
                                                         underlay,
                                                         a2,
                                                         a3)) == 0LL )
    {
      M_left = 0LL;
      if ( (unsigned __int8)google::protobuf::DescriptorPool::TryFindExtensionInFallbackDatabase(this, a2, a3) )
      {
        v11 = this->tables_.ptr_;
        v13[0].first = a2;
        v13[0].second = a3;
        v12._M_node = std::_Rb_tree<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::less<std::pair<google::protobuf::Descriptor const*,int>>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>>::find(
                        &v11->extensions_._M_t,
                        v13)._M_node;
        if ( (std::_Rb_tree_header *)v12._M_node != &v11->extensions_._M_t._M_impl.std::_Rb_tree_header )
          M_left = v12._M_node[1]._M_left;
      }
    }
  }
  if ( mutex )
    google::protobuf::internal::Mutex::Unlock(mutex);
  return M_left;
};

// Line 1444: range 000000000C916B70-000000000C916E05
__int64 __fastcall google::protobuf::DescriptorPool::FindAllExtensions(
        google::protobuf::DescriptorPool *a1,
        google::protobuf::Descriptor *a2,
        std::vector<const google::protobuf::FieldDescriptor*> *a3)
{
  google::protobuf::internal::Mutex *mutex; // r15
  const google::protobuf::FieldDescriptor *v6; // rcx
  google::protobuf::DescriptorDatabase *fallback_database; // r11
  google::protobuf::DescriptorPool::Tables *ptr; // r8
  google::protobuf::Descriptor *v9; // r13
  std::_Hashtable<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::allocator<const google::protobuf::Descriptor*>,std::__detail::_Identity,std::equal_to<const google::protobuf::Descriptor*>,google::protobuf::hash<const google::protobuf::Descriptor*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true> >::size_type M_bucket_count; // rdi
  const google::protobuf::FieldDescriptor **v11; // rax
  google::protobuf::Descriptor *lowercase_name; // rsi
  __int64 v13; // r9
  int (**vptr_DescriptorDatabase)(...); // rax
  const std::string *full_name; // rsi
  google::protobuf::DescriptorDatabase *v16; // rdi
  char v17; // al
  _DWORD *v18; // rdi
  unsigned __int64 v19; // rbp
  google::protobuf::DescriptorPool::Tables *v20; // r13
  int v21; // r14d
  std::_Rb_tree<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::less<std::pair<const google::protobuf::Descriptor*,int> >,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> > >::iterator v22; // rax
  __int64 result; // rax
  std::_Rb_tree_header *v24; // r14
  const google::protobuf::FieldDescriptor *const *v25; // rbp
  const google::protobuf::FieldDescriptor **v26; // rsi
  std::vector<const google::protobuf::FieldDescriptor*>::iterator v27; // rsi
  const google::protobuf::DescriptorPool *underlay; // rdi
  std::true_type v29; // [rsp+0h] [rbp-78h]
  google::protobuf::Descriptor *__v; // [rsp+8h] [rbp-70h] BYREF
  std::pair<const google::protobuf::Descriptor*,int> __k; // [rsp+10h] [rbp-68h] BYREF
  void *v32; // [rsp+20h] [rbp-58h] BYREF
  _BYTE *v33; // [rsp+28h] [rbp-50h]
  __int64 v34; // [rsp+30h] [rbp-48h]

  mutex = a1->mutex_;
  __v = a2;
  if ( mutex )
    google::protobuf::internal::Mutex::Lock(mutex);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear(&a1->tables_.ptr_->known_bad_symbols_._M_h);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear(&a1->tables_.ptr_->known_bad_files_._M_h);
  fallback_database = a1->fallback_database_;
  if ( !fallback_database )
    goto LABEL_24;
  ptr = a1->tables_.ptr_;
  v9 = __v;
  M_bucket_count = ptr->extensions_loaded_from_db_._M_h._M_bucket_count;
  v11 = (const google::protobuf::FieldDescriptor **)ptr->extensions_loaded_from_db_._M_h._M_buckets[(unsigned __int64)__v % M_bucket_count];
  if ( !v11 || (v6 = *v11) == 0LL )
  {
LABEL_14:
    vptr_DescriptorDatabase = fallback_database->_vptr_DescriptorDatabase;
    full_name = __v->full_name_;
    v16 = a1->fallback_database_;
    v32 = 0LL;
    v33 = 0LL;
    v34 = 0LL;
    v17 = vptr_DescriptorDatabase[5](v16, full_name, &v32);
    v18 = v32;
    if ( v17 )
    {
      v19 = 0LL;
      if ( v32 != v33 )
      {
        do
        {
          v20 = a1->tables_.ptr_;
          v21 = v18[v19];
          __k.second = v21;
          __k.first = __v;
          v22._M_node = std::_Rb_tree<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::less<std::pair<google::protobuf::Descriptor const*,int>>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>>::find(
                          &v20->extensions_._M_t,
                          &__k)._M_node;
          if ( (std::_Rb_tree_header *)v22._M_node == &v20->extensions_._M_t._M_impl.std::_Rb_tree_header
            || !v22._M_node[1]._M_left )
          {
            google::protobuf::DescriptorPool::TryFindExtensionInFallbackDatabase(a1, __v, v21);
          }
          v18 = v32;
          ++v19;
        }
        while ( v19 < (v33 - (_BYTE *)v32) >> 2 );
      }
      __k.first = (const google::protobuf::Descriptor *)&a1->tables_.ptr_->extensions_loaded_from_db_;
      std::_Hashtable<google::protobuf::Descriptor const*,google::protobuf::Descriptor const*,std::allocator<google::protobuf::Descriptor const*>,std::__detail::_Identity,std::equal_to<google::protobuf::Descriptor const*>,google::protobuf::hash<google::protobuf::Descriptor const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::_M_insert<google::protobuf::Descriptor const* const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<google::protobuf::Descriptor const*,true>>>>(
        (std::_Hashtable<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::allocator<const google::protobuf::Descriptor*>,std::__detail::_Identity,std::equal_to<const google::protobuf::Descriptor*>,google::protobuf::hash<const google::protobuf::Descriptor*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true> > *const)__k.first,
        (const google::protobuf::Descriptor *const *)&__v,
        (const std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<const google::protobuf::Descriptor*,true> > > *)&__k,
        v29,
        1uLL);
      v18 = v32;
    }
    if ( v18 )
      operator delete(v18);
LABEL_24:
    v9 = __v;
    ptr = a1->tables_.ptr_;
    goto LABEL_25;
  }
  lowercase_name = (google::protobuf::Descriptor *)v6->lowercase_name_;
  v13 = 0LL;
  while ( __v == lowercase_name && __v == (google::protobuf::Descriptor *)v6->full_name_ )
  {
    v6 = (const google::protobuf::FieldDescriptor *)v6->name_;
    ++v13;
    if ( !v6 )
      goto LABEL_13;
LABEL_9:
    lowercase_name = (google::protobuf::Descriptor *)v6->lowercase_name_;
    if ( (unsigned __int64)__v % M_bucket_count != (unsigned __int64)lowercase_name % M_bucket_count )
      goto LABEL_13;
  }
  if ( v13 )
    goto LABEL_25;
  v6 = (const google::protobuf::FieldDescriptor *)v6->name_;
  if ( v6 )
    goto LABEL_9;
LABEL_13:
  if ( !v13 )
    goto LABEL_14;
LABEL_25:
  result = (__int64)ptr->extensions_._M_t._M_impl._M_header._M_parent;
  v24 = &ptr->extensions_._M_t._M_impl.std::_Rb_tree_header;
  v25 = (const google::protobuf::FieldDescriptor *const *)&ptr->extensions_._M_t._M_impl.std::_Rb_tree_header;
  if ( result )
  {
    do
    {
      if ( *(_QWORD *)(result + 32) < (unsigned __int64)v9
        || *(google::protobuf::Descriptor **)(result + 32) == v9 && *(int *)(result + 40) < 0 )
      {
        result = *(_QWORD *)(result + 24);
      }
      else
      {
        v25 = (const google::protobuf::FieldDescriptor *const *)result;
        result = *(_QWORD *)(result + 16);
      }
    }
    while ( result );
    while ( v24 != (std::_Rb_tree_header *)v25 && *((google::protobuf::Descriptor **)v25 + 4) == v9 )
    {
      v27._M_current = a3->_M_impl._M_finish;
      if ( v27._M_current == a3->_M_impl._M_end_of_storage )
      {
        std::vector<google::protobuf::FieldDescriptor const*>::_M_realloc_insert<google::protobuf::FieldDescriptor const* const&>(
          a3,
          v27,
          v25 + 6,
          (const google::protobuf::FieldDescriptor *const *)v6);
      }
      else
      {
        v26 = v27._M_current + 1;
        *(v26 - 1) = (const google::protobuf::FieldDescriptor *)*((_QWORD *)v25 + 6);
        a3->_M_impl._M_finish = v26;
      }
      result = std::_Rb_tree_increment((const std::_Rb_tree_node_base *)v25);
      v25 = (const google::protobuf::FieldDescriptor *const *)result;
    }
  }
  underlay = a1->underlay_;
  if ( underlay )
    result = google::protobuf::DescriptorPool::FindAllExtensions(underlay, __v, a3);
  if ( mutex )
    return google::protobuf::internal::Mutex::Unlock(mutex);
  return result;
};

// Line 1476: range 000000000C8F4BC0-000000000C8F4C05
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::Descriptor::FindFieldByNumber(
        const google::protobuf::Descriptor *const this,
        int key)
{
  const google::protobuf::FileDescriptor *file; // rax
  const std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *tables; // rax
  const google::protobuf::FieldDescriptor *result; // rax
  const google::protobuf::Descriptor *v5; // [rsp+0h] [rbp-18h] BYREF
  int keya; // [rsp+8h] [rbp-10h]

  file = this->file_;
  v5 = this;
  tables = (const std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *)file->tables_;
  keya = key;
  result = (const google::protobuf::FieldDescriptor *)std::_Hashtable<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::Descriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::Descriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                                                        tables + 3,
                                                        (const std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *)&v5)._M_cur;
  if ( result )
  {
    result = (const google::protobuf::FieldDescriptor *)result->camelcase_name_;
    if ( result )
    {
      if ( result->is_extension_ )
        return 0LL;
    }
  }
  return result;
};

// Line 1487: range 000000000C8F4C10-000000000C8F4C56
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::Descriptor::FindFieldByLowercaseName(
        const google::protobuf::Descriptor *const this,
        const std::string *key)
{
  const google::protobuf::FileDescriptor *file; // rax
  const char *M_p; // rdx
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *tables; // rax
  const google::protobuf::FieldDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v6; // [rsp+0h] [rbp-18h] BYREF

  file = this->file_;
  M_p = key->_M_dataplus._M_p;
  v6.first = this;
  tables = (const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *)file->tables_;
  v6.second = M_p;
  result = (const google::protobuf::FieldDescriptor *)std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                                                        tables + 1,
                                                        &v6)._M_cur;
  if ( result )
  {
    result = (const google::protobuf::FieldDescriptor *)result->camelcase_name_;
    if ( result )
    {
      if ( result->is_extension_ )
        return 0LL;
    }
  }
  return result;
};

// Line 1498: range 000000000C8F4C60-000000000C8F4CA6
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::Descriptor::FindFieldByCamelcaseName(
        const google::protobuf::Descriptor *const this,
        const std::string *key)
{
  const google::protobuf::FileDescriptor *file; // rax
  const char *M_p; // rdx
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *tables; // rax
  const google::protobuf::FieldDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v6; // [rsp+0h] [rbp-18h] BYREF

  file = this->file_;
  M_p = key->_M_dataplus._M_p;
  v6.first = this;
  tables = (const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *)file->tables_;
  v6.second = M_p;
  result = (const google::protobuf::FieldDescriptor *)std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                                                        tables + 2,
                                                        &v6)._M_cur;
  if ( result )
  {
    result = (const google::protobuf::FieldDescriptor *)result->camelcase_name_;
    if ( result )
    {
      if ( result->is_extension_ )
        return 0LL;
    }
  }
  return result;
};

// Line 1509: range 000000000C8F4CB0-000000000C8F4D73
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::Descriptor::FindFieldByName(
        const google::protobuf::Descriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptor *file; // rax
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *p_M_h; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v7; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v8; // rax
  std::__detail::_Hash_node_base *v9; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::FieldDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v12; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  file = this->file_;
  v12.first = this;
  p_M_h = &file->tables_->symbols_by_parent_._M_h;
  v5 = *M_p;
  v12.second = M_p;
  if ( (_BYTE)v5 )
  {
    v6 = 0LL;
    do
    {
      ++M_p;
      v6 = v5 + 5 * v6;
      v5 = *M_p;
    }
    while ( (_BYTE)v5 );
    v7 = 0xFFFFLL * (_QWORD)this + v6;
  }
  else
  {
    v7 = 0xFFFFLL * (_QWORD)this;
  }
  v8 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         p_M_h,
         v7 % p_M_h->_M_bucket_count,
         &v12,
         v7);
  if ( v8 && (v9 = v8->_M_nxt) != 0LL )
  {
    M_nxt = v9[3]._M_nxt;
    result = (const google::protobuf::FieldDescriptor *)v9[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.field_descriptor;
  }
  if ( (_DWORD)M_nxt != 2 )
  {
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.field_descriptor;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type == NULL_SYMBOL )
      return 0LL;
  }
  if ( result->is_extension_ )
    return 0LL;
  return result;
};

// Line 1520: range 000000000C8F4D80-000000000C8F4E33
const google::protobuf::OneofDescriptor *__fastcall google::protobuf::Descriptor::FindOneofByName(
        const google::protobuf::Descriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptor *file; // rax
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *p_M_h; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v7; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v8; // rax
  std::__detail::_Hash_node_base *v9; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::OneofDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v12; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  file = this->file_;
  v12.first = this;
  p_M_h = &file->tables_->symbols_by_parent_._M_h;
  v5 = *M_p;
  v12.second = M_p;
  if ( (_BYTE)v5 )
  {
    v6 = 0LL;
    do
    {
      ++M_p;
      v6 = v5 + 5 * v6;
      v5 = *M_p;
    }
    while ( (_BYTE)v5 );
    v7 = 0xFFFFLL * (_QWORD)this + v6;
  }
  else
  {
    v7 = 0xFFFFLL * (_QWORD)this;
  }
  v8 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         p_M_h,
         v7 % p_M_h->_M_bucket_count,
         &v12,
         v7);
  if ( v8 && (v9 = v8->_M_nxt) != 0LL )
  {
    M_nxt = v9[3]._M_nxt;
    result = (const google::protobuf::OneofDescriptor *)v9[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.oneof_descriptor;
  }
  if ( (_DWORD)M_nxt != 3 )
  {
    result = 0LL;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type )
      return google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.oneof_descriptor;
  }
  return result;
};

// Line 1531: range 000000000C8F4E40-000000000C8F4F03
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::Descriptor::FindExtensionByName(
        const google::protobuf::Descriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptor *file; // rax
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *p_M_h; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v7; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v8; // rax
  std::__detail::_Hash_node_base *v9; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::FieldDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v12; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  file = this->file_;
  v12.first = this;
  p_M_h = &file->tables_->symbols_by_parent_._M_h;
  v5 = *M_p;
  v12.second = M_p;
  if ( (_BYTE)v5 )
  {
    v6 = 0LL;
    do
    {
      ++M_p;
      v6 = v5 + 5 * v6;
      v5 = *M_p;
    }
    while ( (_BYTE)v5 );
    v7 = 0xFFFFLL * (_QWORD)this + v6;
  }
  else
  {
    v7 = 0xFFFFLL * (_QWORD)this;
  }
  v8 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         p_M_h,
         v7 % p_M_h->_M_bucket_count,
         &v12,
         v7);
  if ( v8 && (v9 = v8->_M_nxt) != 0LL )
  {
    M_nxt = v9[3]._M_nxt;
    result = (const google::protobuf::FieldDescriptor *)v9[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.field_descriptor;
  }
  if ( (_DWORD)M_nxt != 2 )
  {
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.field_descriptor;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type == NULL_SYMBOL )
      return 0LL;
  }
  if ( !result->is_extension_ )
    return 0LL;
  return result;
};

// Line 1542: range 000000000C8F4F10-000000000C8F4F56
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::Descriptor::FindExtensionByLowercaseName(
        const google::protobuf::Descriptor *const this,
        const std::string *key)
{
  const google::protobuf::FileDescriptor *file; // rax
  const char *M_p; // rdx
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *tables; // rax
  const google::protobuf::FieldDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v6; // [rsp+0h] [rbp-18h] BYREF

  file = this->file_;
  M_p = key->_M_dataplus._M_p;
  v6.first = this;
  tables = (const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *)file->tables_;
  v6.second = M_p;
  result = (const google::protobuf::FieldDescriptor *)std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                                                        tables + 1,
                                                        &v6)._M_cur;
  if ( result )
  {
    result = (const google::protobuf::FieldDescriptor *)result->camelcase_name_;
    if ( result )
    {
      if ( !result->is_extension_ )
        return 0LL;
    }
  }
  return result;
};

// Line 1553: range 000000000C8F4F60-000000000C8F4FA6
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::Descriptor::FindExtensionByCamelcaseName(
        const google::protobuf::Descriptor *const this,
        const std::string *key)
{
  const google::protobuf::FileDescriptor *file; // rax
  const char *M_p; // rdx
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *tables; // rax
  const google::protobuf::FieldDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v6; // [rsp+0h] [rbp-18h] BYREF

  file = this->file_;
  M_p = key->_M_dataplus._M_p;
  v6.first = this;
  tables = (const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *)file->tables_;
  v6.second = M_p;
  result = (const google::protobuf::FieldDescriptor *)std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                                                        tables + 2,
                                                        &v6)._M_cur;
  if ( result )
  {
    result = (const google::protobuf::FieldDescriptor *)result->camelcase_name_;
    if ( result )
    {
      if ( !result->is_extension_ )
        return 0LL;
    }
  }
  return result;
};

// Line 1564: range 000000000C8F4FB0-000000000C8F5063
const google::protobuf::Descriptor *__fastcall google::protobuf::Descriptor::FindNestedTypeByName(
        const google::protobuf::Descriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptor *file; // rax
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *p_M_h; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v7; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v8; // rax
  std::__detail::_Hash_node_base *v9; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::Descriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v12; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  file = this->file_;
  v12.first = this;
  p_M_h = &file->tables_->symbols_by_parent_._M_h;
  v5 = *M_p;
  v12.second = M_p;
  if ( (_BYTE)v5 )
  {
    v6 = 0LL;
    do
    {
      ++M_p;
      v6 = v5 + 5 * v6;
      v5 = *M_p;
    }
    while ( (_BYTE)v5 );
    v7 = 0xFFFFLL * (_QWORD)this + v6;
  }
  else
  {
    v7 = 0xFFFFLL * (_QWORD)this;
  }
  v8 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         p_M_h,
         v7 % p_M_h->_M_bucket_count,
         &v12,
         v7);
  if ( v8 && (v9 = v8->_M_nxt) != 0LL )
  {
    M_nxt = v9[3]._M_nxt;
    result = (const google::protobuf::Descriptor *)v9[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.descriptor;
  }
  if ( (_DWORD)M_nxt != 1 )
  {
    result = 0LL;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type )
      return google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.descriptor;
  }
  return result;
};

// Line 1575: range 000000000C8F5070-000000000C8F5123
const google::protobuf::EnumDescriptor *__fastcall google::protobuf::Descriptor::FindEnumTypeByName(
        const google::protobuf::Descriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptor *file; // rax
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *p_M_h; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v7; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v8; // rax
  std::__detail::_Hash_node_base *v9; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::EnumDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v12; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  file = this->file_;
  v12.first = this;
  p_M_h = &file->tables_->symbols_by_parent_._M_h;
  v5 = *M_p;
  v12.second = M_p;
  if ( (_BYTE)v5 )
  {
    v6 = 0LL;
    do
    {
      ++M_p;
      v6 = v5 + 5 * v6;
      v5 = *M_p;
    }
    while ( (_BYTE)v5 );
    v7 = 0xFFFFLL * (_QWORD)this + v6;
  }
  else
  {
    v7 = 0xFFFFLL * (_QWORD)this;
  }
  v8 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         p_M_h,
         v7 % p_M_h->_M_bucket_count,
         &v12,
         v7);
  if ( v8 && (v9 = v8->_M_nxt) != 0LL )
  {
    M_nxt = v9[3]._M_nxt;
    result = (const google::protobuf::EnumDescriptor *)v9[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.enum_descriptor;
  }
  if ( (_DWORD)M_nxt != 4 )
  {
    result = 0LL;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type )
      return google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.enum_descriptor;
  }
  return result;
};

// Line 1586: range 000000000C8F5130-000000000C8F51E3
const google::protobuf::EnumValueDescriptor *__fastcall google::protobuf::Descriptor::FindEnumValueByName(
        const google::protobuf::Descriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptor *file; // rax
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *p_M_h; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v7; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v8; // rax
  std::__detail::_Hash_node_base *v9; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::EnumValueDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v12; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  file = this->file_;
  v12.first = this;
  p_M_h = &file->tables_->symbols_by_parent_._M_h;
  v5 = *M_p;
  v12.second = M_p;
  if ( (_BYTE)v5 )
  {
    v6 = 0LL;
    do
    {
      ++M_p;
      v6 = v5 + 5 * v6;
      v5 = *M_p;
    }
    while ( (_BYTE)v5 );
    v7 = 0xFFFFLL * (_QWORD)this + v6;
  }
  else
  {
    v7 = 0xFFFFLL * (_QWORD)this;
  }
  v8 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         p_M_h,
         v7 % p_M_h->_M_bucket_count,
         &v12,
         v7);
  if ( v8 && (v9 = v8->_M_nxt) != 0LL )
  {
    M_nxt = v9[3]._M_nxt;
    result = (const google::protobuf::EnumValueDescriptor *)v9[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.enum_value_descriptor;
  }
  if ( (_DWORD)M_nxt != 5 )
  {
    result = 0LL;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type )
      return google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.enum_value_descriptor;
  }
  return result;
};

// Line 1597: range 000000000C8F51F0-000000000C8F52A3
const google::protobuf::EnumValueDescriptor *__fastcall google::protobuf::EnumDescriptor::FindValueByName(
        const google::protobuf::EnumDescriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptor *file; // rax
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *p_M_h; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v7; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v8; // rax
  std::__detail::_Hash_node_base *v9; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::EnumValueDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v12; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  file = this->file_;
  v12.first = this;
  p_M_h = &file->tables_->symbols_by_parent_._M_h;
  v5 = *M_p;
  v12.second = M_p;
  if ( (_BYTE)v5 )
  {
    v6 = 0LL;
    do
    {
      ++M_p;
      v6 = v5 + 5 * v6;
      v5 = *M_p;
    }
    while ( (_BYTE)v5 );
    v7 = 0xFFFFLL * (_QWORD)this + v6;
  }
  else
  {
    v7 = 0xFFFFLL * (_QWORD)this;
  }
  v8 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         p_M_h,
         v7 % p_M_h->_M_bucket_count,
         &v12,
         v7);
  if ( v8 && (v9 = v8->_M_nxt) != 0LL )
  {
    M_nxt = v9[3]._M_nxt;
    result = (const google::protobuf::EnumValueDescriptor *)v9[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.enum_value_descriptor;
  }
  if ( (_DWORD)M_nxt != 5 )
  {
    result = 0LL;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type )
      return google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.enum_value_descriptor;
  }
  return result;
};

// Line 1608: range 000000000C8F52B0-000000000C8F52E3
const google::protobuf::EnumValueDescriptor *__fastcall google::protobuf::EnumDescriptor::FindValueByNumber(
        const google::protobuf::EnumDescriptor *const this,
        int key)
{
  const google::protobuf::FileDescriptor *file; // rax
  const std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *tables; // rax
  const google::protobuf::EnumValueDescriptor *result; // rax
  const google::protobuf::EnumDescriptor *v5; // [rsp+0h] [rbp-18h] BYREF
  int keya; // [rsp+8h] [rbp-10h]

  file = this->file_;
  v5 = this;
  tables = (const std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *)file->tables_;
  keya = key;
  result = (const google::protobuf::EnumValueDescriptor *)std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                                                            tables + 4,
                                                            (const std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *)&v5)._M_cur;
  if ( result )
    return (const google::protobuf::EnumValueDescriptor *)result->type_;
  return result;
};

// Line 1613: range 000000000C8FFD50-000000000C90006B
google::protobuf::EnumDescriptor *__fastcall google::protobuf::EnumDescriptor::FindValueByNumberCreatingIfUnknown(
        google::protobuf::EnumDescriptor *this,
        int a2)
{
  const google::protobuf::FileDescriptorTables *tables; // r13
  std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v5; // rax
  google::protobuf::EnumDescriptor *first; // r12
  google::protobuf::internal::Mutex *p_unknown_enum_values_mu; // r14
  std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *p_M_h; // r13
  std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::iterator v10; // rax
  std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::iterator v11; // rax
  google::protobuf::DescriptorPool::Tables *ptr; // r15
  const google::protobuf::EnumDescriptor *v13; // rax
  void *const *v14; // rcx
  _QWORD *M_finish; // rsi
  const std::string *full_name; // rax
  __int64 v17; // rax
  std::string *String; // rax
  google::protobuf::EnumDescriptor *v19; // rdi
  google::protobuf::EnumValueOptions *M_p; // rdi
  std::string v21; // [rsp+0h] [rbp-98h] BYREF
  std::string v22; // [rsp+20h] [rbp-78h] BYREF
  std::_Hashtable<std::pair<const google::protobuf::EnumDescriptor*,int>,std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::EnumDescriptor*,int>,const google::protobuf::EnumValueDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::EnumDescriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::EnumDescriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type __k; // [rsp+40h] [rbp-58h] BYREF
  __int128 v24[4]; // [rsp+50h] [rbp-48h] BYREF

  tables = this->file_->tables_;
  __k.first = this;
  __k.second = a2;
  v5._M_cur = std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                &tables->enum_values_by_number_._M_h,
                &__k)._M_cur;
  if ( !v5._M_cur
    || (first = (google::protobuf::EnumDescriptor *)*((_QWORD *)&v5._M_cur->_M_storage._M_storage.1 + 2)) == 0LL )
  {
    p_unknown_enum_values_mu = &tables->unknown_enum_values_mu_;
    p_M_h = &tables->unknown_enum_values_by_number_._M_h;
    google::protobuf::internal::Mutex::Lock(p_unknown_enum_values_mu);
    __k.first = this;
    __k.second = a2;
    v10._M_cur = std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                   p_M_h,
                   &__k)._M_cur;
    if ( v10._M_cur
      && (first = (google::protobuf::EnumDescriptor *)*((_QWORD *)&v10._M_cur->_M_storage._M_storage.1 + 2)) != 0LL )
    {
      google::protobuf::internal::Mutex::Unlock(p_unknown_enum_values_mu);
    }
    else
    {
      google::protobuf::internal::Mutex::Unlock(p_unknown_enum_values_mu);
      google::protobuf::internal::Mutex::Lock(p_unknown_enum_values_mu);
      __k.second = a2;
      __k.first = this;
      v11._M_cur = std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                     p_M_h,
                     &__k)._M_cur;
      if ( !v11._M_cur
        || (first = (google::protobuf::EnumDescriptor *)*((_QWORD *)&v11._M_cur->_M_storage._M_storage.1 + 2)) == 0LL )
      {
        google::protobuf::StringPrintf[abi:cxx11](&v21, (char)v21._M_dataplus._M_p);
        if ( google::protobuf::`anonymous namespace'::generated_pool_init_ != 2 )
        {
          __k.first = (const google::protobuf::EnumDescriptor *)off_1A16E058;
          *(_QWORD *)&__k.second = google::protobuf::`anonymous namespace'::InitGeneratedPool;
          LOBYTE(v24[0]) = 0;
          google::protobuf::GoogleOnceInitImpl(
            &google::protobuf::`anonymous namespace'::generated_pool_init_,
            (google::protobuf::Closure *)&__k);
          google::protobuf::internal::FunctionClosure0::~FunctionClosure0((google::protobuf::internal::FunctionClosure0 *const)&__k);
        }
        ptr = google::protobuf::`anonymous namespace'::generated_pool_->tables_.ptr_;
        v13 = (const google::protobuf::EnumDescriptor *)operator new(0x28uLL);
        __k.first = v13;
        M_finish = ptr->allocations_._M_impl._M_finish;
        if ( M_finish == ptr->allocations_._M_impl._M_end_of_storage )
        {
          std::vector<void *>::_M_realloc_insert<void * const&>(
            &ptr->allocations_,
            (std::vector<void*>::iterator)M_finish,
            (void *const *)&__k,
            v14);
        }
        else
        {
          *M_finish = v13;
          ++ptr->allocations_._M_impl._M_finish;
        }
        first = (google::protobuf::EnumDescriptor *)__k.first;
        first->name_ = google::protobuf::DescriptorPool::Tables::AllocateString(
                         (std::vector<std::string*> *)ptr,
                         (__int64)&v21);
        full_name = this->full_name_;
        v22._M_dataplus._M_p = v22._anon_0._M_local_buf;
        std::string::_M_construct<char *>(
          &v22,
          full_name->_M_dataplus._M_p,
          &full_name->_M_dataplus._M_p[full_name->_M_string_length],
          (std::forward_iterator_tag)&v22._anon_0);
        if ( v22._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
          std::__throw_length_error("basic_string::append");
        std::string::_M_append(&v22, ".", 1LL);
        v17 = std::string::_M_append(&v22, v21._M_dataplus._M_p, v21._M_string_length);
        __k.first = (const google::protobuf::EnumDescriptor *)v24;
        if ( *(_QWORD *)v17 == v17 + 16 )
        {
          v24[0] = (__int128)_mm_loadu_si128((const __m128i *)(v17 + 16));
        }
        else
        {
          __k.first = *(const google::protobuf::EnumDescriptor **)v17;
          *(_QWORD *)&v24[0] = *(_QWORD *)(v17 + 16);
        }
        *(_QWORD *)&__k.second = *(_QWORD *)(v17 + 8);
        *(_QWORD *)v17 = v17 + 16;
        *(_QWORD *)(v17 + 8) = 0LL;
        *(_BYTE *)(v17 + 16) = 0;
        String = google::protobuf::DescriptorPool::Tables::AllocateString(
                   (std::vector<std::string*> *)ptr,
                   (__int64)&__k);
        v19 = (google::protobuf::EnumDescriptor *)__k.first;
        first->full_name_ = String;
        if ( v19 != (google::protobuf::EnumDescriptor *)v24 )
          operator delete(v19);
        M_p = (google::protobuf::EnumValueOptions *)v22._M_dataplus._M_p;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v22._M_dataplus._M_p != &v22._anon_0 )
          operator delete(v22._M_dataplus._M_p);
        LODWORD(first->file_) = a2;
        first->containing_type_ = (const google::protobuf::Descriptor *)this;
        first->options_ = (const google::protobuf::EnumOptions *)google::protobuf::EnumValueOptions::default_instance(M_p);
        __k.first = this;
        __k.second = a2;
        *(_QWORD *)&v24[0] = first;
        std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,true>>>>(
          p_M_h,
          &__k);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v21._M_dataplus._M_p != &v21._anon_0 )
          operator delete(v21._M_dataplus._M_p);
      }
      google::protobuf::internal::Mutex::Unlock(p_unknown_enum_values_mu);
    }
  }
  return first;
};

// Line 1618: range 000000000C8F52F0-000000000C8F53A3
const google::protobuf::MethodDescriptor *__fastcall google::protobuf::ServiceDescriptor::FindMethodByName(
        const google::protobuf::ServiceDescriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptor *file; // rax
  const std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *p_M_h; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v7; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v8; // rax
  std::__detail::_Hash_node_base *v9; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::MethodDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v12; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  file = this->file_;
  v12.first = this;
  p_M_h = &file->tables_->symbols_by_parent_._M_h;
  v5 = *M_p;
  v12.second = M_p;
  if ( (_BYTE)v5 )
  {
    v6 = 0LL;
    do
    {
      ++M_p;
      v6 = v5 + 5 * v6;
      v5 = *M_p;
    }
    while ( (_BYTE)v5 );
    v7 = 0xFFFFLL * (_QWORD)this + v6;
  }
  else
  {
    v7 = 0xFFFFLL * (_QWORD)this;
  }
  v8 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         p_M_h,
         v7 % p_M_h->_M_bucket_count,
         &v12,
         v7);
  if ( v8 && (v9 = v8->_M_nxt) != 0LL )
  {
    M_nxt = v9[3]._M_nxt;
    result = (const google::protobuf::MethodDescriptor *)v9[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.method_descriptor;
  }
  if ( (_DWORD)M_nxt != 7 )
  {
    result = 0LL;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type )
      return google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.method_descriptor;
  }
  return result;
};

// Line 1629: range 000000000C8F53B0-000000000C8F5463
const google::protobuf::Descriptor *__fastcall google::protobuf::FileDescriptor::FindMessageTypeByName(
        const google::protobuf::FileDescriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptorTables *tables; // r8
  __int64 v4; // rax
  __int64 v5; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v7; // rax
  std::__detail::_Hash_node_base *v8; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::Descriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v11; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  tables = this->tables_;
  v11.first = this;
  v4 = *M_p;
  v11.second = M_p;
  if ( (_BYTE)v4 )
  {
    v5 = 0LL;
    do
    {
      ++M_p;
      v5 = v4 + 5 * v5;
      v4 = *M_p;
    }
    while ( (_BYTE)v4 );
    v6 = 0xFFFFLL * (_QWORD)this + v5;
  }
  else
  {
    v6 = 0xFFFFLL * (_QWORD)this;
  }
  v7 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         &tables->symbols_by_parent_._M_h,
         v6 % tables->symbols_by_parent_._M_h._M_bucket_count,
         &v11,
         v6);
  if ( v7 && (v8 = v7->_M_nxt) != 0LL )
  {
    M_nxt = v8[3]._M_nxt;
    result = (const google::protobuf::Descriptor *)v8[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.descriptor;
  }
  if ( (_DWORD)M_nxt != 1 )
  {
    result = 0LL;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type )
      return google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.descriptor;
  }
  return result;
};

// Line 1639: range 000000000C8F5470-000000000C8F5523
const google::protobuf::EnumDescriptor *__fastcall google::protobuf::FileDescriptor::FindEnumTypeByName(
        const google::protobuf::FileDescriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptorTables *tables; // r8
  __int64 v4; // rax
  __int64 v5; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v7; // rax
  std::__detail::_Hash_node_base *v8; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::EnumDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v11; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  tables = this->tables_;
  v11.first = this;
  v4 = *M_p;
  v11.second = M_p;
  if ( (_BYTE)v4 )
  {
    v5 = 0LL;
    do
    {
      ++M_p;
      v5 = v4 + 5 * v5;
      v4 = *M_p;
    }
    while ( (_BYTE)v4 );
    v6 = 0xFFFFLL * (_QWORD)this + v5;
  }
  else
  {
    v6 = 0xFFFFLL * (_QWORD)this;
  }
  v7 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         &tables->symbols_by_parent_._M_h,
         v6 % tables->symbols_by_parent_._M_h._M_bucket_count,
         &v11,
         v6);
  if ( v7 && (v8 = v7->_M_nxt) != 0LL )
  {
    M_nxt = v8[3]._M_nxt;
    result = (const google::protobuf::EnumDescriptor *)v8[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.enum_descriptor;
  }
  if ( (_DWORD)M_nxt != 4 )
  {
    result = 0LL;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type )
      return google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.enum_descriptor;
  }
  return result;
};

// Line 1649: range 000000000C8F5530-000000000C8F55E3
const google::protobuf::EnumValueDescriptor *__fastcall google::protobuf::FileDescriptor::FindEnumValueByName(
        const google::protobuf::FileDescriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptorTables *tables; // r8
  __int64 v4; // rax
  __int64 v5; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v7; // rax
  std::__detail::_Hash_node_base *v8; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::EnumValueDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v11; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  tables = this->tables_;
  v11.first = this;
  v4 = *M_p;
  v11.second = M_p;
  if ( (_BYTE)v4 )
  {
    v5 = 0LL;
    do
    {
      ++M_p;
      v5 = v4 + 5 * v5;
      v4 = *M_p;
    }
    while ( (_BYTE)v4 );
    v6 = 0xFFFFLL * (_QWORD)this + v5;
  }
  else
  {
    v6 = 0xFFFFLL * (_QWORD)this;
  }
  v7 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         &tables->symbols_by_parent_._M_h,
         v6 % tables->symbols_by_parent_._M_h._M_bucket_count,
         &v11,
         v6);
  if ( v7 && (v8 = v7->_M_nxt) != 0LL )
  {
    M_nxt = v8[3]._M_nxt;
    result = (const google::protobuf::EnumValueDescriptor *)v8[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.enum_value_descriptor;
  }
  if ( (_DWORD)M_nxt != 5 )
  {
    result = 0LL;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type )
      return google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.enum_value_descriptor;
  }
  return result;
};

// Line 1660: range 000000000C8F55F0-000000000C8F56A3
const google::protobuf::ServiceDescriptor *__fastcall google::protobuf::FileDescriptor::FindServiceByName(
        const google::protobuf::FileDescriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptorTables *tables; // r8
  __int64 v4; // rax
  __int64 v5; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v7; // rax
  std::__detail::_Hash_node_base *v8; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::ServiceDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v11; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  tables = this->tables_;
  v11.first = this;
  v4 = *M_p;
  v11.second = M_p;
  if ( (_BYTE)v4 )
  {
    v5 = 0LL;
    do
    {
      ++M_p;
      v5 = v4 + 5 * v5;
      v4 = *M_p;
    }
    while ( (_BYTE)v4 );
    v6 = 0xFFFFLL * (_QWORD)this + v5;
  }
  else
  {
    v6 = 0xFFFFLL * (_QWORD)this;
  }
  v7 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         &tables->symbols_by_parent_._M_h,
         v6 % tables->symbols_by_parent_._M_h._M_bucket_count,
         &v11,
         v6);
  if ( v7 && (v8 = v7->_M_nxt) != 0LL )
  {
    M_nxt = v8[3]._M_nxt;
    result = (const google::protobuf::ServiceDescriptor *)v8[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.service_descriptor;
  }
  if ( (_DWORD)M_nxt != 6 )
  {
    result = 0LL;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type )
      return google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.service_descriptor;
  }
  return result;
};

// Line 1670: range 000000000C8F56B0-000000000C8F5763
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::FileDescriptor::FindExtensionByName(
        const google::protobuf::FileDescriptor *const this,
        const std::string *key)
{
  const char *M_p; // rdx
  const google::protobuf::FileDescriptorTables *tables; // r8
  __int64 v4; // rax
  __int64 v5; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v6; // rcx
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v7; // rax
  std::__detail::_Hash_node_base *v8; // rax
  std::__detail::_Hash_node_base *M_nxt; // rdx
  const google::protobuf::FieldDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v11; // [rsp+0h] [rbp-18h] BYREF

  M_p = key->_M_dataplus._M_p;
  tables = this->tables_;
  v11.first = this;
  v4 = *M_p;
  v11.second = M_p;
  if ( (_BYTE)v4 )
  {
    v5 = 0LL;
    do
    {
      ++M_p;
      v5 = v4 + 5 * v5;
      v4 = *M_p;
    }
    while ( (_BYTE)v4 );
    v6 = 0xFFFFLL * (_QWORD)this + v5;
  }
  else
  {
    v6 = 0xFFFFLL * (_QWORD)this;
  }
  v7 = std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
         &tables->symbols_by_parent_._M_h,
         v6 % tables->symbols_by_parent_._M_h._M_bucket_count,
         &v11,
         v6);
  if ( v7 && (v8 = v7->_M_nxt) != 0LL )
  {
    M_nxt = v8[3]._M_nxt;
    result = (const google::protobuf::FieldDescriptor *)v8[4]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.field_descriptor;
  }
  if ( (_DWORD)M_nxt != 2 )
  {
    result = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.field_descriptor;
    if ( google::protobuf::`anonymous namespace'::kNullSymbol.type == NULL_SYMBOL )
      return 0LL;
  }
  if ( !result->is_extension_ )
    return 0LL;
  return result;
};

// Line 1680: range 000000000C8F5770-000000000C8F57B2
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::FileDescriptor::FindExtensionByLowercaseName(
        const google::protobuf::FileDescriptor *const this,
        const std::string *key)
{
  const google::protobuf::FileDescriptorTables *tables; // rax
  const char *M_p; // rdx
  const google::protobuf::FieldDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v5; // [rsp+0h] [rbp-18h] BYREF

  tables = this->tables_;
  M_p = key->_M_dataplus._M_p;
  v5.first = this;
  v5.second = M_p;
  result = (const google::protobuf::FieldDescriptor *)std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                                                        &tables->fields_by_lowercase_name_._M_h,
                                                        &v5)._M_cur;
  if ( result )
  {
    result = (const google::protobuf::FieldDescriptor *)result->camelcase_name_;
    if ( result )
    {
      if ( !result->is_extension_ )
        return 0LL;
    }
  }
  return result;
};

// Line 1690: range 000000000C8F57C0-000000000C8F5802
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::FileDescriptor::FindExtensionByCamelcaseName(
        const google::protobuf::FileDescriptor *const this,
        const std::string *key)
{
  const google::protobuf::FileDescriptorTables *tables; // rax
  const char *M_p; // rdx
  const google::protobuf::FieldDescriptor *result; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<void const*,char const*>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type v5; // [rsp+0h] [rbp-18h] BYREF

  tables = this->tables_;
  M_p = key->_M_dataplus._M_p;
  v5.first = this;
  v5.second = M_p;
  result = (const google::protobuf::FieldDescriptor *)std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                                                        &tables->fields_by_camelcase_name_._M_h,
                                                        &v5)._M_cur;
  if ( result )
  {
    result = (const google::protobuf::FieldDescriptor *)result->camelcase_name_;
    if ( result )
    {
      if ( !result->is_extension_ )
        return 0LL;
    }
  }
  return result;
};

// Line 1703: range 000000000C8F5810-000000000C8F584B
const google::protobuf::Descriptor::ExtensionRange *__fastcall google::protobuf::Descriptor::FindExtensionRangeContainingNumber(
        const google::protobuf::Descriptor *const this,
        int number)
{
  int extension_range_count; // edx
  google::protobuf::Descriptor::ExtensionRange *extension_ranges; // rax
  __int64 v4; // rdx
  const google::protobuf::Descriptor::ExtensionRange *v5; // r8

  extension_range_count = this->extension_range_count_;
  if ( extension_range_count <= 0 )
    return 0LL;
  extension_ranges = this->extension_ranges_;
  v4 = (__int64)&extension_ranges[(unsigned int)(extension_range_count - 1) + 1];
  while ( 1 )
  {
    v5 = extension_ranges;
    if ( extension_ranges->start <= number && extension_ranges->end > number )
      break;
    if ( ++extension_ranges == (google::protobuf::Descriptor::ExtensionRange *)v4 )
      return 0LL;
  }
  return v5;
};

// Line 1715: range 000000000C8F5850-000000000C8F588B
const google::protobuf::Descriptor::ReservedRange *__fastcall google::protobuf::Descriptor::FindReservedRangeContainingNumber(
        const google::protobuf::Descriptor *const this,
        int number)
{
  int reserved_range_count; // edx
  google::protobuf::Descriptor::ReservedRange *reserved_ranges; // rax
  __int64 v4; // rdx
  const google::protobuf::Descriptor::ReservedRange *v5; // r8

  reserved_range_count = this->reserved_range_count_;
  if ( reserved_range_count <= 0 )
    return 0LL;
  reserved_ranges = this->reserved_ranges_;
  v4 = (__int64)&reserved_ranges[(unsigned int)(reserved_range_count - 1) + 1];
  while ( 1 )
  {
    v5 = reserved_ranges;
    if ( reserved_ranges->start <= number && reserved_ranges->end > number )
      break;
    if ( ++reserved_ranges == (google::protobuf::Descriptor::ReservedRange *)v4 )
      return 0LL;
  }
  return v5;
};

// Line 1726: range 000000000C912E70-000000000C912F49
__int64 __fastcall google::protobuf::DescriptorPool::TryFindFileInFallbackDatabase(
        google::protobuf::DescriptorPool *this,
        std::string *__v)
{
  unsigned int v3; // r12d
  std::true_type v4; // [rsp+0h] [rbp-108h]
  std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::string,true> > > __node_gen; // [rsp+8h] [rbp-100h] BYREF
  google::protobuf::FileDescriptorProto proto; // [rsp+10h] [rbp-F8h] BYREF

  if ( !this->fallback_database_ )
    return 0LL;
  if ( std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::count(
         &this->tables_.ptr_->known_bad_files_._M_h,
         __v) )
  {
    return 0LL;
  }
  google::protobuf::FileDescriptorProto::FileDescriptorProto(&proto);
  v3 = (*((__int64 (__fastcall **)(google::protobuf::DescriptorDatabase *, std::string *, google::protobuf::FileDescriptorProto *))this->fallback_database_->_vptr_DescriptorDatabase
        + 2))(
         this->fallback_database_,
         __v,
         &proto);
  if ( (_BYTE)v3 && google::protobuf::DescriptorPool::BuildFileFromDatabase(this, &proto) )
  {
    google::protobuf::FileDescriptorProto::~FileDescriptorProto(&proto);
  }
  else
  {
    __node_gen._M_h = (std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::string,true> > >::__hashtable_alloc *)&this->tables_.ptr_->known_bad_files_;
    std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::_M_insert<std::string const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::string,true>>>>(
      (std::_Hashtable<std::string,std::string,std::allocator<std::string >,std::__detail::_Identity,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true> > *const)__node_gen._M_h,
      __v,
      &__node_gen,
      v4,
      1uLL);
    v3 = 0;
    google::protobuf::FileDescriptorProto::~FileDescriptorProto(&proto);
  }
  return v3;
};

// Line 1740: range 000000000C900E20-000000000C90105C
__int64 __fastcall google::protobuf::DescriptorPool::IsSubSymbolOfBuiltType(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        std::forward_iterator_tag a4)
{
  char *v6; // rsi
  char *v7; // rdx
  std::string::size_type M_string_length; // rax
  std::forward_iterator_tag v9; // cl
  std::string::$CFBEC286C7F52157F7E59FC354047095 *M_p; // rdi
  std::string::size_type v11; // rdx
  std::string::size_type M_allocated_capacity; // rsi
  std::string *v13; // r13
  __int64 v14; // rsi
  __int64 v15; // rax
  std::string::pointer v16; // rdx
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v17; // rcx
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v18; // rax
  std::__detail::_Hash_node_base *v19; // rax
  std::__detail::_Hash_node_base *M_nxt; // rax
  unsigned int v21; // r12d
  __int64 v22; // rdi
  unsigned int IsSubSymbolOfBuiltType; // eax
  std::string __beg; // [rsp+0h] [rbp-68h] BYREF
  std::string src; // [rsp+20h] [rbp-48h] BYREF

  v6 = *(char **)a2;
  v7 = &v6[*(_QWORD *)(a2 + 8)];
  __beg._M_dataplus._M_p = __beg._anon_0._M_local_buf;
  std::string::_M_construct<char *>(&__beg, v6, v7, a4);
  while ( 1 )
  {
    M_string_length = std::string::rfind(&__beg, 46LL, -1LL);
    if ( M_string_length == -1LL )
      break;
    src._M_dataplus._M_p = src._anon_0._M_local_buf;
    if ( M_string_length > __beg._M_string_length )
      M_string_length = __beg._M_string_length;
    std::string::_M_construct<char const*>(&src, __beg._M_dataplus._M_p, &__beg._M_dataplus._M_p[M_string_length], v9);
    M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__beg._M_dataplus._M_p;
    v11 = src._M_string_length;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)src._M_dataplus._M_p == &src._anon_0 )
    {
      if ( src._M_string_length )
      {
        if ( src._M_string_length == 1 )
          *__beg._M_dataplus._M_p = src._anon_0._M_local_buf[0];
        else
          memcpy(__beg._M_dataplus._M_p, &src._anon_0, src._M_string_length);
        v11 = src._M_string_length;
        M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__beg._M_dataplus._M_p;
      }
      __beg._M_string_length = v11;
      M_p->_M_local_buf[v11] = 0;
      M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)src._M_dataplus._M_p;
      goto LABEL_9;
    }
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__beg._M_dataplus._M_p == &__beg._anon_0 )
    {
      __beg._M_dataplus._M_p = src._M_dataplus._M_p;
      __beg._M_string_length = src._M_string_length;
      __beg._anon_0._M_allocated_capacity = src._anon_0._M_allocated_capacity;
LABEL_26:
      src._M_dataplus._M_p = src._anon_0._M_local_buf;
      M_p = &src._anon_0;
      goto LABEL_9;
    }
    M_allocated_capacity = __beg._anon_0._M_allocated_capacity;
    __beg._M_dataplus._M_p = src._M_dataplus._M_p;
    __beg._M_string_length = src._M_string_length;
    __beg._anon_0._M_allocated_capacity = src._anon_0._M_allocated_capacity;
    if ( !M_p )
      goto LABEL_26;
    src._M_dataplus._M_p = (std::string::pointer)M_p;
    src._anon_0._M_allocated_capacity = M_allocated_capacity;
LABEL_9:
    src._M_string_length = 0LL;
    M_p->_M_local_buf[0] = 0;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)src._M_dataplus._M_p != &src._anon_0 )
      operator delete(src._M_dataplus._M_p);
    v13 = (std::string *)__beg._M_dataplus._M_p;
    v14 = *(_QWORD *)(a1 + 32);
    src._M_dataplus._M_p = __beg._M_dataplus._M_p;
    v15 = *__beg._M_dataplus._M_p;
    if ( (_BYTE)v15 )
    {
      v16 = __beg._M_dataplus._M_p;
      v17 = 0LL;
      do
      {
        ++v16;
        v17 = v15 + 5 * v17;
        v15 = *v16;
      }
      while ( (_BYTE)v15 );
    }
    else
    {
      v17 = 0LL;
    }
    v18 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
            (const std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *const)(v14 + 312),
            v17 % *(_QWORD *)(v14 + 320),
            (const std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *)&src._M_dataplus._M_p,
            v17);
    if ( v18 && (v19 = v18->_M_nxt) != 0LL )
      M_nxt = v19[2]._M_nxt;
    else
      LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    if ( ((unsigned int)M_nxt & 0xFFFFFFF7) != 0 )
    {
      v21 = 1;
      goto LABEL_30;
    }
  }
  v22 = *(_QWORD *)(a1 + 24);
  if ( v22 )
  {
    IsSubSymbolOfBuiltType = google::protobuf::DescriptorPool::IsSubSymbolOfBuiltType(v22, a2);
    v13 = (std::string *)__beg._M_dataplus._M_p;
    v21 = IsSubSymbolOfBuiltType;
  }
  else
  {
    v13 = (std::string *)__beg._M_dataplus._M_p;
    v21 = 0;
  }
LABEL_30:
  if ( v13 != (std::string *)&__beg._anon_0 )
    operator delete(v13);
  return v21;
};

// Line 1767: range 000000000C730116-000000000C730123
void __fastcall __noreturn google::protobuf::DescriptorPool::TryFindSymbolInFallbackDatabase(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::FileDescriptorProto a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::FileDescriptorProto::~FileDescriptorProto(&a8);
  _Unwind_Resume(v8);
};

// Line 1804: range 000000000C916990-000000000C916A55
__int64 __fastcall google::protobuf::DescriptorPool::TryFindExtensionInFallbackDatabase(
        google::protobuf::DescriptorPool *this,
        const google::protobuf::Descriptor *a2,
        unsigned int a3)
{
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v5; // rax
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type __k; // [rsp+8h] [rbp-100h] BYREF
  google::protobuf::FileDescriptorProto proto; // [rsp+10h] [rbp-F8h] BYREF

  if ( !this->fallback_database_ )
    return 0LL;
  google::protobuf::FileDescriptorProto::FileDescriptorProto(&proto);
  if ( !(*((unsigned __int8 (__fastcall **)(google::protobuf::DescriptorDatabase *, const std::string *, _QWORD, google::protobuf::FileDescriptorProto *))this->fallback_database_->_vptr_DescriptorDatabase
         + 4))(
          this->fallback_database_,
          a2->full_name_,
          a3,
          &proto)
    || (__k = proto.name_.ptr_->_M_dataplus._M_p,
        (v5._M_cur = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                       &this->tables_.ptr_->files_by_name_._M_h,
                       &__k)._M_cur) != 0LL)
    && *((_QWORD *)&v5._M_cur->_M_storage._M_storage.1 + 1) )
  {
    a3 = 0;
  }
  else
  {
    LOBYTE(a3) = google::protobuf::DescriptorPool::BuildFileFromDatabase(this, &proto) != 0;
  }
  google::protobuf::FileDescriptorProto::~FileDescriptorProto(&proto);
  return a3;
};

// Line 1807: range 000000000C7305EA-000000000C7305F7
void __fastcall __noreturn google::protobuf::DescriptorPool::TryFindExtensionInFallbackDatabase(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::FileDescriptorProto a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::FileDescriptorProto::~FileDescriptorProto(&a8);
  _Unwind_Resume(v8);
};

// Line 1829: range 000000000C8F5890-000000000C8F5975
_BOOL8 __fastcall google::protobuf::FieldDescriptor::is_map(google::protobuf::FieldDescriptor *this)
{
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  google::protobuf::GoogleOnceDynamic *v4; // rdi
  google::protobuf::Closure v5; // [rsp+0h] [rbp-38h] BYREF
  void (__fastcall *v6)(const google::protobuf::FieldDescriptor *); // [rsp+8h] [rbp-30h]
  char v7; // [rsp+10h] [rbp-28h]
  google::protobuf::FieldDescriptor *v8; // [rsp+18h] [rbp-20h]

  type_once = this->type_once_;
  if ( type_once )
  {
    if ( type_once->state_ == 2 )
    {
      if ( this->type_ != TYPE_MESSAGE_0 )
        return 0LL;
    }
    else
    {
      v5._vptr_Closure = (int (**)(...))&off_1A17BF90;
      v7 = 0;
      v6 = google::protobuf::FieldDescriptor::TypeOnceInit;
      v8 = this;
      google::protobuf::GoogleOnceInitImpl(&type_once->state_, &v5);
      v5._vptr_Closure = (int (**)(...))&off_1A17BF90;
      google::protobuf::Closure::~Closure(&v5);
      if ( this->type_ != TYPE_MESSAGE_0 )
        return 0LL;
    }
    v4 = this->type_once_;
    if ( v4 )
    {
      if ( v4->state_ != 2 )
      {
        v5._vptr_Closure = (int (**)(...))&off_1A17BF90;
        v7 = 0;
        v6 = google::protobuf::FieldDescriptor::TypeOnceInit;
        v8 = this;
        google::protobuf::GoogleOnceInitImpl(&v4->state_, &v5);
        v5._vptr_Closure = (int (**)(...))&off_1A17BF90;
        google::protobuf::Closure::~Closure(&v5);
      }
    }
  }
  else if ( this->type_ != TYPE_MESSAGE_0 )
  {
    return 0LL;
  }
  return this->message_type_->options_->map_entry_;
};

// Line 1833: range 000000000C8FAB00-000000000C8FAFD7
std::string *__fastcall google::protobuf::FieldDescriptor::DefaultValueAsString[abi:cxx11](
        std::string *dest,
        __int64 a2,
        char a3,
        std::forward_iterator_tag a4)
{
  google::protobuf::ProtobufOnceType *v6; // rdi
  int v7; // edx
  google::protobuf::internal::LogMessage_0 *v8; // rax
  google::protobuf::internal::LogMessage_0 *v9; // rax
  google::protobuf::internal::LogMessage_0 *v10; // rax
  google::protobuf::internal::LogMessage_0 *v11; // rax
  std::forward_iterator_tag v12; // cl
  const char *v14; // rbp
  size_t v15; // rax
  std::forward_iterator_tag v16; // cl
  google::protobuf::ProtobufOnceType *v17; // rdi
  __int64 v18; // rax
  google::protobuf::ProtobufOnceType *v19; // rdi
  __int64 v20; // rsi
  __int64 v21; // rdx
  __int64 v22; // rax
  __int64 v23; // rax
  std::string::size_type v24; // rcx
  std::string v25; // [rsp+0h] [rbp-88h] BYREF
  google::protobuf::internal::LogMessage_0 closure; // [rsp+20h] [rbp-68h] BYREF

  if ( !*(_BYTE *)(a2 + 64) )
  {
    google::protobuf::internal::LogMessage::LogMessage(
      &closure,
      LOGLEVEL_FATAL_0,
      "google/protobuf/descriptor.cc",
      1834);
    v8 = google::protobuf::internal::LogMessage::operator<<(&closure, "CHECK failed: has_default_value(): ");
    v9 = google::protobuf::internal::LogMessage::operator<<(v8, "No default value");
    google::protobuf::internal::LogFinisher::operator=((google::protobuf::internal::LogFinisher *const)&v25, v9);
    google::protobuf::internal::LogMessage::~LogMessage(&closure);
  }
  v6 = *(google::protobuf::ProtobufOnceType **)(a2 + 48);
  if ( v6 && *v6 != 2 )
  {
    LOBYTE(closure.line_) = 0;
    closure.message_._M_dataplus._M_p = (std::string::pointer)a2;
    *(_QWORD *)&closure.level_ = &off_1A17BF90;
    closure.filename_ = (const char *)google::protobuf::FieldDescriptor::TypeOnceInit;
    google::protobuf::GoogleOnceInitImpl(v6, (google::protobuf::Closure *)&closure);
    *(_QWORD *)&closure.level_ = &off_1A17BF90;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&closure);
  }
  v7 = *(_DWORD *)(a2 + 56);
  switch ( v7 )
  {
    case 1:
      google::protobuf::SimpleDtoa[abi:cxx11](dest);
      break;
    case 2:
      google::protobuf::SimpleFtoa[abi:cxx11](dest);
      break;
    case 3:
    case 16:
    case 18:
      google::protobuf::SimpleItoa[abi:cxx11](dest, *(_QWORD *)(a2 + 144));
      break;
    case 4:
    case 6:
      google::protobuf::SimpleItoa[abi:cxx11](dest, *(_QWORD *)(a2 + 144));
      break;
    case 5:
    case 15:
    case 17:
      google::protobuf::SimpleItoa[abi:cxx11](dest, *(_DWORD *)(a2 + 144));
      break;
    case 7:
    case 13:
      google::protobuf::SimpleItoa[abi:cxx11](dest, *(_DWORD *)(a2 + 144));
      break;
    case 8:
      v14 = "true";
      if ( !*(_BYTE *)(a2 + 144) )
        v14 = "false";
      dest->_M_dataplus._M_p = dest->_anon_0._M_local_buf;
      v15 = strlen(v14);
      std::string::_M_construct<char const*>(dest, v14, &v14[v15], v16);
      break;
    case 9:
    case 12:
      if ( a3 )
      {
        google::protobuf::CEscape(&v25);
        v22 = std::string::_M_replace(&v25, 0LL, 0LL, "\"", 1LL);
        *(_QWORD *)&closure.level_ = &closure.line_;
        if ( *(_QWORD *)v22 == v22 + 16 )
        {
          *(__m128i *)&closure.line_ = _mm_loadu_si128((const __m128i *)(v22 + 16));
        }
        else
        {
          *(_QWORD *)&closure.level_ = *(_QWORD *)v22;
          *(_QWORD *)&closure.line_ = *(_QWORD *)(v22 + 16);
        }
        closure.filename_ = *(const char **)(v22 + 8);
        *(_QWORD *)v22 = v22 + 16;
        *(_QWORD *)(v22 + 8) = 0LL;
        *(_BYTE *)(v22 + 16) = 0;
        if ( closure.filename_ == (const char *)0x3FFFFFFFFFFFFFFFLL )
          std::__throw_length_error("basic_string::append");
        v23 = std::string::_M_append(&closure, "\"", 1LL);
        dest->_M_dataplus._M_p = dest->_anon_0._M_local_buf;
        if ( *(_QWORD *)v23 == v23 + 16 )
        {
          dest->_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v23 + 16));
        }
        else
        {
          dest->_M_dataplus._M_p = *(std::string::pointer *)v23;
          dest->_anon_0._M_allocated_capacity = *(_QWORD *)(v23 + 16);
        }
        v24 = *(_QWORD *)(v23 + 8);
        *(_QWORD *)v23 = v23 + 16;
        *(_QWORD *)(v23 + 8) = 0LL;
        dest->_M_string_length = v24;
        *(_BYTE *)(v23 + 16) = 0;
        if ( *(google::protobuf::internal::LogMessage_0 **)&closure.level_ != (google::protobuf::internal::LogMessage_0 *)&closure.line_ )
          operator delete(*(void **)&closure.level_);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v25._M_dataplus._M_p != &v25._anon_0 )
          operator delete(v25._M_dataplus._M_p);
      }
      else
      {
        v19 = *(google::protobuf::ProtobufOnceType **)(a2 + 48);
        if ( v19 )
        {
          if ( *v19 != 2 )
          {
            LOBYTE(closure.line_) = 0;
            closure.message_._M_dataplus._M_p = (std::string::pointer)a2;
            *(_QWORD *)&closure.level_ = &off_1A17BF90;
            closure.filename_ = (const char *)google::protobuf::FieldDescriptor::TypeOnceInit;
            google::protobuf::GoogleOnceInitImpl(v19, (google::protobuf::Closure *)&closure);
            *(_QWORD *)&closure.level_ = &off_1A17BF90;
            google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&closure);
          }
          v7 = *(_DWORD *)(a2 + 56);
        }
        v20 = *(_QWORD *)(a2 + 144);
        if ( v7 == 12 )
        {
          google::protobuf::CEscape(dest);
        }
        else
        {
          v21 = *(_QWORD *)(v20 + 8);
          dest->_M_dataplus._M_p = dest->_anon_0._M_local_buf;
          std::string::_M_construct<char *>(dest, *(char **)v20, (char *)(*(_QWORD *)v20 + v21), a4);
        }
      }
      break;
    case 10:
    case 11:
      google::protobuf::internal::LogMessage::LogMessage(
        &closure,
        LOGLEVEL_ERROR_0,
        "google/protobuf/descriptor.cc",
        1872);
      v10 = google::protobuf::internal::LogMessage::operator<<(&closure, "Messages can't have default values!");
      google::protobuf::internal::LogFinisher::operator=((google::protobuf::internal::LogFinisher *const)&v25, v10);
      google::protobuf::internal::LogMessage::~LogMessage(&closure);
      goto LABEL_8;
    case 14:
      v17 = *(google::protobuf::ProtobufOnceType **)(a2 + 48);
      if ( v17 && *v17 != 2 )
      {
        LOBYTE(closure.line_) = 0;
        closure.message_._M_dataplus._M_p = (std::string::pointer)a2;
        *(_QWORD *)&closure.level_ = &off_1A17BF90;
        closure.filename_ = (const char *)google::protobuf::FieldDescriptor::TypeOnceInit;
        google::protobuf::GoogleOnceInitImpl(v17, (google::protobuf::Closure *)&closure);
        *(_QWORD *)&closure.level_ = &off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&closure);
      }
      v18 = **(_QWORD **)(a2 + 144);
      dest->_M_dataplus._M_p = dest->_anon_0._M_local_buf;
      std::string::_M_construct<char *>(dest, *(char **)v18, (char *)(*(_QWORD *)v18 + *(_QWORD *)(v18 + 8)), a4);
      break;
    default:
LABEL_8:
      google::protobuf::internal::LogMessage::LogMessage(
        &closure,
        LOGLEVEL_FATAL_0,
        "google/protobuf/descriptor.cc",
        1875);
      v11 = google::protobuf::internal::LogMessage::operator<<(
              &closure,
              "Can't get here: failed to get default value as string");
      google::protobuf::internal::LogFinisher::operator=((google::protobuf::internal::LogFinisher *const)&v25, v11);
      google::protobuf::internal::LogMessage::~LogMessage(&closure);
      dest->_M_dataplus._M_p = dest->_anon_0._M_local_buf;
      std::string::_M_construct<char const*>(dest, &off_1B23A528[4], &off_1B23A528[4], v12);
      break;
  }
  return dest;
};

// Line 1834: range 000000000C72DEBA-000000000C72DEC5
void __fastcall __noreturn google::protobuf::FieldDescriptor::DefaultValueAsString[abi:cxx11]()
{
  google::protobuf::internal::LogMessage_0 *v0; // rbp
  struct _Unwind_Exception *v1; // r12

  google::protobuf::internal::LogMessage::~LogMessage(v0);
  _Unwind_Resume(v1);
};

// Line 1881: range 000000000C8FD470-000000000C8FDDDE
void __fastcall google::protobuf::FileDescriptor::CopyTo(
        google::protobuf::FileDescriptor *this,
        google::protobuf::FileDescriptorProto *a2)
{
  const std::string *name; // rsi
  std::string *ptr; // rdi
  const std::string *package; // rsi
  __int64 v7; // r12
  _QWORD *v8; // rdi
  google::protobuf::GoogleOnceDynamic *dependencies_once; // rdi
  const std::string *v10; // r13
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *rep; // rax
  __int64 current_size; // rcx
  int allocated_size; // edx
  int total_size; // esi
  google::protobuf::Arena *arena; // rdi
  _BYTE *AlignedAndAddCleanup; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v17; // rdx
  __int64 v18; // rax
  int v19; // eax
  __int64 v20; // r12
  google::protobuf::RepeatedField<int>::Rep *v21; // rdx
  __int64 v22; // rsi
  int v23; // r13d
  google::protobuf::FileOptions *weak_dependency_count; // rdi
  int v25; // eax
  __int64 v26; // r12
  google::protobuf::RepeatedField<int>::Rep *v27; // rdx
  __int64 v28; // rsi
  int v29; // r13d
  __int64 v30; // r13
  google::protobuf::DescriptorProto *v31; // r14
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v32; // rax
  google::protobuf::Descriptor *v33; // r12
  __int64 v34; // rcx
  int v35; // edx
  int v36; // esi
  google::protobuf::Arena *v37; // rdi
  __int64 v38; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v39; // rdx
  __int64 v40; // r14
  int v41; // r13d
  google::protobuf::EnumDescriptorProto *v42; // r12
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v43; // rax
  google::protobuf::EnumDescriptor *v44; // r15
  __int64 v45; // rcx
  int v46; // edx
  int v47; // esi
  google::protobuf::Arena *v48; // rdi
  __int64 v49; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v50; // rdx
  __int64 v51; // r13
  google::protobuf::ServiceDescriptorProto *v52; // r14
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v53; // rax
  google::protobuf::ServiceDescriptor *v54; // r12
  __int64 v55; // rcx
  int v56; // edx
  int v57; // esi
  google::protobuf::Arena *v58; // rdi
  __int64 v59; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v60; // rdx
  __int64 v61; // r14
  int v62; // r13d
  google::protobuf::FieldDescriptorProto *v63; // r12
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v64; // rax
  google::protobuf::FieldDescriptor *v65; // r15
  __int64 v66; // rcx
  int v67; // edx
  int v68; // esi
  google::protobuf::Arena *v69; // rdi
  __int64 v70; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v71; // rdx
  const google::protobuf::FileOptions *options; // r12
  google::protobuf::FileOptions *v73; // r12
  std::string *v74; // rdi
  const char *v75; // rax
  std::forward_iterator_tag v76; // cl
  __int64 v77; // rdx
  const char *v78; // r12
  std::string *v79; // r12
  std::string::$CFBEC286C7F52157F7E59FC354047095 *M_p; // rdi
  std::string::size_type v81; // rdx
  std::string::size_type M_allocated_capacity; // rcx
  __int64 v83; // rax
  std::string::size_type M_string_length; // rdx
  std::string closure[2]; // [rsp+10h] [rbp-58h] BYREF

  name = this->name_;
  ptr = a2->name_.ptr_;
  a2->_has_bits_.has_bits_[0] |= 1u;
  if ( ptr == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
    google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&a2->name_.ptr_, (__int64)name);
  else
    std::string::_M_assign(ptr, name);
  package = this->package_;
  if ( !package->_M_string_length )
  {
LABEL_4:
    if ( this->syntax_ != SYNTAX_PROTO3 )
      goto LABEL_5;
    goto LABEL_100;
  }
  v74 = a2->package_.ptr_;
  a2->_has_bits_.has_bits_[0] |= 2u;
  if ( v74 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
  {
    google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&a2->package_.ptr_, (__int64)package);
    goto LABEL_4;
  }
  std::string::_M_assign(v74, package);
  if ( this->syntax_ != SYNTAX_PROTO3 )
    goto LABEL_5;
LABEL_100:
  v75 = google::protobuf::FileDescriptor::SyntaxName(
          (google::protobuf::FileDescriptor *)3,
          (google::protobuf::FileDescriptor::Syntax)package);
  a2->_has_bits_.has_bits_[0] |= 4u;
  v77 = -1LL;
  closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
  v78 = v75;
  if ( v75 )
    v77 = (__int64)&v75[strlen(v75)];
  std::string::_M_construct<char const*>(closure, v78, (const char *)v77, v76);
  v79 = a2->syntax_.ptr_;
  if ( v79 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
  {
    v83 = operator new(0x20uLL);
    *(_QWORD *)v83 = v83 + 16;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p == &closure[0]._anon_0 )
    {
      *(__m128i *)(v83 + 16) = _mm_load_si128((const __m128i *)&closure[0]._anon_0);
    }
    else
    {
      *(_QWORD *)v83 = closure[0]._M_dataplus._M_p;
      *(_QWORD *)(v83 + 16) = closure[0]._anon_0._M_allocated_capacity;
    }
    M_string_length = closure[0]._M_string_length;
    a2->syntax_.ptr_ = (std::string *)v83;
    *(_QWORD *)(v83 + 8) = M_string_length;
    goto LABEL_5;
  }
  M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v79->_M_dataplus._M_p;
  v81 = closure[0]._M_string_length;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p == &closure[0]._anon_0 )
  {
    if ( closure[0]._M_string_length )
    {
      if ( closure[0]._M_string_length == 1 )
        M_p->_M_local_buf[0] = closure[0]._anon_0._M_local_buf[0];
      else
        memcpy(M_p, &closure[0]._anon_0, closure[0]._M_string_length);
      v81 = closure[0]._M_string_length;
      M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v79->_M_dataplus._M_p;
    }
    v79->_M_string_length = v81;
    M_p->_M_local_buf[v81] = 0;
    M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p;
    goto LABEL_107;
  }
  if ( M_p == &v79->_anon_0 )
  {
    v79->_M_dataplus._M_p = closure[0]._M_dataplus._M_p;
    v79->_M_string_length = v81;
    v79->_anon_0._M_allocated_capacity = closure[0]._anon_0._M_allocated_capacity;
  }
  else
  {
    v79->_M_dataplus._M_p = closure[0]._M_dataplus._M_p;
    M_allocated_capacity = v79->_anon_0._M_allocated_capacity;
    v79->_M_string_length = v81;
    v79->_anon_0._M_allocated_capacity = closure[0]._anon_0._M_allocated_capacity;
    if ( M_p )
    {
      closure[0]._M_dataplus._M_p = (std::string::pointer)M_p;
      closure[0]._anon_0._M_allocated_capacity = M_allocated_capacity;
      goto LABEL_107;
    }
  }
  closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
  M_p = &closure[0]._anon_0;
LABEL_107:
  closure[0]._M_string_length = 0LL;
  M_p->_M_local_buf[0] = 0;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p != &closure[0]._anon_0 )
    operator delete(closure[0]._M_dataplus._M_p);
LABEL_5:
  v7 = 0LL;
  if ( this->dependency_count_ > 0 )
  {
    while ( 1 )
    {
      dependencies_once = this->dependencies_once_;
      if ( dependencies_once && dependencies_once->state_ != 2 )
      {
        closure[0]._anon_0._M_local_buf[0] = 0;
        closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFB8;
        closure[0]._M_string_length = (std::string::size_type)google::protobuf::FileDescriptor::DependenciesOnceInit;
        *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
        google::protobuf::GoogleOnceInitImpl(&dependencies_once->state_, (google::protobuf::Closure *)closure);
        closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFB8;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
      }
      v10 = this->dependencies_[v7]->name_;
      rep = a2->dependency_.rep_;
      if ( !rep )
        break;
      current_size = a2->dependency_.current_size_;
      allocated_size = rep->allocated_size;
      if ( (int)current_size >= rep->allocated_size )
      {
        total_size = a2->dependency_.total_size_;
        if ( allocated_size != total_size )
        {
          arena = a2->dependency_.arena_;
          rep->allocated_size = allocated_size + 1;
          if ( arena )
            goto LABEL_16;
LABEL_22:
          AlignedAndAddCleanup = (_BYTE *)operator new(0x20uLL);
          goto LABEL_19;
        }
LABEL_21:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->dependency_, total_size + 1);
        arena = a2->dependency_.arena_;
        ++a2->dependency_.rep_->allocated_size;
        if ( !arena )
          goto LABEL_22;
LABEL_16:
        if ( arena->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(arena, (const std::type_info *)&`typeinfo for'std::string, 0x20uLL);
        AlignedAndAddCleanup = google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                 &arena->impl_,
                                 0x20uLL,
                                 google::protobuf::internal::arena_destruct_object<std::string>);
LABEL_19:
        v8 = AlignedAndAddCleanup;
        AlignedAndAddCleanup[16] = 0;
        v17 = a2->dependency_.rep_;
        *(_QWORD *)AlignedAndAddCleanup = AlignedAndAddCleanup + 16;
        v18 = a2->dependency_.current_size_;
        v8[1] = 0LL;
        a2->dependency_.current_size_ = v18 + 1;
        v17->elements[v18] = v8;
        goto LABEL_8;
      }
      v8 = rep->elements[current_size];
      a2->dependency_.current_size_ = current_size + 1;
LABEL_8:
      ++v7;
      std::string::_M_assign(v8, v10);
      if ( this->dependency_count_ <= (int)v7 )
        goto LABEL_23;
    }
    total_size = a2->dependency_.total_size_;
    goto LABEL_21;
  }
LABEL_23:
  if ( this->public_dependency_count_ > 0 )
  {
    v19 = a2->public_dependency_.current_size_;
    v20 = 0LL;
    do
    {
      v22 = v19;
      v23 = this->public_dependencies_[v20];
      if ( v19 == a2->public_dependency_.total_size_ )
      {
        google::protobuf::RepeatedField<int>::Reserve(&a2->public_dependency_, v19 + 1);
        v22 = a2->public_dependency_.current_size_;
      }
      v21 = a2->public_dependency_.rep_;
      v19 = v22 + 1;
      ++v20;
      a2->public_dependency_.current_size_ = v22 + 1;
      v21->elements[v22] = v23;
    }
    while ( this->public_dependency_count_ > (int)v20 );
  }
  weak_dependency_count = (google::protobuf::FileOptions *)(unsigned int)this->weak_dependency_count_;
  if ( (int)weak_dependency_count > 0 )
  {
    v25 = a2->weak_dependency_.current_size_;
    v26 = 0LL;
    do
    {
      v28 = v25;
      v29 = this->weak_dependencies_[v26];
      if ( v25 == a2->weak_dependency_.total_size_ )
      {
        weak_dependency_count = (google::protobuf::FileOptions *)&a2->weak_dependency_;
        google::protobuf::RepeatedField<int>::Reserve(&a2->weak_dependency_, v25 + 1);
        v28 = a2->weak_dependency_.current_size_;
      }
      v27 = a2->weak_dependency_.rep_;
      v25 = v28 + 1;
      ++v26;
      a2->weak_dependency_.current_size_ = v28 + 1;
      v27->elements[v28] = v29;
    }
    while ( this->weak_dependency_count_ > (int)v26 );
  }
  v30 = 0LL;
  if ( this->message_type_count_ > 0 )
  {
    while ( 1 )
    {
      v32 = a2->message_type_.rep_;
      v33 = &this->message_types_[v30];
      if ( !v32 )
        break;
      v34 = a2->message_type_.current_size_;
      v35 = v32->allocated_size;
      if ( (int)v34 >= v32->allocated_size )
      {
        v36 = a2->message_type_.total_size_;
        if ( v35 != v36 )
        {
          v37 = a2->message_type_.arena_;
          v32->allocated_size = v35 + 1;
          if ( v37 )
            goto LABEL_41;
LABEL_47:
          v31 = (google::protobuf::DescriptorProto *)operator new(0xE8uLL);
          google::protobuf::DescriptorProto::DescriptorProto(v31);
          goto LABEL_44;
        }
LABEL_46:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->message_type_, v36 + 1);
        v37 = a2->message_type_.arena_;
        ++a2->message_type_.rep_->allocated_size;
        if ( !v37 )
          goto LABEL_47;
LABEL_41:
        if ( v37->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            v37,
            (const std::type_info *)&`typeinfo for'google::protobuf::DescriptorProto,
            0xE8uLL);
        v31 = (google::protobuf::DescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                     &v37->impl_,
                                                     0xE8uLL,
                                                     google::protobuf::internal::arena_destruct_object<google::protobuf::DescriptorProto>);
        google::protobuf::DescriptorProto::DescriptorProto(v31);
LABEL_44:
        v38 = a2->message_type_.current_size_;
        v39 = a2->message_type_.rep_;
        a2->message_type_.current_size_ = v38 + 1;
        v39->elements[v38] = v31;
        goto LABEL_36;
      }
      v31 = (google::protobuf::DescriptorProto *)v32->elements[v34];
      a2->message_type_.current_size_ = v34 + 1;
LABEL_36:
      weak_dependency_count = (google::protobuf::FileOptions *)v33;
      ++v30;
      google::protobuf::Descriptor::CopyTo(v33, v31);
      if ( this->message_type_count_ <= (int)v30 )
        goto LABEL_48;
    }
    v36 = a2->message_type_.total_size_;
    goto LABEL_46;
  }
LABEL_48:
  v40 = 0LL;
  v41 = 0;
  if ( this->enum_type_count_ > 0 )
  {
    while ( 1 )
    {
      v43 = a2->enum_type_.rep_;
      v44 = &this->enum_types_[v40];
      if ( !v43 )
        break;
      v45 = a2->enum_type_.current_size_;
      v46 = v43->allocated_size;
      if ( (int)v45 >= v43->allocated_size )
      {
        v47 = a2->enum_type_.total_size_;
        if ( v46 != v47 )
        {
          v48 = a2->enum_type_.arena_;
          v43->allocated_size = v46 + 1;
          if ( v48 )
            goto LABEL_56;
LABEL_62:
          v42 = (google::protobuf::EnumDescriptorProto *)operator new(0x40uLL);
          google::protobuf::EnumDescriptorProto::EnumDescriptorProto(v42);
          goto LABEL_59;
        }
LABEL_61:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->enum_type_, v47 + 1);
        v48 = a2->enum_type_.arena_;
        ++a2->enum_type_.rep_->allocated_size;
        if ( !v48 )
          goto LABEL_62;
LABEL_56:
        if ( v48->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            v48,
            (const std::type_info *)&`typeinfo for'google::protobuf::EnumDescriptorProto,
            0x40uLL);
        v42 = (google::protobuf::EnumDescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                         &v48->impl_,
                                                         0x40uLL,
                                                         google::protobuf::internal::arena_destruct_object<google::protobuf::EnumDescriptorProto>);
        google::protobuf::EnumDescriptorProto::EnumDescriptorProto(v42);
LABEL_59:
        v49 = a2->enum_type_.current_size_;
        v50 = a2->enum_type_.rep_;
        a2->enum_type_.current_size_ = v49 + 1;
        v50->elements[v49] = v42;
        goto LABEL_51;
      }
      v42 = (google::protobuf::EnumDescriptorProto *)v43->elements[v45];
      a2->enum_type_.current_size_ = v45 + 1;
LABEL_51:
      weak_dependency_count = (google::protobuf::FileOptions *)v44;
      ++v41;
      ++v40;
      google::protobuf::EnumDescriptor::CopyTo(v44, v42);
      if ( v41 >= this->enum_type_count_ )
        goto LABEL_63;
    }
    v47 = a2->enum_type_.total_size_;
    goto LABEL_61;
  }
LABEL_63:
  v51 = 0LL;
  if ( this->service_count_ > 0 )
  {
    while ( 1 )
    {
      v53 = a2->service_.rep_;
      v54 = &this->services_[v51];
      if ( !v53 )
        break;
      v55 = a2->service_.current_size_;
      v56 = v53->allocated_size;
      if ( (int)v55 >= v53->allocated_size )
      {
        v57 = a2->service_.total_size_;
        if ( v56 != v57 )
        {
          v58 = a2->service_.arena_;
          v53->allocated_size = v56 + 1;
          if ( v58 )
            goto LABEL_71;
LABEL_77:
          v52 = (google::protobuf::ServiceDescriptorProto *)operator new(0x40uLL);
          google::protobuf::ServiceDescriptorProto::ServiceDescriptorProto(v52);
          goto LABEL_74;
        }
LABEL_76:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->service_, v57 + 1);
        v58 = a2->service_.arena_;
        ++a2->service_.rep_->allocated_size;
        if ( !v58 )
          goto LABEL_77;
LABEL_71:
        if ( v58->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            v58,
            (const std::type_info *)&`typeinfo for'google::protobuf::ServiceDescriptorProto,
            0x40uLL);
        v52 = (google::protobuf::ServiceDescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                            &v58->impl_,
                                                            0x40uLL,
                                                            google::protobuf::internal::arena_destruct_object<google::protobuf::ServiceDescriptorProto>);
        google::protobuf::ServiceDescriptorProto::ServiceDescriptorProto(v52);
LABEL_74:
        v59 = a2->service_.current_size_;
        v60 = a2->service_.rep_;
        a2->service_.current_size_ = v59 + 1;
        v60->elements[v59] = v52;
        goto LABEL_66;
      }
      v52 = (google::protobuf::ServiceDescriptorProto *)v53->elements[v55];
      a2->service_.current_size_ = v55 + 1;
LABEL_66:
      weak_dependency_count = (google::protobuf::FileOptions *)v54;
      ++v51;
      google::protobuf::ServiceDescriptor::CopyTo(v54, v52);
      if ( this->service_count_ <= (int)v51 )
        goto LABEL_78;
    }
    v57 = a2->service_.total_size_;
    goto LABEL_76;
  }
LABEL_78:
  v61 = 0LL;
  v62 = 0;
  if ( this->extension_count_ > 0 )
  {
    while ( 1 )
    {
      v64 = a2->extension_.rep_;
      v65 = &this->extensions_[v61];
      if ( !v64 )
        break;
      v66 = a2->extension_.current_size_;
      v67 = v64->allocated_size;
      if ( (int)v66 >= v64->allocated_size )
      {
        v68 = a2->extension_.total_size_;
        if ( v67 != v68 )
        {
          v69 = a2->extension_.arena_;
          v64->allocated_size = v67 + 1;
          if ( v69 )
            goto LABEL_86;
LABEL_92:
          v63 = (google::protobuf::FieldDescriptorProto *)operator new(0x58uLL);
          google::protobuf::FieldDescriptorProto::FieldDescriptorProto(v63);
          goto LABEL_89;
        }
LABEL_91:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->extension_, v68 + 1);
        v69 = a2->extension_.arena_;
        ++a2->extension_.rep_->allocated_size;
        if ( !v69 )
          goto LABEL_92;
LABEL_86:
        if ( v69->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            v69,
            (const std::type_info *)&`typeinfo for'google::protobuf::FieldDescriptorProto,
            0x58uLL);
        v63 = (google::protobuf::FieldDescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                          &v69->impl_,
                                                          0x58uLL,
                                                          google::protobuf::internal::arena_destruct_object<google::protobuf::FieldDescriptorProto>);
        google::protobuf::FieldDescriptorProto::FieldDescriptorProto(v63);
LABEL_89:
        v70 = a2->extension_.current_size_;
        v71 = a2->extension_.rep_;
        a2->extension_.current_size_ = v70 + 1;
        v71->elements[v70] = v63;
        goto LABEL_81;
      }
      v63 = (google::protobuf::FieldDescriptorProto *)v64->elements[v66];
      a2->extension_.current_size_ = v66 + 1;
LABEL_81:
      weak_dependency_count = (google::protobuf::FileOptions *)v65;
      ++v62;
      ++v61;
      google::protobuf::FieldDescriptor::CopyTo(v65, v63);
      if ( v62 >= this->extension_count_ )
        goto LABEL_93;
    }
    v68 = a2->extension_.total_size_;
    goto LABEL_91;
  }
LABEL_93:
  options = this->options_;
  if ( options != (const google::protobuf::FileOptions *)google::protobuf::FileOptions::default_instance(weak_dependency_count) )
  {
    v73 = a2->options_;
    a2->_has_bits_.has_bits_[0] |= 8u;
    if ( !v73 )
    {
      v73 = (google::protobuf::FileOptions *)operator new(0xB8uLL);
      google::protobuf::FileOptions::FileOptions(v73);
      a2->options_ = v73;
    }
    google::protobuf::FileOptions::CopyFrom(v73, this->options_);
  }
};

// Line 1917: range 000000000C8FB320-000000000C8FB42A
void __fastcall google::protobuf::FileDescriptor::CopyJsonNameTo(
        google::protobuf::FileDescriptor *this,
        google::protobuf::FileDescriptorProto *a2)
{
  int message_type_count; // eax
  int extension_count; // edx
  google::protobuf::internal::LogMessage_0 *v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rdi
  __int64 v10; // r13
  int v11; // ebx
  void *v12; // rdi
  google::protobuf::internal::ExplicitlyConstructed<std::string > *v13; // r8
  const std::string *json_name; // rsi
  google::protobuf::internal::LogFinisher v15; // [rsp+Fh] [rbp-69h] BYREF
  google::protobuf::internal::LogMessage_0 v16; // [rsp+10h] [rbp-68h] BYREF

  message_type_count = this->message_type_count_;
  if ( a2->message_type_.current_size_ == message_type_count
    && (extension_count = this->extension_count_, a2->extension_.current_size_ == extension_count) )
  {
    v7 = 0LL;
    if ( message_type_count > 0 )
    {
      do
      {
        v8 = (int)v7;
        v9 = v7++;
        google::protobuf::Descriptor::CopyJsonNameTo(
          &this->message_types_[v9],
          (google::protobuf::DescriptorProto *)a2->message_type_.rep_->elements[v8]);
      }
      while ( this->message_type_count_ > (int)v7 );
      extension_count = this->extension_count_;
    }
    v10 = 0LL;
    v11 = 0;
    if ( extension_count > 0 )
    {
      do
      {
        v12 = a2->extension_.rep_->elements[v11];
        v13 = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)*((_QWORD *)v12 + 7);
        json_name = this->extensions_[v10].json_name_;
        *((_DWORD *)v12 + 4) |= 0x10u;
        if ( v13 == &google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
          google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena((std::string **)v12 + 7, (__int64)json_name);
        else
          std::string::_M_assign(v13, json_name);
        ++v11;
        ++v10;
      }
      while ( v11 < this->extension_count_ );
    }
  }
  else
  {
    google::protobuf::internal::LogMessage::LogMessage(&v16, LOGLEVEL_ERROR_0, "google/protobuf/descriptor.cc", 1920);
    v6 = google::protobuf::internal::LogMessage::operator<<(
           &v16,
           "Cannot copy json_name to a proto of a different size.");
    google::protobuf::internal::LogFinisher::operator=(&v15, v6);
    google::protobuf::internal::LogMessage::~LogMessage(&v16);
  }
};

// Line 1920: range 000000000C72DFB4-000000000C72DFC1
void __fastcall __noreturn google::protobuf::FileDescriptor::CopyJsonNameTo(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 1931: range 000000000C8F5980-000000000C8F59F1
void __fastcall google::protobuf::FileDescriptor::CopySourceCodeInfoTo(
        google::protobuf::FileDescriptor *this,
        google::protobuf::FileDescriptorProto *a2)
{
  const google::protobuf::SourceCodeInfo *source_code_info; // r12
  google::protobuf::SourceCodeInfo *v3; // r12

  source_code_info = this->source_code_info_;
  if ( source_code_info
    && source_code_info != (const google::protobuf::SourceCodeInfo *)google::protobuf::SourceCodeInfo::default_instance((google::protobuf::SourceCodeInfo *)this) )
  {
    v3 = a2->source_code_info_;
    a2->_has_bits_.has_bits_[0] |= 0x10u;
    if ( !v3 )
    {
      v3 = (google::protobuf::SourceCodeInfo *)operator new(0x30uLL);
      google::protobuf::SourceCodeInfo::SourceCodeInfo(v3);
      a2->source_code_info_ = v3;
    }
    google::protobuf::SourceCodeInfo::CopyFrom(v3, this->source_code_info_);
  }
};

// Line 1938: range 000000000C8FC9B0-000000000C8FD45F
void __fastcall google::protobuf::Descriptor::CopyTo(
        google::protobuf::Descriptor *this,
        google::protobuf::DescriptorProto *a2)
{
  const std::string *name; // rsi
  std::string *ptr; // rdi
  __int64 v6; // r14
  int v7; // r13d
  google::protobuf::FieldDescriptorProto *AlignedAndAddCleanup; // r12
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *rep; // rax
  google::protobuf::FieldDescriptor *v10; // r15
  __int64 current_size; // rcx
  int allocated_size; // edx
  int total_size; // esi
  google::protobuf::Arena *arena; // rdi
  __int64 v15; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v16; // rdx
  __int64 v17; // r13
  google::protobuf::OneofDescriptorProto *v18; // r14
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v19; // rax
  google::protobuf::OneofDescriptor *v20; // r12
  __int64 v21; // rcx
  int v22; // edx
  int v23; // esi
  google::protobuf::Arena *v24; // rdi
  __int64 v25; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v26; // rdx
  __int64 v27; // r13
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v28; // rax
  google::protobuf::Descriptor *v29; // r12
  __int64 v30; // rcx
  int v31; // edx
  google::protobuf::DescriptorProto *v32; // r14
  unsigned __int64 enum_type_count; // rdi
  __int64 v34; // r14
  int v35; // r13d
  google::protobuf::EnumDescriptorProto *v36; // r12
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v37; // rax
  google::protobuf::EnumDescriptor *v38; // r15
  __int64 v39; // rcx
  int v40; // edx
  int v41; // esi
  google::protobuf::Arena *v42; // rdi
  __int64 v43; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v44; // rdx
  int v45; // esi
  google::protobuf::Arena *v46; // rdi
  __int64 v47; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v48; // rdx
  __int64 v49; // r13
  google::protobuf::DescriptorProto_ExtensionRange *v50; // r12
  google::protobuf::Descriptor::ExtensionRange *v51; // rax
  int start; // ecx
  google::protobuf::uint32 v53; // esi
  const google::protobuf::ExtensionRangeOptions *options; // r14
  int end; // ecx
  google::protobuf::ExtensionRangeOptions *v56; // r15
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v57; // rax
  __int64 v58; // rcx
  int v59; // edx
  int v60; // esi
  google::protobuf::Arena *v61; // rdi
  __int64 v62; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v63; // rdx
  __int64 v64; // r14
  int v65; // r13d
  google::protobuf::FieldDescriptorProto *v66; // r12
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v67; // rax
  google::protobuf::FieldDescriptor *v68; // r15
  __int64 v69; // rcx
  int v70; // edx
  int v71; // esi
  google::protobuf::Arena *v72; // rdi
  __int64 v73; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v74; // rdx
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v75; // rdx
  __int64 v76; // r13
  google::protobuf::DescriptorProto_ReservedRange *v77; // r12
  google::protobuf::Descriptor::ReservedRange *v78; // rcx
  google::protobuf::uint32 v79; // edi
  int v80; // eax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v81; // rdi
  __int64 v82; // rcx
  int v83; // eax
  int v84; // esi
  google::protobuf::Arena *v85; // rdi
  __int64 v86; // rax
  __int64 v87; // r12
  const std::string *v88; // r14
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v89; // rax
  __int64 v90; // rcx
  int v91; // edx
  int v92; // esi
  google::protobuf::Arena *v93; // rdi
  google::protobuf::DescriptorProto_ExtensionRange *v94; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v95; // rdx
  __int64 v96; // rax
  const google::protobuf::MessageOptions *v97; // r12
  google::protobuf::MessageOptions *v98; // r12
  google::protobuf::Arena *v99; // [rsp+0h] [rbp-48h]

  name = this->name_;
  ptr = a2->name_.ptr_;
  a2->_has_bits_.has_bits_[0] |= 1u;
  if ( ptr == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
    google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&a2->name_.ptr_, (__int64)name);
  else
    std::string::_M_assign(ptr, name);
  v6 = 0LL;
  v7 = 0;
  if ( this->field_count_ > 0 )
  {
    while ( 1 )
    {
      rep = a2->field_.rep_;
      v10 = &this->fields_[v6];
      if ( !rep )
        break;
      current_size = a2->field_.current_size_;
      allocated_size = rep->allocated_size;
      if ( (int)current_size >= rep->allocated_size )
      {
        total_size = a2->field_.total_size_;
        if ( allocated_size != total_size )
        {
          arena = a2->field_.arena_;
          rep->allocated_size = allocated_size + 1;
          if ( arena )
            goto LABEL_11;
LABEL_17:
          AlignedAndAddCleanup = (google::protobuf::FieldDescriptorProto *)operator new(0x58uLL);
          google::protobuf::FieldDescriptorProto::FieldDescriptorProto(AlignedAndAddCleanup);
          goto LABEL_14;
        }
LABEL_16:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->field_, total_size + 1);
        arena = a2->field_.arena_;
        ++a2->field_.rep_->allocated_size;
        if ( !arena )
          goto LABEL_17;
LABEL_11:
        if ( arena->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            arena,
            (const std::type_info *)&`typeinfo for'google::protobuf::FieldDescriptorProto,
            0x58uLL);
        AlignedAndAddCleanup = (google::protobuf::FieldDescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                                           &arena->impl_,
                                                                           0x58uLL,
                                                                           google::protobuf::internal::arena_destruct_object<google::protobuf::FieldDescriptorProto>);
        google::protobuf::FieldDescriptorProto::FieldDescriptorProto(AlignedAndAddCleanup);
LABEL_14:
        v15 = a2->field_.current_size_;
        v16 = a2->field_.rep_;
        a2->field_.current_size_ = v15 + 1;
        v16->elements[v15] = AlignedAndAddCleanup;
        goto LABEL_6;
      }
      AlignedAndAddCleanup = (google::protobuf::FieldDescriptorProto *)rep->elements[current_size];
      a2->field_.current_size_ = current_size + 1;
LABEL_6:
      ++v7;
      ++v6;
      google::protobuf::FieldDescriptor::CopyTo(v10, AlignedAndAddCleanup);
      if ( v7 >= this->field_count_ )
        goto LABEL_18;
    }
    total_size = a2->field_.total_size_;
    goto LABEL_16;
  }
LABEL_18:
  v17 = 0LL;
  if ( this->oneof_decl_count_ > 0 )
  {
    while ( 1 )
    {
      v19 = a2->oneof_decl_.rep_;
      v20 = &this->oneof_decls_[v17];
      if ( !v19 )
        break;
      v21 = a2->oneof_decl_.current_size_;
      v22 = v19->allocated_size;
      if ( (int)v21 >= v19->allocated_size )
      {
        v23 = a2->oneof_decl_.total_size_;
        if ( v22 != v23 )
        {
LABEL_25:
          v24 = a2->oneof_decl_.arena_;
          v19->allocated_size = v22 + 1;
          if ( v24 )
          {
            if ( v24->hooks_cookie_ )
              google::protobuf::Arena::OnArenaAllocation(
                v24,
                (const std::type_info *)&`typeinfo for'google::protobuf::OneofDescriptorProto,
                0x28uLL);
            v18 = (google::protobuf::OneofDescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                              &v24->impl_,
                                                              0x28uLL,
                                                              google::protobuf::internal::arena_destruct_object<google::protobuf::OneofDescriptorProto>);
            google::protobuf::OneofDescriptorProto::OneofDescriptorProto(v18);
          }
          else
          {
            v18 = (google::protobuf::OneofDescriptorProto *)operator new(0x28uLL);
            google::protobuf::OneofDescriptorProto::OneofDescriptorProto(v18);
          }
          v25 = a2->oneof_decl_.current_size_;
          v26 = a2->oneof_decl_.rep_;
          a2->oneof_decl_.current_size_ = v25 + 1;
          v26->elements[v25] = v18;
          goto LABEL_21;
        }
LABEL_31:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->oneof_decl_, v23 + 1);
        v19 = a2->oneof_decl_.rep_;
        v22 = v19->allocated_size;
        goto LABEL_25;
      }
      v18 = (google::protobuf::OneofDescriptorProto *)v19->elements[v21];
      a2->oneof_decl_.current_size_ = v21 + 1;
LABEL_21:
      ++v17;
      google::protobuf::OneofDescriptor::CopyTo(v20, v18);
      if ( this->oneof_decl_count_ <= (int)v17 )
        goto LABEL_33;
    }
    v23 = a2->oneof_decl_.total_size_;
    goto LABEL_31;
  }
LABEL_33:
  v27 = 0LL;
  if ( this->nested_type_count_ > 0 )
  {
    while ( 1 )
    {
      v28 = a2->nested_type_.rep_;
      v29 = &this->nested_types_[v27];
      if ( !v28 )
        break;
      v30 = a2->nested_type_.current_size_;
      v31 = v28->allocated_size;
      if ( (int)v30 >= v28->allocated_size )
      {
        v45 = a2->nested_type_.total_size_;
        if ( v31 != v45 )
        {
          v46 = a2->nested_type_.arena_;
          v28->allocated_size = v31 + 1;
          if ( v46 )
            goto LABEL_55;
LABEL_61:
          v32 = (google::protobuf::DescriptorProto *)operator new(0xE8uLL);
          google::protobuf::DescriptorProto::DescriptorProto(v32);
          goto LABEL_58;
        }
LABEL_60:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->nested_type_, v45 + 1);
        v46 = a2->nested_type_.arena_;
        ++a2->nested_type_.rep_->allocated_size;
        if ( !v46 )
          goto LABEL_61;
LABEL_55:
        if ( v46->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            v46,
            (const std::type_info *)&`typeinfo for'google::protobuf::DescriptorProto,
            0xE8uLL);
        v32 = (google::protobuf::DescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                     &v46->impl_,
                                                     0xE8uLL,
                                                     google::protobuf::internal::arena_destruct_object<google::protobuf::DescriptorProto>);
        google::protobuf::DescriptorProto::DescriptorProto(v32);
LABEL_58:
        v47 = a2->nested_type_.current_size_;
        v48 = a2->nested_type_.rep_;
        a2->nested_type_.current_size_ = v47 + 1;
        v48->elements[v47] = v32;
        goto LABEL_37;
      }
      v32 = (google::protobuf::DescriptorProto *)v28->elements[v30];
      a2->nested_type_.current_size_ = v30 + 1;
LABEL_37:
      ++v27;
      google::protobuf::Descriptor::CopyTo(v29, v32);
      if ( this->nested_type_count_ <= (int)v27 )
        goto LABEL_38;
    }
    v45 = a2->nested_type_.total_size_;
    goto LABEL_60;
  }
LABEL_38:
  enum_type_count = (unsigned int)this->enum_type_count_;
  v34 = 0LL;
  v35 = 0;
  if ( (int)enum_type_count > 0 )
  {
    while ( 1 )
    {
      v37 = a2->enum_type_.rep_;
      v38 = &this->enum_types_[v34];
      if ( !v37 )
        break;
      v39 = a2->enum_type_.current_size_;
      v40 = v37->allocated_size;
      if ( (int)v39 >= v37->allocated_size )
      {
        v41 = a2->enum_type_.total_size_;
        if ( v40 != v41 )
        {
          v42 = a2->enum_type_.arena_;
          v37->allocated_size = v40 + 1;
          if ( v42 )
            goto LABEL_46;
LABEL_52:
          v36 = (google::protobuf::EnumDescriptorProto *)operator new(0x40uLL);
          google::protobuf::EnumDescriptorProto::EnumDescriptorProto(v36);
          goto LABEL_49;
        }
LABEL_51:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->enum_type_, v41 + 1);
        v42 = a2->enum_type_.arena_;
        ++a2->enum_type_.rep_->allocated_size;
        if ( !v42 )
          goto LABEL_52;
LABEL_46:
        if ( v42->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            v42,
            (const std::type_info *)&`typeinfo for'google::protobuf::EnumDescriptorProto,
            0x40uLL);
        v36 = (google::protobuf::EnumDescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                         &v42->impl_,
                                                         0x40uLL,
                                                         google::protobuf::internal::arena_destruct_object<google::protobuf::EnumDescriptorProto>);
        google::protobuf::EnumDescriptorProto::EnumDescriptorProto(v36);
LABEL_49:
        v43 = a2->enum_type_.current_size_;
        v44 = a2->enum_type_.rep_;
        a2->enum_type_.current_size_ = v43 + 1;
        v44->elements[v43] = v36;
        goto LABEL_41;
      }
      v36 = (google::protobuf::EnumDescriptorProto *)v37->elements[v39];
      a2->enum_type_.current_size_ = v39 + 1;
LABEL_41:
      enum_type_count = (unsigned __int64)v38;
      ++v35;
      ++v34;
      google::protobuf::EnumDescriptor::CopyTo(v38, v36);
      if ( v35 >= this->enum_type_count_ )
        goto LABEL_62;
    }
    v41 = a2->enum_type_.total_size_;
    goto LABEL_51;
  }
LABEL_62:
  v49 = 0LL;
  if ( this->extension_range_count_ > 0 )
  {
    while ( 1 )
    {
      v57 = a2->extension_range_.rep_;
      if ( !v57 )
        break;
      v58 = a2->extension_range_.current_size_;
      v59 = v57->allocated_size;
      if ( (int)v58 >= v57->allocated_size )
      {
        v60 = a2->extension_range_.total_size_;
        if ( v59 != v60 )
        {
          v61 = a2->extension_range_.arena_;
          v57->allocated_size = v59 + 1;
          if ( v61 )
            goto LABEL_74;
LABEL_80:
          enum_type_count = operator new(0x28uLL);
          v50 = (google::protobuf::DescriptorProto_ExtensionRange *)enum_type_count;
          google::protobuf::DescriptorProto_ExtensionRange::DescriptorProto_ExtensionRange((google::protobuf::DescriptorProto_ExtensionRange *)enum_type_count);
          goto LABEL_77;
        }
LABEL_79:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->extension_range_, v60 + 1);
        v61 = a2->extension_range_.arena_;
        ++a2->extension_range_.rep_->allocated_size;
        if ( !v61 )
          goto LABEL_80;
LABEL_74:
        if ( v61->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            v61,
            (const std::type_info *)&`typeinfo for'google::protobuf::DescriptorProto_ExtensionRange,
            0x28uLL);
        enum_type_count = (unsigned __int64)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                              &v61->impl_,
                                              0x28uLL,
                                              google::protobuf::internal::arena_destruct_object<google::protobuf::DescriptorProto_ExtensionRange>);
        v50 = (google::protobuf::DescriptorProto_ExtensionRange *)enum_type_count;
        google::protobuf::DescriptorProto_ExtensionRange::DescriptorProto_ExtensionRange((google::protobuf::DescriptorProto_ExtensionRange *)enum_type_count);
LABEL_77:
        v62 = a2->extension_range_.current_size_;
        v63 = a2->extension_range_.rep_;
        a2->extension_range_.current_size_ = v62 + 1;
        v63->elements[v62] = v50;
        goto LABEL_65;
      }
      v50 = (google::protobuf::DescriptorProto_ExtensionRange *)v57->elements[v58];
      a2->extension_range_.current_size_ = v58 + 1;
LABEL_65:
      v51 = &this->extension_ranges_[v49];
      start = v51->start;
      v53 = v50->_has_bits_.has_bits_[0];
      options = v51->options_;
      v50->_has_bits_.has_bits_[0] = v53 | 2;
      v50->start_ = start;
      end = v51->end;
      v50->_has_bits_.has_bits_[0] = v53 | 6;
      v50->end_ = end;
      if ( options != (const google::protobuf::ExtensionRangeOptions *)google::protobuf::ExtensionRangeOptions::default_instance((google::protobuf::ExtensionRangeOptions *)enum_type_count) )
      {
        v56 = v50->options_;
        v50->_has_bits_.has_bits_[0] |= 1u;
        if ( !v56 )
        {
          v56 = (google::protobuf::ExtensionRangeOptions *)operator new(0x68uLL);
          google::protobuf::ExtensionRangeOptions::ExtensionRangeOptions(v56);
          v50->options_ = v56;
        }
        enum_type_count = (unsigned __int64)v56;
        google::protobuf::ExtensionRangeOptions::CopyFrom(v56, options);
      }
      if ( this->extension_range_count_ <= (int)++v49 )
        goto LABEL_81;
    }
    v60 = a2->extension_range_.total_size_;
    goto LABEL_79;
  }
LABEL_81:
  v64 = 0LL;
  v65 = 0;
  if ( this->extension_count_ > 0 )
  {
    while ( 1 )
    {
      v67 = a2->extension_.rep_;
      v68 = &this->extensions_[v64];
      if ( !v67 )
        break;
      v69 = a2->extension_.current_size_;
      v70 = v67->allocated_size;
      if ( (int)v69 >= v67->allocated_size )
      {
        v71 = a2->extension_.total_size_;
        if ( v70 != v71 )
        {
          v72 = a2->extension_.arena_;
          v67->allocated_size = v70 + 1;
          if ( v72 )
            goto LABEL_89;
LABEL_95:
          v66 = (google::protobuf::FieldDescriptorProto *)operator new(0x58uLL);
          google::protobuf::FieldDescriptorProto::FieldDescriptorProto(v66);
          goto LABEL_92;
        }
LABEL_94:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->extension_, v71 + 1);
        v72 = a2->extension_.arena_;
        ++a2->extension_.rep_->allocated_size;
        if ( !v72 )
          goto LABEL_95;
LABEL_89:
        if ( v72->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            v72,
            (const std::type_info *)&`typeinfo for'google::protobuf::FieldDescriptorProto,
            0x58uLL);
        v66 = (google::protobuf::FieldDescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                          &v72->impl_,
                                                          0x58uLL,
                                                          google::protobuf::internal::arena_destruct_object<google::protobuf::FieldDescriptorProto>);
        google::protobuf::FieldDescriptorProto::FieldDescriptorProto(v66);
LABEL_92:
        v73 = a2->extension_.current_size_;
        v74 = a2->extension_.rep_;
        a2->extension_.current_size_ = v73 + 1;
        v74->elements[v73] = v66;
        goto LABEL_84;
      }
      v66 = (google::protobuf::FieldDescriptorProto *)v67->elements[v69];
      a2->extension_.current_size_ = v69 + 1;
LABEL_84:
      enum_type_count = (unsigned __int64)v68;
      ++v65;
      ++v64;
      google::protobuf::FieldDescriptor::CopyTo(v68, v66);
      if ( v65 >= this->extension_count_ )
        goto LABEL_96;
    }
    v71 = a2->extension_.total_size_;
    goto LABEL_94;
  }
LABEL_96:
  if ( this->reserved_range_count_ > 0 )
  {
    v75 = a2->reserved_range_.rep_;
    v76 = 0LL;
    while ( 1 )
    {
      v81 = v75;
      if ( !v75 )
        break;
      v82 = a2->reserved_range_.current_size_;
      v83 = v75->allocated_size;
      if ( (int)v82 >= v75->allocated_size )
      {
        v84 = a2->reserved_range_.total_size_;
        if ( v83 != v84 )
        {
LABEL_103:
          v81->allocated_size = v83 + 1;
          v85 = a2->reserved_range_.arena_;
          if ( v85 )
          {
            if ( v85->hooks_cookie_ )
            {
              v99 = a2->reserved_range_.arena_;
              google::protobuf::Arena::OnArenaAllocation(
                v85,
                (const std::type_info *)&`typeinfo for'google::protobuf::DescriptorProto_ReservedRange,
                0x20uLL);
              v85 = v99;
            }
            v77 = (google::protobuf::DescriptorProto_ReservedRange *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                                       &v85->impl_,
                                                                       0x20uLL,
                                                                       google::protobuf::internal::arena_destruct_object<google::protobuf::DescriptorProto_ReservedRange>);
            google::protobuf::DescriptorProto_ReservedRange::DescriptorProto_ReservedRange(v77);
          }
          else
          {
            v77 = (google::protobuf::DescriptorProto_ReservedRange *)operator new(0x20uLL);
            google::protobuf::DescriptorProto_ReservedRange::DescriptorProto_ReservedRange(v77);
          }
          v86 = a2->reserved_range_.current_size_;
          v75 = a2->reserved_range_.rep_;
          a2->reserved_range_.current_size_ = v86 + 1;
          v75->elements[v86] = v77;
          goto LABEL_99;
        }
LABEL_109:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->reserved_range_, v84 + 1);
        v81 = a2->reserved_range_.rep_;
        v83 = v81->allocated_size;
        goto LABEL_103;
      }
      v77 = (google::protobuf::DescriptorProto_ReservedRange *)v75->elements[v82];
      a2->reserved_range_.current_size_ = v82 + 1;
LABEL_99:
      v78 = &this->reserved_ranges_[v76++];
      v79 = v77->_has_bits_.has_bits_[0];
      v80 = v79 | 3;
      enum_type_count = v79 | 1;
      v77->start_ = v78->start;
      v77->_has_bits_.has_bits_[0] = enum_type_count;
      LODWORD(v78) = v78->end;
      v77->_has_bits_.has_bits_[0] = v80;
      v77->end_ = (int)v78;
      if ( this->reserved_range_count_ <= (int)v76 )
        goto LABEL_111;
    }
    v84 = a2->reserved_range_.total_size_;
    goto LABEL_109;
  }
LABEL_111:
  v87 = 0LL;
  if ( this->reserved_name_count_ > 0 )
  {
    while ( 1 )
    {
      v88 = this->reserved_names_[v87];
      v89 = a2->reserved_name_.rep_;
      if ( !v89 )
        break;
      v90 = a2->reserved_name_.current_size_;
      v91 = v89->allocated_size;
      if ( (int)v90 >= v89->allocated_size )
      {
        v92 = a2->reserved_name_.total_size_;
        if ( v91 != v92 )
        {
LABEL_118:
          v93 = a2->reserved_name_.arena_;
          v89->allocated_size = v91 + 1;
          if ( v93 )
          {
            if ( v93->hooks_cookie_ )
              google::protobuf::Arena::OnArenaAllocation(
                v93,
                (const std::type_info *)&`typeinfo for'std::string,
                0x20uLL);
            v94 = (google::protobuf::DescriptorProto_ExtensionRange *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                                        &v93->impl_,
                                                                        0x20uLL,
                                                                        google::protobuf::internal::arena_destruct_object<std::string>);
          }
          else
          {
            v94 = (google::protobuf::DescriptorProto_ExtensionRange *)operator new(0x20uLL);
          }
          enum_type_count = (unsigned __int64)v94;
          LOBYTE(v94->_has_bits_.has_bits_[0]) = 0;
          v95 = a2->reserved_name_.rep_;
          v94->_vptr_MessageLite = (int (**)(...))&v94->_has_bits_;
          v96 = a2->reserved_name_.current_size_;
          *(_QWORD *)(enum_type_count + 8) = 0LL;
          a2->reserved_name_.current_size_ = v96 + 1;
          v95->elements[v96] = (void *)enum_type_count;
          goto LABEL_114;
        }
LABEL_124:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->reserved_name_, v92 + 1);
        v89 = a2->reserved_name_.rep_;
        v91 = v89->allocated_size;
        goto LABEL_118;
      }
      enum_type_count = (unsigned __int64)v89->elements[v90];
      a2->reserved_name_.current_size_ = v90 + 1;
LABEL_114:
      ++v87;
      std::string::_M_assign(enum_type_count, v88);
      if ( this->reserved_name_count_ <= (int)v87 )
        goto LABEL_126;
    }
    v92 = a2->reserved_name_.total_size_;
    goto LABEL_124;
  }
LABEL_126:
  v97 = this->options_;
  if ( v97 != (const google::protobuf::MessageOptions *)google::protobuf::MessageOptions::default_instance((google::protobuf::MessageOptions *)enum_type_count) )
  {
    v98 = a2->options_;
    a2->_has_bits_.has_bits_[0] |= 2u;
    if ( !v98 )
    {
      v98 = (google::protobuf::MessageOptions *)operator new(0x70uLL);
      google::protobuf::MessageOptions::MessageOptions(v98);
      a2->options_ = v98;
    }
    google::protobuf::MessageOptions::CopyFrom(v98, this->options_);
  }
};

// Line 1979: range 000000000C8FB190-000000000C8FB30C
void __fastcall google::protobuf::Descriptor::CopyJsonNameTo(
        google::protobuf::Descriptor *this,
        google::protobuf::DescriptorProto *a2)
{
  int field_count; // eax
  int nested_type_count; // edx
  google::protobuf::internal::LogMessage_0 *v6; // rax
  __int64 v7; // r13
  int v8; // r12d
  void *v9; // rdi
  google::protobuf::internal::ExplicitlyConstructed<std::string > *v10; // r8
  const std::string *json_name; // rsi
  __int64 v12; // r12
  __int64 v13; // rdx
  __int64 v14; // rdi
  __int64 v15; // r13
  int i; // r12d
  void *v17; // rdi
  google::protobuf::internal::ExplicitlyConstructed<std::string > *v18; // r8
  const std::string *v19; // rsi
  google::protobuf::internal::LogFinisher v20; // [rsp+Fh] [rbp-69h] BYREF
  google::protobuf::internal::LogMessage_0 v21; // [rsp+10h] [rbp-68h] BYREF

  field_count = this->field_count_;
  if ( a2->field_.current_size_ == field_count
    && (nested_type_count = this->nested_type_count_, a2->nested_type_.current_size_ == nested_type_count)
    && a2->extension_.current_size_ == this->extension_count_ )
  {
    v7 = 0LL;
    v8 = 0;
    if ( field_count > 0 )
    {
      do
      {
        v9 = a2->field_.rep_->elements[v8];
        v10 = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)*((_QWORD *)v9 + 7);
        json_name = this->fields_[v7].json_name_;
        *((_DWORD *)v9 + 4) |= 0x10u;
        if ( v10 == &google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
          google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena((std::string **)v9 + 7, (__int64)json_name);
        else
          std::string::_M_assign(v10, json_name);
        ++v8;
        ++v7;
      }
      while ( this->field_count_ > v8 );
      nested_type_count = this->nested_type_count_;
    }
    v12 = 0LL;
    if ( nested_type_count > 0 )
    {
      do
      {
        v13 = (int)v12;
        v14 = v12++;
        google::protobuf::Descriptor::CopyJsonNameTo(
          &this->nested_types_[v14],
          (google::protobuf::DescriptorProto *)a2->nested_type_.rep_->elements[v13]);
      }
      while ( this->nested_type_count_ > (int)v12 );
    }
    v15 = 0LL;
    for ( i = 0; this->extension_count_ > i; ++v15 )
    {
      v17 = a2->extension_.rep_->elements[i];
      v18 = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)*((_QWORD *)v17 + 7);
      v19 = this->extensions_[v15].json_name_;
      *((_DWORD *)v17 + 4) |= 0x10u;
      if ( v18 == &google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
        google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena((std::string **)v17 + 7, (__int64)v19);
      else
        std::string::_M_assign(v18, v19);
      ++i;
    }
  }
  else
  {
    google::protobuf::internal::LogMessage::LogMessage(&v21, LOGLEVEL_ERROR_0, "google/protobuf/descriptor.cc", 1983);
    v6 = google::protobuf::internal::LogMessage::operator<<(
           &v21,
           "Cannot copy json_name to a proto of a different size.");
    google::protobuf::internal::LogFinisher::operator=(&v20, v6);
    google::protobuf::internal::LogMessage::~LogMessage(&v21);
  }
};

// Line 1983: range 000000000C72DFA2-000000000C72DFAF
void __fastcall __noreturn google::protobuf::Descriptor::CopyJsonNameTo(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 1997: range 000000000C8FBDF0-000000000C8FC9A2
void __fastcall google::protobuf::FieldDescriptor::CopyTo(
        google::protobuf::FieldDescriptor *this,
        google::protobuf::FieldDescriptorProto *a2)
{
  const std::string *name; // rsi
  std::string *ptr; // rdi
  google::protobuf::uint32 v6; // edx
  int v7; // eax
  int label; // edx
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  int type; // ecx
  google::protobuf::uint32 v11; // edx
  bool v12; // zf
  const google::protobuf::Descriptor *containing_type; // rcx
  std::string *v14; // rdi
  __int64 v15; // rdi
  google::protobuf::FieldDescriptor::CppType v16; // eax
  const google::protobuf::OneofDescriptor *containing_oneof; // rax
  __int64 v18; // rax
  const google::protobuf::FieldOptions *options; // r12
  google::protobuf::FieldOptions *v20; // r12
  google::protobuf::uint32 v21; // eax
  std::string *v22; // r13
  google::protobuf::GoogleOnceDynamic *v23; // rdi
  const char ***enum_type; // rax
  std::string *v25; // r13
  std::string::$CFBEC286C7F52157F7E59FC354047095 *v26; // rdi
  std::string::size_type v27; // rdx
  std::string::size_type v28; // rcx
  std::string *v29; // rdi
  const std::string *json_name; // rsi
  const google::protobuf::Descriptor *message_type; // rax
  google::protobuf::GoogleOnceDynamic *v32; // rdi
  const google::protobuf::Descriptor *v33; // rdx
  google::protobuf::uint32 v34; // eax
  google::protobuf::GoogleOnceDynamic *v35; // rdi
  google::protobuf::GoogleOnceDynamic *v36; // rdi
  std::string *v37; // r13
  std::string::$CFBEC286C7F52157F7E59FC354047095 *M_p; // rdi
  std::string::size_type v39; // rdx
  std::string::size_type M_allocated_capacity; // rcx
  std::string *v41; // r13
  std::string::$CFBEC286C7F52157F7E59FC354047095 *p_anon_0; // rdi
  std::string::size_type v43; // rdx
  std::string::size_type v44; // rcx
  std::string *v45; // r13
  std::string::$CFBEC286C7F52157F7E59FC354047095 *v46; // rdi
  std::string::size_type v47; // rdx
  std::string::size_type v48; // rcx
  __int64 v49; // rax
  std::string::size_type v50; // rdx
  std::string::size_type M_string_length; // rax
  std::string::size_type v52; // rax
  std::string::size_type v53; // rax
  std::string v54[2]; // [rsp+0h] [rbp-48h] BYREF

  name = this->name_;
  ptr = a2->name_.ptr_;
  a2->_has_bits_.has_bits_[0] |= 1u;
  if ( ptr == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
    google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&a2->name_.ptr_, (__int64)name);
  else
    std::string::_M_assign(ptr, name);
  v6 = a2->_has_bits_.has_bits_[0];
  a2->number_ = this->number_;
  v7 = v6 | 0x40;
  if ( this->has_json_name_ )
  {
    v29 = a2->json_name_.ptr_;
    json_name = this->json_name_;
    a2->_has_bits_.has_bits_[0] = v6 | 0x50;
    if ( v29 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
      google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&a2->json_name_.ptr_, (__int64)json_name);
    else
      std::string::_M_assign(v29, json_name);
    v7 = a2->_has_bits_.has_bits_[0];
  }
  label = this->label_;
  type_once = this->type_once_;
  BYTE1(v7) |= 1u;
  a2->_has_bits_.has_bits_[0] = v7;
  a2->label_ = label;
  if ( type_once )
  {
    if ( type_once->state_ != 2 )
    {
      v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      v54[0]._anon_0._M_local_buf[0] = 0;
      v54[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
      *(&v54[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
      google::protobuf::GoogleOnceInitImpl(&type_once->state_, (google::protobuf::Closure *)v54);
      v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v54);
    }
    v7 = a2->_has_bits_.has_bits_[0];
  }
  type = this->type_;
  v11 = v7;
  BYTE1(v11) = BYTE1(v7) | 2;
  v12 = !this->is_extension_;
  a2->_has_bits_.has_bits_[0] = v11;
  a2->type_ = type;
  if ( !v12 )
  {
    containing_type = this->containing_type_;
    if ( containing_type->is_unqualified_placeholder_ )
    {
      v14 = a2->extendee_.ptr_;
LABEL_11:
      a2->_has_bits_.has_bits_[0] = v11 | 2;
      if ( v14 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
      {
        google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(
          &a2->extendee_.ptr_,
          (__int64)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11]);
        v14 = a2->extendee_.ptr_;
      }
      std::string::_M_append(
        v14,
        this->containing_type_->full_name_->_M_dataplus._M_p,
        this->containing_type_->full_name_->_M_string_length);
      goto LABEL_14;
    }
    a2->_has_bits_.has_bits_[0] = v7 | 0x202;
    v54[0]._M_dataplus._M_p = v54[0]._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(v54, ".", "", (std::forward_iterator_tag)containing_type);
    v37 = a2->extendee_.ptr_;
    if ( v37 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
    {
      v14 = (std::string *)operator new(0x20uLL);
      v14->_M_dataplus._M_p = v14->_anon_0._M_local_buf;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p == &v54[0]._anon_0 )
      {
        v14->_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_load_si128((const __m128i *)&v54[0]._anon_0);
      }
      else
      {
        v14->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
        v14->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
      }
      M_string_length = v54[0]._M_string_length;
      a2->extendee_.ptr_ = v14;
      v14->_M_string_length = M_string_length;
LABEL_81:
      v11 = a2->_has_bits_.has_bits_[0];
      goto LABEL_11;
    }
    M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v37->_M_dataplus._M_p;
    v39 = v54[0]._M_string_length;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p == &v54[0]._anon_0 )
    {
      if ( v54[0]._M_string_length )
      {
        if ( v54[0]._M_string_length == 1 )
          M_p->_M_local_buf[0] = v54[0]._anon_0._M_local_buf[0];
        else
          memcpy(M_p, &v54[0]._anon_0, v54[0]._M_string_length);
        v39 = v54[0]._M_string_length;
        M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v37->_M_dataplus._M_p;
      }
      v37->_M_string_length = v39;
      M_p->_M_local_buf[v39] = 0;
      M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p;
      goto LABEL_78;
    }
    if ( M_p == &v37->_anon_0 )
    {
      v37->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
      v37->_M_string_length = v39;
      v37->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
    }
    else
    {
      v37->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
      M_allocated_capacity = v37->_anon_0._M_allocated_capacity;
      v37->_M_string_length = v39;
      v37->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
      if ( M_p )
      {
        v54[0]._M_dataplus._M_p = (std::string::pointer)M_p;
        v54[0]._anon_0._M_allocated_capacity = M_allocated_capacity;
LABEL_78:
        v54[0]._M_string_length = 0LL;
        M_p->_M_local_buf[0] = 0;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p != &v54[0]._anon_0 )
          operator delete(v54[0]._M_dataplus._M_p);
        v14 = a2->extendee_.ptr_;
        goto LABEL_81;
      }
    }
    v54[0]._M_dataplus._M_p = v54[0]._anon_0._M_local_buf;
    M_p = &v54[0]._anon_0;
    goto LABEL_78;
  }
LABEL_14:
  v15 = (__int64)this->type_once_;
  if ( !v15 )
  {
    v16 = google::protobuf::FieldDescriptor::kTypeToCppTypeMap[this->type_];
    if ( v16 != CPPTYPE_MESSAGE_0 )
    {
LABEL_31:
      if ( v16 != CPPTYPE_ENUM_0 )
        goto LABEL_21;
LABEL_32:
      v21 = a2->_has_bits_.has_bits_[0] | 4;
      if ( this->enum_type_->is_unqualified_placeholder_ )
      {
        v22 = a2->type_name_.ptr_;
LABEL_34:
        a2->_has_bits_.has_bits_[0] = v21;
        if ( v22 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
        {
          google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(
            &a2->type_name_.ptr_,
            (__int64)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11]);
          v22 = a2->type_name_.ptr_;
        }
        v23 = this->type_once_;
        if ( v23 && v23->state_ != 2 )
        {
          v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
          v54[0]._anon_0._M_local_buf[0] = 0;
          v54[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
          *(&v54[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
          google::protobuf::GoogleOnceInitImpl(&v23->state_, (google::protobuf::Closure *)v54);
          v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
          google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v54);
        }
        enum_type = (const char ***)this->enum_type_;
LABEL_68:
        v15 = (__int64)v22;
        std::string::_M_append(v22, *enum_type[1], enum_type[1][1]);
        goto LABEL_21;
      }
      a2->_has_bits_.has_bits_[0] = v21;
      v54[0]._M_dataplus._M_p = v54[0]._anon_0._M_local_buf;
      std::string::_M_construct<char const*>(v54, ".", "", (std::forward_iterator_tag)type);
      v41 = a2->type_name_.ptr_;
      if ( v41 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
      {
        v22 = (std::string *)operator new(0x20uLL);
        v22->_M_dataplus._M_p = v22->_anon_0._M_local_buf;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p == &v54[0]._anon_0 )
        {
          v22->_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_load_si128((const __m128i *)&v54[0]._anon_0);
        }
        else
        {
          v22->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
          v22->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
        }
        v53 = v54[0]._M_string_length;
        a2->type_name_.ptr_ = v22;
        v22->_M_string_length = v53;
LABEL_90:
        v21 = a2->_has_bits_.has_bits_[0] | 4;
        goto LABEL_34;
      }
      p_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v41->_M_dataplus._M_p;
      v43 = v54[0]._M_string_length;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p == &v54[0]._anon_0 )
      {
        if ( v54[0]._M_string_length )
        {
          if ( v54[0]._M_string_length == 1 )
            p_anon_0->_M_local_buf[0] = v54[0]._anon_0._M_local_buf[0];
          else
            memcpy(p_anon_0, &v54[0]._anon_0, v54[0]._M_string_length);
          v43 = v54[0]._M_string_length;
          p_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v41->_M_dataplus._M_p;
        }
        v41->_M_string_length = v43;
        p_anon_0->_M_local_buf[v43] = 0;
        p_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p;
        goto LABEL_87;
      }
      if ( p_anon_0 == &v41->_anon_0 )
      {
        v41->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
        v41->_M_string_length = v43;
        v41->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
      }
      else
      {
        v41->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
        v44 = v41->_anon_0._M_allocated_capacity;
        v41->_M_string_length = v43;
        v41->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
        if ( p_anon_0 )
        {
          v54[0]._M_dataplus._M_p = (std::string::pointer)p_anon_0;
          v54[0]._anon_0._M_allocated_capacity = v44;
LABEL_87:
          v54[0]._M_string_length = 0LL;
          p_anon_0->_M_local_buf[0] = 0;
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p != &v54[0]._anon_0 )
            operator delete(v54[0]._M_dataplus._M_p);
          v22 = a2->type_name_.ptr_;
          goto LABEL_90;
        }
      }
      v54[0]._M_dataplus._M_p = v54[0]._anon_0._M_local_buf;
      p_anon_0 = &v54[0]._anon_0;
      goto LABEL_87;
    }
    goto LABEL_96;
  }
  if ( *(_QWORD *)v15 != 2LL )
  {
    v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    v54[0]._anon_0._M_local_buf[0] = 0;
    v54[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
    *(&v54[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
    google::protobuf::GoogleOnceInitImpl((google::protobuf::ProtobufOnceType *)v15, (google::protobuf::Closure *)v54);
    v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v54);
  }
  v15 = (__int64)this->type_once_;
  v16 = google::protobuf::FieldDescriptor::kTypeToCppTypeMap[this->type_];
  if ( v16 == CPPTYPE_MESSAGE_0 )
  {
    if ( v15 )
    {
      if ( *(_QWORD *)v15 != 2LL )
      {
        v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        v54[0]._anon_0._M_local_buf[0] = 0;
        v54[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
        *(&v54[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
        google::protobuf::GoogleOnceInitImpl(
          (google::protobuf::ProtobufOnceType *)v15,
          (google::protobuf::Closure *)v54);
        v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v54);
      }
      message_type = this->message_type_;
      v32 = this->type_once_;
      if ( message_type->is_placeholder_ )
      {
        a2->_has_bits_.has_bits_[0] &= ~0x200u;
        a2->type_ = 1;
      }
      if ( v32 )
      {
        if ( v32->state_ != 2 )
        {
          v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
          v54[0]._anon_0._M_local_buf[0] = 0;
          v54[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
          *(&v54[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
          google::protobuf::GoogleOnceInitImpl(&v32->state_, (google::protobuf::Closure *)v54);
          v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
          google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v54);
        }
        v33 = this->message_type_;
LABEL_60:
        v34 = a2->_has_bits_.has_bits_[0] | 4;
        if ( v33->is_unqualified_placeholder_ )
        {
          v22 = a2->type_name_.ptr_;
LABEL_62:
          a2->_has_bits_.has_bits_[0] = v34;
          if ( v22 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
          {
            google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(
              &a2->type_name_.ptr_,
              (__int64)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11]);
            v22 = a2->type_name_.ptr_;
          }
          v35 = this->type_once_;
          if ( v35 && v35->state_ != 2 )
          {
            v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
            v54[0]._anon_0._M_local_buf[0] = 0;
            v54[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
            *(&v54[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
            google::protobuf::GoogleOnceInitImpl(&v35->state_, (google::protobuf::Closure *)v54);
            v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
            google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v54);
          }
          enum_type = (const char ***)this->message_type_;
          goto LABEL_68;
        }
        a2->_has_bits_.has_bits_[0] = v34;
        v54[0]._M_dataplus._M_p = v54[0]._anon_0._M_local_buf;
        std::string::_M_construct<char const*>(v54, ".", "", (std::forward_iterator_tag)type);
        v45 = a2->type_name_.ptr_;
        if ( v45 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
        {
          v22 = (std::string *)operator new(0x20uLL);
          v22->_M_dataplus._M_p = v22->_anon_0._M_local_buf;
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p == &v54[0]._anon_0 )
          {
            v22->_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_load_si128((const __m128i *)&v54[0]._anon_0);
          }
          else
          {
            v22->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
            v22->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
          }
          v52 = v54[0]._M_string_length;
          a2->type_name_.ptr_ = v22;
          v22->_M_string_length = v52;
LABEL_107:
          v34 = a2->_has_bits_.has_bits_[0] | 4;
          goto LABEL_62;
        }
        v46 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v45->_M_dataplus._M_p;
        v47 = v54[0]._M_string_length;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p == &v54[0]._anon_0 )
        {
          if ( v54[0]._M_string_length )
          {
            if ( v54[0]._M_string_length == 1 )
              v46->_M_local_buf[0] = v54[0]._anon_0._M_local_buf[0];
            else
              memcpy(v46, &v54[0]._anon_0, v54[0]._M_string_length);
            v47 = v54[0]._M_string_length;
            v46 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v45->_M_dataplus._M_p;
          }
          v45->_M_string_length = v47;
          v46->_M_local_buf[v47] = 0;
          v46 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p;
          goto LABEL_104;
        }
        if ( v46 == &v45->_anon_0 )
        {
          v45->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
          v45->_M_string_length = v47;
          v45->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
        }
        else
        {
          v45->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
          v48 = v45->_anon_0._M_allocated_capacity;
          v45->_M_string_length = v47;
          v45->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
          if ( v46 )
          {
            v54[0]._M_dataplus._M_p = (std::string::pointer)v46;
            v54[0]._anon_0._M_allocated_capacity = v48;
LABEL_104:
            v54[0]._M_string_length = 0LL;
            v46->_M_local_buf[0] = 0;
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p != &v54[0]._anon_0 )
              operator delete(v54[0]._M_dataplus._M_p);
            v22 = a2->type_name_.ptr_;
            goto LABEL_107;
          }
        }
        v54[0]._M_dataplus._M_p = v54[0]._anon_0._M_local_buf;
        v46 = &v54[0]._anon_0;
        goto LABEL_104;
      }
LABEL_98:
      v33 = message_type;
      goto LABEL_60;
    }
LABEL_96:
    message_type = this->message_type_;
    v33 = message_type;
    if ( !message_type->is_placeholder_ )
      goto LABEL_60;
    a2->_has_bits_.has_bits_[0] &= ~0x200u;
    a2->type_ = 1;
    goto LABEL_98;
  }
  if ( !v15 )
    goto LABEL_31;
  if ( *(_QWORD *)v15 == 2LL )
  {
    if ( google::protobuf::FieldDescriptor::kTypeToCppTypeMap[this->type_] != CPPTYPE_ENUM_0 )
      goto LABEL_21;
    goto LABEL_70;
  }
  v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
  v54[0]._anon_0._M_local_buf[0] = 0;
  v54[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
  *(&v54[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
  google::protobuf::GoogleOnceInitImpl((google::protobuf::ProtobufOnceType *)v15, (google::protobuf::Closure *)v54);
  v15 = (__int64)v54;
  v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
  google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v54);
  if ( google::protobuf::FieldDescriptor::kTypeToCppTypeMap[this->type_] == CPPTYPE_ENUM_0 )
  {
LABEL_70:
    v36 = this->type_once_;
    if ( v36 && v36->state_ != 2 )
    {
      v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      v54[0]._anon_0._M_local_buf[0] = 0;
      v54[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
      *(&v54[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
      google::protobuf::GoogleOnceInitImpl(&v36->state_, (google::protobuf::Closure *)v54);
      v54[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v54);
    }
    goto LABEL_32;
  }
LABEL_21:
  if ( !this->has_default_value_ )
    goto LABEL_22;
  google::protobuf::FieldDescriptor::DefaultValueAsString[abi:cxx11](
    v54,
    (__int64)this,
    0,
    (std::forward_iterator_tag)type);
  v25 = a2->default_value_.ptr_;
  a2->_has_bits_.has_bits_[0] |= 8u;
  if ( v25 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
  {
    v15 = 32LL;
    v49 = operator new(0x20uLL);
    *(_QWORD *)v49 = v49 + 16;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p == &v54[0]._anon_0 )
    {
      *(__m128i *)(v49 + 16) = _mm_load_si128((const __m128i *)&v54[0]._anon_0);
    }
    else
    {
      *(_QWORD *)v49 = v54[0]._M_dataplus._M_p;
      *(_QWORD *)(v49 + 16) = v54[0]._anon_0._M_allocated_capacity;
    }
    v50 = v54[0]._M_string_length;
    a2->default_value_.ptr_ = (std::string *)v49;
    *(_QWORD *)(v49 + 8) = v50;
    goto LABEL_22;
  }
  v26 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v25->_M_dataplus._M_p;
  v27 = v54[0]._M_string_length;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p == &v54[0]._anon_0 )
  {
    if ( v54[0]._M_string_length )
    {
      if ( v54[0]._M_string_length == 1 )
        v26->_M_local_buf[0] = v54[0]._anon_0._M_local_buf[0];
      else
        memcpy(v26, &v54[0]._anon_0, v54[0]._M_string_length);
      v27 = v54[0]._M_string_length;
      v26 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v25->_M_dataplus._M_p;
    }
    v25->_M_string_length = v27;
    v26->_M_local_buf[v27] = 0;
    v26 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p;
    goto LABEL_45;
  }
  if ( v26 == &v25->_anon_0 )
  {
    v25->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
    v25->_M_string_length = v27;
    v25->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
  }
  else
  {
    v25->_M_dataplus._M_p = v54[0]._M_dataplus._M_p;
    v28 = v25->_anon_0._M_allocated_capacity;
    v25->_M_string_length = v27;
    v25->_anon_0._M_allocated_capacity = v54[0]._anon_0._M_allocated_capacity;
    if ( v26 )
    {
      v54[0]._M_dataplus._M_p = (std::string::pointer)v26;
      v54[0]._anon_0._M_allocated_capacity = v28;
      goto LABEL_45;
    }
  }
  v54[0]._M_dataplus._M_p = v54[0]._anon_0._M_local_buf;
  v26 = &v54[0]._anon_0;
LABEL_45:
  v54[0]._M_string_length = 0LL;
  v26->_M_local_buf[0] = 0;
  v15 = (__int64)v54[0]._M_dataplus._M_p;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54[0]._M_dataplus._M_p != &v54[0]._anon_0 )
    operator delete(v54[0]._M_dataplus._M_p);
LABEL_22:
  containing_oneof = this->containing_oneof_;
  if ( containing_oneof && !this->is_extension_ )
  {
    v18 = (char *)containing_oneof - (char *)containing_oneof->containing_type_->oneof_decls_;
    a2->_has_bits_.has_bits_[0] |= 0x80u;
    a2->oneof_index_ = -1431655765 * (v18 >> 4);
  }
  options = this->options_;
  if ( options != (const google::protobuf::FieldOptions *)google::protobuf::FieldOptions::default_instance((google::protobuf::FieldOptions *)v15) )
  {
    v20 = a2->options_;
    a2->_has_bits_.has_bits_[0] |= 0x20u;
    if ( !v20 )
    {
      v20 = (google::protobuf::FieldOptions *)operator new(0x78uLL);
      google::protobuf::FieldOptions::FieldOptions(v20);
      a2->options_ = v20;
    }
    google::protobuf::FieldOptions::CopyFrom(v20, this->options_);
  }
};

// Line 2050: range 000000000C8FB030-000000000C8FB057
void __fastcall google::protobuf::FieldDescriptor::CopyJsonNameTo(
        const google::protobuf::FieldDescriptor *const this,
        google::protobuf::FieldDescriptorProto *proto)
{
  const std::string *json_name; // r8
  std::string *ptr; // rdi

  json_name = this->json_name_;
  ptr = proto->json_name_.ptr_;
  proto->_has_bits_.has_bits_[0] |= 0x10u;
  if ( ptr == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
    google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&proto->json_name_.ptr_, (__int64)json_name);
  else
    std::string::_M_assign(ptr, json_name);
};

// Line 2053: range 000000000C8FB060-000000000C8FB0E6
void __fastcall google::protobuf::OneofDescriptor::CopyTo(
        google::protobuf::OneofDescriptor *this,
        google::protobuf::OneofDescriptorProto *a2)
{
  const std::string *name; // rsi
  google::protobuf::internal::ExplicitlyConstructed<std::string > *ptr; // rdi
  const google::protobuf::OneofOptions *options; // r12
  google::protobuf::OneofOptions *v7; // r12

  name = this->name_;
  ptr = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)a2->name_.ptr_;
  a2->_has_bits_.has_bits_[0] |= 1u;
  if ( ptr == &google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
  {
    ptr = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)&a2->name_;
    google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&a2->name_.ptr_, (__int64)name);
  }
  else
  {
    std::string::_M_assign(ptr, name);
  }
  options = this->options_;
  if ( options != (const google::protobuf::OneofOptions *)google::protobuf::OneofOptions::default_instance((google::protobuf::OneofOptions *)ptr) )
  {
    v7 = a2->options_;
    a2->_has_bits_.has_bits_[0] |= 2u;
    if ( !v7 )
    {
      v7 = (google::protobuf::OneofOptions *)operator new(0x68uLL);
      google::protobuf::OneofOptions::OneofOptions(v7);
      a2->options_ = v7;
    }
    google::protobuf::OneofOptions::CopyFrom(v7, this->options_);
  }
};

// Line 2060: range 000000000C8FB430-000000000C8FB5F6
void __fastcall google::protobuf::EnumDescriptor::CopyTo(
        google::protobuf::EnumDescriptor *this,
        google::protobuf::EnumDescriptorProto *a2)
{
  const std::string *name; // rsi
  google::protobuf::internal::ExplicitlyConstructed<std::string > *ptr; // rdi
  __int64 v6; // rbp
  google::protobuf::EnumValueDescriptorProto *AlignedAndAddCleanup; // r12
  google::protobuf::EnumValueDescriptor *v8; // r14
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *rep; // rax
  __int64 current_size; // rcx
  int allocated_size; // edx
  int total_size; // esi
  google::protobuf::Arena *arena; // rdi
  __int64 v14; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v15; // rdx
  const google::protobuf::EnumOptions *options; // rbp
  google::protobuf::EnumOptions *v17; // rbp

  name = this->name_;
  ptr = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)a2->name_.ptr_;
  a2->_has_bits_.has_bits_[0] |= 1u;
  if ( ptr == &google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
  {
    ptr = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)&a2->name_;
    google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&a2->name_.ptr_, (__int64)name);
  }
  else
  {
    std::string::_M_assign(ptr, name);
  }
  v6 = 0LL;
  if ( this->value_count_ > 0 )
  {
    while ( 1 )
    {
      v8 = &this->values_[v6];
      rep = a2->value_.rep_;
      if ( !rep )
        break;
      current_size = a2->value_.current_size_;
      allocated_size = rep->allocated_size;
      if ( (int)current_size >= rep->allocated_size )
      {
        total_size = a2->value_.total_size_;
        if ( allocated_size != total_size )
        {
          arena = a2->value_.arena_;
          rep->allocated_size = allocated_size + 1;
          if ( arena )
            goto LABEL_11;
LABEL_17:
          AlignedAndAddCleanup = (google::protobuf::EnumValueDescriptorProto *)operator new(0x30uLL);
          google::protobuf::EnumValueDescriptorProto::EnumValueDescriptorProto(AlignedAndAddCleanup);
          goto LABEL_14;
        }
LABEL_16:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->value_, total_size + 1);
        arena = a2->value_.arena_;
        ++a2->value_.rep_->allocated_size;
        if ( !arena )
          goto LABEL_17;
LABEL_11:
        if ( arena->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            arena,
            (const std::type_info *)&`typeinfo for'google::protobuf::EnumValueDescriptorProto,
            0x30uLL);
        AlignedAndAddCleanup = (google::protobuf::EnumValueDescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                                               &arena->impl_,
                                                                               0x30uLL,
                                                                               google::protobuf::internal::arena_destruct_object<google::protobuf::EnumValueDescriptorProto>);
        google::protobuf::EnumValueDescriptorProto::EnumValueDescriptorProto(AlignedAndAddCleanup);
LABEL_14:
        v14 = a2->value_.current_size_;
        v15 = a2->value_.rep_;
        a2->value_.current_size_ = v14 + 1;
        v15->elements[v14] = AlignedAndAddCleanup;
        goto LABEL_6;
      }
      AlignedAndAddCleanup = (google::protobuf::EnumValueDescriptorProto *)rep->elements[current_size];
      a2->value_.current_size_ = current_size + 1;
LABEL_6:
      ptr = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)v8;
      ++v6;
      google::protobuf::EnumValueDescriptor::CopyTo(v8, AlignedAndAddCleanup);
      if ( this->value_count_ <= (int)v6 )
        goto LABEL_18;
    }
    total_size = a2->value_.total_size_;
    goto LABEL_16;
  }
LABEL_18:
  options = this->options_;
  if ( options != (const google::protobuf::EnumOptions *)google::protobuf::EnumOptions::default_instance((google::protobuf::EnumOptions *)ptr) )
  {
    v17 = a2->options_;
    a2->_has_bits_.has_bits_[0] |= 2u;
    if ( !v17 )
    {
      v17 = (google::protobuf::EnumOptions *)operator new(0x70uLL);
      google::protobuf::EnumOptions::EnumOptions(v17);
      a2->options_ = v17;
    }
    google::protobuf::EnumOptions::CopyFrom(v17, this->options_);
  }
};

// Line 2072: range 000000000C8FB0F0-000000000C8FB186
void __fastcall google::protobuf::EnumValueDescriptor::CopyTo(
        google::protobuf::EnumValueDescriptor *this,
        google::protobuf::EnumValueDescriptorProto *a2)
{
  const std::string *name; // rsi
  google::protobuf::internal::ExplicitlyConstructed<std::string > *ptr; // rdi
  int number; // eax
  const google::protobuf::EnumValueOptions *options; // r12
  google::protobuf::EnumValueOptions *v8; // r12

  name = this->name_;
  ptr = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)a2->name_.ptr_;
  a2->_has_bits_.has_bits_[0] |= 1u;
  if ( ptr == &google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
  {
    ptr = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)&a2->name_;
    google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&a2->name_.ptr_, (__int64)name);
  }
  else
  {
    std::string::_M_assign(ptr, name);
  }
  number = this->number_;
  a2->_has_bits_.has_bits_[0] |= 4u;
  options = this->options_;
  a2->number_ = number;
  if ( options != (const google::protobuf::EnumValueOptions *)google::protobuf::EnumValueOptions::default_instance((google::protobuf::EnumValueOptions *)ptr) )
  {
    v8 = a2->options_;
    a2->_has_bits_.has_bits_[0] |= 2u;
    if ( !v8 )
    {
      v8 = (google::protobuf::EnumValueOptions *)operator new(0x70uLL);
      google::protobuf::EnumValueOptions::EnumValueOptions(v8);
      a2->options_ = v8;
    }
    google::protobuf::EnumValueOptions::CopyFrom(v8, this->options_);
  }
};

// Line 2081: range 000000000C8FBC10-000000000C8FBDE6
void __fastcall google::protobuf::ServiceDescriptor::CopyTo(
        google::protobuf::ServiceDescriptor *this,
        google::protobuf::ServiceDescriptorProto *a2)
{
  const std::string *name; // rsi
  google::protobuf::internal::ExplicitlyConstructed<std::string > *ptr; // rdi
  __int64 v6; // r13
  int v7; // r12d
  google::protobuf::MethodDescriptorProto *AlignedAndAddCleanup; // rbp
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *rep; // rax
  google::protobuf::MethodDescriptor *v10; // r15
  __int64 current_size; // rcx
  int allocated_size; // edx
  int total_size; // esi
  google::protobuf::Arena *arena; // rdi
  __int64 v15; // rax
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *v16; // rdx
  const google::protobuf::ServiceOptions *options; // rbp
  google::protobuf::ServiceOptions *v18; // rbp

  name = this->name_;
  ptr = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)a2->name_.ptr_;
  a2->_has_bits_.has_bits_[0] |= 1u;
  if ( ptr == &google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
  {
    ptr = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)&a2->name_;
    google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&a2->name_.ptr_, (__int64)name);
  }
  else
  {
    std::string::_M_assign(ptr, name);
  }
  v6 = 0LL;
  v7 = 0;
  if ( this->method_count_ > 0 )
  {
    while ( 1 )
    {
      rep = a2->method_.rep_;
      v10 = &this->methods_[v6];
      if ( !rep )
        break;
      current_size = a2->method_.current_size_;
      allocated_size = rep->allocated_size;
      if ( (int)current_size >= rep->allocated_size )
      {
        total_size = a2->method_.total_size_;
        if ( allocated_size != total_size )
        {
          arena = a2->method_.arena_;
          rep->allocated_size = allocated_size + 1;
          if ( arena )
            goto LABEL_11;
LABEL_17:
          AlignedAndAddCleanup = (google::protobuf::MethodDescriptorProto *)operator new(0x40uLL);
          google::protobuf::MethodDescriptorProto::MethodDescriptorProto(AlignedAndAddCleanup);
          goto LABEL_14;
        }
LABEL_16:
        google::protobuf::internal::RepeatedPtrFieldBase::Reserve(&a2->method_, total_size + 1);
        arena = a2->method_.arena_;
        ++a2->method_.rep_->allocated_size;
        if ( !arena )
          goto LABEL_17;
LABEL_11:
        if ( arena->hooks_cookie_ )
          google::protobuf::Arena::OnArenaAllocation(
            arena,
            (const std::type_info *)&`typeinfo for'google::protobuf::MethodDescriptorProto,
            0x40uLL);
        AlignedAndAddCleanup = (google::protobuf::MethodDescriptorProto *)google::protobuf::internal::ArenaImpl::AllocateAlignedAndAddCleanup(
                                                                            &arena->impl_,
                                                                            0x40uLL,
                                                                            google::protobuf::internal::arena_destruct_object<google::protobuf::MethodDescriptorProto>);
        google::protobuf::MethodDescriptorProto::MethodDescriptorProto(AlignedAndAddCleanup);
LABEL_14:
        v15 = a2->method_.current_size_;
        v16 = a2->method_.rep_;
        a2->method_.current_size_ = v15 + 1;
        v16->elements[v15] = AlignedAndAddCleanup;
        goto LABEL_6;
      }
      AlignedAndAddCleanup = (google::protobuf::MethodDescriptorProto *)rep->elements[current_size];
      a2->method_.current_size_ = current_size + 1;
LABEL_6:
      ptr = (google::protobuf::internal::ExplicitlyConstructed<std::string > *)v10;
      ++v7;
      ++v6;
      google::protobuf::MethodDescriptor::CopyTo(v10, AlignedAndAddCleanup);
      if ( v7 >= this->method_count_ )
        goto LABEL_18;
    }
    total_size = a2->method_.total_size_;
    goto LABEL_16;
  }
LABEL_18:
  options = this->options_;
  if ( options != (const google::protobuf::ServiceOptions *)google::protobuf::ServiceOptions::default_instance((google::protobuf::ServiceOptions *)ptr) )
  {
    v18 = a2->options_;
    a2->_has_bits_.has_bits_[0] |= 2u;
    if ( !v18 )
    {
      v18 = (google::protobuf::ServiceOptions *)operator new(0x70uLL);
      google::protobuf::ServiceOptions::ServiceOptions(v18);
      a2->options_ = v18;
    }
    google::protobuf::ServiceOptions::CopyFrom(v18, this->options_);
  }
};

// Line 2093: range 000000000C8FB600-000000000C8FBC08
void __fastcall google::protobuf::MethodDescriptor::CopyTo(
        google::protobuf::MethodDescriptor *this,
        google::protobuf::MethodDescriptorProto *a2)
{
  const std::string *name; // rsi
  std::string *ptr; // rdi
  std::forward_iterator_tag v6; // cl
  google::protobuf::GoogleOnceDynamic *once; // rdi
  google::protobuf::uint32 v8; // eax
  std::string *v9; // r12
  google::protobuf::GoogleOnceDynamic *v10; // rdi
  std::forward_iterator_tag v11; // cl
  google::protobuf::GoogleOnceDynamic *v12; // rdi
  google::protobuf::uint32 v13; // eax
  std::string *v14; // r12
  google::protobuf::GoogleOnceDynamic *v15; // rdi
  google::protobuf::MethodOptions *v16; // rdi
  const google::protobuf::MethodOptions *options; // r12
  google::protobuf::MethodOptions *v18; // r12
  std::string *v19; // r12
  std::string::$CFBEC286C7F52157F7E59FC354047095 *p_anon_0; // rdi
  std::string::size_type v21; // rdx
  std::string::size_type v22; // rcx
  std::string *v23; // r12
  std::string::$CFBEC286C7F52157F7E59FC354047095 *M_p; // rdi
  std::string::size_type v25; // rdx
  std::string::size_type M_allocated_capacity; // rcx
  std::string::size_type M_string_length; // rax
  std::string::size_type v28; // rax
  std::string v29[2]; // [rsp+0h] [rbp-48h] BYREF

  name = this->name_;
  ptr = a2->name_.ptr_;
  a2->_has_bits_.has_bits_[0] |= 1u;
  if ( ptr == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
    google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(&a2->name_.ptr_, (__int64)name);
  else
    std::string::_M_assign(ptr, name);
  once = this->input_type_.once_;
  if ( once && once->state_ != 2 )
  {
    v29[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFE0;
    v29[0]._anon_0._M_local_buf[0] = 0;
    v29[0]._M_string_length = (std::string::size_type)google::protobuf::internal::LazyDescriptor::OnceStatic;
    *(&v29[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)&this->input_type_;
    google::protobuf::GoogleOnceInitImpl(&once->state_, (google::protobuf::Closure *)v29);
    v29[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFE0;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v29);
  }
  v8 = a2->_has_bits_.has_bits_[0] | 2;
  if ( !this->input_type_.descriptor_->is_unqualified_placeholder_ )
  {
    a2->_has_bits_.has_bits_[0] = v8;
    v29[0]._M_dataplus._M_p = v29[0]._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(v29, ".", "", v6);
    v23 = a2->input_type_.ptr_;
    if ( v23 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
    {
      v9 = (std::string *)operator new(0x20uLL);
      v9->_M_dataplus._M_p = v9->_anon_0._M_local_buf;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v29[0]._M_dataplus._M_p == &v29[0]._anon_0 )
      {
        v9->_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_load_si128((const __m128i *)&v29[0]._anon_0);
      }
      else
      {
        v9->_M_dataplus._M_p = v29[0]._M_dataplus._M_p;
        v9->_anon_0._M_allocated_capacity = v29[0]._anon_0._M_allocated_capacity;
      }
      M_string_length = v29[0]._M_string_length;
      a2->input_type_.ptr_ = v9;
      v9->_M_string_length = M_string_length;
      goto LABEL_46;
    }
    M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v23->_M_dataplus._M_p;
    v25 = v29[0]._M_string_length;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v29[0]._M_dataplus._M_p == &v29[0]._anon_0 )
    {
      if ( v29[0]._M_string_length )
      {
        if ( v29[0]._M_string_length == 1 )
          M_p->_M_local_buf[0] = v29[0]._anon_0._M_local_buf[0];
        else
          memcpy(M_p, &v29[0]._anon_0, v29[0]._M_string_length);
        v25 = v29[0]._M_string_length;
        M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v23->_M_dataplus._M_p;
      }
      v23->_M_string_length = v25;
      M_p->_M_local_buf[v25] = 0;
      M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v29[0]._M_dataplus._M_p;
      goto LABEL_43;
    }
    if ( M_p == &v23->_anon_0 )
    {
      v23->_M_dataplus._M_p = v29[0]._M_dataplus._M_p;
      v23->_M_string_length = v25;
      v23->_anon_0._M_allocated_capacity = v29[0]._anon_0._M_allocated_capacity;
    }
    else
    {
      v23->_M_dataplus._M_p = v29[0]._M_dataplus._M_p;
      M_allocated_capacity = v23->_anon_0._M_allocated_capacity;
      v23->_M_string_length = v25;
      v23->_anon_0._M_allocated_capacity = v29[0]._anon_0._M_allocated_capacity;
      if ( M_p )
      {
        v29[0]._M_dataplus._M_p = (std::string::pointer)M_p;
        v29[0]._anon_0._M_allocated_capacity = M_allocated_capacity;
LABEL_43:
        v29[0]._M_string_length = 0LL;
        M_p->_M_local_buf[0] = 0;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v29[0]._M_dataplus._M_p != &v29[0]._anon_0 )
          operator delete(v29[0]._M_dataplus._M_p);
        v9 = a2->input_type_.ptr_;
LABEL_46:
        a2->_has_bits_.has_bits_[0] |= 2u;
        if ( v9 != (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
          goto LABEL_8;
LABEL_47:
        google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(
          &a2->input_type_.ptr_,
          (__int64)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11]);
        v9 = a2->input_type_.ptr_;
        goto LABEL_8;
      }
    }
    v29[0]._M_dataplus._M_p = v29[0]._anon_0._M_local_buf;
    M_p = &v29[0]._anon_0;
    goto LABEL_43;
  }
  v9 = a2->input_type_.ptr_;
  a2->_has_bits_.has_bits_[0] = v8;
  if ( v9 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
    goto LABEL_47;
LABEL_8:
  v10 = this->input_type_.once_;
  if ( v10 && v10->state_ != 2 )
  {
    v29[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFE0;
    v29[0]._anon_0._M_local_buf[0] = 0;
    v29[0]._M_string_length = (std::string::size_type)google::protobuf::internal::LazyDescriptor::OnceStatic;
    *(&v29[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)&this->input_type_;
    google::protobuf::GoogleOnceInitImpl(&v10->state_, (google::protobuf::Closure *)v29);
    v29[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFE0;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v29);
  }
  std::string::_M_append(
    v9,
    this->input_type_.descriptor_->full_name_->_M_dataplus._M_p,
    this->input_type_.descriptor_->full_name_->_M_string_length);
  v12 = this->output_type_.once_;
  if ( v12 && v12->state_ != 2 )
  {
    v29[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFE0;
    v29[0]._anon_0._M_local_buf[0] = 0;
    v29[0]._M_string_length = (std::string::size_type)google::protobuf::internal::LazyDescriptor::OnceStatic;
    *(&v29[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)&this->output_type_;
    google::protobuf::GoogleOnceInitImpl(&v12->state_, (google::protobuf::Closure *)v29);
    v29[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFE0;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v29);
  }
  v13 = a2->_has_bits_.has_bits_[0] | 4;
  if ( !this->output_type_.descriptor_->is_unqualified_placeholder_ )
  {
    a2->_has_bits_.has_bits_[0] = v13;
    v29[0]._M_dataplus._M_p = v29[0]._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(v29, ".", "", v11);
    v19 = a2->output_type_.ptr_;
    if ( v19 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
    {
      v14 = (std::string *)operator new(0x20uLL);
      v14->_M_dataplus._M_p = v14->_anon_0._M_local_buf;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v29[0]._M_dataplus._M_p == &v29[0]._anon_0 )
      {
        v14->_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_load_si128((const __m128i *)&v29[0]._anon_0);
      }
      else
      {
        v14->_M_dataplus._M_p = v29[0]._M_dataplus._M_p;
        v14->_anon_0._M_allocated_capacity = v29[0]._anon_0._M_allocated_capacity;
      }
      v28 = v29[0]._M_string_length;
      a2->output_type_.ptr_ = v14;
      v14->_M_string_length = v28;
      goto LABEL_36;
    }
    p_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v19->_M_dataplus._M_p;
    v21 = v29[0]._M_string_length;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v29[0]._M_dataplus._M_p == &v29[0]._anon_0 )
    {
      if ( v29[0]._M_string_length )
      {
        if ( v29[0]._M_string_length == 1 )
          p_anon_0->_M_local_buf[0] = v29[0]._anon_0._M_local_buf[0];
        else
          memcpy(p_anon_0, &v29[0]._anon_0, v29[0]._M_string_length);
        v21 = v29[0]._M_string_length;
        p_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v19->_M_dataplus._M_p;
      }
      v19->_M_string_length = v21;
      p_anon_0->_M_local_buf[v21] = 0;
      p_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v29[0]._M_dataplus._M_p;
      goto LABEL_33;
    }
    if ( p_anon_0 == &v19->_anon_0 )
    {
      v19->_M_dataplus._M_p = v29[0]._M_dataplus._M_p;
      v19->_M_string_length = v21;
      v19->_anon_0._M_allocated_capacity = v29[0]._anon_0._M_allocated_capacity;
    }
    else
    {
      v19->_M_dataplus._M_p = v29[0]._M_dataplus._M_p;
      v22 = v19->_anon_0._M_allocated_capacity;
      v19->_M_string_length = v21;
      v19->_anon_0._M_allocated_capacity = v29[0]._anon_0._M_allocated_capacity;
      if ( p_anon_0 )
      {
        v29[0]._M_dataplus._M_p = (std::string::pointer)p_anon_0;
        v29[0]._anon_0._M_allocated_capacity = v22;
LABEL_33:
        v29[0]._M_string_length = 0LL;
        p_anon_0->_M_local_buf[0] = 0;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v29[0]._M_dataplus._M_p != &v29[0]._anon_0 )
          operator delete(v29[0]._M_dataplus._M_p);
        v14 = a2->output_type_.ptr_;
LABEL_36:
        a2->_has_bits_.has_bits_[0] |= 4u;
        if ( v14 != (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
          goto LABEL_16;
LABEL_37:
        google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena(
          &a2->output_type_.ptr_,
          (__int64)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11]);
        v14 = a2->output_type_.ptr_;
        goto LABEL_16;
      }
    }
    v29[0]._M_dataplus._M_p = v29[0]._anon_0._M_local_buf;
    p_anon_0 = &v29[0]._anon_0;
    goto LABEL_33;
  }
  v14 = a2->output_type_.ptr_;
  a2->_has_bits_.has_bits_[0] = v13;
  if ( v14 == (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
    goto LABEL_37;
LABEL_16:
  v15 = this->output_type_.once_;
  if ( v15 && v15->state_ != 2 )
  {
    v29[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFE0;
    v29[0]._anon_0._M_local_buf[0] = 0;
    v29[0]._M_string_length = (std::string::size_type)google::protobuf::internal::LazyDescriptor::OnceStatic;
    *(&v29[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)&this->output_type_;
    google::protobuf::GoogleOnceInitImpl(&v15->state_, (google::protobuf::Closure *)v29);
    v29[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFE0;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v29);
  }
  v16 = (google::protobuf::MethodOptions *)v14;
  std::string::_M_append(
    v14,
    this->output_type_.descriptor_->full_name_->_M_dataplus._M_p,
    this->output_type_.descriptor_->full_name_->_M_string_length);
  options = this->options_;
  if ( options != (const google::protobuf::MethodOptions *)google::protobuf::MethodOptions::default_instance(v16) )
  {
    v18 = a2->options_;
    a2->_has_bits_.has_bits_[0] |= 8u;
    if ( !v18 )
    {
      v18 = (google::protobuf::MethodOptions *)operator new(0x70uLL);
      google::protobuf::MethodOptions::MethodOptions(v18);
      a2->options_ = v18;
    }
    google::protobuf::MethodOptions::CopyFrom(v18, this->options_);
  }
  if ( this->client_streaming_ )
  {
    a2->_has_bits_.has_bits_[0] |= 0x10u;
    a2->client_streaming_ = 1;
  }
  if ( this->server_streaming_ )
  {
    a2->_has_bits_.has_bits_[0] |= 0x20u;
    a2->server_streaming_ = 1;
  }
};

// Line 2123: range 000000000C8FF390-000000000C8FFD48
__int64 __fastcall google::protobuf::`anonymous namespace'::RetrieveOptionsAssumingRightPool(
        int a1,
        google::protobuf::Message *a2,
        __m128i **a3)
{
  __m128i **v3; // r12
  __m128i *v4; // rbp
  void **v5; // r13
  void **v6; // rbx
  const google::protobuf::Message::Reflection *(__fastcall *v7)(const google::protobuf::Message *const); // rdx
  __int64 v8; // rdx
  _QWORD *v9; // rdi
  int v10; // r15d
  __m128i *v11; // rax
  __int64 v12; // rcx
  __int64 *p_truncate_string_field_longer_than; // rdi
  google::protobuf::int64 v14; // rsi
  __m128i *v15; // rax
  __m128i *v16; // rbx
  __int64 v17; // rbx
  google::protobuf::ProtobufOnceType *v18; // rdi
  int v19; // edx
  __int64 v20; // rax
  int v21; // ecx
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // r14
  __int64 m128i_i64; // rcx
  __m128i *v25; // r14
  __m128i *v26; // rax
  __m128i *v27; // rdx
  __int64 v28; // rsi
  const __m128i *v29; // rdx
  __m128i *v30; // rcx
  __int64 v31; // rsi
  __m128i *v32; // rdi
  google::protobuf::TextFormat::Printer *v33; // rdi
  __int64 v34; // rdx
  unsigned __int64 v36; // r14
  int v37; // [rsp+14h] [rbp-144h]
  __m128i *v39; // [rsp+20h] [rbp-138h]
  void *v40; // [rsp+20h] [rbp-138h]
  __int64 v41; // [rsp+28h] [rbp-130h]
  __int64 v42; // [rsp+30h] [rbp-128h]
  __m128i *v43; // [rsp+30h] [rbp-128h]
  char v44; // [rsp+3Bh] [rbp-11Dh]
  __int64 v46; // [rsp+48h] [rbp-110h]
  void *v47; // [rsp+50h] [rbp-108h] BYREF
  _BYTE *v48; // [rsp+58h] [rbp-100h]
  __int64 v49; // [rsp+60h] [rbp-F8h]
  std::string v50; // [rsp+70h] [rbp-E8h] BYREF
  char *__beg; // [rsp+90h] [rbp-C8h] BYREF
  __int64 v52; // [rsp+98h] [rbp-C0h]
  __int64 v53[2]; // [rsp+A0h] [rbp-B8h] BYREF
  std::string target; // [rsp+B0h] [rbp-A8h] BYREF
  google::protobuf::TextFormat::Printer closure; // [rsp+D0h] [rbp-88h] BYREF

  v3 = a3;
  v4 = *a3;
  v5 = (void **)a3[1];
  if ( *a3 != (__m128i *)v5 )
  {
    v6 = (void **)*a3;
    do
    {
      if ( *v6 != v6 + 2 )
        operator delete(*v6);
      v6 += 4;
    }
    while ( v5 != v6 );
    v3[1] = v4;
  }
  v7 = (const google::protobuf::Message::Reflection *(__fastcall *)(const google::protobuf::Message *const))*((_QWORD *)a2->_vptr_MessageLite + 23);
  if ( v7 == google::protobuf::Message::GetReflection )
  {
    (*((void (**)(void))a2->_vptr_MessageLite + 24))();
    v46 = v8;
  }
  else
  {
    v46 = (__int64)v7(a2);
  }
  v47 = 0LL;
  v48 = 0LL;
  v49 = 0LL;
  (*(void (__fastcall **)(__int64, google::protobuf::Message *, void **))(*(_QWORD *)v46 + 128LL))(v46, a2, &v47);
  v9 = v47;
  if ( v48 != v47 )
  {
    v41 = 0LL;
    while ( 1 )
    {
      v44 = 0;
      v37 = 1;
      if ( *(_DWORD *)(v9[v41] + 60LL) != 3 )
        goto LABEL_12;
      v37 = (*(__int64 (__fastcall **)(__int64, google::protobuf::Message *))(*(_QWORD *)v46 + 48LL))(v46, a2);
      if ( v37 > 0 )
        break;
LABEL_80:
      v9 = v47;
      if ( (v48 - (_BYTE *)v47) >> 3 <= (unsigned __int64)++v41 )
        goto LABEL_81;
    }
    v44 = 1;
    v9 = v47;
LABEL_12:
    v10 = 0;
    while ( 1 )
    {
      v50._anon_0._M_local_buf[0] = 0;
      v50._M_dataplus._M_p = v50._anon_0._M_local_buf;
      v50._M_string_length = 0LL;
      v17 = v9[v41];
      v18 = *(google::protobuf::ProtobufOnceType **)(v17 + 48);
      if ( v18 && *v18 != 2 )
      {
        LOBYTE(closure.truncate_string_field_longer_than_) = 0;
        *(_QWORD *)&closure.initial_indent_level_ = &off_1A17BF90;
        *(_QWORD *)&closure.print_message_fields_in_index_order_ = google::protobuf::FieldDescriptor::TypeOnceInit;
        closure.default_field_value_printer_.ptr_ = (const google::protobuf::TextFormat::FastFieldValuePrinter *)v17;
        google::protobuf::GoogleOnceInitImpl(v18, (google::protobuf::Closure *)&closure);
        *(_QWORD *)&closure.initial_indent_level_ = &off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&closure);
      }
      if ( google::protobuf::FieldDescriptor::kTypeToCppTypeMap[*(int *)(v17 + 56)] == CPPTYPE_MESSAGE_0 )
      {
        target._M_string_length = 0LL;
        target._M_dataplus._M_p = target._anon_0._M_local_buf;
        target._anon_0._M_local_buf[0] = 0;
        google::protobuf::TextFormat::Printer::Printer(&closure);
        v21 = -1;
        closure.initial_indent_level_ = a1 + 1;
        if ( v44 )
          v21 = v10;
        google::protobuf::TextFormat::Printer::PrintFieldValueToString(
          &closure,
          a2,
          *((google::protobuf::FieldDescriptor **)v47 + v41),
          v21,
          &target);
        if ( v50._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v50._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        std::string::_M_append(&v50, "{\n", 2LL);
        std::string::_M_append(&v50, target._M_dataplus._M_p, target._M_string_length);
        std::string::_M_replace_aux(&v50, v50._M_string_length, 0LL, 2 * a1, 32LL);
        if ( v50._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
          std::__throw_length_error("basic_string::append");
        std::string::_M_append(&v50, "}", 1LL);
        google::protobuf::TextFormat::Printer::~Printer(&closure);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)target._M_dataplus._M_p != &target._anon_0 )
          operator delete(target._M_dataplus._M_p);
      }
      else
      {
        v19 = -1;
        if ( v44 )
          v19 = v10;
        google::protobuf::TextFormat::PrintFieldValueToString(
          a2,
          *((google::protobuf::FieldDescriptor **)v47 + v41),
          v19,
          &v50);
      }
      LOBYTE(v53[0]) = 0;
      __beg = (char *)v53;
      v52 = 0LL;
      v20 = *((_QWORD *)v47 + v41);
      if ( !*(_BYTE *)(v20 + 66) )
      {
        std::string::_M_assign(&__beg, *(_QWORD *)v20);
        goto LABEL_24;
      }
      std::operator+<char>(&target, "(.", *(const std::string **)(v20 + 8));
      if ( target._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
        std::__throw_length_error("basic_string::append");
      v11 = (__m128i *)std::string::_M_append(&target, ")", 1LL);
      *(_QWORD *)&closure.initial_indent_level_ = &closure.truncate_string_field_longer_than_;
      if ( (__m128i *)v11->m128i_i64[0] == &v11[1] )
      {
        *(__m128i *)&closure.truncate_string_field_longer_than_ = _mm_loadu_si128(v11 + 1);
      }
      else
      {
        *(_QWORD *)&closure.initial_indent_level_ = v11->m128i_i64[0];
        closure.truncate_string_field_longer_than_ = v11[1].m128i_i64[0];
      }
      v12 = v11->m128i_i64[1];
      *(_QWORD *)&closure.print_message_fields_in_index_order_ = v12;
      v11->m128i_i64[0] = (__int64)v11[1].m128i_i64;
      p_truncate_string_field_longer_than = (__int64 *)__beg;
      v11->m128i_i64[1] = 0LL;
      v11[1].m128i_i8[0] = 0;
      if ( *(google::protobuf::TextFormat::Printer **)&closure.initial_indent_level_ == (google::protobuf::TextFormat::Printer *)&closure.truncate_string_field_longer_than_ )
      {
        v34 = *(_QWORD *)&closure.print_message_fields_in_index_order_;
        if ( *(_QWORD *)&closure.print_message_fields_in_index_order_ )
        {
          if ( *(_QWORD *)&closure.print_message_fields_in_index_order_ == 1LL )
            *(_BYTE *)p_truncate_string_field_longer_than = closure.truncate_string_field_longer_than_;
          else
            memcpy(
              p_truncate_string_field_longer_than,
              &closure.truncate_string_field_longer_than_,
              *(size_t *)&closure.print_message_fields_in_index_order_);
          v34 = *(_QWORD *)&closure.print_message_fields_in_index_order_;
          p_truncate_string_field_longer_than = (__int64 *)__beg;
        }
        v52 = v34;
        *((_BYTE *)p_truncate_string_field_longer_than + v34) = 0;
        p_truncate_string_field_longer_than = *(__int64 **)&closure.initial_indent_level_;
        goto LABEL_20;
      }
      LOBYTE(v12) = closure.print_message_fields_in_index_order_;
      if ( p_truncate_string_field_longer_than == v53 )
        break;
      v14 = v53[0];
      __beg = *(char **)&closure.initial_indent_level_;
      v52 = *(_QWORD *)&closure.print_message_fields_in_index_order_;
      v53[0] = closure.truncate_string_field_longer_than_;
      if ( !p_truncate_string_field_longer_than )
        goto LABEL_85;
      *(_QWORD *)&closure.initial_indent_level_ = p_truncate_string_field_longer_than;
      closure.truncate_string_field_longer_than_ = v14;
LABEL_20:
      *(_QWORD *)&closure.print_message_fields_in_index_order_ = 0LL;
      *(_BYTE *)p_truncate_string_field_longer_than = 0;
      if ( *(google::protobuf::TextFormat::Printer **)&closure.initial_indent_level_ != (google::protobuf::TextFormat::Printer *)&closure.truncate_string_field_longer_than_ )
        operator delete(*(void **)&closure.initial_indent_level_);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)target._M_dataplus._M_p != &target._anon_0 )
        operator delete(target._M_dataplus._M_p);
LABEL_24:
      target._M_dataplus._M_p = target._anon_0._M_local_buf;
      std::string::_M_construct<char *>(&target, __beg, &__beg[v52], (std::forward_iterator_tag)v12);
      if ( 0x3FFFFFFFFFFFFFFFLL - target._M_string_length <= 2 )
        std::__throw_length_error("basic_string::append");
      std::string::_M_append(&target, " = ", 3LL);
      v15 = (__m128i *)std::string::_M_append(&target, v50._M_dataplus._M_p, v50._M_string_length);
      *(_QWORD *)&closure.initial_indent_level_ = &closure.truncate_string_field_longer_than_;
      if ( (__m128i *)v15->m128i_i64[0] == &v15[1] )
      {
        *(__m128i *)&closure.truncate_string_field_longer_than_ = _mm_loadu_si128(v15 + 1);
      }
      else
      {
        *(_QWORD *)&closure.initial_indent_level_ = v15->m128i_i64[0];
        closure.truncate_string_field_longer_than_ = v15[1].m128i_i64[0];
      }
      *(_QWORD *)&closure.print_message_fields_in_index_order_ = v15->m128i_i64[1];
      v15[1].m128i_i8[0] = 0;
      v16 = v3[1];
      v15->m128i_i64[0] = (__int64)v15[1].m128i_i64;
      v15->m128i_i64[1] = 0LL;
      if ( v16 != v3[2] )
      {
        v16->m128i_i64[0] = (__int64)v16[1].m128i_i64;
        if ( *(google::protobuf::TextFormat::Printer **)&closure.initial_indent_level_ == (google::protobuf::TextFormat::Printer *)&closure.truncate_string_field_longer_than_ )
        {
          v16[1] = _mm_load_si128((const __m128i *)&closure.truncate_string_field_longer_than_);
        }
        else
        {
          v16->m128i_i64[0] = *(_QWORD *)&closure.initial_indent_level_;
          v16[1].m128i_i64[0] = closure.truncate_string_field_longer_than_;
        }
        v16->m128i_i64[1] = *(_QWORD *)&closure.print_message_fields_in_index_order_;
        v3[1] += 2;
        goto LABEL_31;
      }
      v39 = *v3;
      v42 = (char *)v16 - (char *)*v3;
      v22 = v42 >> 5;
      if ( v42 >> 5 == 0x3FFFFFFFFFFFFFFLL )
        std::__throw_length_error("vector::_M_realloc_insert");
      if ( !v22 )
      {
        v36 = 2LL;
LABEL_87:
        v26 = (__m128i *)operator new(v36 * 16);
        v25 = &v26[v36];
        m128i_i64 = (__int64)v26[2].m128i_i64;
        goto LABEL_61;
      }
      v23 = 2 * v22;
      if ( v22 > 2 * v22 )
      {
        v36 = 0x7FFFFFFFFFFFFFELL;
        goto LABEL_87;
      }
      if ( v23 )
      {
        if ( v23 > 0x3FFFFFFFFFFFFFFLL )
          v23 = 0x3FFFFFFFFFFFFFFLL;
        v36 = 2 * v23;
        goto LABEL_87;
      }
      m128i_i64 = 32LL;
      v25 = 0LL;
      v26 = 0LL;
LABEL_61:
      v27 = (__m128i *)((char *)v26 + v42);
      *(__int64 *)((char *)v26->m128i_i64 + v42) = (__int64)v26[1].m128i_i64 + v42;
      if ( *(google::protobuf::TextFormat::Printer **)&closure.initial_indent_level_ == (google::protobuf::TextFormat::Printer *)&closure.truncate_string_field_longer_than_ )
      {
        v27[1] = _mm_load_si128((const __m128i *)&closure.truncate_string_field_longer_than_);
      }
      else
      {
        v27->m128i_i64[0] = *(_QWORD *)&closure.initial_indent_level_;
        v27[1].m128i_i64[0] = closure.truncate_string_field_longer_than_;
      }
      v28 = *(_QWORD *)&closure.print_message_fields_in_index_order_;
      *(_QWORD *)&closure.initial_indent_level_ = &closure.truncate_string_field_longer_than_;
      *(_QWORD *)&closure.print_message_fields_in_index_order_ = 0LL;
      v27->m128i_i64[1] = v28;
      v29 = v39;
      LOBYTE(closure.truncate_string_field_longer_than_) = 0;
      if ( v16 != v39 )
      {
        v30 = v26;
        do
        {
          v30->m128i_i64[0] = (__int64)v30[1].m128i_i64;
          if ( (const __m128i *)v29->m128i_i64[0] == &v29[1] )
          {
            v30[1] = _mm_loadu_si128(v29 + 1);
          }
          else
          {
            v30->m128i_i64[0] = v29->m128i_i64[0];
            v30[1].m128i_i64[0] = v29[1].m128i_i64[0];
          }
          v31 = v29->m128i_i64[1];
          v29 += 2;
          v30 += 2;
          v30[-2].m128i_i64[1] = v31;
        }
        while ( v16 != v29 );
        m128i_i64 = (__int64)v26[2].m128i_i64 + (char *)v16 - (char *)v39;
      }
      v32 = v39;
      if ( v39 )
      {
        v43 = v26;
        v40 = (void *)m128i_i64;
        operator delete(v32);
        v26 = v43;
        m128i_i64 = (__int64)v40;
      }
      v33 = *(google::protobuf::TextFormat::Printer **)&closure.initial_indent_level_;
      *v3 = v26;
      v3[1] = (__m128i *)m128i_i64;
      v3[2] = v25;
      if ( v33 != (google::protobuf::TextFormat::Printer *)&closure.truncate_string_field_longer_than_ )
        operator delete(v33);
LABEL_31:
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)target._M_dataplus._M_p != &target._anon_0 )
        operator delete(target._M_dataplus._M_p);
      if ( __beg != (char *)v53 )
        operator delete(__beg);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v50._M_dataplus._M_p != &v50._anon_0 )
        operator delete(v50._M_dataplus._M_p);
      if ( ++v10 >= v37 )
        goto LABEL_80;
      v9 = v47;
    }
    __beg = *(char **)&closure.initial_indent_level_;
    v52 = *(_QWORD *)&closure.print_message_fields_in_index_order_;
    v53[0] = closure.truncate_string_field_longer_than_;
LABEL_85:
    *(_QWORD *)&closure.initial_indent_level_ = &closure.truncate_string_field_longer_than_;
    p_truncate_string_field_longer_than = &closure.truncate_string_field_longer_than_;
    goto LABEL_20;
  }
LABEL_81:
  LOBYTE(v3) = v3[1] != *v3;
  if ( v9 )
    operator delete(v9);
  return (unsigned int)v3;
};

// Line 2164: range 000000000C908350-000000000C9084DE
__int64 __fastcall google::protobuf::`anonymous namespace'::RetrieveOptions(
        int a1,
        google::protobuf::Message *a2,
        google::protobuf::DescriptorPool *this,
        __m128i **a4)
{
  __int64 v6; // rax
  const google::protobuf::Descriptor *MessageTypeByName; // r12
  __int64 Prototype; // rax
  google::protobuf::Message *v9; // r15
  char v10; // r12
  google::protobuf::internal::LogMessage_0 *v11; // r12
  __int64 v12; // rax
  google::protobuf::internal::LogMessage_0 *v13; // rax
  unsigned int OptionsAssumingRightPool; // eax
  unsigned int v15; // r12d
  google::protobuf::internal::LogFinisher v17; // [rsp+Fh] [rbp-99h] BYREF
  google::protobuf::DynamicMessageFactory v18; // [rsp+10h] [rbp-98h] BYREF
  google::protobuf::internal::LogMessage_0 v19; // [rsp+40h] [rbp-68h] BYREF

  if ( *(google::protobuf::DescriptorPool **)(*(_QWORD *)((*((__int64 (__fastcall **)(google::protobuf::Message *))a2->_vptr_MessageLite
                                                           + 24))(a2)
                                                        + 16)
                                            + 16LL) == this )
    return (unsigned int)google::protobuf::`anonymous namespace'::RetrieveOptionsAssumingRightPool(a1, a2, a4);
  v6 = (*((__int64 (__fastcall **)(google::protobuf::Message *))a2->_vptr_MessageLite + 24))(a2);
  MessageTypeByName = google::protobuf::DescriptorPool::FindMessageTypeByName(this, *(const std::string **)(v6 + 8));
  if ( !MessageTypeByName )
  {
    return (unsigned int)google::protobuf::`anonymous namespace'::RetrieveOptionsAssumingRightPool(a1, a2, a4);
  }
  else
  {
    google::protobuf::DynamicMessageFactory::DynamicMessageFactory(&v18);
    Prototype = google::protobuf::DynamicMessageFactory::GetPrototype(&v18, MessageTypeByName);
    v9 = (google::protobuf::Message *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)Prototype + 24LL))(Prototype);
    google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&v19, a2);
    v10 = google::protobuf::MessageLite::ParseFromString(v9, &v19);
    if ( *(google::protobuf::internal::LogMessage_0 **)&v19.level_ != (google::protobuf::internal::LogMessage_0 *)&v19.line_ )
      operator delete(*(void **)&v19.level_);
    if ( v10 )
    {
      OptionsAssumingRightPool = google::protobuf::`anonymous namespace'::RetrieveOptionsAssumingRightPool(a1, v9, a4);
    }
    else
    {
      google::protobuf::internal::LogMessage::LogMessage(&v19, LOGLEVEL_ERROR_0, "google/protobuf/descriptor.cc", 2189);
      v11 = google::protobuf::internal::LogMessage::operator<<(&v19, "Found invalid proto option data for: ");
      v12 = (*((__int64 (__fastcall **)(google::protobuf::Message *))a2->_vptr_MessageLite + 24))(a2);
      v13 = google::protobuf::internal::LogMessage::operator<<(v11, *(const std::string **)(v12 + 8));
      google::protobuf::internal::LogFinisher::operator=(&v17, v13);
      google::protobuf::internal::LogMessage::~LogMessage(&v19);
      OptionsAssumingRightPool = google::protobuf::`anonymous namespace'::RetrieveOptionsAssumingRightPool(a1, a2, a4);
    }
    v15 = OptionsAssumingRightPool;
    if ( v9 )
      (*((void (__fastcall **)(google::protobuf::Message *))v9->_vptr_MessageLite + 1))(v9);
    google::protobuf::DynamicMessageFactory::~DynamicMessageFactory(&v18);
  }
  return v15;
};

// Line 2189: range 000000000C72EF54-000000000C72EF79
void __fastcall __noreturn google::protobuf::`anonymous namespace'::RetrieveOptions(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::DynamicMessageFactory a8,
        __int64 a9,
        google::protobuf::internal::LogMessage_0 a10)
{
  struct _Unwind_Exception *v10; // rbp
  __int64 v11; // r15

  google::protobuf::internal::LogMessage::~LogMessage(&a10);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
  google::protobuf::DynamicMessageFactory::~DynamicMessageFactory(&a8);
  _Unwind_Resume(v10);
};

// Line 2198: range 000000000C9097A0-000000000C909902
__int64 __fastcall google::protobuf::`anonymous namespace'::FormatBracketedOptions(
        int a1,
        google::protobuf::Message *a2,
        google::protobuf::DescriptorPool *a3,
        __int64 a4)
{
  void **v4; // r12
  char Options; // al
  void **v7; // rbp
  void **v8; // rbx
  std::string::size_type M_string_length; // rdx
  std::string::$CFBEC286C7F52157F7E59FC354047095 *p_anon_0; // rsi
  int v12[2]; // [rsp+0h] [rbp-A8h] BYREF
  void *v13; // [rsp+8h] [rbp-A0h]
  _QWORD v14[2]; // [rsp+10h] [rbp-98h]
  std::string result; // [rsp+20h] [rbp-88h] BYREF
  google::protobuf::strings::AlphaNum a; // [rsp+40h] [rbp-68h] BYREF

  *(_QWORD *)v12 = 0LL;
  v13 = 0LL;
  v14[0] = 0LL;
  Options = google::protobuf::`anonymous namespace'::RetrieveOptions(a1, a2, a3, (__m128i **)v12);
  v7 = (void **)v13;
  v8 = *(void ***)v12;
  if ( Options )
  {
    result._anon_0._M_local_buf[0] = 0;
    v4 = *(void ***)v12;
    M_string_length = 0LL;
    result._M_dataplus._M_p = result._anon_0._M_local_buf;
    p_anon_0 = &result._anon_0;
    result._M_string_length = 0LL;
    if ( *(void **)v12 != v13 )
    {
      while ( 1 )
      {
        a.piece_data_ = (const char *)*v4;
        a.piece_size_ = (size_t)v4[1];
        google::protobuf::StrAppend(&result, &a);
        v4 += 4;
        if ( v4 == v7 )
          break;
        if ( v8 != v4 )
        {
          if ( 0x3FFFFFFFFFFFFFFFLL - result._M_string_length <= 1 )
            std::__throw_length_error("basic_string::append");
          std::string::_M_append(&result, ", ", 2LL);
        }
      }
      M_string_length = result._M_string_length;
      p_anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)result._M_dataplus._M_p;
    }
    std::string::_M_append(a4, p_anon_0->_M_local_buf, M_string_length);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)result._M_dataplus._M_p != &result._anon_0 )
      operator delete(result._M_dataplus._M_p);
    v7 = (void **)v13;
    v8 = *(void ***)v12;
  }
  LOBYTE(v4) = v8 != v7;
  if ( v8 != v7 )
  {
    do
    {
      if ( *v8 != v8 + 2 )
        operator delete(*v8);
      v8 += 4;
    }
    while ( v8 != v7 );
    v7 = *(void ***)v12;
  }
  if ( v7 )
    operator delete(v7);
  return (unsigned int)v4;
};

// Line 2209: range 000000000C9084F0-000000000C908768
__int64 __fastcall google::protobuf::`anonymous namespace'::FormatLineOptions(
        int a1,
        google::protobuf::Message *a2,
        google::protobuf::DescriptorPool *this,
        __int64 a4)
{
  __int64 *v5; // r12
  char Options; // al
  void **v7; // r13
  void **v8; // r14
  unsigned __int64 v9; // rbx
  __int64 *v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rax
  int v15[2]; // [rsp+10h] [rbp-250h] BYREF
  void *v16; // [rsp+18h] [rbp-248h]
  __int64 v17; // [rsp+20h] [rbp-240h]
  void *v18; // [rsp+30h] [rbp-230h] BYREF
  __int64 v19; // [rsp+38h] [rbp-228h]
  char v20[16]; // [rsp+40h] [rbp-220h] BYREF
  void *v21; // [rsp+50h] [rbp-210h] BYREF
  int v22; // [rsp+58h] [rbp-208h]
  __int64 v23; // [rsp+80h] [rbp-1E0h] BYREF
  int v24; // [rsp+88h] [rbp-1D8h]
  __int64 v25; // [rsp+B0h] [rbp-1B0h] BYREF
  int v26; // [rsp+B8h] [rbp-1A8h]
  __int64 v27; // [rsp+E0h] [rbp-180h] BYREF
  int v28; // [rsp+E8h] [rbp-178h]
  __int64 v29; // [rsp+110h] [rbp-150h] BYREF
  int v30; // [rsp+118h] [rbp-148h]
  __int64 v31; // [rsp+140h] [rbp-120h] BYREF
  int v32; // [rsp+148h] [rbp-118h]
  __int64 v33; // [rsp+170h] [rbp-F0h] BYREF
  int v34; // [rsp+178h] [rbp-E8h]
  __int64 v35; // [rsp+1A0h] [rbp-C0h] BYREF
  int v36; // [rsp+1A8h] [rbp-B8h]
  __int64 v37; // [rsp+1D0h] [rbp-90h] BYREF
  int v38; // [rsp+1D8h] [rbp-88h]
  __int64 v39; // [rsp+200h] [rbp-60h] BYREF
  int v40; // [rsp+208h] [rbp-58h]

  LODWORD(v5) = a1;
  v18 = v20;
  std::string::_M_construct(&v18, 2 * a1, 32LL);
  *(_QWORD *)v15 = 0LL;
  v16 = 0LL;
  v17 = 0LL;
  Options = google::protobuf::`anonymous namespace'::RetrieveOptions(a1, a2, this, (__m128i **)v15);
  v7 = (void **)v16;
  v8 = *(void ***)v15;
  if ( Options )
  {
    if ( *(void **)v15 == v16 )
    {
      LODWORD(v5) = 0;
      goto LABEL_10;
    }
    v9 = 0LL;
    v5 = &v31;
    do
    {
      v39 = 0LL;
      v37 = 0LL;
      v10 = (__int64 *)&v8[4 * v9];
      v35 = 0LL;
      v33 = 0LL;
      v31 = 0LL;
      v29 = 0LL;
      v27 = 0LL;
      v25 = 0LL;
      v11 = *v10;
      v12 = v10[1];
      v40 = -1;
      v23 = v11;
      v24 = v12;
      v38 = -1;
      v21 = v18;
      v36 = -1;
      v22 = v19;
      v34 = -1;
      v32 = -1;
      v30 = -1;
      v28 = -1;
      v26 = -1;
      google::protobuf::strings::SubstituteAndAppend(
        a4,
        "$0option $1;\n",
        &v21,
        &v23,
        &v25,
        &v27,
        &v29,
        &v31,
        &v33,
        &v35,
        &v37,
        &v39);
      v7 = (void **)v16;
      v8 = *(void ***)v15;
      ++v9;
    }
    while ( ((__int64)v16 - *(_QWORD *)v15) >> 5 > v9 );
  }
  LOBYTE(v5) = v8 != v7;
  if ( v8 != v7 )
  {
    do
    {
      if ( *v8 != v8 + 2 )
        operator delete(*v8);
      v8 += 4;
    }
    while ( v8 != v7 );
    v7 = *(void ***)v15;
  }
LABEL_10:
  if ( v7 )
    operator delete(v7);
  if ( v18 != v20 )
    operator delete(v18);
  return (unsigned int)v5;
};

// Line 2211: range 000000000C72EF94-000000000C72EFBB
void __fastcall __noreturn google::protobuf::`anonymous namespace'::FormatLineOptions()
{
  struct _Unwind_Exception *v0; // rbx
  __int64 v1; // rbp
  void *v2; // rdi

  std::vector<std::string>::~vector((std::vector<std::string> *const)(v1 - 592));
  v2 = *(void **)(v1 - 560);
  if ( v2 != (void *)(v1 - 544) )
    operator delete(v2);
  _Unwind_Resume(v0);
};

// Line 2221: range 000000000C72D3DC-000000000C72D457
void __fastcall google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::~SourceLocationCommentPrinter(
        google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *const this)
{
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *M_p; // rdi
  std::_Vector_base<std::string>::pointer M_finish; // r12
  std::_Vector_base<std::string>::pointer i; // rbp
  std::_Vector_base<std::string>::pointer M_start; // rdi
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *v6; // rdi
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *v7; // rdi

  M_p = (google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *)this->prefix_._M_dataplus._M_p;
  if ( M_p != (google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *)&this->prefix_._anon_0 )
    operator delete(M_p);
  M_finish = this->source_loc_.leading_detached_comments._M_impl._M_finish;
  for ( i = this->source_loc_.leading_detached_comments._M_impl._M_start; M_finish != i; ++i )
  {
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)i->_M_dataplus._M_p != &i->_anon_0 )
      operator delete(i->_M_dataplus._M_p);
  }
  M_start = this->source_loc_.leading_detached_comments._M_impl._M_start;
  if ( M_start )
    operator delete(M_start);
  v6 = (google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *)this->source_loc_.trailing_comments._M_dataplus._M_p;
  if ( v6 != (google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *)&this->source_loc_.trailing_comments._anon_0 )
    operator delete(v6);
  v7 = (google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *)this->source_loc_.leading_comments._M_dataplus._M_p;
  if ( v7 != (google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *)&this->source_loc_.leading_comments._anon_0 )
    operator delete(v7);
};

// Line 2244: range 000000000C9006B0-000000000C900E13
void __fastcall google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        std::forward_iterator_tag a4)
{
  __int64 v5; // rax
  unsigned __int64 v6; // r12
  void **v7; // rax
  char *v8; // rax
  void *v9; // rdx
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  void **v13; // r15
  __int64 v14; // rdx
  char *v15; // rsi
  void **v16; // r12
  void **v17; // r12
  void *v18; // rax
  void *v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  void **v22; // r14
  unsigned __int64 v23; // [rsp-280h] [rbp-280h]
  void **v24; // [rsp-280h] [rbp-280h]
  unsigned __int64 v25; // [rsp-280h] [rbp-280h]
  void **v26; // [rsp-278h] [rbp-278h] BYREF
  void **v27; // [rsp-270h] [rbp-270h]
  __int64 v28; // [rsp-268h] [rbp-268h]
  char *v29; // [rsp-258h] [rbp-258h] BYREF
  __int64 v30; // [rsp-250h] [rbp-250h]
  _BYTE v31[16]; // [rsp-248h] [rbp-248h] BYREF
  std::string v32; // [rsp-238h] [rbp-238h] BYREF
  __int64 v33; // [rsp-218h] [rbp-218h] BYREF
  int v34; // [rsp-210h] [rbp-210h]
  void *v35; // [rsp-1E8h] [rbp-1E8h] BYREF
  int v36; // [rsp-1E0h] [rbp-1E0h]
  __int64 v37; // [rsp-1B8h] [rbp-1B8h] BYREF
  int v38; // [rsp-1B0h] [rbp-1B0h]
  __int64 v39; // [rsp-188h] [rbp-188h] BYREF
  int v40; // [rsp-180h] [rbp-180h]
  __int64 v41; // [rsp-158h] [rbp-158h] BYREF
  int v42; // [rsp-150h] [rbp-150h]
  __int64 v43; // [rsp-128h] [rbp-128h] BYREF
  int v44; // [rsp-120h] [rbp-120h]
  __int64 v45; // [rsp-F8h] [rbp-F8h] BYREF
  int v46; // [rsp-F0h] [rbp-F0h]
  __int64 v47; // [rsp-C8h] [rbp-C8h] BYREF
  int v48; // [rsp-C0h] [rbp-C0h]
  __int64 v49; // [rsp-98h] [rbp-98h] BYREF
  int v50; // [rsp-90h] [rbp-90h]
  __int64 v51; // [rsp-68h] [rbp-68h] BYREF
  int v52; // [rsp-60h] [rbp-60h]

  if ( *(_BYTE *)a1 )
  {
    v5 = *(_QWORD *)(a1 + 88);
    if ( *(_QWORD *)(a1 + 96) != v5 )
    {
      v6 = 0LL;
      do
      {
        v32._M_dataplus._M_p = v32._anon_0._M_local_buf;
        std::string::_M_construct<char *>(
          &v32,
          *(char **)(32 * v6 + v5),
          (char *)(*(_QWORD *)(32 * v6 + v5) + *(_QWORD *)(32 * v6 + v5 + 8)),
          (std::forward_iterator_tag)&v32._anon_0);
        google::protobuf::StripWhitespace(&v32);
        v26 = 0LL;
        v27 = 0LL;
        v28 = 0LL;
        google::protobuf::SplitStringUsing(&v32, "\n", &v26);
        v31[0] = 0;
        v29 = v31;
        v7 = v26;
        v30 = 0LL;
        if ( v27 != v26 )
        {
          v23 = 0LL;
          do
          {
            v51 = 0LL;
            v49 = 0LL;
            v47 = 0LL;
            v8 = (char *)&v7[4 * v23];
            v45 = 0LL;
            v43 = 0LL;
            v41 = 0LL;
            v39 = 0LL;
            v37 = 0LL;
            v9 = *(void **)v8;
            v10 = *((_QWORD *)v8 + 1);
            v52 = -1;
            v35 = v9;
            v36 = v10;
            v11 = *(_QWORD *)(a1 + 120);
            v50 = -1;
            v33 = v11;
            v12 = *(_QWORD *)(a1 + 128);
            v48 = -1;
            v46 = -1;
            v44 = -1;
            v42 = -1;
            v40 = -1;
            v38 = -1;
            v34 = v12;
            google::protobuf::strings::SubstituteAndAppend(
              &v29,
              "$0// $1\n",
              &v33,
              &v35,
              &v37,
              &v39,
              &v41,
              &v43,
              &v45,
              &v47,
              &v49,
              &v51);
            v7 = v26;
            ++v23;
          }
          while ( v23 < ((char *)v27 - (char *)v26) >> 5 );
          if ( v26 != v27 )
          {
            v24 = v26;
            v13 = v27;
            do
            {
              if ( *v24 != v24 + 2 )
                operator delete(*v24);
              v24 += 4;
            }
            while ( v13 != v24 );
          }
        }
        if ( v26 )
          operator delete(v26);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v32._M_dataplus._M_p != &v32._anon_0 )
          operator delete(v32._M_dataplus._M_p);
        std::string::_M_append(a2, v29, v30);
        if ( v29 != v31 )
          operator delete(v29);
        if ( *(_QWORD *)(a2 + 8) == 0x3FFFFFFFFFFFFFFFLL )
          std::__throw_length_error("basic_string::append");
        ++v6;
        std::string::_M_append(a2, "\n", 1LL);
        v5 = *(_QWORD *)(a1 + 88);
      }
      while ( (*(_QWORD *)(a1 + 96) - v5) >> 5 > v6 );
    }
    v14 = *(_QWORD *)(a1 + 32);
    if ( v14 )
    {
      v15 = *(char **)(a1 + 24);
      v32._M_dataplus._M_p = v32._anon_0._M_local_buf;
      std::string::_M_construct<char *>(&v32, v15, &v15[v14], a4);
      google::protobuf::StripWhitespace(&v32);
      v26 = 0LL;
      v27 = 0LL;
      v28 = 0LL;
      google::protobuf::SplitStringUsing(&v32, "\n", &v26);
      v31[0] = 0;
      v16 = v26;
      v29 = v31;
      v30 = 0LL;
      if ( v26 != v27 )
      {
        v25 = 0LL;
        do
        {
          v51 = 0LL;
          v49 = 0LL;
          v47 = 0LL;
          v17 = &v16[4 * v25];
          v45 = 0LL;
          v43 = 0LL;
          v41 = 0LL;
          v39 = 0LL;
          v37 = 0LL;
          v18 = *v17;
          v52 = -1;
          v35 = v18;
          v19 = v17[1];
          v50 = -1;
          v36 = (int)v19;
          v20 = *(_QWORD *)(a1 + 120);
          v48 = -1;
          v33 = v20;
          v21 = *(_QWORD *)(a1 + 128);
          v46 = -1;
          v44 = -1;
          v42 = -1;
          v40 = -1;
          v38 = -1;
          v34 = v21;
          google::protobuf::strings::SubstituteAndAppend(
            &v29,
            "$0// $1\n",
            &v33,
            &v35,
            &v37,
            &v39,
            &v41,
            &v43,
            &v45,
            &v47,
            &v49,
            &v51);
          v22 = v27;
          v16 = v26;
          ++v25;
        }
        while ( ((char *)v27 - (char *)v26) >> 5 > v25 );
        if ( v26 != v27 )
        {
          do
          {
            if ( *v16 != v16 + 2 )
              operator delete(*v16);
            v16 += 4;
          }
          while ( v22 != v16 );
        }
      }
      if ( v26 )
        operator delete(v26);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v32._M_dataplus._M_p != &v32._anon_0 )
        operator delete(v32._M_dataplus._M_p);
      std::string::_M_append(a2, v29, v30);
      if ( v29 != v31 )
        operator delete(v29);
    }
  }
};

// Line 2286: range 000000000C919570-000000000C919598
std::string *__fastcall google::protobuf::FileDescriptor::DebugString[abi:cxx11](
        std::string *retstr,
        const google::protobuf::FileDescriptor *const this)
{
  google::protobuf::FileDescriptor::DebugStringWithOptions[abi:cxx11](
    (google::protobuf::FileDescriptor::Syntax)retstr,
    (google::protobuf::FileDescriptor *)this);
  return retstr;
};

// Line 2292: range 000000000C9176F0-000000000C919562
__int64 __fastcall google::protobuf::FileDescriptor::DebugStringWithOptions[abi:cxx11](
        __int64 a1,
        google::protobuf::FileDescriptor *this,
        char *a3,
        const int *a4)
{
  std::forward_iterator_tag v7; // cl
  __int16 v8; // ax
  std::forward_iterator_tag v9; // cl
  __int64 v10; // rdx
  std::forward_iterator_tag v11; // cl
  char SourceLocation; // al
  google::protobuf::FileDescriptor *syntax; // rdi
  std::forward_iterator_tag v14; // cl
  std::_Vector_base<std::string>::pointer M_start; // r13
  std::_Vector_base<std::string>::pointer M_finish; // r14
  __int16 v17; // ax
  std::forward_iterator_tag v18; // cl
  __int64 v19; // rdx
  std::forward_iterator_tag v20; // cl
  char v21; // al
  int *public_dependencies; // rcx
  __int64 public_dependency_count; // rax
  int *weak_dependencies; // rcx
  std::_Rb_tree_node_base::_Base_ptr M_parent; // rax
  google::protobuf::GoogleOnceDynamic *dependencies_once; // rdi
  std::_Rb_tree_header *v27; // rdx
  std::_Rb_tree_node_base::_Base_ptr v28; // rax
  std::_Rb_tree_header *v29; // rdx
  const std::string *v30; // rax
  int (**v31)(...); // rdx
  const std::string *name; // rax
  int (**M_p)(...); // rdx
  std::forward_iterator_tag v34; // cl
  __int16 v35; // ax
  std::forward_iterator_tag v36; // cl
  __int64 v37; // rdx
  std::forward_iterator_tag v38; // cl
  char v39; // al
  const std::string *package; // rax
  std::string::pointer v41; // rdx
  std::string::size_type M_string_length; // rax
  std::_Vector_base<std::string>::pointer v43; // r13
  std::_Vector_base<std::string>::pointer v44; // r14
  __int64 i; // r13
  int extension_count; // esi
  google::protobuf::FieldDescriptor *v47; // r14
  google::protobuf::ProtobufOnceType *p_state; // rdi
  const std::string *v49; // rax
  int (**v50)(...); // rdx
  google::protobuf::ProtobufOnceType *v51; // rdi
  int message_type_count; // ecx
  __int64 v53; // r14
  std::_Rb_tree_node_base::_Base_ptr v54; // rax
  google::protobuf::Descriptor *v55; // rdi
  std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *v56; // rdx
  __int64 j; // r14
  int v58; // r13d
  const google::protobuf::Descriptor *containing_type; // r14
  const std::string *full_name; // rax
  int (**v61)(...); // rdx
  std::string::size_type v62; // rax
  google::protobuf::FieldDescriptor *v63; // rdi
  int v64; // eax
  void **v65; // rbx
  void *v66; // rdi
  void **v67; // r15
  void **v69; // r13
  unsigned __int64 v70; // rbx
  __int64 *v71; // r13
  __int64 v72; // rax
  __int64 v73; // rax
  void **v74; // r15
  void **v75; // r13
  __int64 *v76; // rax
  __int64 v77; // rdx
  void **v78; // r14
  unsigned __int64 v79; // r13
  char *v80; // rax
  char *v81; // rax
  int (**v82)(...); // rdx
  __int64 v83; // rax
  void **v84; // r14
  void **v85; // r13
  std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *v86; // [rsp+20h] [rbp-450h]
  std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *v87; // [rsp+20h] [rbp-450h]
  int *__v; // [rsp+38h] [rbp-438h]
  int *__va; // [rsp+38h] [rbp-438h]
  int *__vb; // [rsp+38h] [rbp-438h]
  int __vc; // [rsp+38h] [rbp-438h]
  int *__vd; // [rsp+38h] [rbp-438h]
  int *__ve; // [rsp+38h] [rbp-438h]
  int *__vf; // [rsp+38h] [rbp-438h]
  std::vector<int> v95; // [rsp+40h] [rbp-430h] BYREF
  void *v96; // [rsp+60h] [rbp-410h] BYREF
  void **v97; // [rsp+68h] [rbp-408h]
  __int64 v98; // [rsp+70h] [rbp-400h]
  google::protobuf::ProtobufOnceType *once; // [rsp+80h] [rbp-3F0h] BYREF
  __int64 v100; // [rsp+88h] [rbp-3E8h]
  char v101[16]; // [rsp+90h] [rbp-3E0h] BYREF
  std::string v102; // [rsp+A0h] [rbp-3D0h] BYREF
  std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> > v103; // [rsp+C0h] [rbp-3B0h] BYREF
  std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> > v104; // [rsp+F0h] [rbp-380h] BYREF
  std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > str; // [rsp+120h] [rbp-350h] BYREF
  google::protobuf::Closure closure; // [rsp+150h] [rbp-320h] BYREF
  void (__fastcall *v107)(const google::protobuf::FileDescriptor *); // [rsp+158h] [rbp-318h]
  char v108; // [rsp+160h] [rbp-310h]
  google::protobuf::FileDescriptor *v109; // [rsp+168h] [rbp-308h]
  __int64 v110; // [rsp+180h] [rbp-2F0h] BYREF
  int v111; // [rsp+188h] [rbp-2E8h]
  __int64 v112; // [rsp+1B0h] [rbp-2C0h] BYREF
  int v113; // [rsp+1B8h] [rbp-2B8h]
  __int64 v114; // [rsp+1E0h] [rbp-290h] BYREF
  int v115; // [rsp+1E8h] [rbp-288h]
  __int64 v116; // [rsp+210h] [rbp-260h] BYREF
  int v117; // [rsp+218h] [rbp-258h]
  __int64 v118; // [rsp+240h] [rbp-230h] BYREF
  int v119; // [rsp+248h] [rbp-228h]
  __int64 v120; // [rsp+270h] [rbp-200h] BYREF
  int v121; // [rsp+278h] [rbp-1F8h]
  __int64 v122; // [rsp+2A0h] [rbp-1D0h] BYREF
  int v123; // [rsp+2A8h] [rbp-1C8h]
  std::string v124; // [rsp+2D0h] [rbp-1A0h] BYREF
  std::string v125; // [rsp+300h] [rbp-170h] BYREF
  __int64 v126; // [rsp+320h] [rbp-150h]
  char v127[16]; // [rsp+328h] [rbp-148h] BYREF
  char *__beg; // [rsp+338h] [rbp-138h]
  __int64 v129; // [rsp+340h] [rbp-130h]
  char v130[16]; // [rsp+348h] [rbp-128h] BYREF
  void *v131; // [rsp+358h] [rbp-118h]
  void **v132; // [rsp+360h] [rbp-110h]
  __int64 v133; // [rsp+368h] [rbp-108h]
  __int16 v134; // [rsp+370h] [rbp-100h]
  char v135; // [rsp+372h] [rbp-FEh]
  std::string v136; // [rsp+378h] [rbp-F8h] BYREF
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter v137; // [rsp+3A0h] [rbp-D0h] BYREF

  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_BYTE *)(a1 + 16) = 0;
  memset(&v102, 0, 24);
  std::vector<int>::_M_realloc_insert<int const&>(
    (std::vector<int> *const)&v102,
    0LL,
    &google::protobuf::FileDescriptorProto::kSyntaxFieldNumber,
    a4);
  v125._M_dataplus._M_p = v125._anon_0._M_local_buf;
  std::string::_M_construct<char const*>(&v125, &off_1B23A528[4], &off_1B23A528[4], v7);
  v137.source_loc_.leading_comments._M_dataplus._M_p = v137.source_loc_.leading_comments._anon_0._M_local_buf;
  v137.source_loc_.trailing_comments._M_dataplus._M_p = v137.source_loc_.trailing_comments._anon_0._M_local_buf;
  v8 = *(_WORD *)a3;
  v137.source_loc_.leading_comments._M_string_length = 0LL;
  *(_WORD *)&v137.options_.include_comments = v8;
  LOBYTE(v8) = a3[2];
  v137.source_loc_.leading_comments._anon_0._M_local_buf[0] = 0;
  v137.options_.elide_oneof_body = v8;
  v137.source_loc_.trailing_comments._M_string_length = 0LL;
  v137.source_loc_.trailing_comments._anon_0._M_local_buf[0] = 0;
  memset(&v137.source_loc_.leading_detached_comments, 0, sizeof(v137.source_loc_.leading_detached_comments));
  v137.prefix_._M_dataplus._M_p = v137.prefix_._anon_0._M_local_buf;
  std::string::_M_construct<char *>(
    &v137.prefix_,
    v125._M_dataplus._M_p,
    &v125._M_dataplus._M_p[v125._M_string_length],
    v9);
  SourceLocation = *a3;
  if ( *a3 )
    SourceLocation = google::protobuf::FileDescriptor::GetSourceLocation(this, &v102, &v137.source_loc_);
  v137.have_source_loc_ = SourceLocation;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v125._M_dataplus._M_p != &v125._anon_0 )
    operator delete(v125._M_dataplus._M_p);
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment((__int64)&v137, a1, v10, v11);
  v125._M_dataplus._M_p = 0LL;
  syntax = (google::protobuf::FileDescriptor *)(unsigned int)this->syntax_;
  LODWORD(v125._M_string_length) = -1;
  v124._M_dataplus._M_p = 0LL;
  LODWORD(v124._M_string_length) = -1;
  v122 = 0LL;
  v123 = -1;
  v120 = 0LL;
  v121 = -1;
  v118 = 0LL;
  v119 = -1;
  v116 = 0LL;
  v117 = -1;
  v114 = 0LL;
  v115 = -1;
  v112 = 0LL;
  v113 = -1;
  v110 = 0LL;
  v111 = -1;
  closure._vptr_Closure = (int (**)(...))google::protobuf::FileDescriptor::SyntaxName(
                                           syntax,
                                           (google::protobuf::FileDescriptor::Syntax)a1);
  LODWORD(v107) = strlen((const char *)closure._vptr_Closure);
  google::protobuf::strings::SubstituteAndAppend(
    a1,
    "syntax = \"$0\";\n\n",
    &closure,
    &v110,
    &v112,
    &v114,
    &v116,
    &v118,
    &v120,
    &v122,
    &v124,
    &v125);
  if ( v137.have_source_loc_ && v137.source_loc_.trailing_comments._M_string_length )
  {
    *(_QWORD *)str._M_impl.gap0 = &str._M_impl._M_header._M_parent;
    std::string::_M_construct<char *>(
      (std::string *const)&str,
      v137.source_loc_.trailing_comments._M_dataplus._M_p,
      &v137.source_loc_.trailing_comments._M_dataplus._M_p[v137.source_loc_.trailing_comments._M_string_length],
      (std::forward_iterator_tag)&str);
    google::protobuf::StripWhitespace((std::string *)&str);
    memset(&v103, 0, 24);
    google::protobuf::SplitStringUsing(&str, 437753683LL, &v103);
    *(_QWORD *)&v104._M_impl._M_header._M_color = 0LL;
    v75 = *(void ***)v103._M_impl.gap0;
    *(_QWORD *)v104._M_impl.gap0 = &v104._M_impl._M_header._M_parent;
    LOBYTE(v104._M_impl._M_header._M_parent) = 0;
    __vf = 0LL;
    if ( *(_QWORD *)v103._M_impl.gap0 != *(_QWORD *)&v103._M_impl._M_header._M_color )
    {
      do
      {
        v125._M_dataplus._M_p = 0LL;
        v124._M_dataplus._M_p = 0LL;
        v122 = 0LL;
        v120 = 0LL;
        v76 = (__int64 *)&v75[4 * (_QWORD)__vf];
        v118 = 0LL;
        v116 = 0LL;
        v114 = 0LL;
        v112 = 0LL;
        v77 = *v76;
        LODWORD(v125._M_string_length) = -1;
        v111 = v76[1];
        closure._vptr_Closure = (int (**)(...))v137.prefix_._M_dataplus._M_p;
        v110 = v77;
        LODWORD(v124._M_string_length) = -1;
        v123 = -1;
        v121 = -1;
        v119 = -1;
        v117 = -1;
        v115 = -1;
        v113 = -1;
        LODWORD(v107) = v137.prefix_._M_string_length;
        google::protobuf::strings::SubstituteAndAppend(
          &v104,
          "$0// $1\n",
          &closure,
          &v110,
          &v112,
          &v114,
          &v116,
          &v118,
          &v120,
          &v122,
          &v124,
          &v125);
        v78 = *(void ***)&v103._M_impl._M_header._M_color;
        v75 = *(void ***)v103._M_impl.gap0;
        __vf = (int *)((char *)__vf + 1);
      }
      while ( (__int64)(*(_QWORD *)&v103._M_impl._M_header._M_color - *(_QWORD *)v103._M_impl.gap0) >> 5 > (unsigned __int64)__vf );
      if ( *(_QWORD *)v103._M_impl.gap0 != *(_QWORD *)&v103._M_impl._M_header._M_color )
      {
        do
        {
          if ( *v75 != v75 + 2 )
            operator delete(*v75);
          v75 += 4;
        }
        while ( v78 != v75 );
      }
    }
    if ( *(_QWORD *)v103._M_impl.gap0 )
      operator delete(*(void **)v103._M_impl.gap0);
    if ( *(std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > **)str._M_impl.gap0 != (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)&str._M_impl._M_header._M_parent )
      operator delete(*(void **)str._M_impl.gap0);
    std::string::_M_append(a1, *(const char **)v104._M_impl.gap0, *(_QWORD *)&v104._M_impl._M_header._M_color);
    if ( *(std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> > **)v104._M_impl.gap0 != (std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> > *)&v104._M_impl._M_header._M_parent )
      operator delete(*(void **)v104._M_impl.gap0);
  }
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v137.prefix_._M_dataplus._M_p != &v137.prefix_._anon_0 )
    operator delete(v137.prefix_._M_dataplus._M_p);
  M_start = v137.source_loc_.leading_detached_comments._M_impl._M_start;
  if ( v137.source_loc_.leading_detached_comments._M_impl._M_finish != v137.source_loc_.leading_detached_comments._M_impl._M_start )
  {
    M_finish = v137.source_loc_.leading_detached_comments._M_impl._M_finish;
    do
    {
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)M_start->_M_dataplus._M_p != &M_start->_anon_0 )
        operator delete(M_start->_M_dataplus._M_p);
      ++M_start;
    }
    while ( M_finish != M_start );
    M_start = v137.source_loc_.leading_detached_comments._M_impl._M_start;
  }
  if ( M_start )
    operator delete(M_start);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v137.source_loc_.trailing_comments._M_dataplus._M_p != &v137.source_loc_.trailing_comments._anon_0 )
    operator delete(v137.source_loc_.trailing_comments._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v137.source_loc_.leading_comments._M_dataplus._M_p != &v137.source_loc_.leading_comments._anon_0 )
    operator delete(v137.source_loc_.leading_comments._M_dataplus._M_p);
  if ( v102._M_dataplus._M_p )
    operator delete(v102._M_dataplus._M_p);
  *(_QWORD *)&v137.have_source_loc_ = &v137.source_loc_.start_column;
  std::string::_M_construct<char const*>((std::string *const)&v137, &off_1B23A528[4], &off_1B23A528[4], v14);
  *(&v125._anon_0._M_allocated_capacity + 1) = (std::string::size_type)v127;
  __beg = v130;
  v17 = *(_WORD *)a3;
  v126 = 0LL;
  v134 = v17;
  LOBYTE(v17) = a3[2];
  v127[0] = 0;
  v135 = v17;
  v129 = 0LL;
  v130[0] = 0;
  v131 = 0LL;
  v132 = 0LL;
  v133 = 0LL;
  v136._M_dataplus._M_p = v136._anon_0._M_local_buf;
  std::string::_M_construct<char *>(
    &v136,
    *(char **)&v137.have_source_loc_,
    (char *)(*(_QWORD *)&v137.have_source_loc_ + *(_QWORD *)&v137.source_loc_.start_line),
    v18);
  v21 = *a3;
  if ( *a3 )
    v21 = google::protobuf::FileDescriptor::GetSourceLocation(
            this,
            (google::protobuf::SourceLocation *)&v125._M_string_length);
  LOBYTE(v125._M_dataplus._M_p) = v21;
  if ( *(google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter **)&v137.have_source_loc_ != (google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter *)&v137.source_loc_.start_column )
    operator delete(*(void **)&v137.have_source_loc_);
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment((__int64)&v125, a1, v19, v20);
  public_dependencies = this->public_dependencies_;
  public_dependency_count = this->public_dependency_count_;
  v103._M_impl._M_header._M_left = &v103._M_impl._M_header;
  v103._M_impl._M_header._M_right = &v103._M_impl._M_header;
  v103._M_impl._M_header._M_color = _S_red;
  v103._M_impl._M_header._M_parent = 0LL;
  v103._M_impl._M_node_count = 0LL;
  v104._M_impl._M_header._M_color = _S_red;
  v104._M_impl._M_header._M_parent = 0LL;
  v104._M_impl._M_header._M_left = &v104._M_impl._M_header;
  v104._M_impl._M_header._M_right = &v104._M_impl._M_header;
  v104._M_impl._M_node_count = 0LL;
  __v = public_dependencies;
  v86 = (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)&public_dependencies[public_dependency_count];
  if ( public_dependencies != (int *)v86 )
  {
    do
      std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int>>::_M_insert_unique_<int &,std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int>>::_Alloc_node>(
        &v103,
        (std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> >::const_iterator)&v103._M_impl.std::_Rb_tree_header,
        __v++,
        (std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> >::_Alloc_node *)public_dependencies);
    while ( v86 != (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)__v );
  }
  weak_dependencies = this->weak_dependencies_;
  __va = weak_dependencies;
  v87 = (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)&weak_dependencies[this->weak_dependency_count_];
  if ( weak_dependencies != (int *)v87 )
  {
    do
      std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int>>::_M_insert_unique_<int &,std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int>>::_Alloc_node>(
        &v104,
        (std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> >::const_iterator)&v104._M_impl.std::_Rb_tree_header,
        __va++,
        (std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> >::_Alloc_node *)weak_dependencies);
    while ( v87 != (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)__va );
  }
  for ( __vb = 0LL; this->dependency_count_ > (int)__vb; __vb = (int *)((char *)__vb + 1) )
  {
    M_parent = v103._M_impl._M_header._M_parent;
    dependencies_once = this->dependencies_once_;
    if ( !v103._M_impl._M_header._M_parent )
      goto LABEL_39;
    v27 = &v103._M_impl.std::_Rb_tree_header;
    do
    {
      while ( M_parent[1]._M_color >= (int)__vb )
      {
        v27 = (std::_Rb_tree_header *)M_parent;
        M_parent = M_parent->_M_left;
        if ( !M_parent )
          goto LABEL_37;
      }
      M_parent = M_parent->_M_right;
    }
    while ( M_parent );
LABEL_37:
    if ( v27 != &v103._M_impl.std::_Rb_tree_header && SLODWORD(v27->_M_node_count) <= (int)__vb )
    {
      *(_QWORD *)&v137.have_source_loc_ = 0LL;
      v137.source_loc_.start_line = -1;
      v124._M_dataplus._M_p = 0LL;
      LODWORD(v124._M_string_length) = -1;
      v122 = 0LL;
      v123 = -1;
      v120 = 0LL;
      v121 = -1;
      v118 = 0LL;
      v119 = -1;
      v116 = 0LL;
      v117 = -1;
      v114 = 0LL;
      v115 = -1;
      v112 = 0LL;
      v113 = -1;
      v110 = 0LL;
      v111 = -1;
      if ( dependencies_once && dependencies_once->state_ != 2 )
      {
        v108 = 0;
        closure._vptr_Closure = (int (**)(...))&off_1A17BFB8;
        v107 = google::protobuf::FileDescriptor::DependenciesOnceInit;
        v109 = this;
        google::protobuf::GoogleOnceInitImpl(&dependencies_once->state_, &closure);
        closure._vptr_Closure = (int (**)(...))&off_1A17BFB8;
        google::protobuf::Closure::~Closure(&closure);
      }
      name = this->dependencies_[(_QWORD)__vb]->name_;
      M_p = (int (**)(...))name->_M_dataplus._M_p;
      LODWORD(v107) = name->_M_string_length;
      closure._vptr_Closure = M_p;
      google::protobuf::strings::SubstituteAndAppend(
        a1,
        "import public \"$0\";\n",
        &closure,
        &v110,
        &v112,
        &v114,
        &v116,
        &v118,
        &v120,
        &v122,
        &v124,
        &v137);
    }
    else
    {
LABEL_39:
      v28 = v104._M_impl._M_header._M_parent;
      if ( !v104._M_impl._M_header._M_parent )
        goto LABEL_46;
      v29 = &v104._M_impl.std::_Rb_tree_header;
      do
      {
        while ( v28[1]._M_color >= (int)__vb )
        {
          v29 = (std::_Rb_tree_header *)v28;
          v28 = v28->_M_left;
          if ( !v28 )
            goto LABEL_44;
        }
        v28 = v28->_M_right;
      }
      while ( v28 );
LABEL_44:
      if ( v29 != &v104._M_impl.std::_Rb_tree_header && SLODWORD(v29->_M_node_count) <= (int)__vb )
      {
        *(_QWORD *)&v137.have_source_loc_ = 0LL;
        v137.source_loc_.start_line = -1;
        v124._M_dataplus._M_p = 0LL;
        LODWORD(v124._M_string_length) = -1;
        v122 = 0LL;
        v123 = -1;
        v120 = 0LL;
        v121 = -1;
        v118 = 0LL;
        v119 = -1;
        v116 = 0LL;
        v117 = -1;
        v114 = 0LL;
        v115 = -1;
        v112 = 0LL;
        v113 = -1;
        v110 = 0LL;
        v111 = -1;
        if ( dependencies_once && dependencies_once->state_ != 2 )
        {
          v108 = 0;
          closure._vptr_Closure = (int (**)(...))&off_1A17BFB8;
          v107 = google::protobuf::FileDescriptor::DependenciesOnceInit;
          v109 = this;
          google::protobuf::GoogleOnceInitImpl(&dependencies_once->state_, &closure);
          closure._vptr_Closure = (int (**)(...))&off_1A17BFB8;
          google::protobuf::Closure::~Closure(&closure);
        }
        v49 = this->dependencies_[(_QWORD)__vb]->name_;
        v50 = (int (**)(...))v49->_M_dataplus._M_p;
        LODWORD(v107) = v49->_M_string_length;
        closure._vptr_Closure = v50;
        google::protobuf::strings::SubstituteAndAppend(
          a1,
          "import weak \"$0\";\n",
          &closure,
          &v110,
          &v112,
          &v114,
          &v116,
          &v118,
          &v120,
          &v122,
          &v124,
          &v137);
      }
      else
      {
LABEL_46:
        *(_QWORD *)&v137.have_source_loc_ = 0LL;
        v137.source_loc_.start_line = -1;
        v124._M_dataplus._M_p = 0LL;
        LODWORD(v124._M_string_length) = -1;
        v122 = 0LL;
        v123 = -1;
        v120 = 0LL;
        v121 = -1;
        v118 = 0LL;
        v119 = -1;
        v116 = 0LL;
        v117 = -1;
        v114 = 0LL;
        v115 = -1;
        v112 = 0LL;
        v113 = -1;
        v110 = 0LL;
        v111 = -1;
        if ( dependencies_once && dependencies_once->state_ != 2 )
        {
          v108 = 0;
          closure._vptr_Closure = (int (**)(...))&off_1A17BFB8;
          v107 = google::protobuf::FileDescriptor::DependenciesOnceInit;
          v109 = this;
          google::protobuf::GoogleOnceInitImpl(&dependencies_once->state_, &closure);
          closure._vptr_Closure = (int (**)(...))&off_1A17BFB8;
          google::protobuf::Closure::~Closure(&closure);
        }
        v30 = this->dependencies_[(_QWORD)__vb]->name_;
        v31 = (int (**)(...))v30->_M_dataplus._M_p;
        LODWORD(v107) = v30->_M_string_length;
        closure._vptr_Closure = v31;
        google::protobuf::strings::SubstituteAndAppend(
          a1,
          "import \"$0\";\n",
          &closure,
          &v110,
          &v112,
          &v114,
          &v116,
          &v118,
          &v120,
          &v122,
          &v124,
          &v137);
      }
    }
  }
  if ( this->package_->_M_string_length )
  {
    memset(&v95, 0, sizeof(v95));
    std::vector<int>::_M_realloc_insert<int const&>(
      &v95,
      0LL,
      &google::protobuf::FileDescriptorProto::kPackageFieldNumber,
      weak_dependencies);
    v124._M_dataplus._M_p = v124._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&v124, &off_1B23A528[4], &off_1B23A528[4], v34);
    v137.source_loc_.leading_comments._M_dataplus._M_p = v137.source_loc_.leading_comments._anon_0._M_local_buf;
    v137.source_loc_.trailing_comments._M_dataplus._M_p = v137.source_loc_.trailing_comments._anon_0._M_local_buf;
    v35 = *(_WORD *)a3;
    v137.source_loc_.leading_comments._M_string_length = 0LL;
    *(_WORD *)&v137.options_.include_comments = v35;
    LOBYTE(v35) = a3[2];
    v137.source_loc_.leading_comments._anon_0._M_local_buf[0] = 0;
    v137.options_.elide_oneof_body = v35;
    v137.source_loc_.trailing_comments._M_string_length = 0LL;
    v137.source_loc_.trailing_comments._anon_0._M_local_buf[0] = 0;
    memset(&v137.source_loc_.leading_detached_comments, 0, sizeof(v137.source_loc_.leading_detached_comments));
    v137.prefix_._M_dataplus._M_p = v137.prefix_._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &v137.prefix_,
      v124._M_dataplus._M_p,
      &v124._M_dataplus._M_p[v124._M_string_length],
      v36);
    v39 = *a3;
    if ( *a3 )
      v39 = google::protobuf::FileDescriptor::GetSourceLocation(this, &v95, &v137.source_loc_);
    v137.have_source_loc_ = v39;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v124._M_dataplus._M_p != &v124._anon_0 )
      operator delete(v124._M_dataplus._M_p);
    google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment((__int64)&v137, a1, v37, v38);
    package = this->package_;
    v124._M_dataplus._M_p = 0LL;
    v122 = 0LL;
    v120 = 0LL;
    v118 = 0LL;
    v116 = 0LL;
    v114 = 0LL;
    v112 = 0LL;
    v110 = 0LL;
    closure._vptr_Closure = 0LL;
    v41 = package->_M_dataplus._M_p;
    LODWORD(v124._M_string_length) = -1;
    M_string_length = package->_M_string_length;
    *(_QWORD *)str._M_impl.gap0 = v41;
    str._M_impl._M_header._M_color = M_string_length;
    v123 = -1;
    v121 = -1;
    v119 = -1;
    v117 = -1;
    v115 = -1;
    v113 = -1;
    v111 = -1;
    LODWORD(v107) = -1;
    google::protobuf::strings::SubstituteAndAppend(
      a1,
      "package $0;\n\n",
      &str,
      &closure,
      &v110,
      &v112,
      &v114,
      &v116,
      &v118,
      &v120,
      &v122,
      &v124);
    if ( v137.have_source_loc_ && v137.source_loc_.trailing_comments._M_string_length )
    {
      v102._M_dataplus._M_p = v102._anon_0._M_local_buf;
      std::string::_M_construct<char *>(
        &v102,
        v137.source_loc_.trailing_comments._M_dataplus._M_p,
        &v137.source_loc_.trailing_comments._M_dataplus._M_p[v137.source_loc_.trailing_comments._M_string_length],
        (std::forward_iterator_tag)&v102._anon_0);
      google::protobuf::StripWhitespace(&v102);
      v96 = 0LL;
      v97 = 0LL;
      v98 = 0LL;
      google::protobuf::SplitStringUsing(&v102, 437753683LL, &v96);
      v79 = 0LL;
      v100 = 0LL;
      once = (google::protobuf::ProtobufOnceType *)v101;
      v80 = (char *)v96;
      v101[0] = 0;
      if ( v96 != v97 )
      {
        do
        {
          v124._M_dataplus._M_p = 0LL;
          v122 = 0LL;
          v81 = &v80[32 * v79];
          v120 = 0LL;
          v118 = 0LL;
          v116 = 0LL;
          v114 = 0LL;
          v112 = 0LL;
          v110 = 0LL;
          v82 = *(int (***)(...))v81;
          LODWORD(v124._M_string_length) = -1;
          v83 = *((_QWORD *)v81 + 1);
          closure._vptr_Closure = v82;
          LODWORD(v107) = v83;
          v123 = -1;
          *(_QWORD *)str._M_impl.gap0 = v137.prefix_._M_dataplus._M_p;
          v121 = -1;
          str._M_impl._M_header._M_color = v137.prefix_._M_string_length;
          v119 = -1;
          v117 = -1;
          v115 = -1;
          v113 = -1;
          v111 = -1;
          google::protobuf::strings::SubstituteAndAppend(
            &once,
            "$0// $1\n",
            &str,
            &closure,
            &v110,
            &v112,
            &v114,
            &v116,
            &v118,
            &v120,
            &v122,
            &v124);
          v80 = (char *)v96;
          ++v79;
        }
        while ( ((char *)v97 - (_BYTE *)v96) >> 5 > v79 );
        if ( v96 != v97 )
        {
          v84 = (void **)v96;
          v85 = v97;
          do
          {
            if ( *v84 != v84 + 2 )
              operator delete(*v84);
            v84 += 4;
          }
          while ( v85 != v84 );
        }
      }
      if ( v96 )
        operator delete(v96);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v102._M_dataplus._M_p != &v102._anon_0 )
        operator delete(v102._M_dataplus._M_p);
      std::string::_M_append(a1, (const char *)once, v100);
      if ( once != (google::protobuf::ProtobufOnceType *)v101 )
        operator delete(once);
    }
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v137.prefix_._M_dataplus._M_p != &v137.prefix_._anon_0 )
      operator delete(v137.prefix_._M_dataplus._M_p);
    v43 = v137.source_loc_.leading_detached_comments._M_impl._M_start;
    if ( v137.source_loc_.leading_detached_comments._M_impl._M_finish != v137.source_loc_.leading_detached_comments._M_impl._M_start )
    {
      v44 = v137.source_loc_.leading_detached_comments._M_impl._M_finish;
      do
      {
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v43->_M_dataplus._M_p != &v43->_anon_0 )
          operator delete(v43->_M_dataplus._M_p);
        ++v43;
      }
      while ( v44 != v43 );
      v43 = v137.source_loc_.leading_detached_comments._M_impl._M_start;
    }
    if ( v43 )
      operator delete(v43);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v137.source_loc_.trailing_comments._M_dataplus._M_p != &v137.source_loc_.trailing_comments._anon_0 )
      operator delete(v137.source_loc_.trailing_comments._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v137.source_loc_.leading_comments._M_dataplus._M_p != &v137.source_loc_.leading_comments._anon_0 )
      operator delete(v137.source_loc_.leading_comments._M_dataplus._M_p);
    if ( v95._M_impl._M_start )
      operator delete(v95._M_impl._M_start);
  }
  if ( (unsigned __int8)google::protobuf::`anonymous namespace'::FormatLineOptions(
                          0,
                          &this->options_->google::protobuf::Message,
                          (google::protobuf::DescriptorPool *)this->pool_,
                          a1) )
  {
    if ( *(_QWORD *)(a1 + 8) == 0x3FFFFFFFFFFFFFFFLL )
      std::__throw_length_error("basic_string::append");
    std::string::_M_append(a1, "\n", 1LL);
  }
  __vc = 0;
  for ( i = 0LL; __vc < this->enum_type_count_; ++i )
  {
    google::protobuf::EnumDescriptor::DebugString(&this->enum_types_[i], 0LL, a1, a3);
    if ( *(_QWORD *)(a1 + 8) == 0x3FFFFFFFFFFFFFFFLL )
      std::__throw_length_error("basic_string::append");
    std::string::_M_append(a1, "\n", 1LL);
    ++__vc;
  }
  extension_count = this->extension_count_;
  str._M_impl._M_header._M_color = _S_red;
  str._M_impl._M_header._M_left = &str._M_impl._M_header;
  str._M_impl._M_header._M_right = &str._M_impl._M_header;
  str._M_impl._M_header._M_parent = 0LL;
  str._M_impl._M_node_count = 0LL;
  __vd = 0LL;
  if ( extension_count > 0 )
  {
    while ( 1 )
    {
      v47 = &this->extensions_[(_QWORD)__vd];
      p_state = &v47->type_once_->state_;
      if ( p_state )
        break;
      if ( v47->type_ == TYPE_GROUP_0 )
        goto LABEL_90;
LABEL_87:
      __vd = (int *)((char *)__vd + 1);
      if ( this->extension_count_ <= (int)__vd )
        goto LABEL_98;
    }
    if ( *p_state != 2 )
    {
      LOBYTE(v137.source_loc_.start_column) = 0;
      *(_QWORD *)&v137.have_source_loc_ = &off_1A17BF90;
      *(_QWORD *)&v137.source_loc_.start_line = google::protobuf::FieldDescriptor::TypeOnceInit;
      v137.source_loc_.leading_comments._M_dataplus._M_p = (std::string::pointer)v47;
      google::protobuf::GoogleOnceInitImpl(p_state, (google::protobuf::Closure *)&v137);
      *(_QWORD *)&v137.have_source_loc_ = &off_1A17BF90;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&v137);
    }
    if ( v47->type_ != TYPE_GROUP_0 )
      goto LABEL_87;
    v47 = &this->extensions_[(_QWORD)__vd];
    v51 = &v47->type_once_->state_;
    if ( v51 && *v51 != 2 )
    {
      LOBYTE(v137.source_loc_.start_column) = 0;
      *(_QWORD *)&v137.have_source_loc_ = &off_1A17BF90;
      *(_QWORD *)&v137.source_loc_.start_line = google::protobuf::FieldDescriptor::TypeOnceInit;
      v137.source_loc_.leading_comments._M_dataplus._M_p = (std::string::pointer)v47;
      google::protobuf::GoogleOnceInitImpl(v51, (google::protobuf::Closure *)&v137);
      *(_QWORD *)&v137.have_source_loc_ = &off_1A17BF90;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&v137);
    }
LABEL_90:
    *(_QWORD *)&v137.have_source_loc_ = v47->message_type_;
    std::_Rb_tree<google::protobuf::Descriptor const*,google::protobuf::Descriptor const*,std::_Identity<google::protobuf::Descriptor const*>,std::less<google::protobuf::Descriptor const*>,std::allocator<google::protobuf::Descriptor const*>>::_M_insert_unique<google::protobuf::Descriptor const*>(
      &str,
      (const google::protobuf::Descriptor **)&v137);
    goto LABEL_87;
  }
LABEL_98:
  message_type_count = this->message_type_count_;
  v53 = 0LL;
  if ( message_type_count > 0 )
  {
    do
    {
      v54 = str._M_impl._M_header._M_parent;
      LOBYTE(message_type_count) = v53;
      v55 = &this->message_types_[v53];
      if ( !str._M_impl._M_header._M_parent )
        goto LABEL_106;
      v56 = (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)&str._M_impl.std::_Rb_tree_header;
      do
      {
        while ( *(_QWORD *)&v54[1]._M_color >= (unsigned __int64)v55 )
        {
          v56 = (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)v54;
          v54 = v54->_M_left;
          if ( !v54 )
            goto LABEL_104;
        }
        v54 = v54->_M_right;
      }
      while ( v54 );
LABEL_104:
      if ( v56 == (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)&str._M_impl.std::_Rb_tree_header
        || v56->_M_impl._M_header._M_right > (std::_Rb_tree_node_base::_Base_ptr)v55 )
      {
LABEL_106:
        google::protobuf::Descriptor::DebugString(v55, 0LL, a1, a3, 1LL);
        if ( *(_QWORD *)(a1 + 8) == 0x3FFFFFFFFFFFFFFFLL )
          std::__throw_length_error("basic_string::append");
        std::string::_M_append(a1, "\n", 1LL);
      }
      ++v53;
    }
    while ( this->message_type_count_ > (int)v53 );
  }
  for ( j = 0LL; this->service_count_ > (int)j; ++j )
  {
    google::protobuf::ServiceDescriptor::DebugString(&this->services_[j]);
    if ( *(_QWORD *)(a1 + 8) == 0x3FFFFFFFFFFFFFFFLL )
      std::__throw_length_error("basic_string::append");
    std::string::_M_append(a1, "\n", 1LL);
  }
  v58 = 0;
  containing_type = 0LL;
  __ve = 0LL;
  if ( this->extension_count_ > 0 )
  {
    do
    {
      v63 = (google::protobuf::FieldDescriptor *)((char *)this->extensions_ + (unsigned __int64)__ve);
      if ( v63->containing_type_ != containing_type )
      {
        if ( v58 )
        {
          if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - *(_QWORD *)(a1 + 8)) <= 2 )
            std::__throw_length_error("basic_string::append");
          std::string::_M_append(a1, "}\n\n", 3LL);
          containing_type = *(const google::protobuf::Descriptor **)((char *)&this->extensions_->containing_type_
                                                                   + (unsigned __int64)__ve);
        }
        else
        {
          containing_type = v63->containing_type_;
        }
        full_name = containing_type->full_name_;
        *(_QWORD *)&v137.have_source_loc_ = 0LL;
        v124._M_dataplus._M_p = 0LL;
        v122 = 0LL;
        v120 = 0LL;
        v118 = 0LL;
        v116 = 0LL;
        v114 = 0LL;
        v112 = 0LL;
        v110 = 0LL;
        v61 = (int (**)(...))full_name->_M_dataplus._M_p;
        v137.source_loc_.start_line = -1;
        v62 = full_name->_M_string_length;
        closure._vptr_Closure = v61;
        LODWORD(v107) = v62;
        LODWORD(v124._M_string_length) = -1;
        v123 = -1;
        v121 = -1;
        v119 = -1;
        v117 = -1;
        v115 = -1;
        v113 = -1;
        v111 = -1;
        google::protobuf::strings::SubstituteAndAppend(
          a1,
          "extend .$0 {\n",
          &closure,
          &v110,
          &v112,
          &v114,
          &v116,
          &v118,
          &v120,
          &v122,
          &v124,
          &v137);
        v63 = (google::protobuf::FieldDescriptor *)((char *)this->extensions_ + (unsigned __int64)__ve);
      }
      google::protobuf::FieldDescriptor::DebugString(v63);
      v64 = this->extension_count_;
      ++v58;
      __ve += 38;
    }
    while ( v58 < v64 );
    if ( v64 > 0 )
    {
      if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - *(_QWORD *)(a1 + 8)) <= 2 )
        std::__throw_length_error("basic_string::append");
      std::string::_M_append(a1, "}\n\n", 3LL);
    }
  }
  if ( LOBYTE(v125._M_dataplus._M_p) && v129 )
  {
    v102._M_dataplus._M_p = v102._anon_0._M_local_buf;
    std::string::_M_construct<char *>(&v102, __beg, &__beg[v129], (std::forward_iterator_tag)message_type_count);
    google::protobuf::StripWhitespace(&v102);
    v96 = 0LL;
    v97 = 0LL;
    v98 = 0LL;
    google::protobuf::SplitStringUsing(&v102, 437753683LL, &v96);
    v101[0] = 0;
    v69 = (void **)v96;
    v70 = 0LL;
    once = (google::protobuf::ProtobufOnceType *)v101;
    v100 = 0LL;
    if ( v97 != v96 )
    {
      do
      {
        *(_QWORD *)&v137.have_source_loc_ = 0LL;
        v124._M_dataplus._M_p = 0LL;
        v71 = (__int64 *)&v69[4 * v70];
        v122 = 0LL;
        v120 = 0LL;
        v118 = 0LL;
        v116 = 0LL;
        v114 = 0LL;
        v112 = 0LL;
        v72 = *v71;
        v137.source_loc_.start_line = -1;
        v110 = v72;
        v73 = v71[1];
        LODWORD(v124._M_string_length) = -1;
        v111 = v73;
        v123 = -1;
        closure._vptr_Closure = (int (**)(...))v136._M_dataplus._M_p;
        v121 = -1;
        LODWORD(v107) = v136._M_string_length;
        v119 = -1;
        v117 = -1;
        v115 = -1;
        v113 = -1;
        google::protobuf::strings::SubstituteAndAppend(
          &once,
          "$0// $1\n",
          &closure,
          &v110,
          &v112,
          &v114,
          &v116,
          &v118,
          &v120,
          &v122,
          &v124,
          &v137);
        v74 = v97;
        v69 = (void **)v96;
        ++v70;
      }
      while ( v70 < ((char *)v97 - (_BYTE *)v96) >> 5 );
      if ( v96 != v97 )
      {
        do
        {
          if ( *v69 != v69 + 2 )
            operator delete(*v69);
          v69 += 4;
        }
        while ( v74 != v69 );
      }
    }
    if ( v96 )
      operator delete(v96);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v102._M_dataplus._M_p != &v102._anon_0 )
      operator delete(v102._M_dataplus._M_p);
    std::string::_M_append(a1, (const char *)once, v100);
    if ( once != (google::protobuf::ProtobufOnceType *)v101 )
      operator delete(once);
  }
  std::_Rb_tree<google::protobuf::Descriptor const*,google::protobuf::Descriptor const*,std::_Identity<google::protobuf::Descriptor const*>,std::less<google::protobuf::Descriptor const*>,std::allocator<google::protobuf::Descriptor const*>>::_M_erase(
    &str,
    (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> >::_Link_type)str._M_impl._M_header._M_parent);
  std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int>>::_M_erase(
    &v104,
    (std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> >::_Link_type)v104._M_impl._M_header._M_parent);
  std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int>>::_M_erase(
    &v103,
    (std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> >::_Link_type)v103._M_impl._M_header._M_parent);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v136._M_dataplus._M_p != &v136._anon_0 )
    operator delete(v136._M_dataplus._M_p);
  v65 = v132;
  v66 = v131;
  if ( v132 != v131 )
  {
    v67 = (void **)v131;
    do
    {
      if ( *v67 != v67 + 2 )
        operator delete(*v67);
      v67 += 4;
    }
    while ( v65 != v67 );
    v66 = v131;
  }
  if ( v66 )
    operator delete(v66);
  if ( __beg != v130 )
    operator delete(__beg);
  if ( *((char **)&v125._anon_0._M_allocated_capacity + 1) != v127 )
    operator delete(*((void **)&v125._anon_0._M_allocated_capacity + 1));
  return a1;
};

// Line 2388: range 000000000C9176C0-000000000C9176E8
std::string *__fastcall google::protobuf::Descriptor::DebugString[abi:cxx11](
        std::string *retstr,
        const google::protobuf::Descriptor *const this)
{
  google::protobuf::DebugStringOptions options; // [rsp+Dh] [rbp-Bh] BYREF

  *(_WORD *)&options.include_comments = 0;
  options.elide_oneof_body = 0;
  google::protobuf::Descriptor::DebugStringWithOptions[abi:cxx11](retstr, this, &options);
  return retstr;
};

// Line 2394: range 000000000C917670-000000000C9176B0
__int64 __fastcall google::protobuf::Descriptor::DebugStringWithOptions[abi:cxx11](__int64 a1, __int64 a2, __int64 a3)
{
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_BYTE *)(a1 + 16) = 0;
  google::protobuf::Descriptor::DebugString(a2, 0LL, a1, a3, 1LL);
  return a1;
};

// Line 2403: range 000000000C90A8E0-000000000C90C2B3
void __fastcall google::protobuf::Descriptor::DebugString(
        google::protobuf::Descriptor *a1,
        int a2,
        __int64 a3,
        __int64 a4,
        char a5)
{
  __int16 v9; // ax
  std::forward_iterator_tag v10; // cl
  __int64 v11; // rdx
  std::forward_iterator_tag v12; // cl
  char SourceLocation; // al
  const std::string *name; // rax
  const char *M_p; // rdx
  std::string::size_type M_string_length; // rax
  int field_count; // eax
  __int64 v18; // rbx
  __int64 v19; // r15
  google::protobuf::ProtobufOnceType *v20; // rdi
  __int64 i; // rbx
  __int64 v22; // r15
  google::protobuf::ProtobufOnceType *v23; // rdi
  __int64 j; // rbx
  std::_Rb_tree_node_base::_Base_ptr M_parent; // rax
  unsigned __int64 v26; // rdi
  std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *v27; // rdx
  __int64 v28; // rax
  int k; // ebx
  __int64 v30; // r14
  __int64 v31; // r15
  int m; // ebx
  google::protobuf::FieldDescriptor *v33; // rdi
  const google::protobuf::OneofDescriptor *containing_oneof; // r8
  google::protobuf::ProtobufOnceType *v35; // rdi
  google::protobuf::ProtobufOnceType *v36; // rdi
  __int64 n; // rbx
  google::protobuf::Descriptor::ExtensionRange *extension_ranges; // rax
  int end; // edi
  __int64 v40; // rbx
  char *v41; // rdx
  int v42; // ecx
  const std::string *full_name; // rax
  const char *v44; // rsi
  std::string::size_type v45; // rax
  google::protobuf::FieldDescriptor *v46; // rdi
  int extension_count; // eax
  __int64 ii; // rbx
  unsigned __int64 v49; // rcx
  std::_Vector_base<std::string>::pointer v50; // rbx
  std::_Vector_base<std::string>::pointer v51; // rdi
  std::_Vector_base<std::string>::pointer v52; // r15
  unsigned __int64 v53; // rcx
  google::protobuf::int32 *v54; // rbx
  bool v55; // zf
  google::protobuf::int32 v56; // edi
  unsigned __int64 v57; // rbx
  std::_Vector_base<std::string>::pointer M_start; // rax
  std::string *v59; // rax
  const char *v60; // rdx
  std::string::size_type v61; // rax
  std::_Vector_base<std::string>::pointer M_finish; // r12
  std::_Vector_base<std::string>::pointer v63; // rbx
  char *v64; // rdx
  int v65; // ecx
  const google::protobuf::Descriptor *containing_type; // [rsp+18h] [rbp-3A8h]
  unsigned int dest; // [rsp+58h] [rbp-368h]
  int desta; // [rsp+58h] [rbp-368h]
  std::string *destb; // [rsp+58h] [rbp-368h]
  std::vector<std::string> v71; // [rsp+60h] [rbp-360h] BYREF
  char *__beg; // [rsp+80h] [rbp-340h] BYREF
  __int64 v73; // [rsp+88h] [rbp-338h]
  char v74[16]; // [rsp+90h] [rbp-330h] BYREF
  void *v75; // [rsp+A0h] [rbp-320h] BYREF
  __int64 v76; // [rsp+A8h] [rbp-318h]
  char v77[16]; // [rsp+B0h] [rbp-310h] BYREF
  std::string str; // [rsp+C0h] [rbp-300h] BYREF
  std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > v79; // [rsp+E0h] [rbp-2E0h] BYREF
  char *v80; // [rsp+110h] [rbp-2B0h] BYREF
  int v81; // [rsp+118h] [rbp-2A8h]
  char v82[36]; // [rsp+11Ch] [rbp-2A4h] BYREF
  char *v83; // [rsp+140h] [rbp-280h] BYREF
  int v84; // [rsp+148h] [rbp-278h]
  char v85[36]; // [rsp+14Ch] [rbp-274h] BYREF
  char *v86; // [rsp+170h] [rbp-250h] BYREF
  int v87; // [rsp+178h] [rbp-248h]
  char buffer[36]; // [rsp+17Ch] [rbp-244h] BYREF
  __int64 v89; // [rsp+1A0h] [rbp-220h] BYREF
  int v90; // [rsp+1A8h] [rbp-218h]
  __int64 v91; // [rsp+1D0h] [rbp-1F0h] BYREF
  int v92; // [rsp+1D8h] [rbp-1E8h]
  __int64 v93; // [rsp+200h] [rbp-1C0h] BYREF
  int v94; // [rsp+208h] [rbp-1B8h]
  __int64 v95; // [rsp+230h] [rbp-190h] BYREF
  int v96; // [rsp+238h] [rbp-188h]
  __int64 v97; // [rsp+260h] [rbp-160h] BYREF
  int v98; // [rsp+268h] [rbp-158h]
  __int64 v99; // [rsp+290h] [rbp-130h] BYREF
  int v100; // [rsp+298h] [rbp-128h]
  google::protobuf::Closure closure; // [rsp+2C0h] [rbp-100h] BYREF
  void (__fastcall *v102)(const google::protobuf::FieldDescriptor *); // [rsp+2C8h] [rbp-F8h]
  char v103; // [rsp+2D0h] [rbp-F0h]
  __int64 v104; // [rsp+2D8h] [rbp-E8h]
  char v105[8]; // [rsp+2F0h] [rbp-D0h] BYREF
  google::protobuf::SourceLocation v106; // [rsp+2F8h] [rbp-C8h] BYREF
  __int16 v107; // [rsp+360h] [rbp-60h]
  char v108; // [rsp+362h] [rbp-5Eh]
  std::string v109; // [rsp+368h] [rbp-58h] BYREF

  if ( a1->options_->map_entry_ )
    return;
  __beg = v74;
  std::string::_M_construct(&__beg, 2 * a2, 32LL);
  dest = a2 + 1;
  v106.leading_comments._M_dataplus._M_p = v106.leading_comments._anon_0._M_local_buf;
  v106.trailing_comments._M_dataplus._M_p = v106.trailing_comments._anon_0._M_local_buf;
  v9 = *(_WORD *)a4;
  v106.leading_comments._M_string_length = 0LL;
  v107 = v9;
  LOBYTE(v9) = *(_BYTE *)(a4 + 2);
  v106.leading_comments._anon_0._M_local_buf[0] = 0;
  v108 = v9;
  v106.trailing_comments._M_string_length = 0LL;
  v106.trailing_comments._anon_0._M_local_buf[0] = 0;
  memset(&v106.leading_detached_comments, 0, sizeof(v106.leading_detached_comments));
  v109._M_dataplus._M_p = v109._anon_0._M_local_buf;
  std::string::_M_construct<char *>(&v109, __beg, &__beg[v73], v10);
  SourceLocation = *(_BYTE *)a4;
  if ( *(_BYTE *)a4 )
    SourceLocation = google::protobuf::Descriptor::GetSourceLocation(a1, &v106);
  v105[0] = SourceLocation;
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment((__int64)v105, a3, v11, v12);
  if ( a5 )
  {
    name = a1->name_;
    closure._vptr_Closure = 0LL;
    v99 = 0LL;
    v97 = 0LL;
    v95 = 0LL;
    v93 = 0LL;
    v91 = 0LL;
    v89 = 0LL;
    v86 = 0LL;
    M_p = name->_M_dataplus._M_p;
    LODWORD(v102) = -1;
    M_string_length = name->_M_string_length;
    v83 = (char *)M_p;
    v84 = M_string_length;
    v100 = -1;
    v80 = __beg;
    v98 = -1;
    v81 = v73;
    v96 = -1;
    v94 = -1;
    v92 = -1;
    v90 = -1;
    v87 = -1;
    google::protobuf::strings::SubstituteAndAppend(
      a3,
      "$0message $1",
      &v80,
      &v83,
      &v86,
      &v89,
      &v91,
      &v93,
      &v95,
      &v97,
      &v99,
      &closure);
  }
  if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - *(_QWORD *)(a3 + 8)) <= 2 )
    std::__throw_length_error("basic_string::append");
  std::string::_M_append(a3, " {\n", 3LL);
  google::protobuf::`anonymous namespace'::FormatLineOptions(
    dest,
    &a1->options_->google::protobuf::Message,
    (google::protobuf::DescriptorPool *)a1->file_->pool_,
    a3);
  field_count = a1->field_count_;
  v18 = 0LL;
  v79._M_impl._M_header._M_color = _S_red;
  v79._M_impl._M_header._M_parent = 0LL;
  v79._M_impl._M_header._M_left = &v79._M_impl._M_header;
  v79._M_impl._M_header._M_right = &v79._M_impl._M_header;
  v79._M_impl._M_node_count = 0LL;
  if ( field_count > 0 )
  {
    do
    {
      while ( 1 )
      {
        v19 = (__int64)&a1->fields_[v18];
        v20 = *(google::protobuf::ProtobufOnceType **)(v19 + 48);
        if ( !v20 )
          break;
        if ( *v20 != 2 )
        {
          v103 = 0;
          closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
          v102 = google::protobuf::FieldDescriptor::TypeOnceInit;
          v104 = v19;
          google::protobuf::GoogleOnceInitImpl(v20, &closure);
          closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
          google::protobuf::Closure::~Closure(&closure);
        }
        if ( *(_DWORD *)(v19 + 56) == 10 )
        {
          v19 = (__int64)&a1->fields_[v18];
          v35 = *(google::protobuf::ProtobufOnceType **)(v19 + 48);
          if ( v35 && *v35 != 2 )
          {
            v103 = 0;
            closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
            v102 = google::protobuf::FieldDescriptor::TypeOnceInit;
            v104 = v19;
            google::protobuf::GoogleOnceInitImpl(v35, &closure);
            closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
            google::protobuf::Closure::~Closure(&closure);
          }
          goto LABEL_16;
        }
LABEL_13:
        if ( a1->field_count_ <= (int)++v18 )
          goto LABEL_17;
      }
      if ( *(_DWORD *)(v19 + 56) != 10 )
        goto LABEL_13;
LABEL_16:
      closure._vptr_Closure = *(int (***)(...))(v19 + 104);
      std::_Rb_tree<google::protobuf::Descriptor const*,google::protobuf::Descriptor const*,std::_Identity<google::protobuf::Descriptor const*>,std::less<google::protobuf::Descriptor const*>,std::allocator<google::protobuf::Descriptor const*>>::_M_insert_unique<google::protobuf::Descriptor const*>(
        &v79,
        (const google::protobuf::Descriptor **)&closure);
      ++v18;
    }
    while ( a1->field_count_ > (int)v18 );
  }
LABEL_17:
  for ( i = 0LL; a1->extension_count_ > (int)i; ++i )
  {
    while ( 1 )
    {
      v22 = (__int64)&a1->extensions_[i];
      v23 = *(google::protobuf::ProtobufOnceType **)(v22 + 48);
      if ( !v23 )
        break;
      if ( *v23 != 2 )
      {
        v103 = 0;
        closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
        v102 = google::protobuf::FieldDescriptor::TypeOnceInit;
        v104 = v22;
        google::protobuf::GoogleOnceInitImpl(v23, &closure);
        closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
        google::protobuf::Closure::~Closure(&closure);
      }
      if ( *(_DWORD *)(v22 + 56) == 10 )
      {
        v22 = (__int64)&a1->extensions_[i];
        v36 = *(google::protobuf::ProtobufOnceType **)(v22 + 48);
        if ( v36 && *v36 != 2 )
        {
          v103 = 0;
          closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
          v102 = google::protobuf::FieldDescriptor::TypeOnceInit;
          v104 = v22;
          google::protobuf::GoogleOnceInitImpl(v36, &closure);
          closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
          google::protobuf::Closure::~Closure(&closure);
        }
        goto LABEL_25;
      }
LABEL_22:
      if ( a1->extension_count_ <= (int)++i )
        goto LABEL_26;
    }
    if ( *(_DWORD *)(v22 + 56) != 10 )
      goto LABEL_22;
LABEL_25:
    closure._vptr_Closure = *(int (***)(...))(v22 + 104);
    std::_Rb_tree<google::protobuf::Descriptor const*,google::protobuf::Descriptor const*,std::_Identity<google::protobuf::Descriptor const*>,std::less<google::protobuf::Descriptor const*>,std::allocator<google::protobuf::Descriptor const*>>::_M_insert_unique<google::protobuf::Descriptor const*>(
      &v79,
      (const google::protobuf::Descriptor **)&closure);
  }
LABEL_26:
  for ( j = 0LL; a1->nested_type_count_ > (int)j; ++j )
  {
    M_parent = v79._M_impl._M_header._M_parent;
    v26 = (unsigned __int64)&a1->nested_types_[j];
    if ( v79._M_impl._M_header._M_parent )
    {
      v27 = (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)&v79._M_impl.std::_Rb_tree_header;
      do
      {
        while ( *(_QWORD *)&M_parent[1]._M_color >= v26 )
        {
          v27 = (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)M_parent;
          M_parent = M_parent->_M_left;
          if ( !M_parent )
            goto LABEL_32;
        }
        M_parent = M_parent->_M_right;
      }
      while ( M_parent );
LABEL_32:
      if ( v27 != (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> > *)&v79._M_impl.std::_Rb_tree_header
        && v27->_M_impl._M_header._M_right <= (std::_Rb_tree_node_base::_Base_ptr)v26 )
      {
        continue;
      }
    }
    google::protobuf::Descriptor::DebugString(v26, dest, a3, a4, 1LL);
  }
  v28 = 0LL;
  for ( k = 0; k < a1->enum_type_count_; v28 = v30 + 56 )
  {
    v30 = v28;
    google::protobuf::EnumDescriptor::DebugString((char *)a1->enum_types_ + v28, dest, a3, a4);
    ++k;
  }
  v31 = 0LL;
  for ( m = 0; m < a1->field_count_; ++v31 )
  {
    v33 = &a1->fields_[v31];
    containing_oneof = v33->containing_oneof_;
    if ( containing_oneof )
    {
      if ( v33 == *(google::protobuf::FieldDescriptor **)containing_oneof->fields_ )
        google::protobuf::OneofDescriptor::DebugString(v33->containing_oneof_, dest, a3, a4);
    }
    else
    {
      google::protobuf::FieldDescriptor::DebugString(v33);
    }
    ++m;
  }
  for ( n = 0LL; a1->extension_range_count_ > (int)n; ++n )
  {
    extension_ranges = a1->extension_ranges_;
    LODWORD(v102) = -1;
    v100 = -1;
    v98 = -1;
    v96 = -1;
    v94 = -1;
    v92 = -1;
    v90 = -1;
    end = extension_ranges[n].end;
    closure._vptr_Closure = 0LL;
    v99 = 0LL;
    v97 = 0LL;
    v95 = 0LL;
    v93 = 0LL;
    v91 = 0LL;
    v89 = 0LL;
    v86 = google::protobuf::FastInt32ToBuffer(end - 1, buffer);
    v87 = strlen(v86);
    v83 = google::protobuf::FastInt32ToBuffer(a1->extension_ranges_[n].start, v85);
    v84 = strlen(v83);
    v80 = __beg;
    v81 = v73;
    google::protobuf::strings::SubstituteAndAppend(
      a3,
      "$0  extensions $1 to $2;\n",
      &v80,
      &v83,
      &v86,
      &v89,
      &v91,
      &v93,
      &v95,
      &v97,
      &v99,
      &closure);
  }
  v40 = 0LL;
  desta = 0;
  containing_type = 0LL;
  if ( a1->extension_count_ > 0 )
  {
    do
    {
      v46 = &a1->extensions_[v40];
      if ( v46->containing_type_ != containing_type )
      {
        v41 = __beg;
        v42 = v73;
        if ( desta )
        {
          v80 = __beg;
          v81 = v73;
          closure._vptr_Closure = 0LL;
          LODWORD(v102) = -1;
          v99 = 0LL;
          v100 = -1;
          v97 = 0LL;
          v98 = -1;
          v95 = 0LL;
          v96 = -1;
          v93 = 0LL;
          v94 = -1;
          v91 = 0LL;
          v92 = -1;
          v89 = 0LL;
          v90 = -1;
          v86 = 0LL;
          v87 = -1;
          v83 = 0LL;
          v84 = -1;
          google::protobuf::strings::SubstituteAndAppend(
            a3,
            "$0  }\n",
            &v80,
            &v83,
            &v86,
            &v89,
            &v91,
            &v93,
            &v95,
            &v97,
            &v99,
            &closure);
          v41 = __beg;
          v42 = v73;
          containing_type = a1->extensions_[v40].containing_type_;
        }
        else
        {
          containing_type = v46->containing_type_;
        }
        closure._vptr_Closure = 0LL;
        v99 = 0LL;
        v97 = 0LL;
        full_name = containing_type->full_name_;
        v95 = 0LL;
        v93 = 0LL;
        v91 = 0LL;
        v89 = 0LL;
        v86 = 0LL;
        v44 = full_name->_M_dataplus._M_p;
        LODWORD(v102) = -1;
        v45 = full_name->_M_string_length;
        v83 = (char *)v44;
        v80 = v41;
        v81 = v42;
        v100 = -1;
        v98 = -1;
        v96 = -1;
        v94 = -1;
        v92 = -1;
        v90 = -1;
        v87 = -1;
        v84 = v45;
        google::protobuf::strings::SubstituteAndAppend(
          a3,
          "$0  extend .$1 {\n",
          &v80,
          &v83,
          &v86,
          &v89,
          &v91,
          &v93,
          &v95,
          &v97,
          &v99,
          &closure);
        v46 = &a1->extensions_[v40];
      }
      google::protobuf::FieldDescriptor::DebugString(v46);
      ++desta;
      extension_count = a1->extension_count_;
      ++v40;
    }
    while ( desta < extension_count );
    v64 = __beg;
    v65 = v73;
    if ( extension_count > 0 )
    {
      v81 = v73;
      v80 = __beg;
      closure._vptr_Closure = 0LL;
      LODWORD(v102) = -1;
      v99 = 0LL;
      v100 = -1;
      v97 = 0LL;
      v98 = -1;
      v95 = 0LL;
      v96 = -1;
      v93 = 0LL;
      v94 = -1;
      v91 = 0LL;
      v92 = -1;
      v89 = 0LL;
      v90 = -1;
      v86 = 0LL;
      v87 = -1;
      v83 = 0LL;
      v84 = -1;
      google::protobuf::strings::SubstituteAndAppend(
        a3,
        "$0  }\n",
        &v80,
        &v83,
        &v86,
        &v89,
        &v91,
        &v93,
        &v95,
        &v97,
        &v99,
        &closure);
      v64 = __beg;
      v65 = v73;
    }
  }
  else
  {
    v64 = __beg;
    v65 = v73;
  }
  if ( a1->reserved_range_count_ > 0 )
  {
    v80 = v64;
    v81 = v65;
    closure._vptr_Closure = 0LL;
    LODWORD(v102) = -1;
    v99 = 0LL;
    v100 = -1;
    v97 = 0LL;
    v98 = -1;
    v95 = 0LL;
    v96 = -1;
    v93 = 0LL;
    v94 = -1;
    v91 = 0LL;
    v92 = -1;
    v89 = 0LL;
    v90 = -1;
    v86 = 0LL;
    v87 = -1;
    v83 = 0LL;
    v84 = -1;
    google::protobuf::strings::SubstituteAndAppend(
      a3,
      "$0  reserved ",
      &v80,
      &v83,
      &v86,
      &v89,
      &v91,
      &v93,
      &v95,
      &v97,
      &v99,
      &closure);
    for ( destb = 0LL; a1->reserved_range_count_ > (int)destb; destb = (std::string *)((char *)destb + 1) )
    {
      v54 = (google::protobuf::int32 *)&a1->reserved_ranges_[(_QWORD)destb];
      v55 = v54[1] == *v54 + 1;
      closure._vptr_Closure = 0LL;
      LODWORD(v102) = -1;
      v99 = 0LL;
      v100 = -1;
      v97 = 0LL;
      v98 = -1;
      v95 = 0LL;
      v96 = -1;
      v93 = 0LL;
      v94 = -1;
      v91 = 0LL;
      v92 = -1;
      v89 = 0LL;
      v90 = -1;
      v86 = 0LL;
      v87 = -1;
      if ( v55 )
      {
        v84 = -1;
        v56 = *v54;
        v83 = 0LL;
        v80 = google::protobuf::FastInt32ToBuffer(v56, v82);
        v81 = strlen(v80);
        google::protobuf::strings::SubstituteAndAppend(
          a3,
          "$0, ",
          &v80,
          &v83,
          &v86,
          &v89,
          &v91,
          &v93,
          &v95,
          &v97,
          &v99,
          &closure);
      }
      else
      {
        v83 = google::protobuf::FastInt32ToBuffer(v54[1] - 1, v85);
        v84 = strlen(v83);
        v80 = google::protobuf::FastInt32ToBuffer(*v54, v82);
        v81 = strlen(v80);
        google::protobuf::strings::SubstituteAndAppend(
          a3,
          "$0 to $1, ",
          &v80,
          &v83,
          &v86,
          &v89,
          &v91,
          &v93,
          &v95,
          &v97,
          &v99,
          &closure);
      }
    }
    v53 = *(_QWORD *)(a3 + 8);
    if ( v53 - 2 > v53 )
      std::__throw_out_of_range_fmt(
        "%s: __pos (which is %zu) > this->size() (which is %zu)",
        "basic_string::replace",
        v53 - 2,
        v53);
    std::string::_M_replace(a3, v53 - 2, 2LL, ";\n", 2LL);
    v64 = __beg;
    v65 = v73;
  }
  if ( a1->reserved_name_count_ > 0 )
  {
    v80 = v64;
    v81 = v65;
    closure._vptr_Closure = 0LL;
    LODWORD(v102) = -1;
    v99 = 0LL;
    v100 = -1;
    v97 = 0LL;
    v98 = -1;
    v95 = 0LL;
    v96 = -1;
    v93 = 0LL;
    v94 = -1;
    v91 = 0LL;
    v92 = -1;
    v89 = 0LL;
    v90 = -1;
    v86 = 0LL;
    v87 = -1;
    v83 = 0LL;
    v84 = -1;
    google::protobuf::strings::SubstituteAndAppend(
      a3,
      "$0  reserved ",
      &v80,
      &v83,
      &v86,
      &v89,
      &v91,
      &v93,
      &v95,
      &v97,
      &v99,
      &closure);
    for ( ii = 0LL; a1->reserved_name_count_ > (int)ii; ++ii )
    {
      closure._vptr_Closure = 0LL;
      LODWORD(v102) = -1;
      v99 = 0LL;
      v100 = -1;
      v97 = 0LL;
      v98 = -1;
      v95 = 0LL;
      v96 = -1;
      v93 = 0LL;
      v94 = -1;
      v91 = 0LL;
      v92 = -1;
      v89 = 0LL;
      v90 = -1;
      v86 = 0LL;
      v87 = -1;
      v83 = 0LL;
      v84 = -1;
      google::protobuf::CEscape(&str);
      v80 = str._M_dataplus._M_p;
      v81 = str._M_string_length;
      google::protobuf::strings::SubstituteAndAppend(
        a3,
        "\"$0\", ",
        &v80,
        &v83,
        &v86,
        &v89,
        &v91,
        &v93,
        &v95,
        &v97,
        &v99,
        &closure);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)str._M_dataplus._M_p != &str._anon_0 )
        operator delete(str._M_dataplus._M_p);
    }
    v49 = *(_QWORD *)(a3 + 8);
    if ( v49 - 2 > v49 )
      std::__throw_out_of_range_fmt(
        "%s: __pos (which is %zu) > this->size() (which is %zu)",
        "basic_string::replace",
        v49 - 2,
        v49);
    std::string::_M_replace(a3, v49 - 2, 2LL, ";\n", 2LL);
    v64 = __beg;
    v65 = v73;
  }
  v80 = v64;
  v81 = v65;
  closure._vptr_Closure = 0LL;
  LODWORD(v102) = -1;
  v99 = 0LL;
  v100 = -1;
  v97 = 0LL;
  v98 = -1;
  v95 = 0LL;
  v96 = -1;
  v93 = 0LL;
  v94 = -1;
  v91 = 0LL;
  v92 = -1;
  v89 = 0LL;
  v90 = -1;
  v86 = 0LL;
  v87 = -1;
  v83 = 0LL;
  v84 = -1;
  google::protobuf::strings::SubstituteAndAppend(
    a3,
    &off_1A179571,
    &v80,
    &v83,
    &v86,
    &v89,
    &v91,
    &v93,
    &v95,
    &v97,
    &v99,
    &closure);
  if ( v105[0] && v106.trailing_comments._M_string_length )
  {
    str._M_dataplus._M_p = str._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &str,
      v106.trailing_comments._M_dataplus._M_p,
      &v106.trailing_comments._M_dataplus._M_p[v106.trailing_comments._M_string_length],
      (std::forward_iterator_tag)&str);
    google::protobuf::StripWhitespace(&str);
    memset(&v71, 0, sizeof(v71));
    google::protobuf::SplitStringUsing(&str, "\n", &v71);
    v77[0] = 0;
    v57 = 0LL;
    v75 = v77;
    M_start = v71._M_impl._M_start;
    v76 = 0LL;
    if ( v71._M_impl._M_start != v71._M_impl._M_finish )
    {
      do
      {
        closure._vptr_Closure = 0LL;
        v99 = 0LL;
        v97 = 0LL;
        v59 = &M_start[v57];
        v95 = 0LL;
        v93 = 0LL;
        v91 = 0LL;
        v89 = 0LL;
        v86 = 0LL;
        v60 = v59->_M_dataplus._M_p;
        LODWORD(v102) = -1;
        v61 = v59->_M_string_length;
        v83 = (char *)v60;
        v84 = v61;
        v80 = v109._M_dataplus._M_p;
        v100 = -1;
        v98 = -1;
        v96 = -1;
        v94 = -1;
        v92 = -1;
        v90 = -1;
        v87 = -1;
        v81 = v109._M_string_length;
        google::protobuf::strings::SubstituteAndAppend(
          &v75,
          "$0// $1\n",
          &v80,
          &v83,
          &v86,
          &v89,
          &v91,
          &v93,
          &v95,
          &v97,
          &v99,
          &closure);
        M_finish = v71._M_impl._M_finish;
        M_start = v71._M_impl._M_start;
        ++v57;
      }
      while ( v57 < v71._M_impl._M_finish - v71._M_impl._M_start );
      if ( v71._M_impl._M_start != v71._M_impl._M_finish )
      {
        v63 = v71._M_impl._M_start;
        do
        {
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v63->_M_dataplus._M_p != &v63->_anon_0 )
            operator delete(v63->_M_dataplus._M_p);
          ++v63;
        }
        while ( M_finish != v63 );
      }
    }
    if ( v71._M_impl._M_start )
      operator delete(v71._M_impl._M_start);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)str._M_dataplus._M_p != &str._anon_0 )
      operator delete(str._M_dataplus._M_p);
    std::string::_M_append(a3, (const char *)v75, v76);
    if ( v75 != v77 )
      operator delete(v75);
  }
  std::_Rb_tree<google::protobuf::Descriptor const*,google::protobuf::Descriptor const*,std::_Identity<google::protobuf::Descriptor const*>,std::less<google::protobuf::Descriptor const*>,std::allocator<google::protobuf::Descriptor const*>>::_M_erase(
    &v79,
    (std::_Rb_tree<const google::protobuf::Descriptor*,const google::protobuf::Descriptor*,std::_Identity<const google::protobuf::Descriptor*>,std::less<const google::protobuf::Descriptor*>,std::allocator<const google::protobuf::Descriptor*> >::_Link_type)v79._M_impl._M_header._M_parent);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v109._M_dataplus._M_p != &v109._anon_0 )
    operator delete(v109._M_dataplus._M_p);
  v50 = v106.leading_detached_comments._M_impl._M_finish;
  v51 = v106.leading_detached_comments._M_impl._M_start;
  if ( v106.leading_detached_comments._M_impl._M_finish != v106.leading_detached_comments._M_impl._M_start )
  {
    v52 = v106.leading_detached_comments._M_impl._M_start;
    do
    {
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v52->_M_dataplus._M_p != &v52->_anon_0 )
        operator delete(v52->_M_dataplus._M_p);
      ++v52;
    }
    while ( v50 != v52 );
    v51 = v106.leading_detached_comments._M_impl._M_start;
  }
  if ( v51 )
    operator delete(v51);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v106.trailing_comments._M_dataplus._M_p != &v106.trailing_comments._anon_0 )
    operator delete(v106.trailing_comments._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v106.leading_comments._M_dataplus._M_p != &v106.leading_comments._anon_0 )
    operator delete(v106.leading_comments._M_dataplus._M_p);
  if ( __beg != v74 )
    operator delete(__beg);
};

// Line 2507: range 000000000C90D6A0-000000000C90D6C8
std::string *__fastcall google::protobuf::FieldDescriptor::DebugString[abi:cxx11](
        std::string *retstr,
        const google::protobuf::FieldDescriptor *const this)
{
  google::protobuf::DebugStringOptions options; // [rsp+Dh] [rbp-Bh] BYREF

  *(_WORD *)&options.include_comments = 0;
  options.elide_oneof_body = 0;
  google::protobuf::FieldDescriptor::DebugStringWithOptions[abi:cxx11](retstr, this, &options);
  return retstr;
};

// Line 2513: range 000000000C90D4B0-000000000C90D68C
__int64 __fastcall google::protobuf::FieldDescriptor::DebugStringWithOptions[abi:cxx11](
        __int64 a1,
        google::protobuf::FieldDescriptor *a2)
{
  bool v2; // zf
  const google::protobuf::Descriptor *containing_type; // rax
  __int64 *full_name; // rax
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v8; // [rsp+0h] [rbp-200h] BYREF
  int v9; // [rsp+8h] [rbp-1F8h]
  __int64 v10; // [rsp+30h] [rbp-1D0h] BYREF
  int v11; // [rsp+38h] [rbp-1C8h]
  __int64 v12; // [rsp+60h] [rbp-1A0h] BYREF
  int v13; // [rsp+68h] [rbp-198h]
  __int64 v14; // [rsp+90h] [rbp-170h] BYREF
  int v15; // [rsp+98h] [rbp-168h]
  __int64 v16; // [rsp+C0h] [rbp-140h] BYREF
  int v17; // [rsp+C8h] [rbp-138h]
  __int64 v18; // [rsp+F0h] [rbp-110h] BYREF
  int v19; // [rsp+F8h] [rbp-108h]
  __int64 v20; // [rsp+120h] [rbp-E0h] BYREF
  int v21; // [rsp+128h] [rbp-D8h]
  __int64 v22; // [rsp+150h] [rbp-B0h] BYREF
  int v23; // [rsp+158h] [rbp-A8h]
  __int64 v24; // [rsp+180h] [rbp-80h] BYREF
  int v25; // [rsp+188h] [rbp-78h]
  __int64 v26; // [rsp+1B0h] [rbp-50h] BYREF
  int v27; // [rsp+1B8h] [rbp-48h]

  *(_BYTE *)(a1 + 16) = 0;
  v2 = !a2->is_extension_;
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0LL;
  if ( !v2 )
  {
    containing_type = a2->containing_type_;
    v26 = 0LL;
    v24 = 0LL;
    full_name = (__int64 *)containing_type->full_name_;
    v22 = 0LL;
    v20 = 0LL;
    v18 = 0LL;
    v16 = 0LL;
    v14 = 0LL;
    v12 = 0LL;
    v10 = 0LL;
    v5 = *full_name;
    v6 = full_name[1];
    v27 = -1;
    v8 = v5;
    v9 = v6;
    v25 = -1;
    v23 = -1;
    v21 = -1;
    v19 = -1;
    v17 = -1;
    v15 = -1;
    v13 = -1;
    v11 = -1;
    google::protobuf::strings::SubstituteAndAppend(
      a1,
      "extend .$0 {\n",
      &v8,
      &v10,
      &v12,
      &v14,
      &v16,
      &v18,
      &v20,
      &v22,
      &v24,
      &v26);
  }
  google::protobuf::FieldDescriptor::DebugString(a2);
  if ( !a2->is_extension_ )
    return a1;
  if ( *(_QWORD *)(a1 + 8) == 0x3FFFFFFFFFFFFFFFLL || *(_QWORD *)(a1 + 8) == 4611686018427387902LL )
    std::__throw_length_error("basic_string::append");
  std::string::_M_append(a1, "}\n", 2LL);
  return a1;
};

// Line 2529: range 000000000C8FA470-000000000C8FA6A4
std::string *__fastcall google::protobuf::FieldDescriptor::FieldTypeNameDebugString[abi:cxx11](
        std::string *retstr,
        __int64 a2,
        __int64 a3,
        std::forward_iterator_tag a4)
{
  google::protobuf::ProtobufOnceType *v5; // rdi
  __int64 v6; // rax
  google::protobuf::ProtobufOnceType *v7; // rdi
  const char *v8; // rbp
  __int64 v9; // rdx
  google::protobuf::ProtobufOnceType *v11; // rdi
  google::protobuf::ProtobufOnceType *v12; // rdi
  google::protobuf::Closure v13; // [rsp+0h] [rbp-38h] BYREF
  void (__fastcall *v14)(const google::protobuf::FieldDescriptor *); // [rsp+8h] [rbp-30h]
  char v15; // [rsp+10h] [rbp-28h]
  __int64 v16; // [rsp+18h] [rbp-20h]

  v5 = *(google::protobuf::ProtobufOnceType **)(a2 + 48);
  if ( v5 )
  {
    if ( *v5 == 2 )
    {
      v6 = *(int *)(a2 + 56);
      if ( (_DWORD)v6 != 11 )
      {
LABEL_4:
        if ( (_DWORD)v6 != 14 )
        {
          v7 = *(google::protobuf::ProtobufOnceType **)(a2 + 48);
          if ( v7 )
          {
            if ( *v7 != 2 )
            {
              v13._vptr_Closure = (int (**)(...))&off_1A17BF90;
              v15 = 0;
              v14 = google::protobuf::FieldDescriptor::TypeOnceInit;
              v16 = a2;
              google::protobuf::GoogleOnceInitImpl(v7, &v13);
              v13._vptr_Closure = (int (**)(...))&off_1A17BF90;
              google::protobuf::Closure::~Closure(&v13);
            }
            v6 = *(int *)(a2 + 56);
          }
          goto LABEL_13;
        }
        v11 = *(google::protobuf::ProtobufOnceType **)(a2 + 48);
        if ( v11 && *v11 != 2 )
        {
          v13._vptr_Closure = (int (**)(...))&off_1A17BF90;
          v15 = 0;
          v14 = google::protobuf::FieldDescriptor::TypeOnceInit;
          v16 = a2;
          google::protobuf::GoogleOnceInitImpl(v11, &v13);
          v13._vptr_Closure = (int (**)(...))&off_1A17BF90;
          google::protobuf::Closure::~Closure(&v13);
        }
LABEL_19:
        std::operator+<char>(retstr, ".", *(const std::string **)(*(_QWORD *)(a2 + 112) + 8LL));
        return retstr;
      }
    }
    else
    {
      v16 = a2;
      v13._vptr_Closure = (int (**)(...))&off_1A17BF90;
      v14 = google::protobuf::FieldDescriptor::TypeOnceInit;
      v15 = 0;
      google::protobuf::GoogleOnceInitImpl(v5, &v13);
      v13._vptr_Closure = (int (**)(...))&off_1A17BF90;
      google::protobuf::Closure::~Closure(&v13);
      v6 = *(int *)(a2 + 56);
      if ( (_DWORD)v6 != 11 )
        goto LABEL_4;
    }
    v12 = *(google::protobuf::ProtobufOnceType **)(a2 + 48);
    if ( v12 && *v12 != 2 )
    {
      v13._vptr_Closure = (int (**)(...))&off_1A17BF90;
      v15 = 0;
      v14 = google::protobuf::FieldDescriptor::TypeOnceInit;
      v16 = a2;
      google::protobuf::GoogleOnceInitImpl(v12, &v13);
      v13._vptr_Closure = (int (**)(...))&off_1A17BF90;
      google::protobuf::Closure::~Closure(&v13);
    }
LABEL_23:
    std::operator+<char>(retstr, ".", *(const std::string **)(*(_QWORD *)(a2 + 104) + 8LL));
    return retstr;
  }
  v6 = *(int *)(a2 + 56);
  if ( (_DWORD)v6 == 11 )
    goto LABEL_23;
  if ( (_DWORD)v6 == 14 )
    goto LABEL_19;
LABEL_13:
  v8 = google::protobuf::FieldDescriptor::kTypeToName[v6];
  v9 = -1LL;
  retstr->_M_dataplus._M_p = retstr->_anon_0._M_local_buf;
  if ( v8 )
    v9 = (__int64)&v8[strlen(v8)];
  std::string::_M_construct<char const*>(retstr, v8, (const char *)v9, a4);
  return retstr;
};

// Line 2544: range 000000000C90C2C0-000000000C90D4AB
void __fastcall google::protobuf::FieldDescriptor::DebugString(
        google::protobuf::FieldDescriptor *this,
        int a2,
        int a3,
        __int64 a4,
        __int64 a5)
{
  __int64 v8; // rdx
  std::forward_iterator_tag v9; // cl
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  __int64 v11; // rdx
  std::forward_iterator_tag v12; // cl
  google::protobuf::GoogleOnceDynamic *v13; // rdi
  std::forward_iterator_tag v14; // cl
  std::string::pointer v15; // rdi
  bool is_map; // al
  __int16 v17; // ax
  __int64 v18; // rdx
  std::forward_iterator_tag v19; // cl
  char SourceLocation; // al
  int number; // edi
  int v22; // eax
  google::protobuf::GoogleOnceDynamic *v23; // rdi
  const std::string *name; // rax
  int (**v25)(...); // rdx
  std::forward_iterator_tag v26; // cl
  bool has_json_name; // r14
  google::protobuf::FieldOptions *options; // rsi
  const google::protobuf::FileDescriptor *file; // rax
  google::protobuf::GoogleOnceDynamic *v30; // rdi
  google::protobuf::GoogleOnceDynamic *v31; // rdi
  std::forward_iterator_tag v32; // cl
  std::_Vector_base<std::string>::pointer v33; // rbx
  std::_Vector_base<std::string>::pointer v34; // rdi
  std::_Vector_base<std::string>::pointer v35; // r15
  const char *v36; // r14
  size_t v37; // rax
  __int64 v38; // r14
  _BYTE *v39; // rdx
  unsigned __int64 v40; // rax
  const char *v41; // rsi
  char *M_p; // rdi
  std::string::size_type M_string_length; // rdx
  std::string::size_type v44; // rsi
  google::protobuf::GoogleOnceDynamic *v45; // rdi
  std::_Vector_base<std::string>::pointer M_start; // r12
  unsigned __int64 v47; // rbx
  std::string *v48; // rax
  int (**v49)(...); // rdx
  std::_Vector_base<std::string>::pointer M_finish; // r14
  std::vector<std::string> v53; // [rsp+30h] [rbp-390h] BYREF
  char *__beg; // [rsp+50h] [rbp-370h] BYREF
  __int64 v55; // [rsp+58h] [rbp-368h]
  char v56[16]; // [rsp+60h] [rbp-360h] BYREF
  void *dest; // [rsp+70h] [rbp-350h] BYREF
  std::string::size_type v58; // [rsp+78h] [rbp-348h]
  __int64 v59[2]; // [rsp+80h] [rbp-340h] BYREF
  void *v60; // [rsp+90h] [rbp-330h] BYREF
  __int64 v61; // [rsp+98h] [rbp-328h]
  __int64 v62[2]; // [rsp+A0h] [rbp-320h] BYREF
  void *v63; // [rsp+B0h] [rbp-310h] BYREF
  __int64 v64; // [rsp+B8h] [rbp-308h]
  char v65[16]; // [rsp+C0h] [rbp-300h] BYREF
  void *v66; // [rsp+D0h] [rbp-2F0h] BYREF
  __int64 v67; // [rsp+D8h] [rbp-2E8h]
  char v68[16]; // [rsp+E0h] [rbp-2E0h] BYREF
  std::string str; // [rsp+F0h] [rbp-2D0h] BYREF
  std::string v70; // [rsp+110h] [rbp-2B0h] BYREF
  google::protobuf::Closure v71; // [rsp+140h] [rbp-280h] BYREF
  void (__fastcall *v72)(const google::protobuf::FieldDescriptor *); // [rsp+148h] [rbp-278h]
  char v73; // [rsp+150h] [rbp-270h]
  google::protobuf::FieldDescriptor *v74; // [rsp+158h] [rbp-268h]
  google::protobuf::Closure v75; // [rsp+170h] [rbp-250h] BYREF
  void (__fastcall *v76)(const google::protobuf::FieldDescriptor *); // [rsp+178h] [rbp-248h]
  char v77; // [rsp+180h] [rbp-240h]
  google::protobuf::FieldDescriptor *v78; // [rsp+188h] [rbp-238h]
  google::protobuf::Closure v79; // [rsp+1A0h] [rbp-220h] BYREF
  void (__fastcall *v80)(const google::protobuf::FieldDescriptor *); // [rsp+1A8h] [rbp-218h]
  char v81; // [rsp+1B0h] [rbp-210h]
  google::protobuf::FieldDescriptor *v82; // [rsp+1B8h] [rbp-208h]
  char *v83; // [rsp+1D0h] [rbp-1F0h] BYREF
  int v84; // [rsp+1D8h] [rbp-1E8h]
  char buffer[36]; // [rsp+1DCh] [rbp-1E4h] BYREF
  __int64 v86; // [rsp+200h] [rbp-1C0h] BYREF
  int v87; // [rsp+208h] [rbp-1B8h]
  __int64 v88; // [rsp+230h] [rbp-190h] BYREF
  int v89; // [rsp+238h] [rbp-188h]
  __int64 v90; // [rsp+260h] [rbp-160h] BYREF
  int v91; // [rsp+268h] [rbp-158h]
  __int64 v92; // [rsp+290h] [rbp-130h] BYREF
  int v93; // [rsp+298h] [rbp-128h]
  std::string closure; // [rsp+2C0h] [rbp-100h] BYREF
  __int64 v95; // [rsp+2F0h] [rbp-D0h] BYREF
  google::protobuf::SourceLocation v96; // [rsp+2F8h] [rbp-C8h] BYREF
  __int16 v97; // [rsp+360h] [rbp-60h]
  char v98; // [rsp+362h] [rbp-5Eh]
  std::string v99; // [rsp+368h] [rbp-58h] BYREF

  __beg = v56;
  std::string::_M_construct(&__beg, 2 * a2, 32LL);
  v58 = 0LL;
  dest = v59;
  LOBYTE(v59[0]) = 0;
  if ( !google::protobuf::FieldDescriptor::is_map(this) )
  {
    google::protobuf::FieldDescriptor::FieldTypeNameDebugString[abi:cxx11](&closure, (__int64)this, v8, v9);
    M_p = (char *)dest;
    M_string_length = closure._M_string_length;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure._M_dataplus._M_p == &closure._anon_0 )
    {
      if ( closure._M_string_length )
      {
        if ( closure._M_string_length == 1 )
          *(_BYTE *)dest = closure._anon_0._M_local_buf[0];
        else
          memcpy(dest, &closure._anon_0, closure._M_string_length);
        M_string_length = closure._M_string_length;
        M_p = (char *)dest;
      }
      v58 = M_string_length;
      M_p[M_string_length] = 0;
      M_p = closure._M_dataplus._M_p;
    }
    else
    {
      v14.gap0[0] = closure._anon_0._M_local_buf[0];
      if ( dest == v59 )
      {
        dest = closure._M_dataplus._M_p;
        v58 = closure._M_string_length;
        v59[0] = closure._anon_0._M_allocated_capacity;
      }
      else
      {
        v44 = v59[0];
        dest = closure._M_dataplus._M_p;
        v58 = closure._M_string_length;
        v59[0] = closure._anon_0._M_allocated_capacity;
        if ( M_p )
        {
          closure._M_dataplus._M_p = M_p;
          closure._anon_0._M_allocated_capacity = v44;
          goto LABEL_95;
        }
      }
      closure._M_dataplus._M_p = closure._anon_0._M_local_buf;
      M_p = closure._anon_0._M_local_buf;
    }
LABEL_95:
    closure._M_string_length = 0LL;
    *M_p = 0;
    v15 = closure._M_dataplus._M_p;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure._M_dataplus._M_p == &closure._anon_0 )
      goto LABEL_12;
    goto LABEL_11;
  }
  v95 = 0LL;
  type_once = this->type_once_;
  v96.start_line = -1;
  closure._M_dataplus._M_p = 0LL;
  LODWORD(closure._M_string_length) = -1;
  v92 = 0LL;
  v93 = -1;
  v90 = 0LL;
  v91 = -1;
  v88 = 0LL;
  v89 = -1;
  v86 = 0LL;
  v87 = -1;
  v83 = 0LL;
  v84 = -1;
  v79._vptr_Closure = 0LL;
  LODWORD(v80) = -1;
  if ( type_once && type_once->state_ != 2 )
  {
    v77 = 0;
    v78 = this;
    v75._vptr_Closure = (int (**)(...))&off_1A17BF90;
    v76 = google::protobuf::FieldDescriptor::TypeOnceInit;
    google::protobuf::GoogleOnceInitImpl(&type_once->state_, &v75);
    v75._vptr_Closure = (int (**)(...))&off_1A17BF90;
    google::protobuf::Closure::~Closure(&v75);
  }
  google::protobuf::FieldDescriptor::FieldTypeNameDebugString[abi:cxx11](
    &v70,
    (__int64)&this->message_type_->fields_[1],
    v8,
    v9);
  v13 = this->type_once_;
  v75._vptr_Closure = (int (**)(...))v70._M_dataplus._M_p;
  LODWORD(v76) = v70._M_string_length;
  if ( v13 && v13->state_ != 2 )
  {
    v73 = 0;
    v74 = this;
    v71._vptr_Closure = (int (**)(...))&off_1A17BF90;
    v72 = google::protobuf::FieldDescriptor::TypeOnceInit;
    google::protobuf::GoogleOnceInitImpl(&v13->state_, &v71);
    v71._vptr_Closure = (int (**)(...))&off_1A17BF90;
    google::protobuf::Closure::~Closure(&v71);
  }
  google::protobuf::FieldDescriptor::FieldTypeNameDebugString[abi:cxx11](
    &str,
    (__int64)this->message_type_->fields_,
    v11,
    v12);
  v71._vptr_Closure = (int (**)(...))str._M_dataplus._M_p;
  LODWORD(v72) = str._M_string_length;
  google::protobuf::strings::SubstituteAndAppend(
    &dest,
    "map<$0, $1>",
    &v71,
    &v75,
    &v79,
    &v83,
    &v86,
    &v88,
    &v90,
    &v92,
    &closure,
    &v95);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)str._M_dataplus._M_p != &str._anon_0 )
    operator delete(str._M_dataplus._M_p);
  v15 = v70._M_dataplus._M_p;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v70._M_dataplus._M_p != &v70._anon_0 )
LABEL_11:
    operator delete(v15);
LABEL_12:
  if ( this->label_ == LABEL_OPTIONAL && (a3 == 1 || this->file_->syntax_ == SYNTAX_PROTO3) )
  {
    LOBYTE(v62[0]) = 0;
    v60 = v62;
    v61 = 0LL;
  }
  else
  {
    is_map = google::protobuf::FieldDescriptor::is_map(this);
    v61 = 0LL;
    v60 = v62;
    LOBYTE(v62[0]) = 0;
    if ( !is_map )
    {
      v36 = google::protobuf::FieldDescriptor::kLabelToName[this->label_];
      v37 = strlen(v36);
      std::string::_M_replace(&v60, 0LL, 0LL, v36, v37);
      v38 = v61;
      v39 = v60;
      v40 = 15LL;
      if ( v60 != v62 )
        v40 = v62[0];
      if ( v61 + 1 > v40 )
      {
        std::string::_M_mutate(&v60, v61, 0LL, 0LL, 1LL);
        v39 = v60;
      }
      v39[v38] = 32;
      v61 = v38 + 1;
      *((_BYTE *)v60 + v38 + 1) = 0;
    }
  }
  v96.leading_comments._M_dataplus._M_p = v96.leading_comments._anon_0._M_local_buf;
  v96.trailing_comments._M_dataplus._M_p = v96.trailing_comments._anon_0._M_local_buf;
  v17 = *(_WORD *)a5;
  v96.leading_comments._M_string_length = 0LL;
  v97 = v17;
  LOBYTE(v17) = *(_BYTE *)(a5 + 2);
  v96.leading_comments._anon_0._M_local_buf[0] = 0;
  v98 = v17;
  v96.trailing_comments._M_string_length = 0LL;
  v96.trailing_comments._anon_0._M_local_buf[0] = 0;
  memset(&v96.leading_detached_comments, 0, sizeof(v96.leading_detached_comments));
  v99._M_dataplus._M_p = v99._anon_0._M_local_buf;
  std::string::_M_construct<char *>(&v99, __beg, &__beg[v55], v14);
  SourceLocation = *(_BYTE *)a5;
  if ( *(_BYTE *)a5 )
    SourceLocation = google::protobuf::FieldDescriptor::GetSourceLocation(this, &v96);
  LOBYTE(v95) = SourceLocation;
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment((__int64)&v95, a4, v18, v19);
  number = this->number_;
  closure._M_dataplus._M_p = 0LL;
  LODWORD(closure._M_string_length) = -1;
  v92 = 0LL;
  v93 = -1;
  v90 = 0LL;
  v91 = -1;
  v88 = 0LL;
  v89 = -1;
  v86 = 0LL;
  v87 = -1;
  v83 = google::protobuf::FastInt32ToBuffer(number, buffer);
  v22 = strlen(v83);
  v23 = this->type_once_;
  v84 = v22;
  if ( v23 )
  {
    if ( v23->state_ == 2 )
    {
      if ( this->type_ != TYPE_GROUP_0 )
      {
LABEL_21:
        name = this->name_;
        goto LABEL_22;
      }
    }
    else
    {
      v81 = 0;
      v79._vptr_Closure = (int (**)(...))&off_1A17BF90;
      v80 = google::protobuf::FieldDescriptor::TypeOnceInit;
      v82 = this;
      google::protobuf::GoogleOnceInitImpl(&v23->state_, &v79);
      v79._vptr_Closure = (int (**)(...))&off_1A17BF90;
      google::protobuf::Closure::~Closure(&v79);
      if ( this->type_ != TYPE_GROUP_0 )
        goto LABEL_21;
    }
    v45 = this->type_once_;
    if ( v45 && v45->state_ != 2 )
    {
      v81 = 0;
      v79._vptr_Closure = (int (**)(...))&off_1A17BF90;
      v80 = google::protobuf::FieldDescriptor::TypeOnceInit;
      v82 = this;
      google::protobuf::GoogleOnceInitImpl(&v45->state_, &v79);
      v79._vptr_Closure = (int (**)(...))&off_1A17BF90;
      google::protobuf::Closure::~Closure(&v79);
    }
  }
  else if ( this->type_ != TYPE_GROUP_0 )
  {
    goto LABEL_21;
  }
  name = this->message_type_->name_;
LABEL_22:
  v25 = (int (**)(...))name->_M_dataplus._M_p;
  LODWORD(v80) = name->_M_string_length;
  v79._vptr_Closure = v25;
  v75._vptr_Closure = (int (**)(...))dest;
  LODWORD(v76) = v58;
  v71._vptr_Closure = (int (**)(...))v60;
  LODWORD(v72) = v61;
  v70._M_dataplus._M_p = __beg;
  LODWORD(v70._M_string_length) = v55;
  google::protobuf::strings::SubstituteAndAppend(
    a4,
    "$0$1$2 $3 = $4",
    &v70,
    &v71,
    &v75,
    &v79,
    &v83,
    &v86,
    &v88,
    &v90,
    &v92,
    &closure);
  if ( this->has_default_value_ )
  {
    closure._M_dataplus._M_p = 0LL;
    LODWORD(closure._M_string_length) = -1;
    v92 = 0LL;
    v93 = -1;
    v90 = 0LL;
    v91 = -1;
    v88 = 0LL;
    v89 = -1;
    v86 = 0LL;
    v87 = -1;
    v83 = 0LL;
    v84 = -1;
    v79._vptr_Closure = 0LL;
    LODWORD(v80) = -1;
    v75._vptr_Closure = 0LL;
    LODWORD(v76) = -1;
    v71._vptr_Closure = 0LL;
    LODWORD(v72) = -1;
    google::protobuf::FieldDescriptor::DefaultValueAsString[abi:cxx11](&str, (__int64)this, 1, v26);
    v70._M_dataplus._M_p = str._M_dataplus._M_p;
    LODWORD(v70._M_string_length) = str._M_string_length;
    google::protobuf::strings::SubstituteAndAppend(
      a4,
      " [default = $0",
      &v70,
      &v71,
      &v75,
      &v79,
      &v83,
      &v86,
      &v88,
      &v90,
      &v92,
      &closure);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)str._M_dataplus._M_p != &str._anon_0 )
      operator delete(str._M_dataplus._M_p);
    if ( !this->has_json_name_ )
      goto LABEL_31;
    if ( *(_QWORD *)(a4 + 8) == 0x3FFFFFFFFFFFFFFFLL || *(_QWORD *)(a4 + 8) == 4611686018427387902LL )
      std::__throw_length_error("basic_string::append");
    std::string::_M_append(a4, ", ", 2LL);
  }
  else
  {
    has_json_name = this->has_json_name_;
    if ( !has_json_name )
      goto LABEL_32;
    if ( *(_QWORD *)(a4 + 8) == 0x3FFFFFFFFFFFFFFFLL )
      std::__throw_length_error("basic_string::append");
    std::string::_M_append(a4, "[", 1LL);
  }
  if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - *(_QWORD *)(a4 + 8)) <= 0xC )
    std::__throw_length_error("basic_string::append");
  std::string::_M_append(a4, "json_name = \"", 13LL);
  google::protobuf::CEscape(&closure);
  std::string::_M_append(a4, closure._M_dataplus._M_p, closure._M_string_length);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure._M_dataplus._M_p != &closure._anon_0 )
    operator delete(closure._M_dataplus._M_p);
  if ( *(_QWORD *)(a4 + 8) == 0x3FFFFFFFFFFFFFFFLL )
    std::__throw_length_error("basic_string::append");
  std::string::_M_append(a4, "\"", 1LL);
LABEL_31:
  has_json_name = 1;
LABEL_32:
  options = (google::protobuf::FieldOptions *)this->options_;
  v65[0] = 0;
  v63 = v65;
  file = this->file_;
  v64 = 0LL;
  if ( (unsigned __int8)google::protobuf::`anonymous namespace'::FormatBracketedOptions(
                          a2,
                          options,
                          (google::protobuf::DescriptorPool *)file->pool_,
                          (__int64)&v63) )
  {
    v41 = "\"$0\", " + 4;
    if ( !has_json_name )
      v41 = ": [" + 1;
    if ( *(_QWORD *)(a4 + 8) == 0x3FFFFFFFFFFFFFFFLL || *(_QWORD *)(a4 + 8) == 4611686018427387902LL )
      std::__throw_length_error("basic_string::append");
    std::string::_M_append(a4, v41, 2LL, a4);
    std::string::_M_append(a4, (const char *)v63, v64);
  }
  else if ( !has_json_name )
  {
    goto LABEL_36;
  }
  if ( *(_QWORD *)(a4 + 8) == 0x3FFFFFFFFFFFFFFFLL )
    std::__throw_length_error("basic_string::append");
  std::string::_M_append(a4, "]", 1LL);
LABEL_36:
  v30 = this->type_once_;
  if ( v30 && v30->state_ != 2 )
  {
    closure._anon_0._M_local_buf[0] = 0;
    closure._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    closure._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
    *(&closure._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
    google::protobuf::GoogleOnceInitImpl(&v30->state_, (google::protobuf::Closure *)&closure);
    closure._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&closure);
  }
  if ( this->type_ == TYPE_GROUP_0 )
  {
    if ( *(_BYTE *)(a5 + 1) )
    {
      if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - *(_QWORD *)(a4 + 8)) <= 9 )
        std::__throw_length_error("basic_string::append");
      std::string::_M_append(a4, " { ... };\n", 10LL);
    }
    else
    {
      v31 = this->type_once_;
      if ( v31 && v31->state_ != 2 )
      {
        closure._anon_0._M_local_buf[0] = 0;
        closure._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        closure._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
        *(&closure._anon_0._M_allocated_capacity + 1) = (std::string::size_type)this;
        google::protobuf::GoogleOnceInitImpl(&v31->state_, (google::protobuf::Closure *)&closure);
        closure._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&closure);
      }
      google::protobuf::Descriptor::DebugString((google::protobuf::Descriptor *)this->message_type_, a2, a4, a5, 0);
    }
  }
  else
  {
    if ( *(_QWORD *)(a4 + 8) == 0x3FFFFFFFFFFFFFFFLL || *(_QWORD *)(a4 + 8) == 4611686018427387902LL )
      std::__throw_length_error("basic_string::append");
    std::string::_M_append(a4, ";\n", 2LL);
  }
  if ( (_BYTE)v95 && v96.trailing_comments._M_string_length )
  {
    str._M_dataplus._M_p = str._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &str,
      v96.trailing_comments._M_dataplus._M_p,
      &v96.trailing_comments._M_dataplus._M_p[v96.trailing_comments._M_string_length],
      v32);
    google::protobuf::StripWhitespace(&str);
    memset(&v53, 0, sizeof(v53));
    google::protobuf::SplitStringUsing(&str, "\n", &v53);
    v68[0] = 0;
    M_start = v53._M_impl._M_start;
    v47 = 0LL;
    v66 = v68;
    v67 = 0LL;
    if ( v53._M_impl._M_finish != v53._M_impl._M_start )
    {
      do
      {
        closure._M_dataplus._M_p = 0LL;
        v92 = 0LL;
        v48 = &M_start[v47];
        v90 = 0LL;
        v88 = 0LL;
        v86 = 0LL;
        v83 = 0LL;
        v79._vptr_Closure = 0LL;
        v75._vptr_Closure = 0LL;
        v49 = (int (**)(...))v48->_M_dataplus._M_p;
        LODWORD(closure._M_string_length) = -1;
        LODWORD(v72) = v48->_M_string_length;
        v71._vptr_Closure = v49;
        v70._M_dataplus._M_p = v99._M_dataplus._M_p;
        v93 = -1;
        LODWORD(v70._M_string_length) = v99._M_string_length;
        v91 = -1;
        v89 = -1;
        v87 = -1;
        v84 = -1;
        LODWORD(v80) = -1;
        LODWORD(v76) = -1;
        google::protobuf::strings::SubstituteAndAppend(
          &v66,
          "$0// $1\n",
          &v70,
          &v71,
          &v75,
          &v79,
          &v83,
          &v86,
          &v88,
          &v90,
          &v92,
          &closure);
        M_finish = v53._M_impl._M_finish;
        M_start = v53._M_impl._M_start;
        ++v47;
      }
      while ( v53._M_impl._M_finish - v53._M_impl._M_start > v47 );
      if ( v53._M_impl._M_start != v53._M_impl._M_finish )
      {
        do
        {
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)M_start->_M_dataplus._M_p != &M_start->_anon_0 )
            operator delete(M_start->_M_dataplus._M_p);
          ++M_start;
        }
        while ( M_finish != M_start );
      }
    }
    if ( v53._M_impl._M_start )
      operator delete(v53._M_impl._M_start);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)str._M_dataplus._M_p != &str._anon_0 )
      operator delete(str._M_dataplus._M_p);
    std::string::_M_append(a4, (const char *)v66, v67);
    if ( v66 != v68 )
      operator delete(v66);
  }
  if ( v63 != v65 )
    operator delete(v63);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v99._M_dataplus._M_p != &v99._anon_0 )
    operator delete(v99._M_dataplus._M_p);
  v33 = v96.leading_detached_comments._M_impl._M_finish;
  v34 = v96.leading_detached_comments._M_impl._M_start;
  if ( v96.leading_detached_comments._M_impl._M_finish != v96.leading_detached_comments._M_impl._M_start )
  {
    v35 = v96.leading_detached_comments._M_impl._M_start;
    do
    {
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v35->_M_dataplus._M_p != &v35->_anon_0 )
        operator delete(v35->_M_dataplus._M_p);
      ++v35;
    }
    while ( v33 != v35 );
    v34 = v96.leading_detached_comments._M_impl._M_start;
  }
  if ( v34 )
    operator delete(v34);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v96.trailing_comments._M_dataplus._M_p != &v96.trailing_comments._anon_0 )
    operator delete(v96.trailing_comments._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v96.leading_comments._M_dataplus._M_p != &v96.leading_comments._anon_0 )
    operator delete(v96.leading_comments._M_dataplus._M_p);
  if ( v60 != v62 )
    operator delete(v60);
  if ( dest != v59 )
    operator delete(dest);
  if ( __beg != v56 )
    operator delete(__beg);
};

// Line 2630: range 000000000C917640-000000000C917668
std::string *__fastcall google::protobuf::OneofDescriptor::DebugString[abi:cxx11](
        std::string *retstr,
        const google::protobuf::OneofDescriptor *const this)
{
  google::protobuf::DebugStringOptions options; // [rsp+Dh] [rbp-Bh] BYREF

  *(_WORD *)&options.include_comments = 0;
  options.elide_oneof_body = 0;
  google::protobuf::OneofDescriptor::DebugStringWithOptions[abi:cxx11](retstr, this, &options);
  return retstr;
};

// Line 2636: range 000000000C917600-000000000C91763A
__int64 __fastcall google::protobuf::OneofDescriptor::DebugStringWithOptions[abi:cxx11](
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_BYTE *)(a1 + 16) = 0;
  google::protobuf::OneofDescriptor::DebugString(a2, 0LL, a1, a3);
  return a1;
};

// Line 2644: range 000000000C916E10-000000000C9175F8
void __fastcall google::protobuf::OneofDescriptor::DebugString(
        google::protobuf::OneofDescriptor *a1,
        int a2,
        __int64 a3,
        __int64 a4)
{
  int v6; // r13d
  __int16 v7; // ax
  std::forward_iterator_tag v8; // cl
  __int64 v9; // rdx
  std::forward_iterator_tag v10; // cl
  char SourceLocation; // al
  const std::string *name; // rax
  __int64 M_p; // rdx
  std::string::size_type M_string_length; // rax
  __int64 v15; // rax
  std::forward_iterator_tag v16; // cl
  std::_Vector_base<std::string>::pointer v17; // rbx
  std::_Vector_base<std::string>::pointer v18; // rdi
  std::_Vector_base<std::string>::pointer v19; // r15
  __int64 i; // rbx
  std::_Vector_base<std::string>::pointer M_start; // r14
  unsigned __int64 v22; // rbx
  std::string *v23; // r14
  __int64 v24; // rax
  std::string::size_type v25; // rax
  std::_Vector_base<std::string>::pointer M_finish; // r13
  std::vector<std::string> v27; // [rsp+10h] [rbp-330h] BYREF
  char *__beg; // [rsp+30h] [rbp-310h] BYREF
  __int64 v29; // [rsp+38h] [rbp-308h]
  char v30[16]; // [rsp+40h] [rbp-300h] BYREF
  void *v31; // [rsp+50h] [rbp-2F0h] BYREF
  __int64 v32; // [rsp+58h] [rbp-2E8h]
  char v33[16]; // [rsp+60h] [rbp-2E0h] BYREF
  std::string str; // [rsp+70h] [rbp-2D0h] BYREF
  char *v35; // [rsp+90h] [rbp-2B0h] BYREF
  int v36; // [rsp+98h] [rbp-2A8h]
  __int64 v37; // [rsp+C0h] [rbp-280h] BYREF
  int v38; // [rsp+C8h] [rbp-278h]
  __int64 v39; // [rsp+F0h] [rbp-250h] BYREF
  int v40; // [rsp+F8h] [rbp-248h]
  __int64 v41; // [rsp+120h] [rbp-220h] BYREF
  int v42; // [rsp+128h] [rbp-218h]
  __int64 v43; // [rsp+150h] [rbp-1F0h] BYREF
  int v44; // [rsp+158h] [rbp-1E8h]
  __int64 v45; // [rsp+180h] [rbp-1C0h] BYREF
  int v46; // [rsp+188h] [rbp-1B8h]
  __int64 v47; // [rsp+1B0h] [rbp-190h] BYREF
  int v48; // [rsp+1B8h] [rbp-188h]
  __int64 v49; // [rsp+1E0h] [rbp-160h] BYREF
  int v50; // [rsp+1E8h] [rbp-158h]
  __int64 v51; // [rsp+210h] [rbp-130h] BYREF
  int v52; // [rsp+218h] [rbp-128h]
  __int64 v53; // [rsp+240h] [rbp-100h] BYREF
  int v54; // [rsp+248h] [rbp-F8h]
  char v55[8]; // [rsp+270h] [rbp-D0h] BYREF
  google::protobuf::SourceLocation v56; // [rsp+278h] [rbp-C8h] BYREF
  __int16 v57; // [rsp+2E0h] [rbp-60h]
  char v58; // [rsp+2E2h] [rbp-5Eh]
  std::string v59; // [rsp+2E8h] [rbp-58h] BYREF

  v6 = a2 + 1;
  __beg = v30;
  std::string::_M_construct(&__beg, 2 * a2, 32LL);
  v56.leading_comments._M_dataplus._M_p = v56.leading_comments._anon_0._M_local_buf;
  v56.trailing_comments._M_dataplus._M_p = v56.trailing_comments._anon_0._M_local_buf;
  v7 = *(_WORD *)a4;
  v56.leading_comments._M_string_length = 0LL;
  v57 = v7;
  LOBYTE(v7) = *(_BYTE *)(a4 + 2);
  v56.leading_comments._anon_0._M_local_buf[0] = 0;
  v58 = v7;
  v56.trailing_comments._M_string_length = 0LL;
  v56.trailing_comments._anon_0._M_local_buf[0] = 0;
  memset(&v56.leading_detached_comments, 0, sizeof(v56.leading_detached_comments));
  v59._M_dataplus._M_p = v59._anon_0._M_local_buf;
  std::string::_M_construct<char *>(&v59, __beg, &__beg[v29], v8);
  SourceLocation = *(_BYTE *)a4;
  if ( *(_BYTE *)a4 )
    SourceLocation = google::protobuf::OneofDescriptor::GetSourceLocation(a1, &v56);
  v55[0] = SourceLocation;
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment((__int64)v55, a3, v9, v10);
  v53 = 0LL;
  v51 = 0LL;
  name = a1->name_;
  v49 = 0LL;
  v47 = 0LL;
  v45 = 0LL;
  v43 = 0LL;
  v41 = 0LL;
  v39 = 0LL;
  M_p = (__int64)name->_M_dataplus._M_p;
  v54 = -1;
  M_string_length = name->_M_string_length;
  v37 = M_p;
  v38 = M_string_length;
  v52 = -1;
  v35 = __beg;
  v50 = -1;
  v36 = v29;
  v48 = -1;
  v46 = -1;
  v44 = -1;
  v42 = -1;
  v40 = -1;
  google::protobuf::strings::SubstituteAndAppend(
    a3,
    "$0oneof $1 {",
    &v35,
    &v37,
    &v39,
    &v41,
    &v43,
    &v45,
    &v47,
    &v49,
    &v51,
    &v53);
  google::protobuf::`anonymous namespace'::FormatLineOptions(
    v6,
    &a1->options_->google::protobuf::Message,
    (google::protobuf::DescriptorPool *)a1->containing_type_->file_->pool_,
    a3);
  v15 = *(_QWORD *)(a3 + 8);
  if ( *(_BYTE *)(a4 + 2) )
  {
    if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v15) <= 6 )
      std::__throw_length_error("basic_string::append");
    std::string::_M_append(a3, " ... }\n", 7LL);
  }
  else
  {
    if ( v15 == 0x3FFFFFFFFFFFFFFFLL )
      std::__throw_length_error("basic_string::append");
    std::string::_M_append(a3, "\n", 1LL);
    for ( i = 0LL; a1->field_count_ > (int)i; ++i )
      google::protobuf::FieldDescriptor::DebugString((google::protobuf::FieldDescriptor *)a1->fields_[i], v6, 1, a3, a4);
    v53 = 0LL;
    v35 = __beg;
    v54 = -1;
    v36 = v29;
    v51 = 0LL;
    v52 = -1;
    v49 = 0LL;
    v50 = -1;
    v47 = 0LL;
    v48 = -1;
    v45 = 0LL;
    v46 = -1;
    v43 = 0LL;
    v44 = -1;
    v41 = 0LL;
    v42 = -1;
    v39 = 0LL;
    v40 = -1;
    v37 = 0LL;
    v38 = -1;
    google::protobuf::strings::SubstituteAndAppend(
      a3,
      &off_1A179571,
      &v35,
      &v37,
      &v39,
      &v41,
      &v43,
      &v45,
      &v47,
      &v49,
      &v51,
      &v53);
  }
  if ( v55[0] && v56.trailing_comments._M_string_length )
  {
    str._M_dataplus._M_p = str._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &str,
      v56.trailing_comments._M_dataplus._M_p,
      &v56.trailing_comments._M_dataplus._M_p[v56.trailing_comments._M_string_length],
      v16);
    google::protobuf::StripWhitespace(&str);
    memset(&v27, 0, sizeof(v27));
    google::protobuf::SplitStringUsing(&str, "\n", &v27);
    v33[0] = 0;
    M_start = v27._M_impl._M_start;
    v22 = 0LL;
    v31 = v33;
    v32 = 0LL;
    if ( v27._M_impl._M_finish != v27._M_impl._M_start )
    {
      do
      {
        v53 = 0LL;
        v51 = 0LL;
        v23 = &M_start[v22];
        v49 = 0LL;
        v47 = 0LL;
        v45 = 0LL;
        v43 = 0LL;
        v41 = 0LL;
        v39 = 0LL;
        v24 = (__int64)v23->_M_dataplus._M_p;
        v54 = -1;
        v37 = v24;
        v25 = v23->_M_string_length;
        v52 = -1;
        v38 = v25;
        v50 = -1;
        v35 = v59._M_dataplus._M_p;
        v48 = -1;
        v36 = v59._M_string_length;
        v46 = -1;
        v44 = -1;
        v42 = -1;
        v40 = -1;
        google::protobuf::strings::SubstituteAndAppend(
          &v31,
          "$0// $1\n",
          &v35,
          &v37,
          &v39,
          &v41,
          &v43,
          &v45,
          &v47,
          &v49,
          &v51,
          &v53);
        M_finish = v27._M_impl._M_finish;
        M_start = v27._M_impl._M_start;
        ++v22;
      }
      while ( v27._M_impl._M_finish - v27._M_impl._M_start > v22 );
      if ( v27._M_impl._M_start != v27._M_impl._M_finish )
      {
        do
        {
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)M_start->_M_dataplus._M_p != &M_start->_anon_0 )
            operator delete(M_start->_M_dataplus._M_p);
          ++M_start;
        }
        while ( M_finish != M_start );
      }
    }
    if ( v27._M_impl._M_start )
      operator delete(v27._M_impl._M_start);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)str._M_dataplus._M_p != &str._anon_0 )
      operator delete(str._M_dataplus._M_p);
    std::string::_M_append(a3, (const char *)v31, v32);
    if ( v31 != v33 )
      operator delete(v31);
  }
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v59._M_dataplus._M_p != &v59._anon_0 )
    operator delete(v59._M_dataplus._M_p);
  v17 = v56.leading_detached_comments._M_impl._M_finish;
  v18 = v56.leading_detached_comments._M_impl._M_start;
  if ( v56.leading_detached_comments._M_impl._M_finish != v56.leading_detached_comments._M_impl._M_start )
  {
    v19 = v56.leading_detached_comments._M_impl._M_start;
    do
    {
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v19->_M_dataplus._M_p != &v19->_anon_0 )
        operator delete(v19->_M_dataplus._M_p);
      ++v19;
    }
    while ( v17 != v19 );
    v18 = v56.leading_detached_comments._M_impl._M_start;
  }
  if ( v18 )
    operator delete(v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v56.trailing_comments._M_dataplus._M_p != &v56.trailing_comments._anon_0 )
    operator delete(v56.trailing_comments._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v56.leading_comments._M_dataplus._M_p != &v56.leading_comments._anon_0 )
    operator delete(v56.leading_comments._M_dataplus._M_p);
  if ( __beg != v30 )
    operator delete(__beg);
};

// Line 2668: range 000000000C90A8B0-000000000C90A8D8
std::string *__fastcall google::protobuf::EnumDescriptor::DebugString[abi:cxx11](
        std::string *retstr,
        const google::protobuf::EnumDescriptor *const this)
{
  google::protobuf::DebugStringOptions options; // [rsp+Dh] [rbp-Bh] BYREF

  *(_WORD *)&options.include_comments = 0;
  options.elide_oneof_body = 0;
  google::protobuf::EnumDescriptor::DebugStringWithOptions[abi:cxx11](retstr, this, &options);
  return retstr;
};

// Line 2674: range 000000000C90A870-000000000C90A8AA
__int64 __fastcall google::protobuf::EnumDescriptor::DebugStringWithOptions[abi:cxx11](
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_BYTE *)(a1 + 16) = 0;
  google::protobuf::EnumDescriptor::DebugString(a2, 0LL, a1, a3);
  return a1;
};

// Line 2682: range 000000000C90A0F0-000000000C90A864
void __fastcall google::protobuf::EnumDescriptor::DebugString(
        google::protobuf::EnumDescriptor *a1,
        int a2,
        __int64 a3,
        __int64 a4)
{
  int v6; // r13d
  __int16 v7; // ax
  std::forward_iterator_tag v8; // cl
  __int64 v9; // rdx
  std::forward_iterator_tag v10; // cl
  char SourceLocation; // al
  const std::string *name; // rax
  __int64 M_p; // rdx
  std::string::size_type M_string_length; // rax
  __int64 i; // rbx
  std::forward_iterator_tag v16; // cl
  std::_Vector_base<std::string>::pointer v17; // rbx
  std::_Vector_base<std::string>::pointer v18; // rdi
  std::_Vector_base<std::string>::pointer v19; // r15
  std::_Vector_base<std::string>::pointer M_start; // r14
  unsigned __int64 v21; // rbx
  std::string *v22; // r14
  __int64 v23; // rax
  std::string::size_type v24; // rax
  std::_Vector_base<std::string>::pointer M_finish; // r13
  std::vector<std::string> v26; // [rsp+10h] [rbp-330h] BYREF
  char *__beg; // [rsp+30h] [rbp-310h] BYREF
  __int64 v28; // [rsp+38h] [rbp-308h]
  char v29[16]; // [rsp+40h] [rbp-300h] BYREF
  void *v30; // [rsp+50h] [rbp-2F0h] BYREF
  __int64 v31; // [rsp+58h] [rbp-2E8h]
  char v32[16]; // [rsp+60h] [rbp-2E0h] BYREF
  std::string str; // [rsp+70h] [rbp-2D0h] BYREF
  char *v34; // [rsp+90h] [rbp-2B0h] BYREF
  int v35; // [rsp+98h] [rbp-2A8h]
  __int64 v36; // [rsp+C0h] [rbp-280h] BYREF
  int v37; // [rsp+C8h] [rbp-278h]
  __int64 v38; // [rsp+F0h] [rbp-250h] BYREF
  int v39; // [rsp+F8h] [rbp-248h]
  __int64 v40; // [rsp+120h] [rbp-220h] BYREF
  int v41; // [rsp+128h] [rbp-218h]
  __int64 v42; // [rsp+150h] [rbp-1F0h] BYREF
  int v43; // [rsp+158h] [rbp-1E8h]
  __int64 v44; // [rsp+180h] [rbp-1C0h] BYREF
  int v45; // [rsp+188h] [rbp-1B8h]
  __int64 v46; // [rsp+1B0h] [rbp-190h] BYREF
  int v47; // [rsp+1B8h] [rbp-188h]
  __int64 v48; // [rsp+1E0h] [rbp-160h] BYREF
  int v49; // [rsp+1E8h] [rbp-158h]
  __int64 v50; // [rsp+210h] [rbp-130h] BYREF
  int v51; // [rsp+218h] [rbp-128h]
  __int64 v52; // [rsp+240h] [rbp-100h] BYREF
  int v53; // [rsp+248h] [rbp-F8h]
  char v54[8]; // [rsp+270h] [rbp-D0h] BYREF
  google::protobuf::SourceLocation v55; // [rsp+278h] [rbp-C8h] BYREF
  __int16 v56; // [rsp+2E0h] [rbp-60h]
  char v57; // [rsp+2E2h] [rbp-5Eh]
  std::string v58; // [rsp+2E8h] [rbp-58h] BYREF

  v6 = a2 + 1;
  __beg = v29;
  std::string::_M_construct(&__beg, 2 * a2, 32LL);
  v55.leading_comments._M_dataplus._M_p = v55.leading_comments._anon_0._M_local_buf;
  v55.trailing_comments._M_dataplus._M_p = v55.trailing_comments._anon_0._M_local_buf;
  v7 = *(_WORD *)a4;
  v55.leading_comments._M_string_length = 0LL;
  v56 = v7;
  LOBYTE(v7) = *(_BYTE *)(a4 + 2);
  v55.leading_comments._anon_0._M_local_buf[0] = 0;
  v57 = v7;
  v55.trailing_comments._M_string_length = 0LL;
  v55.trailing_comments._anon_0._M_local_buf[0] = 0;
  memset(&v55.leading_detached_comments, 0, sizeof(v55.leading_detached_comments));
  v58._M_dataplus._M_p = v58._anon_0._M_local_buf;
  std::string::_M_construct<char *>(&v58, __beg, &__beg[v28], v8);
  SourceLocation = *(_BYTE *)a4;
  if ( *(_BYTE *)a4 )
    SourceLocation = google::protobuf::EnumDescriptor::GetSourceLocation(a1, &v55);
  v54[0] = SourceLocation;
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment((__int64)v54, a3, v9, v10);
  v52 = 0LL;
  v50 = 0LL;
  name = a1->name_;
  v48 = 0LL;
  v46 = 0LL;
  v44 = 0LL;
  v42 = 0LL;
  v40 = 0LL;
  v38 = 0LL;
  M_p = (__int64)name->_M_dataplus._M_p;
  v53 = -1;
  M_string_length = name->_M_string_length;
  v36 = M_p;
  v37 = M_string_length;
  v51 = -1;
  v34 = __beg;
  v49 = -1;
  v35 = v28;
  v47 = -1;
  v45 = -1;
  v43 = -1;
  v41 = -1;
  v39 = -1;
  google::protobuf::strings::SubstituteAndAppend(
    a3,
    "$0enum $1 {\n",
    &v34,
    &v36,
    &v38,
    &v40,
    &v42,
    &v44,
    &v46,
    &v48,
    &v50,
    &v52);
  google::protobuf::`anonymous namespace'::FormatLineOptions(
    v6,
    &a1->options_->google::protobuf::Message,
    (google::protobuf::DescriptorPool *)a1->file_->pool_,
    a3);
  for ( i = 0LL; a1->value_count_ > (int)i; ++i )
    google::protobuf::EnumValueDescriptor::DebugString(&a1->values_[i], v6);
  v52 = 0LL;
  v34 = __beg;
  v53 = -1;
  v35 = v28;
  v50 = 0LL;
  v51 = -1;
  v48 = 0LL;
  v49 = -1;
  v46 = 0LL;
  v47 = -1;
  v44 = 0LL;
  v45 = -1;
  v42 = 0LL;
  v43 = -1;
  v40 = 0LL;
  v41 = -1;
  v38 = 0LL;
  v39 = -1;
  v36 = 0LL;
  v37 = -1;
  google::protobuf::strings::SubstituteAndAppend(
    a3,
    &off_1A179571,
    &v34,
    &v36,
    &v38,
    &v40,
    &v42,
    &v44,
    &v46,
    &v48,
    &v50,
    &v52);
  if ( v54[0] && v55.trailing_comments._M_string_length )
  {
    str._M_dataplus._M_p = str._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &str,
      v55.trailing_comments._M_dataplus._M_p,
      &v55.trailing_comments._M_dataplus._M_p[v55.trailing_comments._M_string_length],
      v16);
    google::protobuf::StripWhitespace(&str);
    memset(&v26, 0, sizeof(v26));
    google::protobuf::SplitStringUsing(&str, "\n", &v26);
    v32[0] = 0;
    M_start = v26._M_impl._M_start;
    v21 = 0LL;
    v30 = v32;
    v31 = 0LL;
    if ( v26._M_impl._M_finish != v26._M_impl._M_start )
    {
      do
      {
        v52 = 0LL;
        v50 = 0LL;
        v22 = &M_start[v21];
        v48 = 0LL;
        v46 = 0LL;
        v44 = 0LL;
        v42 = 0LL;
        v40 = 0LL;
        v38 = 0LL;
        v23 = (__int64)v22->_M_dataplus._M_p;
        v53 = -1;
        v36 = v23;
        v24 = v22->_M_string_length;
        v51 = -1;
        v37 = v24;
        v49 = -1;
        v34 = v58._M_dataplus._M_p;
        v47 = -1;
        v35 = v58._M_string_length;
        v45 = -1;
        v43 = -1;
        v41 = -1;
        v39 = -1;
        google::protobuf::strings::SubstituteAndAppend(
          &v30,
          "$0// $1\n",
          &v34,
          &v36,
          &v38,
          &v40,
          &v42,
          &v44,
          &v46,
          &v48,
          &v50,
          &v52);
        M_finish = v26._M_impl._M_finish;
        M_start = v26._M_impl._M_start;
        ++v21;
      }
      while ( v26._M_impl._M_finish - v26._M_impl._M_start > v21 );
      if ( v26._M_impl._M_start != v26._M_impl._M_finish )
      {
        do
        {
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)M_start->_M_dataplus._M_p != &M_start->_anon_0 )
            operator delete(M_start->_M_dataplus._M_p);
          ++M_start;
        }
        while ( M_finish != M_start );
      }
    }
    if ( v26._M_impl._M_start )
      operator delete(v26._M_impl._M_start);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)str._M_dataplus._M_p != &str._anon_0 )
      operator delete(str._M_dataplus._M_p);
    std::string::_M_append(a3, (const char *)v30, v31);
    if ( v30 != v32 )
      operator delete(v30);
  }
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v58._M_dataplus._M_p != &v58._anon_0 )
    operator delete(v58._M_dataplus._M_p);
  v17 = v55.leading_detached_comments._M_impl._M_finish;
  v18 = v55.leading_detached_comments._M_impl._M_start;
  if ( v55.leading_detached_comments._M_impl._M_finish != v55.leading_detached_comments._M_impl._M_start )
  {
    v19 = v55.leading_detached_comments._M_impl._M_start;
    do
    {
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v19->_M_dataplus._M_p != &v19->_anon_0 )
        operator delete(v19->_M_dataplus._M_p);
      ++v19;
    }
    while ( v17 != v19 );
    v18 = v55.leading_detached_comments._M_impl._M_start;
  }
  if ( v18 )
    operator delete(v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v55.trailing_comments._M_dataplus._M_p != &v55.trailing_comments._anon_0 )
    operator delete(v55.trailing_comments._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v55.leading_comments._M_dataplus._M_p != &v55.leading_comments._anon_0 )
    operator delete(v55.leading_comments._M_dataplus._M_p);
  if ( __beg != v29 )
    operator delete(__beg);
};

// Line 2703: range 000000000C9195E0-000000000C919608
std::string *__fastcall google::protobuf::EnumValueDescriptor::DebugString[abi:cxx11](
        std::string *retstr,
        const google::protobuf::EnumValueDescriptor *const this)
{
  google::protobuf::DebugStringOptions options; // [rsp+Dh] [rbp-Bh] BYREF

  *(_WORD *)&options.include_comments = 0;
  options.elide_oneof_body = 0;
  google::protobuf::EnumValueDescriptor::DebugStringWithOptions[abi:cxx11](retstr, this, &options);
  return retstr;
};

// Line 2709: range 000000000C9195A0-000000000C9195DA
__int64 __fastcall google::protobuf::EnumValueDescriptor::DebugStringWithOptions[abi:cxx11](
        __int64 a1,
        google::protobuf::EnumValueDescriptor *a2)
{
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_BYTE *)(a1 + 16) = 0;
  google::protobuf::EnumValueDescriptor::DebugString(a2, 0);
  return a1;
};

// Line 2717: range 000000000C909910-000000000C90A0E3
void __fastcall google::protobuf::EnumValueDescriptor::DebugString(
        google::protobuf::EnumValueDescriptor *this,
        int a2,
        __int64 a3,
        __int64 a4)
{
  __int16 v7; // ax
  std::forward_iterator_tag v8; // cl
  __int64 v9; // rdx
  std::forward_iterator_tag v10; // cl
  char SourceLocation; // al
  int number; // edi
  std::string::pointer M_p; // rdx
  google::protobuf::EnumValueOptions *options; // rsi
  const google::protobuf::EnumDescriptor *type; // rax
  std::forward_iterator_tag v16; // cl
  std::_Vector_base<std::string>::pointer v17; // rbx
  std::_Vector_base<std::string>::pointer v18; // rdi
  std::_Vector_base<std::string>::pointer v19; // r14
  unsigned __int64 v20; // rbx
  std::_Vector_base<std::string>::pointer M_start; // rax
  std::string *v22; // rax
  __int64 v23; // rdx
  std::_Vector_base<std::string>::pointer M_finish; // r12
  std::_Vector_base<std::string>::pointer v25; // rbx
  std::vector<std::string> v27; // [rsp+10h] [rbp-350h] BYREF
  char *__beg; // [rsp+30h] [rbp-330h] BYREF
  __int64 v29; // [rsp+38h] [rbp-328h]
  char v30[16]; // [rsp+40h] [rbp-320h] BYREF
  void *v31; // [rsp+50h] [rbp-310h] BYREF
  __int64 v32; // [rsp+58h] [rbp-308h]
  char v33[16]; // [rsp+60h] [rbp-300h] BYREF
  void *v34; // [rsp+70h] [rbp-2F0h] BYREF
  __int64 v35; // [rsp+78h] [rbp-2E8h]
  char v36[16]; // [rsp+80h] [rbp-2E0h] BYREF
  std::string str; // [rsp+90h] [rbp-2D0h] BYREF
  void *v38; // [rsp+B0h] [rbp-2B0h] BYREF
  int v39; // [rsp+B8h] [rbp-2A8h]
  __int64 v40; // [rsp+E0h] [rbp-280h] BYREF
  int M_string_length; // [rsp+E8h] [rbp-278h]
  char *v42; // [rsp+110h] [rbp-250h] BYREF
  int v43; // [rsp+118h] [rbp-248h]
  char buffer[36]; // [rsp+11Ch] [rbp-244h] BYREF
  __int64 v45; // [rsp+140h] [rbp-220h] BYREF
  int v46; // [rsp+148h] [rbp-218h]
  __int64 v47; // [rsp+170h] [rbp-1F0h] BYREF
  int v48; // [rsp+178h] [rbp-1E8h]
  __int64 v49; // [rsp+1A0h] [rbp-1C0h] BYREF
  int v50; // [rsp+1A8h] [rbp-1B8h]
  __int64 v51; // [rsp+1D0h] [rbp-190h] BYREF
  int v52; // [rsp+1D8h] [rbp-188h]
  __int64 v53; // [rsp+200h] [rbp-160h] BYREF
  int v54; // [rsp+208h] [rbp-158h]
  __int64 v55; // [rsp+230h] [rbp-130h] BYREF
  int v56; // [rsp+238h] [rbp-128h]
  __int64 v57; // [rsp+260h] [rbp-100h] BYREF
  int v58; // [rsp+268h] [rbp-F8h]
  char v59[8]; // [rsp+290h] [rbp-D0h] BYREF
  google::protobuf::SourceLocation v60; // [rsp+298h] [rbp-C8h] BYREF
  __int16 v61; // [rsp+300h] [rbp-60h]
  char v62; // [rsp+302h] [rbp-5Eh]
  std::string v63; // [rsp+308h] [rbp-58h] BYREF

  __beg = v30;
  std::string::_M_construct(&__beg, 2 * a2, 32LL);
  v60.leading_comments._M_dataplus._M_p = v60.leading_comments._anon_0._M_local_buf;
  v60.trailing_comments._M_dataplus._M_p = v60.trailing_comments._anon_0._M_local_buf;
  v7 = *(_WORD *)a4;
  v60.leading_comments._M_string_length = 0LL;
  v61 = v7;
  LOBYTE(v7) = *(_BYTE *)(a4 + 2);
  v60.leading_comments._anon_0._M_local_buf[0] = 0;
  v62 = v7;
  v60.trailing_comments._M_string_length = 0LL;
  v60.trailing_comments._anon_0._M_local_buf[0] = 0;
  memset(&v60.leading_detached_comments, 0, sizeof(v60.leading_detached_comments));
  v63._M_dataplus._M_p = v63._anon_0._M_local_buf;
  std::string::_M_construct<char *>(&v63, __beg, &__beg[v29], v8);
  SourceLocation = *(_BYTE *)a4;
  if ( *(_BYTE *)a4 )
    SourceLocation = google::protobuf::EnumValueDescriptor::GetSourceLocation(this, &v60);
  v59[0] = SourceLocation;
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment((__int64)v59, a3, v9, v10);
  number = this->number_;
  v57 = 0LL;
  v58 = -1;
  v55 = 0LL;
  v56 = -1;
  v53 = 0LL;
  v54 = -1;
  v51 = 0LL;
  v52 = -1;
  v49 = 0LL;
  v50 = -1;
  v47 = 0LL;
  v48 = -1;
  v45 = 0LL;
  v46 = -1;
  v42 = google::protobuf::FastInt32ToBuffer(number, buffer);
  v43 = strlen(v42);
  M_p = this->name_->_M_dataplus._M_p;
  M_string_length = this->name_->_M_string_length;
  v40 = (__int64)M_p;
  v38 = __beg;
  v39 = v29;
  google::protobuf::strings::SubstituteAndAppend(
    a3,
    "$0$1 = $2",
    &v38,
    &v40,
    &v42,
    &v45,
    &v47,
    &v49,
    &v51,
    &v53,
    &v55,
    &v57);
  options = (google::protobuf::EnumValueOptions *)this->options_;
  v31 = v33;
  type = this->type_;
  v33[0] = 0;
  v32 = 0LL;
  if ( (unsigned __int8)google::protobuf::`anonymous namespace'::FormatBracketedOptions(
                          a2,
                          options,
                          (google::protobuf::DescriptorPool *)type->file_->pool_,
                          (__int64)&v31) )
  {
    v38 = v31;
    v57 = 0LL;
    v39 = v32;
    v58 = -1;
    v55 = 0LL;
    v56 = -1;
    v53 = 0LL;
    v54 = -1;
    v51 = 0LL;
    v52 = -1;
    v49 = 0LL;
    v50 = -1;
    v47 = 0LL;
    v48 = -1;
    v45 = 0LL;
    v46 = -1;
    v42 = 0LL;
    v43 = -1;
    v40 = 0LL;
    M_string_length = -1;
    google::protobuf::strings::SubstituteAndAppend(
      a3,
      " [$0]",
      &v38,
      &v40,
      &v42,
      &v45,
      &v47,
      &v49,
      &v51,
      &v53,
      &v55,
      &v57);
  }
  if ( *(_QWORD *)(a3 + 8) == 0x3FFFFFFFFFFFFFFFLL || *(_QWORD *)(a3 + 8) == 4611686018427387902LL )
    std::__throw_length_error("basic_string::append");
  std::string::_M_append(a3, ";\n", 2LL);
  if ( v59[0] && v60.trailing_comments._M_string_length )
  {
    str._M_dataplus._M_p = str._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &str,
      v60.trailing_comments._M_dataplus._M_p,
      &v60.trailing_comments._M_dataplus._M_p[v60.trailing_comments._M_string_length],
      v16);
    google::protobuf::StripWhitespace(&str);
    memset(&v27, 0, sizeof(v27));
    google::protobuf::SplitStringUsing(&str, "\n", &v27);
    v36[0] = 0;
    v20 = 0LL;
    v34 = v36;
    M_start = v27._M_impl._M_start;
    v35 = 0LL;
    if ( v27._M_impl._M_start != v27._M_impl._M_finish )
    {
      do
      {
        v57 = 0LL;
        v55 = 0LL;
        v22 = &M_start[v20];
        v53 = 0LL;
        v51 = 0LL;
        v49 = 0LL;
        v47 = 0LL;
        v45 = 0LL;
        v42 = 0LL;
        v23 = (__int64)v22->_M_dataplus._M_p;
        v58 = -1;
        M_string_length = v22->_M_string_length;
        v40 = v23;
        v38 = v63._M_dataplus._M_p;
        v56 = -1;
        v39 = v63._M_string_length;
        v54 = -1;
        v52 = -1;
        v50 = -1;
        v48 = -1;
        v46 = -1;
        v43 = -1;
        google::protobuf::strings::SubstituteAndAppend(
          &v34,
          "$0// $1\n",
          &v38,
          &v40,
          &v42,
          &v45,
          &v47,
          &v49,
          &v51,
          &v53,
          &v55,
          &v57);
        M_finish = v27._M_impl._M_finish;
        M_start = v27._M_impl._M_start;
        ++v20;
      }
      while ( v27._M_impl._M_finish - v27._M_impl._M_start > v20 );
      if ( v27._M_impl._M_start != v27._M_impl._M_finish )
      {
        v25 = v27._M_impl._M_start;
        do
        {
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v25->_M_dataplus._M_p != &v25->_anon_0 )
            operator delete(v25->_M_dataplus._M_p);
          ++v25;
        }
        while ( M_finish != v25 );
      }
    }
    if ( v27._M_impl._M_start )
      operator delete(v27._M_impl._M_start);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)str._M_dataplus._M_p != &str._anon_0 )
      operator delete(str._M_dataplus._M_p);
    std::string::_M_append(a3, (const char *)v34, v35);
    if ( v34 != v36 )
      operator delete(v34);
  }
  if ( v31 != v33 )
    operator delete(v31);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v63._M_dataplus._M_p != &v63._anon_0 )
    operator delete(v63._M_dataplus._M_p);
  v17 = v60.leading_detached_comments._M_impl._M_finish;
  v18 = v60.leading_detached_comments._M_impl._M_start;
  if ( v60.leading_detached_comments._M_impl._M_finish != v60.leading_detached_comments._M_impl._M_start )
  {
    v19 = v60.leading_detached_comments._M_impl._M_start;
    do
    {
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v19->_M_dataplus._M_p != &v19->_anon_0 )
        operator delete(v19->_M_dataplus._M_p);
      ++v19;
    }
    while ( v17 != v19 );
    v18 = v60.leading_detached_comments._M_impl._M_start;
  }
  if ( v18 )
    operator delete(v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v60.trailing_comments._M_dataplus._M_p != &v60.trailing_comments._anon_0 )
    operator delete(v60.trailing_comments._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v60.leading_comments._M_dataplus._M_p != &v60.leading_comments._anon_0 )
    operator delete(v60.leading_comments._M_dataplus._M_p);
  if ( __beg != v30 )
    operator delete(__beg);
};

// Line 2737: range 000000000C909770-000000000C909798
std::string *__fastcall google::protobuf::ServiceDescriptor::DebugString[abi:cxx11](
        std::string *retstr,
        const google::protobuf::ServiceDescriptor *const this)
{
  google::protobuf::DebugStringOptions options; // [rsp+Dh] [rbp-Bh] BYREF

  *(_WORD *)&options.include_comments = 0;
  options.elide_oneof_body = 0;
  google::protobuf::ServiceDescriptor::DebugStringWithOptions[abi:cxx11](retstr, this, &options);
  return retstr;
};

// Line 2743: range 000000000C909730-000000000C909765
__int64 __fastcall google::protobuf::ServiceDescriptor::DebugStringWithOptions[abi:cxx11](
        __int64 a1,
        google::protobuf::ServiceDescriptor *a2)
{
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_BYTE *)(a1 + 16) = 0;
  google::protobuf::ServiceDescriptor::DebugString(a2);
  return a1;
};

// Line 2751: range 000000000C9090C0-000000000C909729
void __fastcall google::protobuf::ServiceDescriptor::DebugString(
        google::protobuf::ServiceDescriptor *this,
        __int64 a2,
        __int64 a3,
        std::forward_iterator_tag a4)
{
  __int16 v5; // ax
  std::forward_iterator_tag v6; // cl
  __int64 v7; // rdx
  std::forward_iterator_tag v8; // cl
  char SourceLocation; // al
  const std::string *name; // rax
  std::string::pointer M_p; // rdx
  int v12; // ebx
  std::forward_iterator_tag v13; // cl
  std::_Vector_base<std::string>::pointer v14; // rbx
  std::_Vector_base<std::string>::pointer v15; // rdi
  std::_Vector_base<std::string>::pointer v16; // r15
  std::_Vector_base<std::string>::pointer M_start; // r14
  unsigned __int64 v18; // rbx
  std::string *v19; // r14
  __int64 v20; // rax
  std::_Vector_base<std::string>::pointer M_finish; // r12
  google::protobuf::SourceLocation *i; // [rsp+8h] [rbp-318h]
  std::vector<std::string> v23; // [rsp+10h] [rbp-310h] BYREF
  void *v24; // [rsp+30h] [rbp-2F0h] BYREF
  __int64 v25; // [rsp+38h] [rbp-2E8h]
  char v26[16]; // [rsp+40h] [rbp-2E0h] BYREF
  std::string str; // [rsp+50h] [rbp-2D0h] BYREF
  std::string::pointer v28; // [rsp+70h] [rbp-2B0h] BYREF
  int M_string_length; // [rsp+78h] [rbp-2A8h]
  __int64 v30; // [rsp+A0h] [rbp-280h] BYREF
  int v31; // [rsp+A8h] [rbp-278h]
  __int64 v32; // [rsp+D0h] [rbp-250h] BYREF
  int v33; // [rsp+D8h] [rbp-248h]
  __int64 v34; // [rsp+100h] [rbp-220h] BYREF
  int v35; // [rsp+108h] [rbp-218h]
  __int64 v36; // [rsp+130h] [rbp-1F0h] BYREF
  int v37; // [rsp+138h] [rbp-1E8h]
  __int64 v38; // [rsp+160h] [rbp-1C0h] BYREF
  int v39; // [rsp+168h] [rbp-1B8h]
  __int64 v40; // [rsp+190h] [rbp-190h] BYREF
  int v41; // [rsp+198h] [rbp-188h]
  __int64 v42; // [rsp+1C0h] [rbp-160h] BYREF
  int v43; // [rsp+1C8h] [rbp-158h]
  __int64 v44; // [rsp+1F0h] [rbp-130h] BYREF
  int v45; // [rsp+1F8h] [rbp-128h]
  std::string v46; // [rsp+220h] [rbp-100h] BYREF
  char v47[8]; // [rsp+250h] [rbp-D0h] BYREF
  google::protobuf::SourceLocation v48; // [rsp+258h] [rbp-C8h] BYREF
  __int16 v49; // [rsp+2C0h] [rbp-60h]
  char v50; // [rsp+2C2h] [rbp-5Eh]
  std::string v51; // [rsp+2C8h] [rbp-58h] BYREF

  v46._M_dataplus._M_p = v46._anon_0._M_local_buf;
  std::string::_M_construct<char const*>(&v46, &off_1B23A528[4], &off_1B23A528[4], a4);
  v48.leading_comments._M_dataplus._M_p = v48.leading_comments._anon_0._M_local_buf;
  v48.trailing_comments._M_dataplus._M_p = v48.trailing_comments._anon_0._M_local_buf;
  v5 = *(_WORD *)a3;
  v48.leading_comments._M_string_length = 0LL;
  v49 = v5;
  LOBYTE(v5) = *(_BYTE *)(a3 + 2);
  v48.leading_comments._anon_0._M_local_buf[0] = 0;
  v50 = v5;
  v48.trailing_comments._M_string_length = 0LL;
  v48.trailing_comments._anon_0._M_local_buf[0] = 0;
  memset(&v48.leading_detached_comments, 0, sizeof(v48.leading_detached_comments));
  v51._M_dataplus._M_p = v51._anon_0._M_local_buf;
  std::string::_M_construct<char *>(&v51, v46._M_dataplus._M_p, &v46._M_dataplus._M_p[v46._M_string_length], v6);
  SourceLocation = *(_BYTE *)a3;
  if ( *(_BYTE *)a3 )
    SourceLocation = google::protobuf::ServiceDescriptor::GetSourceLocation(this, &v48);
  v47[0] = SourceLocation;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v46._M_dataplus._M_p != &v46._anon_0 )
    operator delete(v46._M_dataplus._M_p);
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment((__int64)v47, a2, v7, v8);
  name = this->name_;
  v46._M_dataplus._M_p = 0LL;
  v44 = 0LL;
  v42 = 0LL;
  v40 = 0LL;
  v38 = 0LL;
  v36 = 0LL;
  v34 = 0LL;
  v32 = 0LL;
  v30 = 0LL;
  M_p = name->_M_dataplus._M_p;
  LODWORD(v46._M_string_length) = -1;
  M_string_length = name->_M_string_length;
  v28 = M_p;
  v45 = -1;
  v43 = -1;
  v41 = -1;
  v39 = -1;
  v37 = -1;
  v35 = -1;
  v33 = -1;
  v31 = -1;
  google::protobuf::strings::SubstituteAndAppend(
    a2,
    "service $0 {\n",
    &v28,
    &v30,
    &v32,
    &v34,
    &v36,
    &v38,
    &v40,
    &v42,
    &v44,
    &v46);
  google::protobuf::`anonymous namespace'::FormatLineOptions(
    1,
    &this->options_->google::protobuf::Message,
    (google::protobuf::DescriptorPool *)this->file_->pool_,
    a2);
  v12 = 0;
  for ( i = 0LL; v12 < this->method_count_; ++v12 )
    google::protobuf::MethodDescriptor::DebugString((google::protobuf::MethodDescriptor *)((char *)this->methods_
                                                                                         + (unsigned __int64)i++));
  if ( *(_QWORD *)(a2 + 8) == 0x3FFFFFFFFFFFFFFFLL || *(_QWORD *)(a2 + 8) == 4611686018427387902LL )
    std::__throw_length_error("basic_string::append");
  std::string::_M_append(a2, "}\n", 2LL);
  if ( v47[0] && v48.trailing_comments._M_string_length )
  {
    str._M_dataplus._M_p = str._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &str,
      v48.trailing_comments._M_dataplus._M_p,
      &v48.trailing_comments._M_dataplus._M_p[v48.trailing_comments._M_string_length],
      v13);
    google::protobuf::StripWhitespace(&str);
    memset(&v23, 0, sizeof(v23));
    google::protobuf::SplitStringUsing(&str, "\n", &v23);
    v26[0] = 0;
    M_start = v23._M_impl._M_start;
    v18 = 0LL;
    v24 = v26;
    v25 = 0LL;
    if ( v23._M_impl._M_start != v23._M_impl._M_finish )
    {
      do
      {
        v46._M_dataplus._M_p = 0LL;
        v44 = 0LL;
        v19 = &M_start[v18];
        v42 = 0LL;
        v40 = 0LL;
        v38 = 0LL;
        v36 = 0LL;
        v34 = 0LL;
        v32 = 0LL;
        v20 = (__int64)v19->_M_dataplus._M_p;
        LODWORD(v46._M_string_length) = -1;
        v30 = v20;
        v31 = v19->_M_string_length;
        v45 = -1;
        v28 = v51._M_dataplus._M_p;
        v43 = -1;
        M_string_length = v51._M_string_length;
        v41 = -1;
        v39 = -1;
        v37 = -1;
        v35 = -1;
        v33 = -1;
        google::protobuf::strings::SubstituteAndAppend(
          &v24,
          "$0// $1\n",
          &v28,
          &v30,
          &v32,
          &v34,
          &v36,
          &v38,
          &v40,
          &v42,
          &v44,
          &v46);
        M_finish = v23._M_impl._M_finish;
        M_start = v23._M_impl._M_start;
        ++v18;
      }
      while ( v23._M_impl._M_finish - v23._M_impl._M_start > v18 );
      if ( v23._M_impl._M_start != v23._M_impl._M_finish )
      {
        do
        {
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)M_start->_M_dataplus._M_p != &M_start->_anon_0 )
            operator delete(M_start->_M_dataplus._M_p);
          ++M_start;
        }
        while ( M_finish != M_start );
      }
    }
    if ( v23._M_impl._M_start )
      operator delete(v23._M_impl._M_start);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)str._M_dataplus._M_p != &str._anon_0 )
      operator delete(str._M_dataplus._M_p);
    std::string::_M_append(a2, (const char *)v24, v25);
    if ( v24 != v26 )
      operator delete(v24);
  }
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v51._M_dataplus._M_p != &v51._anon_0 )
    operator delete(v51._M_dataplus._M_p);
  v14 = v48.leading_detached_comments._M_impl._M_finish;
  v15 = v48.leading_detached_comments._M_impl._M_start;
  if ( v48.leading_detached_comments._M_impl._M_finish != v48.leading_detached_comments._M_impl._M_start )
  {
    v16 = v48.leading_detached_comments._M_impl._M_start;
    do
    {
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v16->_M_dataplus._M_p != &v16->_anon_0 )
        operator delete(v16->_M_dataplus._M_p);
      ++v16;
    }
    while ( v14 != v16 );
    v15 = v48.leading_detached_comments._M_impl._M_start;
  }
  if ( v15 )
    operator delete(v15);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v48.trailing_comments._M_dataplus._M_p != &v48.trailing_comments._anon_0 )
    operator delete(v48.trailing_comments._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v48.leading_comments._M_dataplus._M_p != &v48.leading_comments._anon_0 )
    operator delete(v48.leading_comments._M_dataplus._M_p);
};

// Line 2769: range 000000000C909090-000000000C9090B8
std::string *__fastcall google::protobuf::MethodDescriptor::DebugString[abi:cxx11](
        std::string *retstr,
        const google::protobuf::MethodDescriptor *const this)
{
  google::protobuf::DebugStringOptions options; // [rsp+Dh] [rbp-Bh] BYREF

  *(_WORD *)&options.include_comments = 0;
  options.elide_oneof_body = 0;
  google::protobuf::MethodDescriptor::DebugStringWithOptions[abi:cxx11](retstr, this, &options);
  return retstr;
};

// Line 2775: range 000000000C909050-000000000C90908A
__int64 __fastcall google::protobuf::MethodDescriptor::DebugStringWithOptions[abi:cxx11](
        __int64 a1,
        google::protobuf::MethodDescriptor *a2)
{
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_BYTE *)(a1 + 16) = 0;
  google::protobuf::MethodDescriptor::DebugString(a2);
  return a1;
};

// Line 2783: range 000000000C908770-000000000C909043
void __fastcall google::protobuf::MethodDescriptor::DebugString(
        google::protobuf::MethodDescriptor *this,
        int a2,
        __int64 a3,
        __int64 a4)
{
  __int16 v7; // ax
  std::forward_iterator_tag v8; // cl
  __int64 v9; // rdx
  std::forward_iterator_tag v10; // cl
  char SourceLocation; // al
  bool v12; // zf
  const char *v13; // rdi
  int v14; // eax
  const char *v15; // rdi
  int v16; // eax
  google::protobuf::GoogleOnceDynamic *once; // rdi
  google::protobuf::GoogleOnceDynamic *v18; // rdi
  const std::string *full_name; // rax
  int (**M_p)(...); // rdx
  std::string::size_type M_string_length; // rax
  const std::string *v22; // rax
  int (**v23)(...); // rdx
  const std::string *name; // rax
  char *v25; // rdx
  google::protobuf::MethodOptions *options; // rsi
  const google::protobuf::ServiceDescriptor *service; // rax
  std::forward_iterator_tag v28; // cl
  std::_Vector_base<std::string>::pointer v29; // rbx
  std::_Vector_base<std::string>::pointer v30; // rdi
  std::_Vector_base<std::string>::pointer v31; // r14
  unsigned __int64 v32; // rbx
  std::_Vector_base<std::string>::pointer M_start; // rax
  std::string *v34; // rax
  char *v35; // rdx
  std::string::size_type v36; // rax
  std::_Vector_base<std::string>::pointer v37; // rbx
  std::_Vector_base<std::string>::pointer M_finish; // r14
  int v39; // [rsp+Ch] [rbp-354h]
  std::vector<std::string> v40; // [rsp+10h] [rbp-350h] BYREF
  char *__beg; // [rsp+30h] [rbp-330h] BYREF
  __int64 v42; // [rsp+38h] [rbp-328h]
  char v43[16]; // [rsp+40h] [rbp-320h] BYREF
  void *v44; // [rsp+50h] [rbp-310h] BYREF
  __int64 v45; // [rsp+58h] [rbp-308h]
  char v46[16]; // [rsp+60h] [rbp-300h] BYREF
  void *v47; // [rsp+70h] [rbp-2F0h] BYREF
  __int64 v48; // [rsp+78h] [rbp-2E8h]
  char v49[16]; // [rsp+80h] [rbp-2E0h] BYREF
  std::string str; // [rsp+90h] [rbp-2D0h] BYREF
  void *v51; // [rsp+B0h] [rbp-2B0h] BYREF
  int v52; // [rsp+B8h] [rbp-2A8h]
  char *v53; // [rsp+E0h] [rbp-280h] BYREF
  int v54; // [rsp+E8h] [rbp-278h]
  google::protobuf::Closure closure; // [rsp+110h] [rbp-250h] BYREF
  void (__fastcall *v56)(google::protobuf::internal::LazyDescriptor *); // [rsp+118h] [rbp-248h]
  char v57; // [rsp+120h] [rbp-240h]
  google::protobuf::internal::LazyDescriptor *p_input_type; // [rsp+128h] [rbp-238h]
  google::protobuf::Closure v59; // [rsp+140h] [rbp-220h] BYREF
  void (__fastcall *v60)(google::protobuf::internal::LazyDescriptor *); // [rsp+148h] [rbp-218h]
  char v61; // [rsp+150h] [rbp-210h]
  google::protobuf::internal::LazyDescriptor *p_output_type; // [rsp+158h] [rbp-208h]
  const char *v63; // [rsp+170h] [rbp-1F0h] BYREF
  int v64; // [rsp+178h] [rbp-1E8h]
  const char *v65; // [rsp+1A0h] [rbp-1C0h] BYREF
  int v66; // [rsp+1A8h] [rbp-1B8h]
  __int64 v67; // [rsp+1D0h] [rbp-190h] BYREF
  int v68; // [rsp+1D8h] [rbp-188h]
  __int64 v69; // [rsp+200h] [rbp-160h] BYREF
  int v70; // [rsp+208h] [rbp-158h]
  __int64 v71; // [rsp+230h] [rbp-130h] BYREF
  int v72; // [rsp+238h] [rbp-128h]
  __int64 v73; // [rsp+260h] [rbp-100h] BYREF
  int v74; // [rsp+268h] [rbp-F8h]
  char v75[8]; // [rsp+290h] [rbp-D0h] BYREF
  google::protobuf::SourceLocation v76; // [rsp+298h] [rbp-C8h] BYREF
  __int16 v77; // [rsp+300h] [rbp-60h]
  char v78; // [rsp+302h] [rbp-5Eh]
  std::string v79; // [rsp+308h] [rbp-58h] BYREF

  __beg = v43;
  std::string::_M_construct(&__beg, 2 * a2, 32LL);
  v39 = a2 + 1;
  v76.leading_comments._M_dataplus._M_p = v76.leading_comments._anon_0._M_local_buf;
  v76.trailing_comments._M_dataplus._M_p = v76.trailing_comments._anon_0._M_local_buf;
  v7 = *(_WORD *)a4;
  v76.leading_comments._M_string_length = 0LL;
  v77 = v7;
  LOBYTE(v7) = *(_BYTE *)(a4 + 2);
  v76.leading_comments._anon_0._M_local_buf[0] = 0;
  v78 = v7;
  v76.trailing_comments._M_string_length = 0LL;
  v76.trailing_comments._anon_0._M_local_buf[0] = 0;
  memset(&v76.leading_detached_comments, 0, sizeof(v76.leading_detached_comments));
  v79._M_dataplus._M_p = v79._anon_0._M_local_buf;
  std::string::_M_construct<char *>(&v79, __beg, &__beg[v42], v8);
  SourceLocation = *(_BYTE *)a4;
  if ( *(_BYTE *)a4 )
    SourceLocation = google::protobuf::MethodDescriptor::GetSourceLocation(this, &v76);
  v75[0] = SourceLocation;
  google::protobuf::`anonymous namespace'::SourceLocationCommentPrinter::AddPreComment((__int64)v75, a3, v9, v10);
  v12 = !this->server_streaming_;
  v73 = 0LL;
  v74 = -1;
  v13 = &off_1B23A528[4];
  v71 = 0LL;
  if ( !v12 )
    v13 = "stream ";
  v72 = -1;
  v65 = v13;
  v69 = 0LL;
  v70 = -1;
  v67 = 0LL;
  v68 = -1;
  v14 = strlen(v13);
  v15 = &off_1B23A528[4];
  if ( this->client_streaming_ )
    v15 = "stream ";
  v66 = v14;
  v63 = v15;
  v16 = strlen(v15);
  once = this->output_type_.once_;
  v64 = v16;
  if ( once && once->state_ != 2 )
  {
    v59._vptr_Closure = (int (**)(...))&off_1A17BFE0;
    v61 = 0;
    v60 = google::protobuf::internal::LazyDescriptor::OnceStatic;
    p_output_type = &this->output_type_;
    google::protobuf::GoogleOnceInitImpl(&once->state_, &v59);
    v59._vptr_Closure = (int (**)(...))&off_1A17BFE0;
    google::protobuf::Closure::~Closure(&v59);
  }
  v18 = this->input_type_.once_;
  full_name = this->output_type_.descriptor_->full_name_;
  M_p = (int (**)(...))full_name->_M_dataplus._M_p;
  M_string_length = full_name->_M_string_length;
  v59._vptr_Closure = M_p;
  LODWORD(v60) = M_string_length;
  if ( v18 && v18->state_ != 2 )
  {
    closure._vptr_Closure = (int (**)(...))&off_1A17BFE0;
    v56 = google::protobuf::internal::LazyDescriptor::OnceStatic;
    v57 = 0;
    p_input_type = &this->input_type_;
    google::protobuf::GoogleOnceInitImpl(&v18->state_, &closure);
    closure._vptr_Closure = (int (**)(...))&off_1A17BFE0;
    google::protobuf::Closure::~Closure(&closure);
  }
  v22 = this->input_type_.descriptor_->full_name_;
  v23 = (int (**)(...))v22->_M_dataplus._M_p;
  LODWORD(v56) = v22->_M_string_length;
  name = this->name_;
  closure._vptr_Closure = v23;
  v25 = name->_M_dataplus._M_p;
  v54 = name->_M_string_length;
  v53 = v25;
  v51 = __beg;
  v52 = v42;
  google::protobuf::strings::SubstituteAndAppend(
    a3,
    "$0rpc $1($4.$2) returns ($5.$3)",
    &v51,
    &v53,
    &closure,
    &v59,
    &v63,
    &v65,
    &v67,
    &v69,
    &v71,
    &v73);
  options = (google::protobuf::MethodOptions *)this->options_;
  v46[0] = 0;
  v44 = v46;
  service = this->service_;
  v45 = 0LL;
  if ( (unsigned __int8)google::protobuf::`anonymous namespace'::FormatLineOptions(
                          v39,
                          options,
                          (google::protobuf::DescriptorPool *)service->file_->pool_,
                          (__int64)&v44) )
  {
    v73 = 0LL;
    v53 = __beg;
    v74 = -1;
    v54 = v42;
    v71 = 0LL;
    v51 = v44;
    v72 = -1;
    v52 = v45;
    v69 = 0LL;
    v70 = -1;
    v67 = 0LL;
    v68 = -1;
    v65 = 0LL;
    v66 = -1;
    v63 = 0LL;
    v64 = -1;
    v59._vptr_Closure = 0LL;
    LODWORD(v60) = -1;
    closure._vptr_Closure = 0LL;
    LODWORD(v56) = -1;
    google::protobuf::strings::SubstituteAndAppend(
      a3,
      " {\n$0$1}\n",
      &v51,
      &v53,
      &closure,
      &v59,
      &v63,
      &v65,
      &v67,
      &v69,
      &v71,
      &v73);
    if ( !v75[0] )
      goto LABEL_15;
    goto LABEL_34;
  }
  if ( *(_QWORD *)(a3 + 8) == 0x3FFFFFFFFFFFFFFFLL || *(_QWORD *)(a3 + 8) == 4611686018427387902LL )
    std::__throw_length_error("basic_string::append");
  std::string::_M_append(a3, ";\n", 2LL);
  if ( v75[0] )
  {
LABEL_34:
    if ( v76.trailing_comments._M_string_length )
    {
      str._M_dataplus._M_p = str._anon_0._M_local_buf;
      std::string::_M_construct<char *>(
        &str,
        v76.trailing_comments._M_dataplus._M_p,
        &v76.trailing_comments._M_dataplus._M_p[v76.trailing_comments._M_string_length],
        v28);
      google::protobuf::StripWhitespace(&str);
      memset(&v40, 0, sizeof(v40));
      google::protobuf::SplitStringUsing(&str, "\n", &v40);
      v49[0] = 0;
      v32 = 0LL;
      v47 = v49;
      M_start = v40._M_impl._M_start;
      v48 = 0LL;
      if ( v40._M_impl._M_start != v40._M_impl._M_finish )
      {
        do
        {
          v73 = 0LL;
          v71 = 0LL;
          v34 = &M_start[v32];
          v69 = 0LL;
          v67 = 0LL;
          v65 = 0LL;
          v63 = 0LL;
          v59._vptr_Closure = 0LL;
          closure._vptr_Closure = 0LL;
          v35 = v34->_M_dataplus._M_p;
          v74 = -1;
          v36 = v34->_M_string_length;
          v53 = v35;
          v54 = v36;
          v72 = -1;
          v51 = v79._M_dataplus._M_p;
          v70 = -1;
          v52 = v79._M_string_length;
          v68 = -1;
          v66 = -1;
          v64 = -1;
          LODWORD(v60) = -1;
          LODWORD(v56) = -1;
          google::protobuf::strings::SubstituteAndAppend(
            &v47,
            "$0// $1\n",
            &v51,
            &v53,
            &closure,
            &v59,
            &v63,
            &v65,
            &v67,
            &v69,
            &v71,
            &v73);
          M_start = v40._M_impl._M_start;
          ++v32;
        }
        while ( v40._M_impl._M_finish - v40._M_impl._M_start > v32 );
        if ( v40._M_impl._M_start != v40._M_impl._M_finish )
        {
          v37 = v40._M_impl._M_start;
          M_finish = v40._M_impl._M_finish;
          do
          {
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v37->_M_dataplus._M_p != &v37->_anon_0 )
              operator delete(v37->_M_dataplus._M_p);
            ++v37;
          }
          while ( M_finish != v37 );
        }
      }
      if ( v40._M_impl._M_start )
        operator delete(v40._M_impl._M_start);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)str._M_dataplus._M_p != &str._anon_0 )
        operator delete(str._M_dataplus._M_p);
      std::string::_M_append(a3, (const char *)v47, v48);
      if ( v47 != v49 )
        operator delete(v47);
    }
  }
LABEL_15:
  if ( v44 != v46 )
    operator delete(v44);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v79._M_dataplus._M_p != &v79._anon_0 )
    operator delete(v79._M_dataplus._M_p);
  v29 = v76.leading_detached_comments._M_impl._M_finish;
  v30 = v76.leading_detached_comments._M_impl._M_start;
  if ( v76.leading_detached_comments._M_impl._M_finish != v76.leading_detached_comments._M_impl._M_start )
  {
    v31 = v76.leading_detached_comments._M_impl._M_start;
    do
    {
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v31->_M_dataplus._M_p != &v31->_anon_0 )
        operator delete(v31->_M_dataplus._M_p);
      ++v31;
    }
    while ( v29 != v31 );
    v30 = v76.leading_detached_comments._M_impl._M_start;
  }
  if ( v30 )
    operator delete(v30);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v76.trailing_comments._M_dataplus._M_p != &v76.trailing_comments._anon_0 )
    operator delete(v76.trailing_comments._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v76.leading_comments._M_dataplus._M_p != &v76.leading_comments._anon_0 )
    operator delete(v76.leading_comments._M_dataplus._M_p);
  if ( __beg != v43 )
    operator delete(__beg);
};

// Line 2814: range 000000000C901A50-000000000C901B6F
__int64 __fastcall google::protobuf::FileDescriptor::GetSourceLocation(
        __int64 a1,
        google::protobuf::int32 **a2,
        __int64 a3)
{
  __int64 v4; // rdx
  std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *SourceLocation; // rax
  std::_Hashtable<std::string,std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*>,std::allocator<std::pair<const std::string,const google::protobuf::SourceCodeInfo_Location*> >,std::__detail::_Select1st,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v6; // rbp
  std::__detail::_Hash_node_base *M_nxt; // rdx
  std::__detail::_Hash_node_base *v9; // rsi
  google::protobuf::internal::RepeatedPtrIterator<const std::string > v10; // rsi
  google::protobuf::internal::LogMessage_0 *v11; // rax
  std::forward_iterator_tag v12; // [rsp+0h] [rbp-68h]
  google::protobuf::internal::LogFinisher v13; // [rsp+Fh] [rbp-59h] BYREF
  google::protobuf::internal::LogMessage_0 v14; // [rsp+10h] [rbp-58h] BYREF

  if ( !a3 )
  {
    google::protobuf::internal::LogMessage::LogMessage(&v14, LOGLEVEL_FATAL_0, "./google/protobuf/stubs/logging.h", 166);
    v11 = google::protobuf::internal::LogMessage::operator<<(&v14, "'out_location' must not be NULL");
    google::protobuf::internal::LogFinisher::operator=(&v13, v11);
    google::protobuf::internal::LogMessage::~LogMessage(&v14);
  }
  v4 = *(_QWORD *)(a1 + 152);
  if ( !v4 )
    return 0LL;
  SourceLocation = google::protobuf::FileDescriptorTables::GetSourceLocation(*(_QWORD *)(a1 + 144), a2, v4);
  v6 = SourceLocation;
  if ( !SourceLocation || (unsigned int)(LODWORD(SourceLocation[6]._M_nxt) - 3) > 1 )
    return 0LL;
  M_nxt = SourceLocation[7]._M_nxt;
  v9 = SourceLocation[12]._M_nxt;
  *(_DWORD *)a3 = M_nxt[1]._M_nxt;
  *(_DWORD *)(a3 + 8) = HIDWORD(M_nxt[1]._M_nxt);
  *(_DWORD *)(a3 + 4) = M_nxt[(LODWORD(SourceLocation[6]._M_nxt) != 3) + 1]._M_nxt;
  *(_DWORD *)(a3 + 12) = *((_DWORD *)&M_nxt->_M_nxt + LODWORD(SourceLocation[6]._M_nxt) + 1);
  std::string::_M_assign(a3 + 16, v9);
  std::string::_M_assign(a3 + 48, v6[13]._M_nxt);
  v10.it_ = (void *const *)&v6[11]._M_nxt->_M_nxt;
  if ( v10.it_ )
    ++v10.it_;
  std::vector<std::string>::_M_assign_aux<google::protobuf::internal::RepeatedPtrIterator<std::string const>>(
    (std::vector<std::string> *const)(a3 + 80),
    v10,
    (google::protobuf::internal::RepeatedPtrIterator<const std::string >)&v10.it_[SLODWORD(v6[10]._M_nxt)],
    v12);
  return 1LL;
};

// Line 2838: range 000000000C901B80-000000000C901BC9
__int64 __fastcall google::protobuf::FileDescriptor::GetSourceLocation(
        google::protobuf::FileDescriptor *this,
        google::protobuf::SourceLocation *a2)
{
  unsigned int SourceLocation; // r12d
  void *v4[5]; // [rsp+0h] [rbp-28h] BYREF

  memset(v4, 0, 24);
  SourceLocation = google::protobuf::FileDescriptor::GetSourceLocation(
                     (__int64)this,
                     (google::protobuf::int32 **)v4,
                     (__int64)a2);
  if ( v4[0] )
    operator delete(v4[0]);
  return SourceLocation;
};

// Line 2852: range 000000000C901BD0-000000000C901C2D
__int64 __fastcall google::protobuf::Descriptor::GetSourceLocation(
        google::protobuf::Descriptor *this,
        google::protobuf::SourceLocation *a2)
{
  unsigned int SourceLocation; // r12d
  std::vector<int> v4[2]; // [rsp+0h] [rbp-38h] BYREF

  memset(v4, 0, 24);
  google::protobuf::Descriptor::GetLocationPath(this, v4);
  SourceLocation = google::protobuf::FileDescriptor::GetSourceLocation(
                     (__int64)this->file_,
                     &v4[0]._M_impl._M_start,
                     (__int64)a2);
  if ( v4[0]._M_impl._M_start )
    operator delete(v4[0]._M_impl._M_start);
  return SourceLocation;
};

// Line 2858: range 000000000C901C40-000000000C901C9D
__int64 __fastcall google::protobuf::FieldDescriptor::GetSourceLocation(
        google::protobuf::FieldDescriptor *this,
        google::protobuf::SourceLocation *a2)
{
  unsigned int SourceLocation; // r12d
  std::vector<int> v4[2]; // [rsp+0h] [rbp-38h] BYREF

  memset(v4, 0, 24);
  google::protobuf::FieldDescriptor::GetLocationPath(this, v4);
  SourceLocation = google::protobuf::FileDescriptor::GetSourceLocation(
                     (__int64)this->file_,
                     &v4[0]._M_impl._M_start,
                     (__int64)a2);
  if ( v4[0]._M_impl._M_start )
    operator delete(v4[0]._M_impl._M_start);
  return SourceLocation;
};

// Line 2864: range 000000000C901CB0-000000000C901D11
__int64 __fastcall google::protobuf::OneofDescriptor::GetSourceLocation(
        google::protobuf::OneofDescriptor *this,
        google::protobuf::SourceLocation *a2)
{
  unsigned int SourceLocation; // r12d
  std::vector<int> v4[2]; // [rsp+0h] [rbp-38h] BYREF

  memset(v4, 0, 24);
  google::protobuf::OneofDescriptor::GetLocationPath(this, v4);
  SourceLocation = google::protobuf::FileDescriptor::GetSourceLocation(
                     (__int64)this->containing_type_->file_,
                     &v4[0]._M_impl._M_start,
                     (__int64)a2);
  if ( v4[0]._M_impl._M_start )
    operator delete(v4[0]._M_impl._M_start);
  return SourceLocation;
};

// Line 2870: range 000000000C901D20-000000000C901D7D
__int64 __fastcall google::protobuf::EnumDescriptor::GetSourceLocation(
        google::protobuf::EnumDescriptor *this,
        google::protobuf::SourceLocation *a2)
{
  unsigned int SourceLocation; // r12d
  std::vector<int> v4[2]; // [rsp+0h] [rbp-38h] BYREF

  memset(v4, 0, 24);
  google::protobuf::EnumDescriptor::GetLocationPath(this, v4);
  SourceLocation = google::protobuf::FileDescriptor::GetSourceLocation(
                     (__int64)this->file_,
                     &v4[0]._M_impl._M_start,
                     (__int64)a2);
  if ( v4[0]._M_impl._M_start )
    operator delete(v4[0]._M_impl._M_start);
  return SourceLocation;
};

// Line 2876: range 000000000C901D90-000000000C901DF1
__int64 __fastcall google::protobuf::MethodDescriptor::GetSourceLocation(
        google::protobuf::MethodDescriptor *this,
        google::protobuf::SourceLocation *a2)
{
  unsigned int SourceLocation; // r12d
  std::vector<int> v4[2]; // [rsp+0h] [rbp-38h] BYREF

  memset(v4, 0, 24);
  google::protobuf::MethodDescriptor::GetLocationPath(this, v4);
  SourceLocation = google::protobuf::FileDescriptor::GetSourceLocation(
                     (__int64)this->service_->file_,
                     &v4[0]._M_impl._M_start,
                     (__int64)a2);
  if ( v4[0]._M_impl._M_start )
    operator delete(v4[0]._M_impl._M_start);
  return SourceLocation;
};

// Line 2882: range 000000000C901E00-000000000C901E5D
__int64 __fastcall google::protobuf::ServiceDescriptor::GetSourceLocation(
        google::protobuf::ServiceDescriptor *this,
        google::protobuf::SourceLocation *a2)
{
  unsigned int SourceLocation; // r12d
  std::vector<int> v4[2]; // [rsp+0h] [rbp-38h] BYREF

  memset(v4, 0, 24);
  google::protobuf::ServiceDescriptor::GetLocationPath(this, v4);
  SourceLocation = google::protobuf::FileDescriptor::GetSourceLocation(
                     (__int64)this->file_,
                     &v4[0]._M_impl._M_start,
                     (__int64)a2);
  if ( v4[0]._M_impl._M_start )
    operator delete(v4[0]._M_impl._M_start);
  return SourceLocation;
};

// Line 2889: range 000000000C901E70-000000000C901ED1
__int64 __fastcall google::protobuf::EnumValueDescriptor::GetSourceLocation(
        google::protobuf::EnumValueDescriptor *this,
        google::protobuf::SourceLocation *a2)
{
  unsigned int SourceLocation; // r12d
  std::vector<int> v4[2]; // [rsp+0h] [rbp-38h] BYREF

  memset(v4, 0, 24);
  google::protobuf::EnumValueDescriptor::GetLocationPath(this, v4);
  SourceLocation = google::protobuf::FileDescriptor::GetSourceLocation(
                     (__int64)this->type_->file_,
                     &v4[0]._M_impl._M_start,
                     (__int64)a2);
  if ( v4[0]._M_impl._M_start )
    operator delete(v4[0]._M_impl._M_start);
  return SourceLocation;
};

// Line 2895: range 000000000C8F87E0-000000000C8F889D
void __fastcall google::protobuf::Descriptor::GetLocationPath(
        const google::protobuf::Descriptor *const this,
        std::vector<int> *output)
{
  int *v2; // rdx
  const int *v3; // rcx
  const google::protobuf::Descriptor *containing_type; // rdi
  const int *v7; // rcx
  std::_Vector_base<int>::pointer M_finish; // rsi
  const google::protobuf::Descriptor *v9; // rax
  int v10; // ebx
  std::_Vector_base<int>::pointer v11; // rsi
  int v12[7]; // [rsp+Ch] [rbp-1Ch] BYREF

  containing_type = this->containing_type_;
  if ( containing_type )
  {
    google::protobuf::Descriptor::GetLocationPath(containing_type, output);
    M_finish = output->_M_impl._M_finish;
    if ( M_finish == output->_M_impl._M_end_of_storage )
    {
      std::vector<int>::_M_realloc_insert<int const&>(
        output,
        (std::vector<int>::iterator)M_finish,
        &google::protobuf::DescriptorProto::kNestedTypeFieldNumber,
        v7);
    }
    else
    {
      *M_finish = 3;
      output->_M_impl._M_finish = M_finish + 1;
    }
  }
  else
  {
    v11 = output->_M_impl._M_finish;
    if ( v11 != output->_M_impl._M_end_of_storage )
    {
      *v11 = 4;
      output->_M_impl._M_finish = v11 + 1;
      goto LABEL_9;
    }
    std::vector<int>::_M_realloc_insert<int const&>(
      output,
      (std::vector<int>::iterator)v11,
      &google::protobuf::FileDescriptorProto::kMessageTypeFieldNumber,
      v3);
  }
  v9 = this->containing_type_;
  if ( !v9 )
  {
LABEL_9:
    v10 = 954437177 * (((char *)this - (char *)this->file_->message_types_) >> 4);
    goto LABEL_6;
  }
  v10 = 954437177 * (((char *)this - (char *)v9->nested_types_) >> 4);
LABEL_6:
  v12[0] = v10;
  std::vector<int>::emplace_back<int>(output, v12, v2);
};

// Line 2906: range 000000000C8F88B0-000000000C8F89E5
void __fastcall google::protobuf::FieldDescriptor::GetLocationPath(
        const google::protobuf::FieldDescriptor *const this,
        std::vector<int> *output)
{
  int *v2; // rdx
  const int *v3; // rcx
  const google::protobuf::Descriptor *extension_scope; // rdi
  const int *v7; // rcx
  std::_Vector_base<int>::pointer v8; // rsi
  int v9; // ebx
  std::_Vector_base<int>::pointer M_finish; // rsi
  const google::protobuf::Descriptor *v11; // rax
  const int *v12; // rcx
  std::_Vector_base<int>::pointer v13; // rsi
  int v14[7]; // [rsp+Ch] [rbp-1Ch] BYREF

  if ( this->is_extension_ )
  {
    extension_scope = this->extension_scope_;
    if ( !extension_scope )
    {
      M_finish = output->_M_impl._M_finish;
      if ( M_finish == output->_M_impl._M_end_of_storage )
      {
        std::vector<int>::_M_realloc_insert<int const&>(
          output,
          (std::vector<int>::iterator)M_finish,
          &google::protobuf::FileDescriptorProto::kExtensionFieldNumber,
          v3);
        if ( !this->is_extension_ )
          goto LABEL_6;
      }
      else
      {
        *M_finish = 7;
        output->_M_impl._M_finish = M_finish + 1;
      }
      goto LABEL_10;
    }
    google::protobuf::Descriptor::GetLocationPath(extension_scope, output);
    v8 = output->_M_impl._M_finish;
    if ( v8 == output->_M_impl._M_end_of_storage )
    {
      std::vector<int>::_M_realloc_insert<int const&>(
        output,
        (std::vector<int>::iterator)v8,
        &google::protobuf::DescriptorProto::kExtensionFieldNumber,
        v7);
    }
    else
    {
      *v8 = 6;
      output->_M_impl._M_finish = v8 + 1;
    }
  }
  else
  {
    google::protobuf::Descriptor::GetLocationPath(this->containing_type_, output);
    v13 = output->_M_impl._M_finish;
    if ( v13 == output->_M_impl._M_end_of_storage )
    {
      std::vector<int>::_M_realloc_insert<int const&>(
        output,
        (std::vector<int>::iterator)v13,
        &google::protobuf::DescriptorProto::kFieldFieldNumber,
        v12);
    }
    else
    {
      *v13 = 2;
      output->_M_impl._M_finish = v13 + 1;
    }
  }
  if ( !this->is_extension_ )
  {
LABEL_6:
    v9 = 678152731 * (((char *)this - (char *)this->containing_type_->fields_) >> 3);
    goto LABEL_7;
  }
LABEL_10:
  v11 = this->extension_scope_;
  if ( v11 )
    v9 = 678152731 * (((char *)this - (char *)v11->extensions_) >> 3);
  else
    v9 = 678152731 * (((char *)this - (char *)this->file_->extensions_) >> 3);
LABEL_7:
  v14[0] = v9;
  std::vector<int>::emplace_back<int>(output, v14, v2);
};

// Line 2923: range 000000000C8F89F0-000000000C8F8A5D
void __fastcall google::protobuf::OneofDescriptor::GetLocationPath(
        const google::protobuf::OneofDescriptor *const this,
        std::vector<int> *output)
{
  int *v3; // rdx
  const int *v4; // rcx
  std::_Vector_base<int>::pointer M_finish; // rsi
  int v6[7]; // [rsp+Ch] [rbp-1Ch] BYREF

  google::protobuf::Descriptor::GetLocationPath(this->containing_type_, output);
  M_finish = output->_M_impl._M_finish;
  if ( M_finish == output->_M_impl._M_end_of_storage )
  {
    std::vector<int>::_M_realloc_insert<int const&>(
      output,
      (std::vector<int>::iterator)M_finish,
      &google::protobuf::DescriptorProto::kOneofDeclFieldNumber,
      v4);
  }
  else
  {
    *M_finish = 8;
    output->_M_impl._M_finish = M_finish + 1;
  }
  v6[0] = -1431655765 * (((char *)this - (char *)this->containing_type_->oneof_decls_) >> 4);
  std::vector<int>::emplace_back<int>(output, v6, v3);
};

// Line 2929: range 000000000C8F8A60-000000000C8F8B1D
void __fastcall google::protobuf::EnumDescriptor::GetLocationPath(
        const google::protobuf::EnumDescriptor *const this,
        std::vector<int> *output)
{
  int *v2; // rdx
  const int *v3; // rcx
  const google::protobuf::Descriptor *containing_type; // rdi
  const int *v7; // rcx
  std::_Vector_base<int>::pointer M_finish; // rsi
  const google::protobuf::Descriptor *v9; // rax
  int v10; // ebx
  std::_Vector_base<int>::pointer v11; // rsi
  int v12[7]; // [rsp+Ch] [rbp-1Ch] BYREF

  containing_type = this->containing_type_;
  if ( containing_type )
  {
    google::protobuf::Descriptor::GetLocationPath(containing_type, output);
    M_finish = output->_M_impl._M_finish;
    if ( M_finish == output->_M_impl._M_end_of_storage )
    {
      std::vector<int>::_M_realloc_insert<int const&>(
        output,
        (std::vector<int>::iterator)M_finish,
        &google::protobuf::DescriptorProto::kEnumTypeFieldNumber,
        v7);
    }
    else
    {
      *M_finish = 4;
      output->_M_impl._M_finish = M_finish + 1;
    }
  }
  else
  {
    v11 = output->_M_impl._M_finish;
    if ( v11 != output->_M_impl._M_end_of_storage )
    {
      *v11 = 5;
      output->_M_impl._M_finish = v11 + 1;
      goto LABEL_9;
    }
    std::vector<int>::_M_realloc_insert<int const&>(
      output,
      (std::vector<int>::iterator)v11,
      &google::protobuf::FileDescriptorProto::kEnumTypeFieldNumber,
      v3);
  }
  v9 = this->containing_type_;
  if ( !v9 )
  {
LABEL_9:
    v10 = -1227133513 * (((char *)this - (char *)this->file_->enum_types_) >> 3);
    goto LABEL_6;
  }
  v10 = -1227133513 * (((char *)this - (char *)v9->enum_types_) >> 3);
LABEL_6:
  v12[0] = v10;
  std::vector<int>::emplace_back<int>(output, v12, v2);
};

// Line 2940: range 000000000C8F8B30-000000000C8F8B9D
void __fastcall google::protobuf::EnumValueDescriptor::GetLocationPath(
        const google::protobuf::EnumValueDescriptor *const this,
        std::vector<int> *output)
{
  int *v3; // rdx
  const int *v4; // rcx
  std::_Vector_base<int>::pointer M_finish; // rsi
  int v6[7]; // [rsp+Ch] [rbp-1Ch] BYREF

  google::protobuf::EnumDescriptor::GetLocationPath(this->type_, output);
  M_finish = output->_M_impl._M_finish;
  if ( M_finish == output->_M_impl._M_end_of_storage )
  {
    std::vector<int>::_M_realloc_insert<int const&>(
      output,
      (std::vector<int>::iterator)M_finish,
      &google::protobuf::EnumDescriptorProto::kValueFieldNumber,
      v4);
  }
  else
  {
    *M_finish = 2;
    output->_M_impl._M_finish = M_finish + 1;
  }
  v6[0] = -858993459 * (((char *)this - (char *)this->type_->values_) >> 3);
  std::vector<int>::emplace_back<int>(output, v6, v3);
};

// Line 2946: range 000000000C8F8BA0-000000000C8F8C0C
void __fastcall google::protobuf::ServiceDescriptor::GetLocationPath(
        const google::protobuf::ServiceDescriptor *const this,
        std::vector<int> *output)
{
  int *v2; // rdx
  const int *v3; // rcx
  std::_Vector_base<int>::pointer M_finish; // rsi
  int v7[3]; // [rsp+1Ch] [rbp-Ch] BYREF

  M_finish = output->_M_impl._M_finish;
  if ( M_finish == output->_M_impl._M_end_of_storage )
  {
    std::vector<int>::_M_realloc_insert<int const&>(
      output,
      (std::vector<int>::iterator)M_finish,
      &google::protobuf::FileDescriptorProto::kServiceFieldNumber,
      v3);
  }
  else
  {
    *M_finish = 6;
    output->_M_impl._M_finish = M_finish + 1;
  }
  v7[0] = -1431655765 * (((char *)this - (char *)this->file_->services_) >> 4);
  std::vector<int>::emplace_back<int>(output, v7, v2);
};

// Line 2951: range 000000000C8F8C10-000000000C8F8C7D
void __fastcall google::protobuf::MethodDescriptor::GetLocationPath(
        const google::protobuf::MethodDescriptor *const this,
        std::vector<int> *output)
{
  int *v3; // rdx
  const int *v4; // rcx
  std::_Vector_base<int>::pointer M_finish; // rsi
  int v6[7]; // [rsp+Ch] [rbp-1Ch] BYREF

  google::protobuf::ServiceDescriptor::GetLocationPath(this->service_, output);
  M_finish = output->_M_impl._M_finish;
  if ( M_finish == output->_M_impl._M_end_of_storage )
  {
    std::vector<int>::_M_realloc_insert<int const&>(
      output,
      (std::vector<int>::iterator)M_finish,
      &google::protobuf::ServiceDescriptorProto::kMethodFieldNumber,
      v4);
  }
  else
  {
    *M_finish = 2;
    output->_M_impl._M_finish = M_finish + 1;
  }
  v6[0] = -991146299 * (((char *)this - (char *)this->service_->methods_) >> 3);
  std::vector<int>::emplace_back<int>(output, v6, v3);
};

// Line 2966: range 000000000C72D2A2-000000000C72D2CB
void __fastcall google::protobuf::`anonymous namespace'::OptionsToInterpret::~OptionsToInterpret(
        google::protobuf::`anonymous namespace'::OptionsToInterpret *const this)
{
  google::protobuf::`anonymous namespace'::OptionsToInterpret *M_p; // rdi

  M_p = (google::protobuf::`anonymous namespace'::OptionsToInterpret *)this->element_name._M_dataplus._M_p;
  if ( M_p != (google::protobuf::`anonymous namespace'::OptionsToInterpret *)&this->element_name._anon_0 )
    operator delete(M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)this->name_scope._M_dataplus._M_p != &this->name_scope._anon_0 )
    operator delete(this->name_scope._M_dataplus._M_p);
};

// Line 3397: range 000000000C912B30-000000000C912C60
const google::protobuf::FileDescriptor *__fastcall google::protobuf::DescriptorPool::BuildFile(
        google::protobuf::DescriptorPool *this,
        const google::protobuf::FileDescriptorProto *proto)
{
  google::protobuf::internal::LogMessage_0 *v2; // rax
  google::protobuf::internal::LogMessage_0 *v3; // rax
  google::protobuf::internal::LogMessage_0 *v4; // rax
  const google::protobuf::FileDescriptor *v5; // r13
  google::protobuf::internal::LogFinisher v7; // [rsp+Fh] [rbp-129h] BYREF
  google::protobuf::DescriptorBuilder v8; // [rsp+10h] [rbp-128h] BYREF

  if ( this->fallback_database_ )
  {
    google::protobuf::internal::LogMessage::LogMessage(
      (google::protobuf::internal::LogMessage_0 *const)&v8,
      LOGLEVEL_FATAL_0,
      "google/protobuf/descriptor.cc",
      3398);
    v2 = google::protobuf::internal::LogMessage::operator<<(
           (google::protobuf::internal::LogMessage_0 *const)&v8,
           "CHECK failed: fallback_database_ == NULL: ");
    v3 = google::protobuf::internal::LogMessage::operator<<(
           v2,
           "Cannot call BuildFile on a DescriptorPool that uses a DescriptorDatabase.  You must instead find a way to get"
           " your file into the underlying database.");
    google::protobuf::internal::LogFinisher::operator=(&v7, v3);
    google::protobuf::internal::LogMessage::~LogMessage((google::protobuf::internal::LogMessage_0 *const)&v8);
  }
  if ( this->mutex_ )
  {
    google::protobuf::internal::LogMessage::LogMessage(
      (google::protobuf::internal::LogMessage_0 *const)&v8,
      LOGLEVEL_FATAL_0,
      "google/protobuf/descriptor.cc",
      3402);
    v4 = google::protobuf::internal::LogMessage::operator<<(
           (google::protobuf::internal::LogMessage_0 *const)&v8,
           "CHECK failed: mutex_ == NULL: ");
    google::protobuf::internal::LogFinisher::operator=(&v7, v4);
    google::protobuf::internal::LogMessage::~LogMessage((google::protobuf::internal::LogMessage_0 *const)&v8);
  }
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear(&this->tables_.ptr_->known_bad_symbols_._M_h);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear(&this->tables_.ptr_->known_bad_files_._M_h);
  google::protobuf::DescriptorBuilder::DescriptorBuilder(&v8, this, this->tables_.ptr_, 0LL);
  v5 = google::protobuf::DescriptorBuilder::BuildFile(&v8, proto);
  google::protobuf::DescriptorBuilder::~DescriptorBuilder(&v8);
  return v5;
};

// Line 3398: range 000000000C73006C-000000000C730077
void __fastcall __noreturn google::protobuf::DescriptorPool::BuildFile()
{
  struct _Unwind_Exception *v0; // rbp
  google::protobuf::internal::LogMessage_0 *v1; // r12

  google::protobuf::internal::LogMessage::~LogMessage(v1);
  _Unwind_Resume(v0);
};

// Line 3410: range 000000000C912C70-000000000C912DA8
const google::protobuf::FileDescriptor *__fastcall google::protobuf::DescriptorPool::BuildFileCollectingErrors(
        google::protobuf::DescriptorPool *this,
        const google::protobuf::FileDescriptorProto *proto,
        google::protobuf::DescriptorPool::ErrorCollector *a3)
{
  google::protobuf::internal::LogMessage_0 *v4; // rax
  google::protobuf::internal::LogMessage_0 *v5; // rax
  google::protobuf::internal::LogMessage_0 *v6; // rax
  const google::protobuf::FileDescriptor *v7; // r13
  google::protobuf::internal::LogFinisher v9; // [rsp+Fh] [rbp-139h] BYREF
  google::protobuf::DescriptorBuilder v10; // [rsp+10h] [rbp-138h] BYREF

  if ( this->fallback_database_ )
  {
    google::protobuf::internal::LogMessage::LogMessage(
      (google::protobuf::internal::LogMessage_0 *const)&v10,
      LOGLEVEL_FATAL_0,
      "google/protobuf/descriptor.cc",
      3411);
    v4 = google::protobuf::internal::LogMessage::operator<<(
           (google::protobuf::internal::LogMessage_0 *const)&v10,
           "CHECK failed: fallback_database_ == NULL: ");
    v5 = google::protobuf::internal::LogMessage::operator<<(
           v4,
           "Cannot call BuildFile on a DescriptorPool that uses a DescriptorDatabase.  You must instead find a way to get"
           " your file into the underlying database.");
    google::protobuf::internal::LogFinisher::operator=(&v9, v5);
    google::protobuf::internal::LogMessage::~LogMessage((google::protobuf::internal::LogMessage_0 *const)&v10);
  }
  if ( this->mutex_ )
  {
    google::protobuf::internal::LogMessage::LogMessage(
      (google::protobuf::internal::LogMessage_0 *const)&v10,
      LOGLEVEL_FATAL_0,
      "google/protobuf/descriptor.cc",
      3415);
    v6 = google::protobuf::internal::LogMessage::operator<<(
           (google::protobuf::internal::LogMessage_0 *const)&v10,
           "CHECK failed: mutex_ == NULL: ");
    google::protobuf::internal::LogFinisher::operator=(&v9, v6);
    google::protobuf::internal::LogMessage::~LogMessage((google::protobuf::internal::LogMessage_0 *const)&v10);
  }
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear(&this->tables_.ptr_->known_bad_symbols_._M_h);
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::clear(&this->tables_.ptr_->known_bad_files_._M_h);
  google::protobuf::DescriptorBuilder::DescriptorBuilder(&v10, this, this->tables_.ptr_, a3);
  v7 = google::protobuf::DescriptorBuilder::BuildFile(&v10, proto);
  google::protobuf::DescriptorBuilder::~DescriptorBuilder(&v10);
  return v7;
};

// Line 3411: range 000000000C73009C-000000000C7300A7
void __fastcall __noreturn google::protobuf::DescriptorPool::BuildFileCollectingErrors()
{
  struct _Unwind_Exception *v0; // rbp
  google::protobuf::internal::LogMessage_0 *v1; // r12

  google::protobuf::internal::LogMessage::~LogMessage(v1);
  _Unwind_Resume(v0);
};

// Line 3423: range 000000000C912DB0-000000000C912E6A
const google::protobuf::FileDescriptor *__fastcall google::protobuf::DescriptorPool::BuildFileFromDatabase(
        google::protobuf::DescriptorPool *this,
        const google::protobuf::FileDescriptorProto *proto)
{
  google::protobuf::DescriptorPool::Tables *ptr; // r12
  const google::protobuf::FileDescriptor *v3; // r12
  google::protobuf::DescriptorBuilder v5; // [rsp+0h] [rbp-128h] BYREF

  google::protobuf::internal::Mutex::AssertHeld(this->mutex_);
  ptr = this->tables_.ptr_;
  if ( std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::count(
         &ptr->known_bad_files_._M_h,
         proto->name_.ptr_) )
  {
    return 0LL;
  }
  google::protobuf::DescriptorBuilder::DescriptorBuilder(&v5, this, ptr, this->default_error_collector_);
  v3 = google::protobuf::DescriptorBuilder::BuildFile(&v5, proto);
  google::protobuf::DescriptorBuilder::~DescriptorBuilder(&v5);
  if ( v3 )
    return v3;
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::_M_insert<std::string const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::string,true>>>>(
    &this->tables_.ptr_->known_bad_files_._M_h,
    proto->name_.ptr_,
    (const std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::string,true> > > *)&v5,
    (std::true_type)(LOBYTE(this->tables_.ptr_) + 24),
    1uLL);
  return 0LL;
};

// Line 3429: range 000000000C7300CC-000000000C7300D7
void __fastcall __noreturn google::protobuf::DescriptorPool::BuildFileFromDatabase()
{
  struct _Unwind_Exception *v0; // rbp
  void *retaddr; // [rsp+0h] [rbp+0h] BYREF

  google::protobuf::DescriptorBuilder::~DescriptorBuilder((google::protobuf::DescriptorBuilder *const)&retaddr);
  _Unwind_Resume(v0);
};

// Line 3437: range 000000000C8FA240-000000000C8FA345
void __fastcall google::protobuf::DescriptorBuilder::DescriptorBuilder(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::DescriptorPool *a2,
        google::protobuf::DescriptorPool::Tables *a3,
        google::protobuf::DescriptorPool::ErrorCollector *a4)
{
  std::string::$CFBEC286C7F52157F7E59FC354047095 *p_anon_0; // r12
  std::string::$CFBEC286C7F52157F7E59FC354047095 *v5; // rbp
  std::_Rb_tree_header *v7; // rax
  std::string *p_undefine_resolved_name; // rdi

  p_anon_0 = &this->possible_undeclared_dependency_name_._anon_0;
  v5 = &this->filename_._anon_0;
  this->dependencies_._M_t._M_impl._M_header._M_left = &this->dependencies_._M_t._M_impl._M_header;
  this->dependencies_._M_t._M_impl._M_header._M_right = &this->dependencies_._M_t._M_impl._M_header;
  v7 = &this->unused_dependency_._M_t._M_impl.std::_Rb_tree_header;
  p_undefine_resolved_name = &this->undefine_resolved_name_;
  p_undefine_resolved_name[-2]._M_dataplus._M_p = (std::string::pointer)v7;
  p_undefine_resolved_name[-2]._M_string_length = (std::string::size_type)v7;
  p_undefine_resolved_name[-8]._anon_0._M_allocated_capacity = (std::string::size_type)a2;
  *(&p_undefine_resolved_name[-8]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a3;
  p_undefine_resolved_name[-7]._M_dataplus._M_p = (std::string::pointer)a4;
  p_undefine_resolved_name[-7]._M_string_length = 0LL;
  p_undefine_resolved_name[-7]._anon_0._M_allocated_capacity = 0LL;
  *(&p_undefine_resolved_name[-7]._anon_0._M_allocated_capacity + 1) = 0LL;
  LOBYTE(p_undefine_resolved_name[-6]._M_dataplus._M_p) = 0;
  p_undefine_resolved_name[-6]._M_string_length = (std::string::size_type)v5;
  p_undefine_resolved_name[-6]._anon_0._M_allocated_capacity = 0LL;
  p_undefine_resolved_name[-6]._anon_0._M_local_buf[8] = 0;
  LODWORD(p_undefine_resolved_name[-4]._M_dataplus._M_p) = 0;
  p_undefine_resolved_name[-4]._M_string_length = 0LL;
  p_undefine_resolved_name[-3]._M_dataplus._M_p = 0LL;
  *(_DWORD *)p_undefine_resolved_name[-3]._anon_0._M_local_buf = 0;
  *(&p_undefine_resolved_name[-3]._anon_0._M_allocated_capacity + 1) = 0LL;
  p_undefine_resolved_name[-2]._anon_0._M_allocated_capacity = 0LL;
  *(&p_undefine_resolved_name[-2]._anon_0._M_allocated_capacity + 1) = 0LL;
  p_undefine_resolved_name[-1]._M_dataplus._M_p = (std::string::pointer)p_anon_0;
  p_undefine_resolved_name[-1]._M_string_length = 0LL;
  p_undefine_resolved_name[-1]._anon_0._M_local_buf[0] = 0;
  this->undefine_resolved_name_._M_dataplus._M_p = this->undefine_resolved_name_._anon_0._M_local_buf;
  std::string::_M_construct<char const*>(
    p_undefine_resolved_name,
    &off_1B23A528[4],
    &off_1B23A528[4],
    (std::forward_iterator_tag)a4);
};

// Line 3448: range 000000000C8F8580-000000000C8F864C
void __fastcall google::protobuf::DescriptorBuilder::~DescriptorBuilder(
        google::protobuf::DescriptorBuilder *const this)
{
  google::protobuf::DescriptorBuilder *M_p; // rdi
  google::protobuf::DescriptorBuilder *v3; // rdi
  google::protobuf::DescriptorBuilder *v4; // rdi
  std::_Vector_base<google::protobuf::(anonymous namespace)::OptionsToInterpret,std::allocator<google::protobuf::(anonymous namespace)::OptionsToInterpret> >::pointer M_finish; // r12
  std::_Vector_base<google::protobuf::(anonymous namespace)::OptionsToInterpret,std::allocator<google::protobuf::(anonymous namespace)::OptionsToInterpret> >::pointer M_start; // rbp
  std::string::$CFBEC286C7F52157F7E59FC354047095 *v7; // rdi

  M_p = (google::protobuf::DescriptorBuilder *)this->undefine_resolved_name_._M_dataplus._M_p;
  if ( M_p != (google::protobuf::DescriptorBuilder *)&this->undefine_resolved_name_._anon_0 )
    operator delete(M_p);
  v3 = (google::protobuf::DescriptorBuilder *)this->possible_undeclared_dependency_name_._M_dataplus._M_p;
  if ( v3 != (google::protobuf::DescriptorBuilder *)&this->possible_undeclared_dependency_name_._anon_0 )
    operator delete(v3);
  std::_Rb_tree<google::protobuf::FileDescriptor const*,google::protobuf::FileDescriptor const*,std::_Identity<google::protobuf::FileDescriptor const*>,std::less<google::protobuf::FileDescriptor const*>,std::allocator<google::protobuf::FileDescriptor const*>>::_M_erase(
    &this->unused_dependency_._M_t,
    (std::_Rb_tree<const google::protobuf::FileDescriptor*,const google::protobuf::FileDescriptor*,std::_Identity<const google::protobuf::FileDescriptor*>,std::less<const google::protobuf::FileDescriptor*>,std::allocator<const google::protobuf::FileDescriptor*> >::_Link_type)this->unused_dependency_._M_t._M_impl._M_header._M_parent);
  std::_Rb_tree<google::protobuf::FileDescriptor const*,google::protobuf::FileDescriptor const*,std::_Identity<google::protobuf::FileDescriptor const*>,std::less<google::protobuf::FileDescriptor const*>,std::allocator<google::protobuf::FileDescriptor const*>>::_M_erase(
    &this->dependencies_._M_t,
    (std::_Rb_tree<const google::protobuf::FileDescriptor*,const google::protobuf::FileDescriptor*,std::_Identity<const google::protobuf::FileDescriptor*>,std::less<const google::protobuf::FileDescriptor*>,std::allocator<const google::protobuf::FileDescriptor*> >::_Link_type)this->dependencies_._M_t._M_impl._M_header._M_parent);
  v4 = (google::protobuf::DescriptorBuilder *)this->filename_._M_dataplus._M_p;
  if ( v4 != (google::protobuf::DescriptorBuilder *)&this->filename_._anon_0 )
    operator delete(v4);
  M_finish = this->options_to_interpret_._M_impl._M_finish;
  M_start = this->options_to_interpret_._M_impl._M_start;
  if ( M_finish != M_start )
  {
    do
    {
      v7 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)M_start->element_name._M_dataplus._M_p;
      if ( v7 != &M_start->element_name._anon_0 )
        operator delete(v7);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)M_start->name_scope._M_dataplus._M_p != &M_start->name_scope._anon_0 )
        operator delete(M_start->name_scope._M_dataplus._M_p);
      ++M_start;
    }
    while ( M_finish != M_start );
    M_start = this->options_to_interpret_._M_impl._M_start;
  }
  if ( M_start )
    operator delete(M_start);
};

// Line 3454: range 000000000C8F5AC0-000000000C8F5BE2
void __fastcall google::protobuf::DescriptorBuilder::AddError(
        __int64 a1,
        const std::string *a2,
        __int64 a3,
        unsigned int a4,
        const std::string *a5)
{
  __int64 v7; // rdi
  google::protobuf::internal::LogMessage_0 *v8; // rax
  google::protobuf::internal::LogMessage_0 *v9; // rax
  google::protobuf::internal::LogMessage_0 *v10; // rax
  google::protobuf::internal::LogMessage_0 *v11; // rax
  google::protobuf::internal::LogMessage_0 *v12; // rax
  google::protobuf::internal::LogMessage_0 *v13; // rax
  google::protobuf::internal::LogMessage_0 *v14; // rax
  google::protobuf::internal::LogFinisher v15; // [rsp+Fh] [rbp-69h] BYREF
  google::protobuf::internal::LogMessage_0 v16; // [rsp+10h] [rbp-68h] BYREF

  v7 = *(_QWORD *)(a1 + 16);
  if ( v7 )
  {
    (*(void (__fastcall **)(__int64, __int64, const std::string *, __int64, _QWORD, const std::string *))(*(_QWORD *)v7 + 16LL))(
      v7,
      a1 + 56,
      a2,
      a3,
      a4,
      a5);
    *(_BYTE *)(a1 + 48) = 1;
  }
  else
  {
    if ( !*(_BYTE *)(a1 + 48) )
    {
      google::protobuf::internal::LogMessage::LogMessage(&v16, LOGLEVEL_ERROR_0, "google/protobuf/descriptor.cc", 3457);
      v12 = google::protobuf::internal::LogMessage::operator<<(&v16, "Invalid proto descriptor for file \"");
      v13 = google::protobuf::internal::LogMessage::operator<<(v12, (const std::string *)(a1 + 56));
      v14 = google::protobuf::internal::LogMessage::operator<<(v13, "\":");
      google::protobuf::internal::LogFinisher::operator=(&v15, v14);
      google::protobuf::internal::LogMessage::~LogMessage(&v16);
    }
    google::protobuf::internal::LogMessage::LogMessage(&v16, LOGLEVEL_ERROR_0, "google/protobuf/descriptor.cc", 3460);
    v8 = google::protobuf::internal::LogMessage::operator<<(&v16, "  ");
    v9 = google::protobuf::internal::LogMessage::operator<<(v8, a2);
    v10 = google::protobuf::internal::LogMessage::operator<<(v9, ptr);
    v11 = google::protobuf::internal::LogMessage::operator<<(v10, a5);
    google::protobuf::internal::LogFinisher::operator=(&v15, v11);
    google::protobuf::internal::LogMessage::~LogMessage(&v16);
    *(_BYTE *)(a1 + 48) = 1;
  }
};

// Line 3457: range 000000000C72D510-000000000C72D51B
void __fastcall __noreturn google::protobuf::DescriptorBuilder::AddError()
{
  struct _Unwind_Exception *v0; // rbp
  google::protobuf::internal::LogMessage_0 *v1; // r13

  google::protobuf::internal::LogMessage::~LogMessage(v1);
  _Unwind_Resume(v0);
};

// Line 3472: range 000000000C8F8FE0-000000000C8F905E
void __fastcall google::protobuf::DescriptorBuilder::AddError(
        __int64 a1,
        const std::string *a2,
        __int64 a3,
        unsigned int a4,
        const char *a5)
{
  __int64 v7; // rdx
  std::string v9[2]; // [rsp+0h] [rbp-58h] BYREF

  v7 = -1LL;
  v9[0]._M_dataplus._M_p = v9[0]._anon_0._M_local_buf;
  if ( a5 )
    v7 = (__int64)&a5[strlen(a5)];
  std::string::_M_construct<char const*>(v9, a5, (const char *)v7, (std::forward_iterator_tag)a4);
  google::protobuf::DescriptorBuilder::AddError(a1, a2, a3, a4, v9);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v9[0]._M_dataplus._M_p != &v9[0]._anon_0 )
    operator delete(v9[0]._M_dataplus._M_p);
};

// Line 3480: range 000000000C8F6910-000000000C8F71D1
void __fastcall google::protobuf::DescriptorBuilder::AddNotDefinedError(
        __int64 a1,
        const std::string *a2,
        __int64 a3,
        unsigned int a4,
        const std::string *a5)
{
  __int64 *v8; // rax
  __int64 v9; // rbx
  __int64 v10; // rax
  const char *v11; // rsi
  __int64 v12; // rax
  __int64 v13; // rax
  const char *v14; // rsi
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  const char *v18; // rsi
  __int64 v19; // rax
  __int64 v20; // rax
  const char *M_p; // rsi
  __int64 v22; // rax
  __int64 v23; // rax
  std::string::pointer v24; // rdi
  __int64 v25; // rax
  std::string v27; // [rsp+30h] [rbp-F8h] BYREF
  void *v28; // [rsp+50h] [rbp-D8h] BYREF
  __int64 v29; // [rsp+58h] [rbp-D0h]
  __m128i v30; // [rsp+60h] [rbp-C8h] BYREF
  void *v31; // [rsp+70h] [rbp-B8h] BYREF
  __int64 v32; // [rsp+78h] [rbp-B0h]
  __m128i v33; // [rsp+80h] [rbp-A8h] BYREF
  void *v34; // [rsp+90h] [rbp-98h] BYREF
  __int64 v35; // [rsp+98h] [rbp-90h]
  __m128i v36; // [rsp+A0h] [rbp-88h] BYREF
  std::string v37; // [rsp+B0h] [rbp-78h] BYREF
  std::string v38[2]; // [rsp+D0h] [rbp-58h] BYREF

  v8 = *(__int64 **)(a1 + 200);
  if ( v8 )
  {
    v9 = *v8;
    std::operator+<char>(&v27, "\"", (const std::string *)(a1 + 208));
    if ( 0x3FFFFFFFFFFFFFFFLL - v27._M_string_length <= 0x19 )
      std::__throw_length_error("basic_string::append");
    v10 = std::string::_M_append(&v27, "\" seems to be defined in \"", 26LL);
    v28 = &v30;
    if ( *(_QWORD *)v10 == v10 + 16 )
    {
      v30 = _mm_loadu_si128((const __m128i *)(v10 + 16));
    }
    else
    {
      v28 = *(void **)v10;
      v30.m128i_i64[0] = *(_QWORD *)(v10 + 16);
    }
    v29 = *(_QWORD *)(v10 + 8);
    *(_QWORD *)v10 = v10 + 16;
    *(_BYTE *)(v10 + 16) = 0;
    v11 = *(const char **)v9;
    *(_QWORD *)(v10 + 8) = 0LL;
    v12 = std::string::_M_append(&v28, v11, *(_QWORD *)(v9 + 8));
    v31 = &v33;
    if ( *(_QWORD *)v12 == v12 + 16 )
    {
      v33 = _mm_loadu_si128((const __m128i *)(v12 + 16));
    }
    else
    {
      v31 = *(void **)v12;
      v33.m128i_i64[0] = *(_QWORD *)(v12 + 16);
    }
    v32 = *(_QWORD *)(v12 + 8);
    *(_QWORD *)(v12 + 8) = 0LL;
    *(_BYTE *)(v12 + 16) = 0;
    *(_QWORD *)v12 = v12 + 16;
    if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v32) <= 0x1C )
      std::__throw_length_error("basic_string::append");
    v13 = std::string::_M_append(&v31, "\", which is not imported by \"", 29LL);
    v34 = &v36;
    if ( *(_QWORD *)v13 == v13 + 16 )
    {
      v36 = _mm_loadu_si128((const __m128i *)(v13 + 16));
    }
    else
    {
      v34 = *(void **)v13;
      v36.m128i_i64[0] = *(_QWORD *)(v13 + 16);
    }
    v35 = *(_QWORD *)(v13 + 8);
    *(_QWORD *)v13 = v13 + 16;
    *(_BYTE *)(v13 + 16) = 0;
    v14 = *(const char **)(a1 + 56);
    *(_QWORD *)(v13 + 8) = 0LL;
    v15 = std::string::_M_append(&v34, v14, *(_QWORD *)(a1 + 64));
    v37._M_dataplus._M_p = v37._anon_0._M_local_buf;
    if ( *(_QWORD *)v15 == v15 + 16 )
    {
      v37._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v15 + 16));
    }
    else
    {
      v37._M_dataplus._M_p = *(std::string::pointer *)v15;
      v37._anon_0._M_allocated_capacity = *(_QWORD *)(v15 + 16);
    }
    v37._M_string_length = *(_QWORD *)(v15 + 8);
    *(_QWORD *)(v15 + 8) = 0LL;
    *(_BYTE *)(v15 + 16) = 0;
    *(_QWORD *)v15 = v15 + 16;
    if ( 0x3FFFFFFFFFFFFFFFLL - v37._M_string_length <= 0x33 )
      std::__throw_length_error("basic_string::append");
    v16 = std::string::_M_append(&v37, "\".  To use it here, please add the necessary import.", 52LL);
    v38[0]._M_dataplus._M_p = v38[0]._anon_0._M_local_buf;
    if ( *(_QWORD *)v16 == v16 + 16 )
    {
      v38[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v16 + 16));
    }
    else
    {
      v38[0]._M_dataplus._M_p = *(std::string::pointer *)v16;
      v38[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v16 + 16);
    }
    v38[0]._M_string_length = *(_QWORD *)(v16 + 8);
    *(_QWORD *)v16 = v16 + 16;
    *(_QWORD *)(v16 + 8) = 0LL;
    *(_BYTE *)(v16 + 16) = 0;
    google::protobuf::DescriptorBuilder::AddError(a1, a2, a3, a4, v38);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v38[0]._M_dataplus._M_p != &v38[0]._anon_0 )
      operator delete(v38[0]._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v37._M_dataplus._M_p != &v37._anon_0 )
      operator delete(v37._M_dataplus._M_p);
    if ( v34 != &v36 )
      operator delete(v34);
    if ( v31 != &v33 )
      operator delete(v31);
    if ( v28 != &v30 )
      operator delete(v28);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v27._M_dataplus._M_p != &v27._anon_0 )
      operator delete(v27._M_dataplus._M_p);
    if ( !*(_QWORD *)(a1 + 248) )
      return;
    goto LABEL_30;
  }
  if ( *(_QWORD *)(a1 + 248) )
  {
LABEL_30:
    std::operator+<char>(&v27, "\"", a5);
    if ( 0x3FFFFFFFFFFFFFFFLL - v27._M_string_length <= 0x11 )
      std::__throw_length_error("basic_string::append");
    v17 = std::string::_M_append(&v27, "\" is resolved to \"", 18LL);
    v28 = &v30;
    if ( *(_QWORD *)v17 == v17 + 16 )
    {
      v30 = _mm_loadu_si128((const __m128i *)(v17 + 16));
    }
    else
    {
      v28 = *(void **)v17;
      v30.m128i_i64[0] = *(_QWORD *)(v17 + 16);
    }
    v29 = *(_QWORD *)(v17 + 8);
    *(_QWORD *)v17 = v17 + 16;
    *(_BYTE *)(v17 + 16) = 0;
    v18 = *(const char **)(a1 + 240);
    *(_QWORD *)(v17 + 8) = 0LL;
    v19 = std::string::_M_append(&v28, v18, *(_QWORD *)(a1 + 248));
    v31 = &v33;
    if ( *(_QWORD *)v19 == v19 + 16 )
    {
      v33 = _mm_loadu_si128((const __m128i *)(v19 + 16));
    }
    else
    {
      v31 = *(void **)v19;
      v33.m128i_i64[0] = *(_QWORD *)(v19 + 16);
    }
    v32 = *(_QWORD *)(v19 + 8);
    *(_QWORD *)(v19 + 8) = 0LL;
    *(_BYTE *)(v19 + 16) = 0;
    *(_QWORD *)v19 = v19 + 16;
    if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v32) <= 0x77 )
      std::__throw_length_error("basic_string::append");
    v20 = std::string::_M_append(
            &v31,
            "\", which is not defined. The innermost scope is searched first in name resolution. Consider using a leading '.'(i.e., \".",
            120LL);
    v34 = &v36;
    if ( *(_QWORD *)v20 == v20 + 16 )
    {
      v36 = _mm_loadu_si128((const __m128i *)(v20 + 16));
    }
    else
    {
      v34 = *(void **)v20;
      v36.m128i_i64[0] = *(_QWORD *)(v20 + 16);
    }
    v35 = *(_QWORD *)(v20 + 8);
    *(_QWORD *)v20 = v20 + 16;
    *(_BYTE *)(v20 + 16) = 0;
    M_p = a5->_M_dataplus._M_p;
    *(_QWORD *)(v20 + 8) = 0LL;
    v22 = std::string::_M_append(&v34, M_p, a5->_M_string_length);
    v37._M_dataplus._M_p = v37._anon_0._M_local_buf;
    if ( *(_QWORD *)v22 == v22 + 16 )
    {
      v37._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v22 + 16));
    }
    else
    {
      v37._M_dataplus._M_p = *(std::string::pointer *)v22;
      v37._anon_0._M_allocated_capacity = *(_QWORD *)(v22 + 16);
    }
    v37._M_string_length = *(_QWORD *)(v22 + 8);
    *(_QWORD *)(v22 + 8) = 0LL;
    *(_BYTE *)(v22 + 16) = 0;
    *(_QWORD *)v22 = v22 + 16;
    if ( 0x3FFFFFFFFFFFFFFFLL - v37._M_string_length <= 0x24 )
      std::__throw_length_error("basic_string::append");
    v23 = std::string::_M_append(&v37, "\") to start from the outermost scope.", 37LL);
    v38[0]._M_dataplus._M_p = v38[0]._anon_0._M_local_buf;
    if ( *(_QWORD *)v23 == v23 + 16 )
    {
      v38[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v23 + 16));
    }
    else
    {
      v38[0]._M_dataplus._M_p = *(std::string::pointer *)v23;
      v38[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v23 + 16);
    }
    v38[0]._M_string_length = *(_QWORD *)(v23 + 8);
    *(_QWORD *)v23 = v23 + 16;
    *(_QWORD *)(v23 + 8) = 0LL;
    *(_BYTE *)(v23 + 16) = 0;
    google::protobuf::DescriptorBuilder::AddError(a1, a2, a3, a4, v38);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v38[0]._M_dataplus._M_p != &v38[0]._anon_0 )
      operator delete(v38[0]._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v37._M_dataplus._M_p != &v37._anon_0 )
      operator delete(v37._M_dataplus._M_p);
    if ( v34 != &v36 )
      operator delete(v34);
    if ( v31 != &v33 )
      operator delete(v31);
    if ( v28 != &v30 )
      operator delete(v28);
    v24 = v27._M_dataplus._M_p;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v27._M_dataplus._M_p == &v27._anon_0 )
      return;
LABEL_54:
    operator delete(v24);
    return;
  }
  std::operator+<char>(&v37, "\"", a5);
  if ( 0x3FFFFFFFFFFFFFFFLL - v37._M_string_length <= 0x10 )
    std::__throw_length_error("basic_string::append");
  v25 = std::string::_M_append(&v37, "\" is not defined.", 17LL);
  v38[0]._M_dataplus._M_p = v38[0]._anon_0._M_local_buf;
  if ( *(_QWORD *)v25 == v25 + 16 )
  {
    v38[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v25 + 16));
  }
  else
  {
    v38[0]._M_dataplus._M_p = *(std::string::pointer *)v25;
    v38[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v25 + 16);
  }
  v38[0]._M_string_length = *(_QWORD *)(v25 + 8);
  *(_QWORD *)v25 = v25 + 16;
  *(_QWORD *)(v25 + 8) = 0LL;
  *(_BYTE *)(v25 + 16) = 0;
  google::protobuf::DescriptorBuilder::AddError(a1, a2, a3, a4, v38);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v38[0]._M_dataplus._M_p != &v38[0]._anon_0 )
    operator delete(v38[0]._M_dataplus._M_p);
  v24 = v37._M_dataplus._M_p;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v37._M_dataplus._M_p != &v37._anon_0 )
    goto LABEL_54;
};

// Line 3509: range 000000000C8F5BF0-000000000C8F5CD1
void __fastcall google::protobuf::DescriptorBuilder::AddWarning(
        __int64 a1,
        const std::string *a2,
        const google::protobuf::Message *a3,
        google::protobuf::DescriptorPool::ErrorCollector::ErrorLocation a4,
        const std::string *a5)
{
  const std::string *v6; // rbp
  __int64 v7; // r10
  void (__fastcall *v8)(google::protobuf::DescriptorPool::ErrorCollector *const, const std::string *, const std::string *, const google::protobuf::Message *, google::protobuf::DescriptorPool::ErrorCollector::ErrorLocation, const std::string *); // rax
  google::protobuf::internal::LogMessage_0 *v9; // rax
  google::protobuf::internal::LogMessage_0 *v10; // rax
  google::protobuf::internal::LogMessage_0 *v11; // rax
  google::protobuf::internal::LogMessage_0 *v12; // rax
  google::protobuf::internal::LogMessage_0 *v13; // rax
  google::protobuf::internal::LogFinisher v14; // [rsp+Fh] [rbp-59h] BYREF
  google::protobuf::internal::LogMessage_0 v15; // [rsp+10h] [rbp-58h] BYREF

  v6 = (const std::string *)(a1 + 56);
  v7 = *(_QWORD *)(a1 + 16);
  if ( v7 )
  {
    v8 = *(void (__fastcall **)(google::protobuf::DescriptorPool::ErrorCollector *const, const std::string *, const std::string *, const google::protobuf::Message *, google::protobuf::DescriptorPool::ErrorCollector::ErrorLocation, const std::string *))(*(_QWORD *)v7 + 24LL);
    if ( v8 != google::protobuf::DescriptorPool::ErrorCollector::AddWarning )
      v8(*(google::protobuf::DescriptorPool::ErrorCollector *const *)(a1 + 16), v6, a2, a3, a4, a5);
  }
  else
  {
    google::protobuf::internal::LogMessage::LogMessage(&v15, LOGLEVEL_WARNING_0, "google/protobuf/descriptor.cc", 3511);
    v9 = google::protobuf::internal::LogMessage::operator<<(&v15, v6);
    v10 = google::protobuf::internal::LogMessage::operator<<(v9, " ");
    v11 = google::protobuf::internal::LogMessage::operator<<(v10, a2);
    v12 = google::protobuf::internal::LogMessage::operator<<(v11, ptr);
    v13 = google::protobuf::internal::LogMessage::operator<<(v12, a5);
    google::protobuf::internal::LogFinisher::operator=(&v14, v13);
    google::protobuf::internal::LogMessage::~LogMessage(&v15);
  }
};

// Line 3511: range 000000000C72D530-000000000C72D53D
void __fastcall __noreturn google::protobuf::DescriptorBuilder::AddWarning(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 3519: range 000000000C8F5CE0-000000000C8F5D34
bool __fastcall google::protobuf::DescriptorBuilder::IsInPackage(
        google::protobuf::DescriptorBuilder *const this,
        const google::protobuf::FileDescriptor *file,
        const std::string *package_name)
{
  const std::string *package; // rdi
  std::string::size_type M_string_length; // rdx
  bool result; // al
  const std::string *v7; // rcx
  std::string::size_type v8; // rdx

  package = file->package_;
  M_string_length = package_name->_M_string_length;
  if ( M_string_length > package->_M_string_length
    || (unsigned int)std::string::compare(package, 0LL, M_string_length, package_name) )
  {
    return 0;
  }
  v7 = file->package_;
  v8 = package_name->_M_string_length;
  result = 1;
  if ( v7->_M_string_length != v8 )
    return v7->_M_dataplus._M_p[v8] == 46;
  return result;
};

// Line 3525: range 000000000C8F8650-000000000C8F8711
__int64 __fastcall google::protobuf::DescriptorBuilder::RecordPublicDependencies(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::FileDescriptor *a2)
{
  std::pair<std::_Rb_tree_iterator<const google::protobuf::FileDescriptor*>,bool> v3; // rax
  google::protobuf::FileDescriptor *v4; // rbx
  __int64 v5; // rbp
  google::protobuf::ProtobufOnceType *p_state; // rdi
  __int64 v7; // r12
  google::protobuf::FileDescriptor *__v; // [rsp+8h] [rbp-50h] BYREF
  google::protobuf::Closure closure; // [rsp+10h] [rbp-48h] BYREF
  void (__fastcall *v11)(const google::protobuf::FileDescriptor *); // [rsp+18h] [rbp-40h]
  char v12; // [rsp+20h] [rbp-38h]
  google::protobuf::FileDescriptor *v13; // [rsp+28h] [rbp-30h]

  __v = a2;
  if ( a2 )
  {
    v3 = std::_Rb_tree<google::protobuf::FileDescriptor const*,google::protobuf::FileDescriptor const*,std::_Identity<google::protobuf::FileDescriptor const*>,std::less<google::protobuf::FileDescriptor const*>,std::allocator<google::protobuf::FileDescriptor const*>>::_M_insert_unique<google::protobuf::FileDescriptor const* const&>(
           &this->dependencies_._M_t,
           (const google::protobuf::FileDescriptor *const *)&__v);
    if ( v3.second )
    {
      v4 = __v;
      if ( __v )
      {
        v5 = 0LL;
        do
        {
          if ( v4->public_dependency_count_ <= (int)v5 )
            break;
          p_state = &v4->dependencies_once_->state_;
          v7 = v4->public_dependencies_[v5];
          if ( p_state && *p_state != 2 )
          {
            v12 = 0;
            closure._vptr_Closure = (int (**)(...))&off_1A17BFB8;
            v11 = google::protobuf::FileDescriptor::DependenciesOnceInit;
            v13 = v4;
            google::protobuf::GoogleOnceInitImpl(p_state, &closure);
            closure._vptr_Closure = (int (**)(...))&off_1A17BFB8;
            google::protobuf::Closure::~Closure(&closure);
          }
          ++v5;
          v3.first._M_node = (std::_Rb_tree_iterator<const google::protobuf::FileDescriptor*>::_Base_ptr)google::protobuf::DescriptorBuilder::RecordPublicDependencies(this, v4->dependencies_[v7]);
          v4 = __v;
        }
        while ( __v );
      }
    }
  }
  return (__int64)v3.first._M_node;
};

// Line 3533: range 000000000C913E10-000000000C913FD3
__int64 __fastcall google::protobuf::DescriptorBuilder::FindSymbolNotEnforcingDepsHelper(
        google::protobuf::DescriptorPool **a1,
        google::protobuf::DescriptorPool *a2,
        std::string *a3,
        char a4)
{
  google::protobuf::internal::Mutex *mutex; // r14
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type M_p; // rdx
  google::protobuf::DescriptorPool::Tables *ptr; // rsi
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v9; // rcx
  __int64 v10; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v11; // rax
  std::__detail::_Hash_node_base *M_nxt; // rbx
  const google::protobuf::DescriptorPool *underlay; // rsi
  unsigned int SymbolNotEnforcingDepsHelper; // eax
  std::string::pointer v16; // rdx
  google::protobuf::DescriptorPool::Tables *v17; // rsi
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v18; // rcx
  __int64 v19; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v20; // rax
  std::__detail::_Hash_node_base *v21; // rbx
  unsigned int v22; // [rsp+8h] [rbp-50h]
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type __k[8]; // [rsp+18h] [rbp-40h] BYREF

  mutex = 0LL;
  if ( *a1 != a2 )
  {
    mutex = a2->mutex_;
    if ( a2->mutex_ )
      google::protobuf::internal::Mutex::Lock(a2->mutex_);
  }
  M_p = a3->_M_dataplus._M_p;
  ptr = a2->tables_.ptr_;
  v9 = 0LL;
  v10 = *a3->_M_dataplus._M_p;
  for ( __k[0] = a3->_M_dataplus._M_p; (_BYTE)v10; v10 = *M_p )
  {
    ++M_p;
    v9 = v10 + 5 * v9;
  }
  v11 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
          &ptr->symbols_by_name_._M_h,
          v9 % ptr->symbols_by_name_._M_h._M_bucket_count,
          __k,
          v9);
  if ( v11 && v11->_M_nxt )
    M_nxt = v11->_M_nxt[2]._M_nxt;
  else
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
  v22 = (unsigned int)M_nxt;
  if ( !(_DWORD)M_nxt )
  {
    underlay = a2->underlay_;
    if ( underlay
      && (SymbolNotEnforcingDepsHelper = google::protobuf::DescriptorBuilder::FindSymbolNotEnforcingDepsHelper(
                                           a1,
                                           underlay,
                                           a3,
                                           1LL)) != 0 )
    {
      v22 = SymbolNotEnforcingDepsHelper;
    }
    else if ( a4 && (unsigned __int8)google::protobuf::DescriptorPool::TryFindSymbolInFallbackDatabase(a2, a3) )
    {
      v16 = a3->_M_dataplus._M_p;
      v17 = a2->tables_.ptr_;
      v18 = 0LL;
      v19 = *a3->_M_dataplus._M_p;
      for ( __k[0] = a3->_M_dataplus._M_p; (_BYTE)v19; v19 = *v16 )
      {
        ++v16;
        v18 = v19 + 5 * v18;
      }
      v20 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
              &v17->symbols_by_name_._M_h,
              v18 % v17->symbols_by_name_._M_h._M_bucket_count,
              __k,
              v18);
      if ( v20 && v20->_M_nxt )
        v21 = v20->_M_nxt[2]._M_nxt;
      else
        LODWORD(v21) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
      v22 = (unsigned int)v21;
    }
  }
  if ( mutex )
    google::protobuf::internal::Mutex::Unlock(mutex);
  return v22;
};

// Line 3562: range 000000000C913FE0-000000000C913FE9
google::protobuf::Symbol __fastcall google::protobuf::DescriptorBuilder::FindSymbolNotEnforcingDeps(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name,
        bool build_it)
{
  google::protobuf::Symbol::Type SymbolNotEnforcingDepsHelper; // eax
  google::protobuf::Symbol::$9563B2B6DA4D533FB15633169CBAFFAD v4; // rdx
  google::protobuf::Symbol result; // 0:eax.4,8:rdx.8

  SymbolNotEnforcingDepsHelper = (unsigned int)google::protobuf::DescriptorBuilder::FindSymbolNotEnforcingDepsHelper(
                                                 (google::protobuf::DescriptorPool **)this,
                                                 (google::protobuf::DescriptorPool *)this->pool_,
                                                 (std::string *)name,
                                                 build_it);
  result._anon_0 = v4;
  result.type = SymbolNotEnforcingDepsHelper;
  return result;
};

// Line 3565: range 000000000C913FF0-000000000C9141A6
google::protobuf::Symbol __fastcall google::protobuf::DescriptorBuilder::FindSymbol(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name,
        bool build_it)
{
  google::protobuf::Symbol::Type SymbolNotEnforcingDepsHelper; // eax
  const google::protobuf::Descriptor *descriptor; // rdx
  const google::protobuf::Descriptor *v6; // r12
  google::protobuf::Symbol::Type v7; // r13d
  google::protobuf::Symbol::Type type; // eax
  const google::protobuf::FileDescriptor *fields; // rsi
  google::protobuf::FileDescriptor *v10; // r8
  std::_Rb_tree_node_base::_Base_ptr M_parent; // rcx
  std::_Rb_tree_header *v12; // r15
  std::_Rb_tree_header *v13; // rdx
  std::_Rb_tree_node_base::_Base_ptr M_left; // r14
  const google::protobuf::FileDescriptor *v15; // rsi
  const google::protobuf::FileDescriptor *file; // [rsp+8h] [rbp-40h] BYREF
  google::protobuf::Symbol result; // 0:eax.4,8:rdx.8

  SymbolNotEnforcingDepsHelper = (unsigned int)google::protobuf::DescriptorBuilder::FindSymbolNotEnforcingDepsHelper(
                                                 (google::protobuf::DescriptorPool **)this,
                                                 (google::protobuf::DescriptorPool *)this->pool_,
                                                 (std::string *)name,
                                                 build_it);
  v6 = descriptor;
  v7 = SymbolNotEnforcingDepsHelper;
  if ( SymbolNotEnforcingDepsHelper )
  {
    fields = (const google::protobuf::FileDescriptor *)descriptor;
    if ( this->pool_->enforce_dependencies_ )
    {
      switch ( SymbolNotEnforcingDepsHelper )
      {
        case MESSAGE_0:
        case ENUM:
        case SERVICE:
          fields = descriptor->file_;
          break;
        case FIELD:
          fields = (const google::protobuf::FileDescriptor *)descriptor->fields_;
          break;
        case ONEOF:
        case METHOD:
          fields = (const google::protobuf::FileDescriptor *)descriptor->file_->pool_;
          break;
        case ENUM_VALUE:
          fields = descriptor->containing_type_->file_;
          break;
        case PACKAGE:
          break;
        default:
          fields = 0LL;
          break;
      }
      v10 = this->file_;
      file = fields;
      if ( v10 != fields )
      {
        M_parent = this->dependencies_._M_t._M_impl._M_header._M_parent;
        v12 = &this->dependencies_._M_t._M_impl.std::_Rb_tree_header;
        if ( !M_parent )
          goto LABEL_14;
        v13 = &this->dependencies_._M_t._M_impl.std::_Rb_tree_header;
        do
        {
          while ( *(_QWORD *)&M_parent[1]._M_color >= (unsigned __int64)fields )
          {
            v13 = (std::_Rb_tree_header *)M_parent;
            M_parent = M_parent->_M_left;
            if ( !M_parent )
              goto LABEL_12;
          }
          M_parent = M_parent->_M_right;
        }
        while ( M_parent );
LABEL_12:
        if ( v12 == v13 || v13->_M_node_count > (unsigned __int64)fields )
        {
LABEL_14:
          if ( SymbolNotEnforcingDepsHelper != PACKAGE )
          {
LABEL_15:
            this->possible_undeclared_dependency_ = fields;
            std::string::_M_assign(&this->possible_undeclared_dependency_name_, name);
            type = google::protobuf::`anonymous namespace'::kNullSymbol.type;
            descriptor = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.descriptor;
            goto LABEL_29;
          }
          if ( !google::protobuf::DescriptorBuilder::IsInPackage(this, v10, name) )
          {
            M_left = this->dependencies_._M_t._M_impl._M_header._M_left;
            if ( v12 == (std::_Rb_tree_header *)M_left )
            {
LABEL_27:
              fields = file;
              goto LABEL_15;
            }
            while ( 1 )
            {
              v15 = *(const google::protobuf::FileDescriptor **)&M_left[1]._M_color;
              if ( v15 )
              {
                if ( google::protobuf::DescriptorBuilder::IsInPackage(this, v15, name) )
                  break;
              }
              M_left = (std::_Rb_tree_node_base::_Base_ptr)std::_Rb_tree_increment(M_left);
              if ( v12 == (std::_Rb_tree_header *)M_left )
                goto LABEL_27;
            }
          }
          descriptor = v6;
          type = PACKAGE;
          goto LABEL_29;
        }
      }
      std::_Rb_tree<google::protobuf::FileDescriptor const*,google::protobuf::FileDescriptor const*,std::_Identity<google::protobuf::FileDescriptor const*>,std::less<google::protobuf::FileDescriptor const*>,std::allocator<google::protobuf::FileDescriptor const*>>::erase(
        &this->unused_dependency_._M_t,
        &file);
    }
    type = v7;
    descriptor = v6;
    goto LABEL_29;
  }
  type = NULL_SYMBOL;
LABEL_29:
  result._anon_0 = (google::protobuf::Symbol::$9563B2B6DA4D533FB15633169CBAFFAD)descriptor;
  result.type = type;
  return result;
};

// Line 3608: range 000000000C9141B0-000000000C91459C
__int64 __fastcall google::protobuf::DescriptorBuilder::LookupSymbolNoPlaceholder(
        google::protobuf::DescriptorBuilder *this,
        std::string *name,
        __int64 a3,
        int a4,
        bool a5)
{
  std::string::pointer M_p; // rax
  std::string::size_type M_string_length; // rdx
  std::string::pointer v11; // rsi
  unsigned __int64 v12; // rax
  std::string::size_type v13; // rdx
  const char *v14; // rsi
  std::forward_iterator_tag v15; // cl
  char *M_local_buf; // rdi
  std::string::size_type v17; // rdx
  std::string::size_type v18; // rsi
  char *v19; // rsi
  char *v20; // rdx
  unsigned __int64 v21; // rax
  std::string::size_type v22; // r12
  unsigned __int64 v23; // rax
  google::protobuf::Symbol::Type v24; // r14d
  std::string::size_type v25; // rdx
  __int64 v26; // rcx
  void *v27; // rdi
  google::protobuf::Symbol::Type type; // eax
  void *dest; // [rsp+10h] [rbp-98h] BYREF
  std::string::size_type v33; // [rsp+18h] [rbp-90h]
  std::forward_iterator_tag v34[8]; // [rsp+20h] [rbp-88h] BYREF
  std::string src; // [rsp+30h] [rbp-78h] BYREF
  std::string namea; // [rsp+50h] [rbp-58h] BYREF

  M_p = this->undefine_resolved_name_._M_dataplus._M_p;
  this->undefine_resolved_name_._M_string_length = 0LL;
  this->possible_undeclared_dependency_ = 0LL;
  *M_p = 0;
  M_string_length = name->_M_string_length;
  if ( M_string_length )
  {
    v11 = name->_M_dataplus._M_p;
    if ( *v11 == 46 )
    {
      namea._M_dataplus._M_p = namea._anon_0._M_local_buf;
      std::string::_M_construct<char const*>(&namea, v11 + 1, &v11[M_string_length], (std::forward_iterator_tag)a4);
      type = google::protobuf::DescriptorBuilder::FindSymbol(this, &namea, a5).type;
      v27 = namea._M_dataplus._M_p;
      v24 = type;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)namea._M_dataplus._M_p != &namea._anon_0 )
        goto LABEL_24;
      return (unsigned int)v24;
    }
  }
  v12 = std::string::find(name, 46LL, 0LL);
  v34[0].gap0[0] = 0;
  dest = v34;
  v33 = 0LL;
  if ( v12 != -1LL )
  {
    v13 = name->_M_string_length;
    v14 = name->_M_dataplus._M_p;
    src._M_dataplus._M_p = src._anon_0._M_local_buf;
    if ( v12 > v13 )
      v12 = v13;
    std::string::_M_construct<char const*>(&src, v14, &v14[v12], (std::forward_iterator_tag)v34);
    M_local_buf = (char *)dest;
    v17 = src._M_string_length;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)src._M_dataplus._M_p == &src._anon_0 )
    {
      if ( src._M_string_length )
      {
        if ( src._M_string_length == 1 )
          *(_BYTE *)dest = src._anon_0._M_local_buf[0];
        else
          memcpy(dest, &src._anon_0, src._M_string_length);
        v17 = src._M_string_length;
        M_local_buf = (char *)dest;
      }
      v33 = v17;
      M_local_buf[v17] = 0;
      M_local_buf = src._M_dataplus._M_p;
      goto LABEL_10;
    }
    v15.gap0[0] = src._anon_0._M_local_buf[0];
    if ( dest == v34 )
    {
      dest = src._M_dataplus._M_p;
      v33 = src._M_string_length;
      *(_QWORD *)v34[0].gap0 = src._anon_0._M_allocated_capacity;
    }
    else
    {
      v18 = *(_QWORD *)v34[0].gap0;
      dest = src._M_dataplus._M_p;
      v33 = src._M_string_length;
      *(_QWORD *)v34[0].gap0 = src._anon_0._M_allocated_capacity;
      if ( M_local_buf )
      {
        src._M_dataplus._M_p = M_local_buf;
        src._anon_0._M_allocated_capacity = v18;
        goto LABEL_10;
      }
    }
    src._M_dataplus._M_p = src._anon_0._M_local_buf;
    M_local_buf = src._anon_0._M_local_buf;
LABEL_10:
    src._M_string_length = 0LL;
    *M_local_buf = 0;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)src._M_dataplus._M_p != &src._anon_0 )
      operator delete(src._M_dataplus._M_p);
    goto LABEL_12;
  }
  std::string::_M_assign(&dest, name);
LABEL_12:
  v19 = *(char **)a3;
  v20 = (char *)(*(_QWORD *)a3 + *(_QWORD *)(a3 + 8));
  namea._M_dataplus._M_p = namea._anon_0._M_local_buf;
  std::string::_M_construct<char *>(&namea, v19, v20, v15);
  while ( 1 )
  {
    v21 = std::string::rfind(&namea, 46LL, -1LL);
    if ( v21 == -1LL )
    {
      v24 = google::protobuf::DescriptorBuilder::FindSymbol(this, name, a5).type;
      goto LABEL_21;
    }
    if ( v21 > namea._M_string_length )
      std::__throw_out_of_range_fmt(
        "%s: __pos (which is %zu) > this->size() (which is %zu)",
        "basic_string::erase",
        v21,
        namea._M_string_length);
    namea._M_string_length = v21;
    namea._M_dataplus._M_p[v21] = 0;
    v22 = namea._M_string_length;
    std::string::_M_replace_aux(&namea, namea._M_string_length, 0LL, 1LL, 46LL);
    std::string::_M_append(&namea, (const char *)dest, v33);
    v23 = *(_OWORD *)&google::protobuf::DescriptorBuilder::FindSymbol(this, &namea, a5);
    v24 = (int)v23;
    if ( (_DWORD)v23 )
      break;
LABEL_29:
    if ( v22 > namea._M_string_length )
      std::__throw_out_of_range_fmt(
        "%s: __pos (which is %zu) > this->size() (which is %zu)",
        "basic_string::erase",
        v22,
        namea._M_string_length);
    namea._M_string_length = v22;
    namea._M_dataplus._M_p[v22] = 0;
  }
  v25 = name->_M_string_length;
  if ( v33 >= v25 )
  {
    if ( a4 != 1 || (_DWORD)v23 == 1 || (_DWORD)v23 == 4 )
      goto LABEL_21;
    goto LABEL_29;
  }
  if ( (unsigned int)v23 > 8 )
    goto LABEL_29;
  v26 = 338LL;
  if ( !_bittest64(&v26, v23) )
    goto LABEL_29;
  std::string::_M_append(&namea, &name->_M_dataplus._M_p[v33], v25 - v33);
  v24 = google::protobuf::DescriptorBuilder::FindSymbol(this, &namea, a5).type;
  if ( v24 == NULL_SYMBOL )
    std::string::_M_assign(&this->undefine_resolved_name_, &namea);
LABEL_21:
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)namea._M_dataplus._M_p != &namea._anon_0 )
    operator delete(namea._M_dataplus._M_p);
  v27 = dest;
  if ( dest != v34 )
LABEL_24:
    operator delete(v27);
  return (unsigned int)v24;
};

// Line 3684: range 000000000C9145B0-000000000C914600
google::protobuf::Symbol __fastcall google::protobuf::DescriptorBuilder::LookupSymbol(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name,
        const std::string *relative_to,
        google::protobuf::DescriptorPool::PlaceholderType placeholder_type,
        google::protobuf::DescriptorBuilder::ResolveMode resolve_mode,
        bool build_it)
{
  __int64 v8; // rax
  google::protobuf::Symbol::$9563B2B6DA4D533FB15633169CBAFFAD v9; // rdx
  __int64 v10; // rcx
  const google::protobuf::DescriptorPool *pool; // rdi
  google::protobuf::Symbol result; // 0:eax.4,8:rdx.8

  v8 = google::protobuf::DescriptorBuilder::LookupSymbolNoPlaceholder(
         this,
         (std::string *)name,
         (__int64)relative_to,
         resolve_mode,
         build_it);
  if ( !(_DWORD)v8 )
  {
    pool = this->pool_;
    if ( this->pool_->allow_unknown_ )
      LODWORD(v8) = google::protobuf::DescriptorPool::NewPlaceholderWithMutexHeld(
                      pool,
                      name,
                      (unsigned int)placeholder_type,
                      v10,
                      v8);
  }
  result._anon_0 = v9;
  result.type = v8;
  return result;
};

// Line 3716: range 000000000C900650-000000000C9006AA
__int64 __fastcall google::protobuf::DescriptorPool::NewPlaceholder(
        google::protobuf::internal::Mutex **a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5)
{
  google::protobuf::internal::Mutex *v6; // r12
  unsigned int v7; // r14d

  v6 = *a1;
  if ( *a1 )
    google::protobuf::internal::Mutex::Lock(*a1);
  v7 = google::protobuf::DescriptorPool::NewPlaceholderWithMutexHeld(a1, a2, a3, a4, a5);
  if ( v6 )
    google::protobuf::internal::Mutex::Unlock(v6);
  return v7;
};

// Line 3722: range 000000000C900070-000000000C90063C
__int64 __fastcall google::protobuf::DescriptorPool::NewPlaceholderWithMutexHeld(__int64 a1, const char **a2, int a3)
{
  google::protobuf::internal::Mutex *v5; // rdi
  const char *v6; // rax
  const char *v7; // rsi
  char v8; // dl
  const char *v9; // r8
  const char *v10; // rcx
  char v11; // al
  std::vector<std::string*> *v13; // r12
  std::string *String; // r12
  unsigned __int64 v15; // rax
  std::forward_iterator_tag v16; // cl
  unsigned __int64 v17; // r14
  unsigned __int64 M_string_length; // rdx
  std::vector<std::string*> *v19; // r8
  std::string::size_type v20; // rcx
  std::string::size_type v21; // r14
  std::vector<std::string*> *v22; // r8
  std::string::size_type v23; // rdx
  __int64 v24; // rax
  __int64 v25; // r8
  google::protobuf::DescriptorPool::Tables *v26; // rdi
  _QWORD *v27; // r14
  char *v28; // rdi
  unsigned int v29; // ecx
  __int64 v30; // rax
  char *Bytes; // r14
  __int64 v32; // rax
  google::protobuf::DescriptorPool::Tables *v33; // rdi
  bool v34; // zf
  std::string **v35; // rax
  std::string **v36; // rbp
  std::vector<std::string*> *v37; // r12
  std::forward_iterator_tag v38; // cl
  std::string *v39; // rax
  std::forward_iterator_tag v40; // cl
  std::string *M_p; // rdi
  std::string::size_type v42; // rdx
  _QWORD *v43; // rax
  std::vector<std::string*> *v44; // r12
  std::string *v45; // rax
  __int64 v47; // [rsp+0h] [rbp-78h]
  std::vector<std::string*> *v48; // [rsp+8h] [rbp-70h]
  std::string *v49; // [rsp+8h] [rbp-70h]
  __int64 v50; // [rsp+8h] [rbp-70h]
  std::vector<std::string*> *v51; // [rsp+10h] [rbp-68h]
  std::string *v52; // [rsp+10h] [rbp-68h]
  __int64 v53; // [rsp+18h] [rbp-60h]
  std::string v54; // [rsp+20h] [rbp-58h] BYREF

  v5 = *(google::protobuf::internal::Mutex **)a1;
  if ( v5 )
    google::protobuf::internal::Mutex::AssertHeld(v5);
  v6 = a2[1];
  if ( !v6 )
    return *(_QWORD *)&google::protobuf::`anonymous namespace'::kNullSymbol.type;
  v7 = *a2;
  v8 = 0;
  v9 = *a2;
  v10 = &v6[(_QWORD)*a2];
  do
  {
    v11 = *v9;
    if ( *v9 > 96 )
    {
      if ( v11 > 122 )
        return *(_QWORD *)&google::protobuf::`anonymous namespace'::kNullSymbol.type;
LABEL_10:
      v8 = 0;
      goto LABEL_11;
    }
    if ( v11 > 64 )
    {
      if ( v11 > 90 && v11 != 95 )
        return *(_QWORD *)&google::protobuf::`anonymous namespace'::kNullSymbol.type;
      goto LABEL_10;
    }
    if ( v11 > 47 && v11 <= 57 )
      goto LABEL_10;
    if ( v11 != 46 || v8 )
      return *(_QWORD *)&google::protobuf::`anonymous namespace'::kNullSymbol.type;
    v8 = 1;
LABEL_11:
    ++v9;
  }
  while ( v9 != v10 );
  if ( v8 )
    return *(_QWORD *)&google::protobuf::`anonymous namespace'::kNullSymbol.type;
  v13 = *(std::vector<std::string*> **)(a1 + 32);
  if ( *v7 == 46 )
  {
    v54._M_dataplus._M_p = v54._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&v54, v7 + 1, v9, (std::forward_iterator_tag)v10);
    String = google::protobuf::DescriptorPool::Tables::AllocateString(v13, (__int64)&v54);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54._M_dataplus._M_p != &v54._anon_0 )
      operator delete(v54._M_dataplus._M_p);
  }
  else
  {
    String = google::protobuf::DescriptorPool::Tables::AllocateString(
               *(std::vector<std::string*> **)(a1 + 32),
               (__int64)a2);
  }
  v15 = std::string::rfind(String, 46LL, -1LL);
  v17 = v15;
  if ( v15 == -1LL )
  {
    if ( google::protobuf::internal::empty_string_once_init_ != 2 )
    {
      v54._M_dataplus._M_p = (std::string::pointer)off_1A16E058;
      v54._M_string_length = (std::string::size_type)google::protobuf::internal::InitEmptyString;
      v54._anon_0._M_local_buf[0] = 0;
      google::protobuf::GoogleOnceInitImpl(
        &google::protobuf::internal::empty_string_once_init_,
        (google::protobuf::Closure *)&v54);
      google::protobuf::internal::FunctionClosure0::~FunctionClosure0((google::protobuf::internal::FunctionClosure0 *const)&v54);
    }
    v52 = String;
    v49 = (std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11];
  }
  else
  {
    M_string_length = v15;
    if ( String->_M_string_length <= v15 )
      M_string_length = String->_M_string_length;
    v19 = *(std::vector<std::string*> **)(a1 + 32);
    v54._M_dataplus._M_p = v54._anon_0._M_local_buf;
    v48 = v19;
    std::string::_M_construct<char const*>(
      &v54,
      String->_M_dataplus._M_p,
      &String->_M_dataplus._M_p[M_string_length],
      v16);
    v49 = google::protobuf::DescriptorPool::Tables::AllocateString(v48, (__int64)&v54);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54._M_dataplus._M_p != &v54._anon_0 )
      operator delete(v54._M_dataplus._M_p);
    v20 = String->_M_string_length;
    v21 = v17 + 1;
    v22 = *(std::vector<std::string*> **)(a1 + 32);
    if ( v21 > v20 )
      std::__throw_out_of_range_fmt(
        "%s: __pos (which is %zu) > this->size() (which is %zu)",
        "basic_string::substr",
        v21,
        v20);
    v23 = String->_M_string_length;
    v54._M_dataplus._M_p = v54._anon_0._M_local_buf;
    if ( v21 > v23 )
      std::__throw_out_of_range_fmt(
        "%s: __pos (which is %zu) > this->size() (which is %zu)",
        "basic_string::basic_string",
        v21,
        v23);
    v51 = v22;
    std::string::_M_construct<char const*>(
      &v54,
      &String->_M_dataplus._M_p[v21],
      &String->_M_dataplus._M_p[v23],
      (std::forward_iterator_tag)v20);
    v52 = google::protobuf::DescriptorPool::Tables::AllocateString(v51, (__int64)&v54);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54._M_dataplus._M_p != &v54._anon_0 )
      operator delete(v54._M_dataplus._M_p);
  }
  v54._M_dataplus._M_p = v54._anon_0._M_local_buf;
  std::string::_M_construct<char *>(
    &v54,
    String->_M_dataplus._M_p,
    &String->_M_dataplus._M_p[String->_M_string_length],
    v16);
  if ( 0x3FFFFFFFFFFFFFFFLL - v54._M_string_length <= 0x11 )
    std::__throw_length_error("basic_string::append");
  std::string::_M_append(&v54, ".placeholder.proto", 18LL);
  v24 = google::protobuf::DescriptorPool::NewPlaceholderFileWithMutexHeld(a1, &v54);
  v25 = v24;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v54._M_dataplus._M_p != &v54._anon_0 )
  {
    v53 = v24;
    operator delete(v54._M_dataplus._M_p);
    v25 = v53;
  }
  v26 = *(google::protobuf::DescriptorPool::Tables **)(a1 + 32);
  *(_QWORD *)(v25 + 8) = v49;
  if ( a3 == 1 )
  {
    *(_DWORD *)(v25 + 48) = 1;
    v47 = v25;
    Bytes = (char *)google::protobuf::DescriptorPool::Tables::AllocateBytes(v26, 56);
    *(_QWORD *)(v47 + 112) = Bytes;
    *(_OWORD *)(Bytes + 24) = 0LL;
    *(_OWORD *)(Bytes + 40) = 0LL;
    *((_QWORD *)Bytes + 1) = String;
    *((_QWORD *)Bytes + 2) = v47;
    *(_QWORD *)Bytes = v52;
    v32 = google::protobuf::EnumOptions::default_instance((google::protobuf::EnumOptions *)v26);
    Bytes[40] = 1;
    v33 = *(google::protobuf::DescriptorPool::Tables **)(a1 + 32);
    *((_QWORD *)Bytes + 4) = v32;
    v34 = **a2 == 46;
    *((_DWORD *)Bytes + 11) = 1;
    Bytes[41] = !v34;
    v35 = (std::string **)google::protobuf::DescriptorPool::Tables::AllocateBytes(v33, 40);
    *((_QWORD *)Bytes + 6) = v35;
    v36 = v35;
    v35[4] = 0LL;
    *(_OWORD *)v35 = 0LL;
    *((_OWORD *)v35 + 1) = 0LL;
    v37 = *(std::vector<std::string*> **)(a1 + 32);
    v54._M_dataplus._M_p = v54._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&v54, "PLACEHOLDER_VALUE", "", v38);
    v39 = google::protobuf::DescriptorPool::Tables::AllocateString(v37, (__int64)&v54);
    M_p = (std::string *)v54._M_dataplus._M_p;
    *v36 = v39;
    if ( M_p != (std::string *)&v54._anon_0 )
      operator delete(M_p);
    v42 = v49->_M_string_length;
    if ( v42 )
    {
      v44 = *(std::vector<std::string*> **)(a1 + 32);
      v54._M_dataplus._M_p = v54._anon_0._M_local_buf;
      std::string::_M_construct<char *>(&v54, v49->_M_dataplus._M_p, &v49->_M_dataplus._M_p[v42], v40);
      if ( 0x3FFFFFFFFFFFFFFFLL - v54._M_string_length <= 0x11 )
        std::__throw_length_error("basic_string::append");
      std::string::_M_append(&v54, ".PLACEHOLDER_VALUE", 18LL);
      v45 = google::protobuf::DescriptorPool::Tables::AllocateString(v44, (__int64)&v54);
      M_p = (std::string *)v54._M_dataplus._M_p;
      v36[1] = v45;
      if ( M_p != (std::string *)&v54._anon_0 )
        operator delete(M_p);
    }
    else
    {
      v36[1] = *v36;
    }
    v36[3] = (std::string *)Bytes;
    *((_DWORD *)v36 + 4) = 0;
    v36[4] = (std::string *)google::protobuf::EnumValueOptions::default_instance((google::protobuf::EnumValueOptions *)M_p);
    return 4LL;
  }
  else
  {
    *(_DWORD *)(v25 + 44) = 1;
    v50 = v25;
    v27 = google::protobuf::DescriptorPool::Tables::AllocateBytes(v26, 144);
    v28 = (char *)((unsigned __int64)(v27 + 4) & 0xFFFFFFFFFFFFFFF8LL);
    *(_QWORD *)(v50 + 104) = v27;
    v27[3] = 0LL;
    v27[17] = 0LL;
    v29 = (unsigned int)((_DWORD)v27 - (_DWORD)v28 + 144) >> 3;
    memset(v28, 0, 8LL * v29);
    v27[1] = String;
    v27[2] = v50;
    *v27 = v52;
    v30 = google::protobuf::MessageOptions::default_instance((google::protobuf::MessageOptions *)&v28[8 * v29]);
    *((_BYTE *)v27 + 136) = 1;
    v27[4] = v30;
    *((_BYTE *)v27 + 137) = **a2 != 46;
    if ( a3 == 2 )
    {
      *((_DWORD *)v27 + 30) = 1;
      v43 = google::protobuf::DescriptorPool::Tables::AllocateBytes(
              *(google::protobuf::DescriptorPool::Tables *const *)(a1 + 32),
              16);
      v27[9] = v43;
      *v43 = 0x2000000000000001LL;
    }
    return 1LL;
  }
};

// Line 3817: range 000000000C8FE300-000000000C8FE342
__int64 __fastcall google::protobuf::DescriptorPool::NewPlaceholderFile(
        google::protobuf::internal::Mutex **a1,
        __int64 a2)
{
  google::protobuf::internal::Mutex *v2; // r12
  __int64 v3; // r13

  v2 = *a1;
  if ( *a1 )
    google::protobuf::internal::Mutex::Lock(*a1);
  v3 = google::protobuf::DescriptorPool::NewPlaceholderFileWithMutexHeld(a1, a2);
  if ( v2 )
    google::protobuf::internal::Mutex::Unlock(v2);
  return v3;
};

// Line 3823: range 000000000C8FE1A0-000000000C8FE2F6
google::protobuf::FileDescriptor *__fastcall google::protobuf::DescriptorPool::NewPlaceholderFileWithMutexHeld(
        const google::protobuf::DescriptorPool *a1,
        __int64 a2)
{
  google::protobuf::internal::Mutex *mutex; // rdi
  google::protobuf::FileDescriptor *v4; // rax
  google::protobuf::FileDescriptor *v5; // r12
  std::vector<std::string*> *ptr; // rdi
  __int64 v7; // rax
  google::protobuf::internal::FunctionClosure0 v9[2]; // [rsp+0h] [rbp-38h] BYREF

  mutex = a1->mutex_;
  if ( mutex )
    google::protobuf::internal::Mutex::AssertHeld(mutex);
  v4 = google::protobuf::DescriptorPool::Tables::Allocate<google::protobuf::FileDescriptor>(a1->tables_.ptr_);
  v4->name_ = 0LL;
  v5 = v4;
  v4->source_code_info_ = 0LL;
  memset(
    (void *)((unsigned __int64)&v4->package_ & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v4 - (((_DWORD)v4 + 8) & 0xFFFFFFF8) + 160) >> 3));
  ptr = (std::vector<std::string*> *)a1->tables_.ptr_;
  v4->name_ = google::protobuf::DescriptorPool::Tables::AllocateString(ptr, a2);
  if ( google::protobuf::internal::empty_string_once_init_ != 2 )
  {
    v9[0]._vptr_Closure = (int (**)(...))off_1A16E058;
    v9[0].self_deleting_ = 0;
    v9[0].function_ = google::protobuf::internal::InitEmptyString;
    google::protobuf::GoogleOnceInitImpl(&google::protobuf::internal::empty_string_once_init_, &v9[0]);
    ptr = (std::vector<std::string*> *)v9;
    google::protobuf::internal::FunctionClosure0::~FunctionClosure0(v9);
  }
  v5->package_ = (const std::string *)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11];
  v5->pool_ = a1;
  v5->options_ = (const google::protobuf::FileOptions *)google::protobuf::FileOptions::default_instance((google::protobuf::FileOptions *)ptr);
  if ( google::protobuf::`anonymous namespace'::file_descriptor_tables_once_init_ != 2 )
  {
    v9[0]._vptr_Closure = (int (**)(...))off_1A16E058;
    v9[0].self_deleting_ = 0;
    v9[0].function_ = (google::protobuf::internal::FunctionClosure0::FunctionType)google::protobuf::`anonymous namespace'::InitFileDescriptorTables;
    google::protobuf::GoogleOnceInitImpl(
      &google::protobuf::`anonymous namespace'::file_descriptor_tables_once_init_,
      &v9[0]);
    ptr = (std::vector<std::string*> *)v9;
    google::protobuf::internal::FunctionClosure0::~FunctionClosure0(v9);
  }
  v5->tables_ = google::protobuf::`anonymous namespace'::file_descriptor_tables_;
  v7 = google::protobuf::SourceCodeInfo::default_instance((google::protobuf::SourceCodeInfo *)ptr);
  v5->syntax_ = SYNTAX_PROTO2;
  v5->source_code_info_ = (const google::protobuf::SourceCodeInfo *)v7;
  *(_WORD *)&v5->is_placeholder_ = 257;
  return v5;
};

// Line 3846: range 000000000C904080-000000000C9049C5
__int64 __fastcall google::protobuf::DescriptorBuilder::AddSymbol(
        __int64 a1,
        std::string *a2,
        __int64 a3,
        const char **a4,
        __int64 a5,
        __int64 a6,
        __int128 a7)
{
  __int64 v10; // rbx
  unsigned int v11; // r13d
  const char *v12; // rax
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *v13; // rdi
  unsigned int v14; // edx
  std::string::pointer M_p; // rdx
  __int64 v17; // rsi
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v18; // rcx
  __int64 i; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v20; // rax
  std::__detail::_Hash_node_base *v21; // rdx
  std::__detail::_Hash_node_base *M_nxt; // rax
  const google::protobuf::Descriptor *descriptor; // rdx
  __int64 *file; // rcx
  __int64 v25; // rbx
  __int64 v26; // rax
  const char *v27; // rsi
  __int64 v28; // rax
  __int64 v29; // rax
  std::string::pointer v30; // rdi
  unsigned __int64 v31; // rax
  std::forward_iterator_tag v32; // cl
  unsigned __int64 M_string_length; // rdx
  const char *v34; // rsi
  unsigned __int64 v35; // rbx
  std::forward_iterator_tag v36; // cl
  std::string::size_type v37; // rdx
  std::string::pointer v38; // rsi
  __int64 v39; // rax
  __int64 v40; // rcx
  __int64 v41; // rax
  std::string *v42; // r9
  std::string::size_type v43; // rax
  std::string::size_type M_allocated_capacity; // rdi
  std::string::size_type v45; // rcx
  __int64 v46; // rax
  __int64 v47; // rax
  google::protobuf::internal::LogMessage_0 *v48; // rax
  google::protobuf::internal::LogMessage_0 *v49; // rax
  google::protobuf::internal::LogMessage_0 *v50; // rax
  __int64 v51; // rax
  std::string v53; // [rsp+10h] [rbp-118h] BYREF
  void *v54; // [rsp+30h] [rbp-F8h] BYREF
  __int64 v55; // [rsp+38h] [rbp-F0h]
  __m128i v56; // [rsp+40h] [rbp-E8h] BYREF
  std::string v57; // [rsp+50h] [rbp-D8h] BYREF
  std::string v58; // [rsp+70h] [rbp-B8h] BYREF
  std::string v59; // [rsp+90h] [rbp-98h] BYREF
  google::protobuf::internal::LogMessage_0 __k[2]; // [rsp+B0h] [rbp-78h] BYREF

  v10 = a3;
  if ( !a3 )
    v10 = *(_QWORD *)(a1 + 88);
  v11 = google::protobuf::DescriptorPool::Tables::AddSymbol(
          *(_QWORD *)(a1 + 8),
          (const char **)&a2->_M_dataplus._M_p,
          a7,
          *((__int64 *)&a7 + 1));
  if ( (_BYTE)v11 )
  {
    v12 = *a4;
    *(_QWORD *)&__k[0].level_ = v10;
    v13 = *(std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > **)(a1 + 96);
    __k[0].filename_ = v12;
    *(_OWORD *)&__k[0].line_ = a7;
    std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,true>>>>(
      v13,
      (std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *)__k);
    v11 = v14;
    if ( !(_BYTE)v14 && !*(_BYTE *)(a1 + 48) )
    {
      google::protobuf::internal::LogMessage::LogMessage(__k, LOGLEVEL_ERROR_0, "google/protobuf/descriptor.cc", 3856);
      v48 = google::protobuf::internal::LogMessage::operator<<(__k, "\"");
      v49 = google::protobuf::internal::LogMessage::operator<<(v48, a2);
      v50 = google::protobuf::internal::LogMessage::operator<<(
              v49,
              "\" not previously defined in symbols_by_name_, but was defined in symbols_by_parent_; this shouldn't be possible.");
      google::protobuf::internal::LogFinisher::operator=((google::protobuf::internal::LogFinisher *const)&v59, v50);
      v11 = 0;
      google::protobuf::internal::LogMessage::~LogMessage(__k);
    }
    return v11;
  }
  M_p = a2->_M_dataplus._M_p;
  v17 = *(_QWORD *)(a1 + 8);
  v18 = 0LL;
  *(_QWORD *)&__k[0].level_ = M_p;
  for ( i = *M_p; (_BYTE)i; i = *M_p )
  {
    ++M_p;
    v18 = i + 5 * v18;
  }
  v20 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
          (const std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *const)(v17 + 312),
          v18 % *(_QWORD *)(v17 + 320),
          (const std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *)__k,
          v18);
  if ( v20 && (v21 = v20->_M_nxt) != 0LL )
  {
    M_nxt = v21[2]._M_nxt;
    descriptor = (const google::protobuf::Descriptor *)v21[3]._M_nxt;
  }
  else
  {
    LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
    descriptor = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.descriptor;
  }
  file = (__int64 *)descriptor;
  switch ( (int)M_nxt )
  {
    case 1:
    case 4:
    case 6:
      file = (__int64 *)descriptor->file_;
      break;
    case 2:
      file = (__int64 *)descriptor->fields_;
      break;
    case 3:
    case 7:
      file = (__int64 *)descriptor->file_->pool_;
      break;
    case 5:
      file = (__int64 *)descriptor->containing_type_->file_;
      break;
    case 8:
      break;
    default:
      file = 0LL;
      break;
  }
  if ( *(__int64 **)(a1 + 88) == file )
  {
    v31 = std::string::rfind(a2, 46LL, -1LL);
    if ( v31 == -1LL )
    {
      std::operator+<char>(&v59, "\"", a2);
      if ( 0x3FFFFFFFFFFFFFFFLL - v59._M_string_length <= 0x14 )
        std::__throw_length_error("basic_string::append");
      v51 = std::string::_M_append(&v59, "\" is already defined.", 21LL);
      *(_QWORD *)&__k[0].level_ = &__k[0].line_;
      if ( *(_QWORD *)v51 == v51 + 16 )
      {
        *(__m128i *)&__k[0].line_ = _mm_loadu_si128((const __m128i *)(v51 + 16));
      }
      else
      {
        *(_QWORD *)&__k[0].level_ = *(_QWORD *)v51;
        *(_QWORD *)&__k[0].line_ = *(_QWORD *)(v51 + 16);
      }
      __k[0].filename_ = *(const char **)(v51 + 8);
      *(_QWORD *)v51 = v51 + 16;
      *(_QWORD *)(v51 + 8) = 0LL;
      *(_BYTE *)(v51 + 16) = 0;
      google::protobuf::DescriptorBuilder::AddError(a1, a2, a5, 0, (const std::string *)__k);
      if ( *(google::protobuf::internal::LogMessage_0 **)&__k[0].level_ != (google::protobuf::internal::LogMessage_0 *)&__k[0].line_ )
        operator delete(*(void **)&__k[0].level_);
      v30 = v59._M_dataplus._M_p;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v59._M_dataplus._M_p != &v59._anon_0 )
        goto LABEL_32;
    }
    else
    {
      M_string_length = a2->_M_string_length;
      v34 = a2->_M_dataplus._M_p;
      v58._M_dataplus._M_p = v58._anon_0._M_local_buf;
      if ( v31 <= M_string_length )
        M_string_length = v31;
      v35 = v31 + 1;
      std::string::_M_construct<char const*>(&v58, v34, &v34[M_string_length], v32);
      v37 = a2->_M_string_length;
      if ( v35 > v37 )
        std::__throw_out_of_range_fmt(
          "%s: __pos (which is %zu) > this->size() (which is %zu)",
          "basic_string::substr",
          v35,
          a2->_M_string_length);
      v38 = a2->_M_dataplus._M_p;
      v53._M_dataplus._M_p = v53._anon_0._M_local_buf;
      std::string::_M_construct<char const*>(&v53, &v38[v35], &v38[v37], v36);
      v39 = std::string::_M_replace(&v53, 0LL, 0LL, "\"", 1LL);
      v54 = &v56;
      if ( *(_QWORD *)v39 == v39 + 16 )
      {
        v56 = _mm_loadu_si128((const __m128i *)(v39 + 16));
      }
      else
      {
        v54 = *(void **)v39;
        v56.m128i_i64[0] = *(_QWORD *)(v39 + 16);
      }
      v40 = *(_QWORD *)(v39 + 8);
      *(_BYTE *)(v39 + 16) = 0;
      v55 = v40;
      *(_QWORD *)(v39 + 8) = 0LL;
      *(_QWORD *)v39 = v39 + 16;
      if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v55) <= 0x18 )
        std::__throw_length_error("basic_string::append");
      v41 = std::string::_M_append(&v54, "\" is already defined in \"", 25LL);
      v57._M_dataplus._M_p = v57._anon_0._M_local_buf;
      if ( *(_QWORD *)v41 == v41 + 16 )
      {
        v57._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v41 + 16));
      }
      else
      {
        v57._M_dataplus._M_p = *(std::string::pointer *)v41;
        v57._anon_0._M_allocated_capacity = *(_QWORD *)(v41 + 16);
      }
      v57._M_string_length = *(_QWORD *)(v41 + 8);
      *(_BYTE *)(v41 + 16) = 0;
      *(_QWORD *)v41 = v41 + 16;
      v42 = (std::string *)v57._M_dataplus._M_p;
      *(_QWORD *)(v41 + 8) = 0LL;
      v43 = 15LL;
      M_allocated_capacity = 15LL;
      if ( v42 != (std::string *)&v57._anon_0 )
        M_allocated_capacity = v57._anon_0._M_allocated_capacity;
      v45 = v57._M_string_length + v58._M_string_length;
      if ( v57._M_string_length + v58._M_string_length <= M_allocated_capacity )
        goto LABEL_48;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v58._M_dataplus._M_p != &v58._anon_0 )
        v43 = v58._anon_0._M_allocated_capacity;
      if ( v45 <= v43 )
        v46 = std::string::_M_replace(&v58, 0LL, 0LL, (const char *)v42, v57._M_string_length);
      else
LABEL_48:
        v46 = std::string::_M_append(&v57, v58._M_dataplus._M_p, v58._M_string_length, v45, v57._M_string_length);
      v59._M_dataplus._M_p = v59._anon_0._M_local_buf;
      if ( *(_QWORD *)v46 == v46 + 16 )
      {
        v59._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v46 + 16));
      }
      else
      {
        v59._M_dataplus._M_p = *(std::string::pointer *)v46;
        v59._anon_0._M_allocated_capacity = *(_QWORD *)(v46 + 16);
      }
      v59._M_string_length = *(_QWORD *)(v46 + 8);
      *(_QWORD *)(v46 + 8) = 0LL;
      *(_BYTE *)(v46 + 16) = 0;
      *(_QWORD *)v46 = v46 + 16;
      if ( v59._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v59._M_string_length == 4611686018427387902LL )
        std::__throw_length_error("basic_string::append");
      v47 = std::string::_M_append(&v59, "\".", 2LL);
      *(_QWORD *)&__k[0].level_ = &__k[0].line_;
      if ( *(_QWORD *)v47 == v47 + 16 )
      {
        *(__m128i *)&__k[0].line_ = _mm_loadu_si128((const __m128i *)(v47 + 16));
      }
      else
      {
        *(_QWORD *)&__k[0].level_ = *(_QWORD *)v47;
        *(_QWORD *)&__k[0].line_ = *(_QWORD *)(v47 + 16);
      }
      __k[0].filename_ = *(const char **)(v47 + 8);
      *(_QWORD *)v47 = v47 + 16;
      *(_QWORD *)(v47 + 8) = 0LL;
      *(_BYTE *)(v47 + 16) = 0;
      google::protobuf::DescriptorBuilder::AddError(a1, a2, a5, 0, (const std::string *)__k);
      if ( *(google::protobuf::internal::LogMessage_0 **)&__k[0].level_ != (google::protobuf::internal::LogMessage_0 *)&__k[0].line_ )
        operator delete(*(void **)&__k[0].level_);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v59._M_dataplus._M_p != &v59._anon_0 )
        operator delete(v59._M_dataplus._M_p);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v57._M_dataplus._M_p != &v57._anon_0 )
        operator delete(v57._M_dataplus._M_p);
      if ( v54 != &v56 )
        operator delete(v54);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v53._M_dataplus._M_p != &v53._anon_0 )
        operator delete(v53._M_dataplus._M_p);
      v30 = v58._M_dataplus._M_p;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v58._M_dataplus._M_p != &v58._anon_0 )
        goto LABEL_32;
    }
  }
  else
  {
    v25 = *file;
    std::operator+<char>(&v57, "\"", a2);
    if ( 0x3FFFFFFFFFFFFFFFLL - v57._M_string_length <= 0x1D )
      std::__throw_length_error("basic_string::append");
    v26 = std::string::_M_append(&v57, "\" is already defined in file \"", 30LL);
    v58._M_dataplus._M_p = v58._anon_0._M_local_buf;
    if ( *(_QWORD *)v26 == v26 + 16 )
    {
      v58._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v26 + 16));
    }
    else
    {
      v58._M_dataplus._M_p = *(std::string::pointer *)v26;
      v58._anon_0._M_allocated_capacity = *(_QWORD *)(v26 + 16);
    }
    v58._M_string_length = *(_QWORD *)(v26 + 8);
    *(_QWORD *)v26 = v26 + 16;
    *(_BYTE *)(v26 + 16) = 0;
    v27 = *(const char **)v25;
    *(_QWORD *)(v26 + 8) = 0LL;
    v28 = std::string::_M_append(&v58, v27, *(_QWORD *)(v25 + 8));
    v59._M_dataplus._M_p = v59._anon_0._M_local_buf;
    if ( *(_QWORD *)v28 == v28 + 16 )
    {
      v59._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v28 + 16));
    }
    else
    {
      v59._M_dataplus._M_p = *(std::string::pointer *)v28;
      v59._anon_0._M_allocated_capacity = *(_QWORD *)(v28 + 16);
    }
    v59._M_string_length = *(_QWORD *)(v28 + 8);
    *(_QWORD *)(v28 + 8) = 0LL;
    *(_BYTE *)(v28 + 16) = 0;
    *(_QWORD *)v28 = v28 + 16;
    if ( v59._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v59._M_string_length == 4611686018427387902LL )
      std::__throw_length_error("basic_string::append");
    v29 = std::string::_M_append(&v59, "\".", 2LL);
    *(_QWORD *)&__k[0].level_ = &__k[0].line_;
    if ( *(_QWORD *)v29 == v29 + 16 )
    {
      *(__m128i *)&__k[0].line_ = _mm_loadu_si128((const __m128i *)(v29 + 16));
    }
    else
    {
      *(_QWORD *)&__k[0].level_ = *(_QWORD *)v29;
      *(_QWORD *)&__k[0].line_ = *(_QWORD *)(v29 + 16);
    }
    __k[0].filename_ = *(const char **)(v29 + 8);
    *(_QWORD *)v29 = v29 + 16;
    *(_QWORD *)(v29 + 8) = 0LL;
    *(_BYTE *)(v29 + 16) = 0;
    google::protobuf::DescriptorBuilder::AddError(a1, a2, a5, 0, (const std::string *)__k);
    if ( *(google::protobuf::internal::LogMessage_0 **)&__k[0].level_ != (google::protobuf::internal::LogMessage_0 *)&__k[0].line_ )
      operator delete(*(void **)&__k[0].level_);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v59._M_dataplus._M_p != &v59._anon_0 )
      operator delete(v59._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v58._M_dataplus._M_p != &v58._anon_0 )
      operator delete(v58._M_dataplus._M_p);
    v30 = v57._M_dataplus._M_p;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v57._M_dataplus._M_p != &v57._anon_0 )
LABEL_32:
      operator delete(v30);
  }
  return v11;
};

// Line 3887: range 000000000C903C30-000000000C904073
void __fastcall google::protobuf::DescriptorBuilder::AddPackage(__int64 a1, std::string *a2, __int64 a3, __int64 a4)
{
  std::forward_iterator_tag v7; // cl
  unsigned __int64 M_string_length; // rdx
  const char *M_p; // rsi
  std::vector<std::string*> *v10; // r8
  std::string *String; // rax
  std::string *v12; // rsi
  std::forward_iterator_tag v13; // cl
  unsigned __int64 v14; // rdx
  std::string::pointer v15; // rsi
  char *v16; // rdx
  __int64 v17; // rsi
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__hash_code v18; // rcx
  __int64 i; // rax
  std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::__node_base *v20; // rax
  std::__detail::_Hash_node_base *v21; // rdx
  std::__detail::_Hash_node_base *M_nxt; // rax
  const google::protobuf::Descriptor *descriptor; // rdx
  __int64 *file; // rax
  __int64 v25; // rbx
  __int64 v26; // rax
  void *v27; // rcx
  const char *v28; // rsi
  __int64 v29; // rax
  __int64 v30; // rcx
  __int64 v31; // rax
  unsigned __int64 v32; // [rsp+0h] [rbp-C8h]
  std::vector<std::string*> *v33; // [rsp+8h] [rbp-C0h]
  std::string *v34; // [rsp+8h] [rbp-C0h]
  std::string v35; // [rsp+10h] [rbp-B8h] BYREF
  void *v36[2]; // [rsp+30h] [rbp-98h] BYREF
  __m128i v37; // [rsp+40h] [rbp-88h] BYREF
  void *v38; // [rsp+50h] [rbp-78h] BYREF
  __int64 v39; // [rsp+58h] [rbp-70h]
  __m128i v40; // [rsp+60h] [rbp-68h] BYREF
  std::string v41; // [rsp+70h] [rbp-58h] BYREF

  if ( (unsigned __int8)google::protobuf::DescriptorPool::Tables::AddSymbol(
                          *(_QWORD *)(a1 + 8),
                          (const char **)&a2->_M_dataplus._M_p,
                          8u,
                          a4) )
  {
    v32 = std::string::rfind(a2, 46LL, -1LL);
    if ( v32 == -1LL )
    {
      google::protobuf::DescriptorBuilder::ValidateSymbolName(a1, a2, a2, a3);
    }
    else
    {
      M_string_length = a2->_M_string_length;
      M_p = a2->_M_dataplus._M_p;
      v10 = *(std::vector<std::string*> **)(a1 + 8);
      v41._M_dataplus._M_p = v41._anon_0._M_local_buf;
      if ( v32 <= M_string_length )
        M_string_length = v32;
      v33 = v10;
      std::string::_M_construct<char const*>(&v41, M_p, &M_p[M_string_length], v7);
      String = google::protobuf::DescriptorPool::Tables::AllocateString(v33, (__int64)&v41);
      v12 = String;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v41._M_dataplus._M_p != &v41._anon_0 )
      {
        v34 = String;
        operator delete(v41._M_dataplus._M_p);
        v12 = v34;
      }
      google::protobuf::DescriptorBuilder::AddPackage(a1, v12, a3, a4);
      v14 = a2->_M_string_length;
      if ( v32 + 1 > v14 )
        std::__throw_out_of_range_fmt(
          "%s: __pos (which is %zu) > this->size() (which is %zu)",
          "basic_string::substr",
          v32 + 1,
          a2->_M_string_length);
      v15 = a2->_M_dataplus._M_p;
      v41._M_dataplus._M_p = v41._anon_0._M_local_buf;
      std::string::_M_construct<char const*>(&v41, &v15[v32 + 1], &v15[v14], v13);
      google::protobuf::DescriptorBuilder::ValidateSymbolName(a1, &v41, a2, a3);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v41._M_dataplus._M_p != &v41._anon_0 )
        operator delete(v41._M_dataplus._M_p);
    }
  }
  else
  {
    v16 = a2->_M_dataplus._M_p;
    v17 = *(_QWORD *)(a1 + 8);
    v18 = 0LL;
    v41._M_dataplus._M_p = v16;
    for ( i = *v16; (_BYTE)i; i = *v16 )
    {
      ++v16;
      v18 = i + 5 * v18;
    }
    v20 = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_find_before_node(
            (const std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> > *const)(v17 + 312),
            v18 % *(_QWORD *)(v17 + 320),
            (const std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::Symbol>,std::allocator<std::pair<char const* const,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *)&v41._M_dataplus._M_p,
            v18);
    if ( v20 && (v21 = v20->_M_nxt) != 0LL )
    {
      M_nxt = v21[2]._M_nxt;
      descriptor = (const google::protobuf::Descriptor *)v21[3]._M_nxt;
      if ( (_DWORD)M_nxt == 8 )
        return;
    }
    else
    {
      LODWORD(M_nxt) = google::protobuf::`anonymous namespace'::kNullSymbol.type;
      descriptor = google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.descriptor;
      if ( google::protobuf::`anonymous namespace'::kNullSymbol.type == PACKAGE )
        return;
    }
    switch ( (int)M_nxt )
    {
      case 1:
      case 4:
      case 6:
        file = (__int64 *)descriptor->file_;
        break;
      case 2:
        file = (__int64 *)descriptor->fields_;
        break;
      case 3:
      case 7:
        file = (__int64 *)descriptor->file_->pool_;
        break;
      case 5:
        file = (__int64 *)descriptor->containing_type_->file_;
        break;
      default:
        BUG();
    }
    v25 = *file;
    std::operator+<char>(&v35, "\"", a2);
    if ( 0x3FFFFFFFFFFFFFFFLL - v35._M_string_length <= 0x41 )
      std::__throw_length_error("basic_string::append");
    v26 = std::string::_M_append(&v35, "\" is already defined (as something other than a package) in file \"", 66LL);
    v36[0] = &v37;
    if ( *(_QWORD *)v26 == v26 + 16 )
    {
      v37 = _mm_loadu_si128((const __m128i *)(v26 + 16));
    }
    else
    {
      v36[0] = *(void **)v26;
      v37.m128i_i64[0] = *(_QWORD *)(v26 + 16);
    }
    v27 = *(void **)(v26 + 8);
    *(_BYTE *)(v26 + 16) = 0;
    v36[1] = v27;
    *(_QWORD *)v26 = v26 + 16;
    v28 = *(const char **)v25;
    *(_QWORD *)(v26 + 8) = 0LL;
    v29 = std::string::_M_append(v36, v28, *(_QWORD *)(v25 + 8));
    v38 = &v40;
    if ( *(_QWORD *)v29 == v29 + 16 )
    {
      v40 = _mm_loadu_si128((const __m128i *)(v29 + 16));
    }
    else
    {
      v38 = *(void **)v29;
      v40.m128i_i64[0] = *(_QWORD *)(v29 + 16);
    }
    v30 = *(_QWORD *)(v29 + 8);
    *(_BYTE *)(v29 + 16) = 0;
    v39 = v30;
    *(_QWORD *)(v29 + 8) = 0LL;
    *(_QWORD *)v29 = v29 + 16;
    if ( v39 == 0x3FFFFFFFFFFFFFFFLL || v39 == 4611686018427387902LL )
      std::__throw_length_error("basic_string::append");
    v31 = std::string::_M_append(&v38, "\".", 2LL);
    v41._M_dataplus._M_p = v41._anon_0._M_local_buf;
    if ( *(_QWORD *)v31 == v31 + 16 )
    {
      v41._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v31 + 16));
    }
    else
    {
      v41._M_dataplus._M_p = *(std::string::pointer *)v31;
      v41._anon_0._M_allocated_capacity = *(_QWORD *)(v31 + 16);
    }
    v41._M_string_length = *(_QWORD *)(v31 + 8);
    *(_QWORD *)v31 = v31 + 16;
    *(_QWORD *)(v31 + 8) = 0LL;
    *(_BYTE *)(v31 + 16) = 0;
    google::protobuf::DescriptorBuilder::AddError(a1, a2, a3, 0, &v41);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v41._M_dataplus._M_p != &v41._anon_0 )
      operator delete(v41._M_dataplus._M_p);
    if ( v38 != &v40 )
      operator delete(v38);
    if ( v36[0] != &v37 )
      operator delete(v36[0]);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v35._M_dataplus._M_p != &v35._anon_0 )
      operator delete(v35._M_dataplus._M_p);
  }
};

// Line 3914: range 000000000C8F9070-000000000C8F9207
void __fastcall google::protobuf::DescriptorBuilder::ValidateSymbolName(
        __int64 a1,
        const std::string *a2,
        const std::string *a3,
        __int64 a4)
{
  __int64 v6; // rbx
  __int64 v7; // rax
  std::string::size_type v8; // rcx
  char v9; // al
  std::string v10; // [rsp+0h] [rbp-78h] BYREF
  std::string v11[2]; // [rsp+20h] [rbp-58h] BYREF

  v6 = 0LL;
  if ( a2->_M_string_length )
  {
    while ( 1 )
    {
      v9 = a2->_M_dataplus._M_p[v6];
      if ( v9 > 96 )
        break;
      if ( v9 > 64 )
      {
        if ( v9 <= 90 )
          goto LABEL_11;
      }
      else if ( v9 <= 47 )
      {
        goto LABEL_4;
      }
      if ( v9 <= 57 )
      {
LABEL_11:
        if ( a2->_M_string_length <= ++v6 )
          return;
      }
      else
      {
        if ( v9 != 95 )
        {
LABEL_4:
          std::operator+<char>(&v10, "\"", a2);
          if ( 0x3FFFFFFFFFFFFFFFLL - v10._M_string_length <= 0x1B )
            std::__throw_length_error("basic_string::append");
          v7 = std::string::_M_append(&v10, "\" is not a valid identifier.", 28LL);
          v11[0]._M_dataplus._M_p = v11[0]._anon_0._M_local_buf;
          if ( *(_QWORD *)v7 == v7 + 16 )
          {
            v11[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v7 + 16));
          }
          else
          {
            v11[0]._M_dataplus._M_p = *(std::string::pointer *)v7;
            v11[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v7 + 16);
          }
          v8 = *(_QWORD *)(v7 + 8);
          *(_BYTE *)(v7 + 16) = 0;
          v11[0]._M_string_length = v8;
          *(_QWORD *)v7 = v7 + 16;
          *(_QWORD *)(v7 + 8) = 0LL;
          google::protobuf::DescriptorBuilder::AddError(a1, a3, a4, 0, v11);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v11[0]._M_dataplus._M_p != &v11[0]._anon_0 )
            operator delete(v11[0]._M_dataplus._M_p);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v10._M_dataplus._M_p != &v10._anon_0 )
            operator delete(v10._M_dataplus._M_p);
          goto LABEL_11;
        }
        if ( a2->_M_string_length <= ++v6 )
          return;
      }
    }
    if ( v9 > 122 )
      goto LABEL_4;
    goto LABEL_11;
  }
  google::protobuf::DescriptorBuilder::AddError(a1, a3, a4, 0, "Missing name.");
};

// Line 3945: range 000000000C902360-000000000C902402
void __fastcall google::protobuf::DescriptorBuilder::AllocateOptions(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::FileOptions *orig_options,
        google::protobuf::FileDescriptor *descriptor,
        std::forward_iterator_tag a4)
{
  const std::string *package; // rax
  const std::string *name; // r14
  std::string::size_type M_string_length; // rdx
  std::string v8[2]; // [rsp+0h] [rbp-48h] BYREF

  package = descriptor->package_;
  name = descriptor->name_;
  M_string_length = package->_M_string_length;
  v8[0]._M_dataplus._M_p = v8[0]._anon_0._M_local_buf;
  std::string::_M_construct<char *>(v8, package->_M_dataplus._M_p, &package->_M_dataplus._M_p[M_string_length], a4);
  if ( 0x3FFFFFFFFFFFFFFFLL - v8[0]._M_string_length <= 5 )
    std::__throw_length_error("basic_string::append");
  std::string::_M_append(v8, ".dummy", 6LL);
  google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::FileDescriptor>(
    this,
    v8,
    name,
    orig_options,
    descriptor);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v8[0]._M_dataplus._M_p != &v8[0]._anon_0 )
    operator delete(v8[0]._M_dataplus._M_p);
};

// Line 3951: range 000000000C91D700-000000000C91D880
void __fastcall google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::Descriptor::ExtensionRange>(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name_scope,
        const std::string *element_name,
        const google::protobuf::Descriptor::ExtensionRange::OptionsType *orig_options,
        google::protobuf::Descriptor::ExtensionRange *descriptor)
{
  google::protobuf::DescriptorPool::Tables *tables; // r14
  google::protobuf::ExtensionRangeOptions *v9; // rbp
  google::protobuf::Message **v10; // rdx
  std::forward_iterator_tag v11; // cl
  int current_size; // eax
  char *M_p; // rsi
  std::string::size_type M_string_length; // rdx
  std::forward_iterator_tag v15; // cl
  google::protobuf::`anonymous namespace'::OptionsToInterpret *v16; // rdx
  google::protobuf::`anonymous namespace'::OptionsToInterpret v18; // [rsp+10h] [rbp-88h] BYREF

  tables = this->tables_;
  v9 = (google::protobuf::ExtensionRangeOptions *)operator new(0x68uLL);
  google::protobuf::ExtensionRangeOptions::ExtensionRangeOptions(v9);
  v18.name_scope._M_dataplus._M_p = (std::string::pointer)v9;
  std::vector<google::protobuf::Message *>::emplace_back<google::protobuf::Message *>(
    &tables->messages_,
    (google::protobuf::Message **)&v18,
    v10);
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&v18, orig_options);
  google::protobuf::MessageLite::ParseFromString(v9, &v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
    operator delete(v18.name_scope._M_dataplus._M_p);
  current_size = v9->uninterpreted_option_.current_size_;
  descriptor->options_ = v9;
  if ( current_size > 0 )
  {
    M_p = name_scope->_M_dataplus._M_p;
    M_string_length = name_scope->_M_string_length;
    v18.name_scope._M_dataplus._M_p = v18.name_scope._anon_0._M_local_buf;
    std::string::_M_construct<char *>(&v18.name_scope, M_p, &M_p[M_string_length], v11);
    v18.element_name._M_dataplus._M_p = v18.element_name._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &v18.element_name,
      element_name->_M_dataplus._M_p,
      &element_name->_M_dataplus._M_p[element_name->_M_string_length],
      v15);
    v18.original_options = orig_options;
    v18.options = v9;
    std::vector<google::protobuf::`anonymous namespace'::OptionsToInterpret>::emplace_back<google::protobuf::`anonymous namespace'::OptionsToInterpret>(
      &this->options_to_interpret_,
      &v18,
      v16);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.element_name._M_dataplus._M_p != &v18.element_name._anon_0 )
      operator delete(v18.element_name._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
      operator delete(v18.name_scope._M_dataplus._M_p);
  }
};

// Line 3951: range 000000000C91D3E0-000000000C91D560
void __fastcall google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::Descriptor>(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name_scope,
        const std::string *element_name,
        const google::protobuf::Descriptor::OptionsType *orig_options,
        google::protobuf::Descriptor *descriptor)
{
  google::protobuf::DescriptorPool::Tables *tables; // r14
  google::protobuf::MessageOptions *v9; // rbp
  google::protobuf::Message **v10; // rdx
  std::forward_iterator_tag v11; // cl
  int current_size; // eax
  char *M_p; // rsi
  std::string::size_type M_string_length; // rdx
  std::forward_iterator_tag v15; // cl
  google::protobuf::`anonymous namespace'::OptionsToInterpret *v16; // rdx
  google::protobuf::`anonymous namespace'::OptionsToInterpret v18; // [rsp+10h] [rbp-88h] BYREF

  tables = this->tables_;
  v9 = (google::protobuf::MessageOptions *)operator new(0x70uLL);
  google::protobuf::MessageOptions::MessageOptions(v9);
  v18.name_scope._M_dataplus._M_p = (std::string::pointer)v9;
  std::vector<google::protobuf::Message *>::emplace_back<google::protobuf::Message *>(
    &tables->messages_,
    (google::protobuf::Message **)&v18,
    v10);
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&v18, orig_options);
  google::protobuf::MessageLite::ParseFromString(v9, &v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
    operator delete(v18.name_scope._M_dataplus._M_p);
  current_size = v9->uninterpreted_option_.current_size_;
  descriptor->options_ = v9;
  if ( current_size > 0 )
  {
    M_p = name_scope->_M_dataplus._M_p;
    M_string_length = name_scope->_M_string_length;
    v18.name_scope._M_dataplus._M_p = v18.name_scope._anon_0._M_local_buf;
    std::string::_M_construct<char *>(&v18.name_scope, M_p, &M_p[M_string_length], v11);
    v18.element_name._M_dataplus._M_p = v18.element_name._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &v18.element_name,
      element_name->_M_dataplus._M_p,
      &element_name->_M_dataplus._M_p[element_name->_M_string_length],
      v15);
    v18.original_options = orig_options;
    v18.options = v9;
    std::vector<google::protobuf::`anonymous namespace'::OptionsToInterpret>::emplace_back<google::protobuf::`anonymous namespace'::OptionsToInterpret>(
      &this->options_to_interpret_,
      &v18,
      v16);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.element_name._M_dataplus._M_p != &v18.element_name._anon_0 )
      operator delete(v18.element_name._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
      operator delete(v18.name_scope._M_dataplus._M_p);
  }
};

// Line 3951: range 000000000C91DA20-000000000C91DBA0
void __fastcall google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::EnumDescriptor>(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name_scope,
        const std::string *element_name,
        const google::protobuf::EnumDescriptor::OptionsType *orig_options,
        google::protobuf::EnumDescriptor *descriptor)
{
  google::protobuf::DescriptorPool::Tables *tables; // r14
  google::protobuf::EnumOptions *v9; // rbp
  google::protobuf::Message **v10; // rdx
  std::forward_iterator_tag v11; // cl
  int current_size; // eax
  char *M_p; // rsi
  std::string::size_type M_string_length; // rdx
  std::forward_iterator_tag v15; // cl
  google::protobuf::`anonymous namespace'::OptionsToInterpret *v16; // rdx
  google::protobuf::`anonymous namespace'::OptionsToInterpret v18; // [rsp+10h] [rbp-88h] BYREF

  tables = this->tables_;
  v9 = (google::protobuf::EnumOptions *)operator new(0x70uLL);
  google::protobuf::EnumOptions::EnumOptions(v9);
  v18.name_scope._M_dataplus._M_p = (std::string::pointer)v9;
  std::vector<google::protobuf::Message *>::emplace_back<google::protobuf::Message *>(
    &tables->messages_,
    (google::protobuf::Message **)&v18,
    v10);
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&v18, orig_options);
  google::protobuf::MessageLite::ParseFromString(v9, &v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
    operator delete(v18.name_scope._M_dataplus._M_p);
  current_size = v9->uninterpreted_option_.current_size_;
  descriptor->options_ = v9;
  if ( current_size > 0 )
  {
    M_p = name_scope->_M_dataplus._M_p;
    M_string_length = name_scope->_M_string_length;
    v18.name_scope._M_dataplus._M_p = v18.name_scope._anon_0._M_local_buf;
    std::string::_M_construct<char *>(&v18.name_scope, M_p, &M_p[M_string_length], v11);
    v18.element_name._M_dataplus._M_p = v18.element_name._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &v18.element_name,
      element_name->_M_dataplus._M_p,
      &element_name->_M_dataplus._M_p[element_name->_M_string_length],
      v15);
    v18.original_options = orig_options;
    v18.options = v9;
    std::vector<google::protobuf::`anonymous namespace'::OptionsToInterpret>::emplace_back<google::protobuf::`anonymous namespace'::OptionsToInterpret>(
      &this->options_to_interpret_,
      &v18,
      v16);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.element_name._M_dataplus._M_p != &v18.element_name._anon_0 )
      operator delete(v18.element_name._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
      operator delete(v18.name_scope._M_dataplus._M_p);
  }
};

// Line 3951: range 000000000C91DBB0-000000000C91DD30
void __fastcall google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::EnumValueDescriptor>(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name_scope,
        const std::string *element_name,
        const google::protobuf::EnumValueDescriptor::OptionsType *orig_options,
        google::protobuf::EnumValueDescriptor *descriptor)
{
  google::protobuf::DescriptorPool::Tables *tables; // r14
  google::protobuf::EnumValueOptions *v9; // rbp
  google::protobuf::Message **v10; // rdx
  std::forward_iterator_tag v11; // cl
  int current_size; // eax
  char *M_p; // rsi
  std::string::size_type M_string_length; // rdx
  std::forward_iterator_tag v15; // cl
  google::protobuf::`anonymous namespace'::OptionsToInterpret *v16; // rdx
  google::protobuf::`anonymous namespace'::OptionsToInterpret v18; // [rsp+10h] [rbp-88h] BYREF

  tables = this->tables_;
  v9 = (google::protobuf::EnumValueOptions *)operator new(0x70uLL);
  google::protobuf::EnumValueOptions::EnumValueOptions(v9);
  v18.name_scope._M_dataplus._M_p = (std::string::pointer)v9;
  std::vector<google::protobuf::Message *>::emplace_back<google::protobuf::Message *>(
    &tables->messages_,
    (google::protobuf::Message **)&v18,
    v10);
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&v18, orig_options);
  google::protobuf::MessageLite::ParseFromString(v9, &v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
    operator delete(v18.name_scope._M_dataplus._M_p);
  current_size = v9->uninterpreted_option_.current_size_;
  descriptor->options_ = v9;
  if ( current_size > 0 )
  {
    M_p = name_scope->_M_dataplus._M_p;
    M_string_length = name_scope->_M_string_length;
    v18.name_scope._M_dataplus._M_p = v18.name_scope._anon_0._M_local_buf;
    std::string::_M_construct<char *>(&v18.name_scope, M_p, &M_p[M_string_length], v11);
    v18.element_name._M_dataplus._M_p = v18.element_name._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &v18.element_name,
      element_name->_M_dataplus._M_p,
      &element_name->_M_dataplus._M_p[element_name->_M_string_length],
      v15);
    v18.original_options = orig_options;
    v18.options = v9;
    std::vector<google::protobuf::`anonymous namespace'::OptionsToInterpret>::emplace_back<google::protobuf::`anonymous namespace'::OptionsToInterpret>(
      &this->options_to_interpret_,
      &v18,
      v16);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.element_name._M_dataplus._M_p != &v18.element_name._anon_0 )
      operator delete(v18.element_name._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
      operator delete(v18.name_scope._M_dataplus._M_p);
  }
};

// Line 3951: range 000000000C91D570-000000000C91D6F0
void __fastcall google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::FieldDescriptor>(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name_scope,
        const std::string *element_name,
        const google::protobuf::FieldDescriptor::OptionsType *orig_options,
        google::protobuf::FieldDescriptor *descriptor)
{
  google::protobuf::DescriptorPool::Tables *tables; // r14
  google::protobuf::FieldOptions *v9; // rbp
  google::protobuf::Message **v10; // rdx
  std::forward_iterator_tag v11; // cl
  int current_size; // eax
  char *M_p; // rsi
  std::string::size_type M_string_length; // rdx
  std::forward_iterator_tag v15; // cl
  google::protobuf::`anonymous namespace'::OptionsToInterpret *v16; // rdx
  google::protobuf::`anonymous namespace'::OptionsToInterpret v18; // [rsp+10h] [rbp-88h] BYREF

  tables = this->tables_;
  v9 = (google::protobuf::FieldOptions *)operator new(0x78uLL);
  google::protobuf::FieldOptions::FieldOptions(v9);
  v18.name_scope._M_dataplus._M_p = (std::string::pointer)v9;
  std::vector<google::protobuf::Message *>::emplace_back<google::protobuf::Message *>(
    &tables->messages_,
    (google::protobuf::Message **)&v18,
    v10);
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&v18, orig_options);
  google::protobuf::MessageLite::ParseFromString(v9, &v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
    operator delete(v18.name_scope._M_dataplus._M_p);
  current_size = v9->uninterpreted_option_.current_size_;
  descriptor->options_ = v9;
  if ( current_size > 0 )
  {
    M_p = name_scope->_M_dataplus._M_p;
    M_string_length = name_scope->_M_string_length;
    v18.name_scope._M_dataplus._M_p = v18.name_scope._anon_0._M_local_buf;
    std::string::_M_construct<char *>(&v18.name_scope, M_p, &M_p[M_string_length], v11);
    v18.element_name._M_dataplus._M_p = v18.element_name._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &v18.element_name,
      element_name->_M_dataplus._M_p,
      &element_name->_M_dataplus._M_p[element_name->_M_string_length],
      v15);
    v18.original_options = orig_options;
    v18.options = v9;
    std::vector<google::protobuf::`anonymous namespace'::OptionsToInterpret>::emplace_back<google::protobuf::`anonymous namespace'::OptionsToInterpret>(
      &this->options_to_interpret_,
      &v18,
      v16);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.element_name._M_dataplus._M_p != &v18.element_name._anon_0 )
      operator delete(v18.element_name._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
      operator delete(v18.name_scope._M_dataplus._M_p);
  }
};

// Line 3951: range 000000000C91D250-000000000C91D3D0
void __fastcall google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::FileDescriptor>(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name_scope,
        const std::string *element_name,
        const google::protobuf::FileDescriptor::OptionsType *orig_options,
        google::protobuf::FileDescriptor *descriptor)
{
  google::protobuf::DescriptorPool::Tables *tables; // r14
  google::protobuf::FileOptions *v9; // rbp
  google::protobuf::Message **v10; // rdx
  std::forward_iterator_tag v11; // cl
  int current_size; // eax
  char *M_p; // rsi
  std::string::size_type M_string_length; // rdx
  std::forward_iterator_tag v15; // cl
  google::protobuf::`anonymous namespace'::OptionsToInterpret *v16; // rdx
  google::protobuf::`anonymous namespace'::OptionsToInterpret v18; // [rsp+10h] [rbp-88h] BYREF

  tables = this->tables_;
  v9 = (google::protobuf::FileOptions *)operator new(0xB8uLL);
  google::protobuf::FileOptions::FileOptions(v9);
  v18.name_scope._M_dataplus._M_p = (std::string::pointer)v9;
  std::vector<google::protobuf::Message *>::emplace_back<google::protobuf::Message *>(
    &tables->messages_,
    (google::protobuf::Message **)&v18,
    v10);
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&v18, orig_options);
  google::protobuf::MessageLite::ParseFromString(v9, &v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
    operator delete(v18.name_scope._M_dataplus._M_p);
  current_size = v9->uninterpreted_option_.current_size_;
  descriptor->options_ = v9;
  if ( current_size > 0 )
  {
    M_p = name_scope->_M_dataplus._M_p;
    M_string_length = name_scope->_M_string_length;
    v18.name_scope._M_dataplus._M_p = v18.name_scope._anon_0._M_local_buf;
    std::string::_M_construct<char *>(&v18.name_scope, M_p, &M_p[M_string_length], v11);
    v18.element_name._M_dataplus._M_p = v18.element_name._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &v18.element_name,
      element_name->_M_dataplus._M_p,
      &element_name->_M_dataplus._M_p[element_name->_M_string_length],
      v15);
    v18.original_options = orig_options;
    v18.options = v9;
    std::vector<google::protobuf::`anonymous namespace'::OptionsToInterpret>::emplace_back<google::protobuf::`anonymous namespace'::OptionsToInterpret>(
      &this->options_to_interpret_,
      &v18,
      v16);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.element_name._M_dataplus._M_p != &v18.element_name._anon_0 )
      operator delete(v18.element_name._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
      operator delete(v18.name_scope._M_dataplus._M_p);
  }
};

// Line 3951: range 000000000C91DED0-000000000C91E050
void __fastcall google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::MethodDescriptor>(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name_scope,
        const std::string *element_name,
        const google::protobuf::MethodDescriptor::OptionsType *orig_options,
        google::protobuf::MethodDescriptor *descriptor)
{
  google::protobuf::DescriptorPool::Tables *tables; // r14
  google::protobuf::MethodOptions *v9; // rbp
  google::protobuf::Message **v10; // rdx
  std::forward_iterator_tag v11; // cl
  int current_size; // eax
  char *M_p; // rsi
  std::string::size_type M_string_length; // rdx
  std::forward_iterator_tag v15; // cl
  google::protobuf::`anonymous namespace'::OptionsToInterpret *v16; // rdx
  google::protobuf::`anonymous namespace'::OptionsToInterpret v18; // [rsp+10h] [rbp-88h] BYREF

  tables = this->tables_;
  v9 = (google::protobuf::MethodOptions *)operator new(0x70uLL);
  google::protobuf::MethodOptions::MethodOptions(v9);
  v18.name_scope._M_dataplus._M_p = (std::string::pointer)v9;
  std::vector<google::protobuf::Message *>::emplace_back<google::protobuf::Message *>(
    &tables->messages_,
    (google::protobuf::Message **)&v18,
    v10);
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&v18, orig_options);
  google::protobuf::MessageLite::ParseFromString(v9, &v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
    operator delete(v18.name_scope._M_dataplus._M_p);
  current_size = v9->uninterpreted_option_.current_size_;
  descriptor->options_ = v9;
  if ( current_size > 0 )
  {
    M_p = name_scope->_M_dataplus._M_p;
    M_string_length = name_scope->_M_string_length;
    v18.name_scope._M_dataplus._M_p = v18.name_scope._anon_0._M_local_buf;
    std::string::_M_construct<char *>(&v18.name_scope, M_p, &M_p[M_string_length], v11);
    v18.element_name._M_dataplus._M_p = v18.element_name._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &v18.element_name,
      element_name->_M_dataplus._M_p,
      &element_name->_M_dataplus._M_p[element_name->_M_string_length],
      v15);
    v18.original_options = orig_options;
    v18.options = v9;
    std::vector<google::protobuf::`anonymous namespace'::OptionsToInterpret>::emplace_back<google::protobuf::`anonymous namespace'::OptionsToInterpret>(
      &this->options_to_interpret_,
      &v18,
      v16);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.element_name._M_dataplus._M_p != &v18.element_name._anon_0 )
      operator delete(v18.element_name._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
      operator delete(v18.name_scope._M_dataplus._M_p);
  }
};

// Line 3951: range 000000000C91D890-000000000C91DA10
void __fastcall google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::OneofDescriptor>(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name_scope,
        const std::string *element_name,
        const google::protobuf::OneofDescriptor::OptionsType *orig_options,
        google::protobuf::OneofDescriptor *descriptor)
{
  google::protobuf::DescriptorPool::Tables *tables; // r14
  google::protobuf::OneofOptions *v9; // rbp
  google::protobuf::Message **v10; // rdx
  std::forward_iterator_tag v11; // cl
  int current_size; // eax
  char *M_p; // rsi
  std::string::size_type M_string_length; // rdx
  std::forward_iterator_tag v15; // cl
  google::protobuf::`anonymous namespace'::OptionsToInterpret *v16; // rdx
  google::protobuf::`anonymous namespace'::OptionsToInterpret v18; // [rsp+10h] [rbp-88h] BYREF

  tables = this->tables_;
  v9 = (google::protobuf::OneofOptions *)operator new(0x68uLL);
  google::protobuf::OneofOptions::OneofOptions(v9);
  v18.name_scope._M_dataplus._M_p = (std::string::pointer)v9;
  std::vector<google::protobuf::Message *>::emplace_back<google::protobuf::Message *>(
    &tables->messages_,
    (google::protobuf::Message **)&v18,
    v10);
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&v18, orig_options);
  google::protobuf::MessageLite::ParseFromString(v9, &v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
    operator delete(v18.name_scope._M_dataplus._M_p);
  current_size = v9->uninterpreted_option_.current_size_;
  descriptor->options_ = v9;
  if ( current_size > 0 )
  {
    M_p = name_scope->_M_dataplus._M_p;
    M_string_length = name_scope->_M_string_length;
    v18.name_scope._M_dataplus._M_p = v18.name_scope._anon_0._M_local_buf;
    std::string::_M_construct<char *>(&v18.name_scope, M_p, &M_p[M_string_length], v11);
    v18.element_name._M_dataplus._M_p = v18.element_name._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &v18.element_name,
      element_name->_M_dataplus._M_p,
      &element_name->_M_dataplus._M_p[element_name->_M_string_length],
      v15);
    v18.original_options = orig_options;
    v18.options = v9;
    std::vector<google::protobuf::`anonymous namespace'::OptionsToInterpret>::emplace_back<google::protobuf::`anonymous namespace'::OptionsToInterpret>(
      &this->options_to_interpret_,
      &v18,
      v16);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.element_name._M_dataplus._M_p != &v18.element_name._anon_0 )
      operator delete(v18.element_name._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
      operator delete(v18.name_scope._M_dataplus._M_p);
  }
};

// Line 3951: range 000000000C91DD40-000000000C91DEC0
void __fastcall google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::ServiceDescriptor>(
        google::protobuf::DescriptorBuilder *const this,
        const std::string *name_scope,
        const std::string *element_name,
        const google::protobuf::ServiceDescriptor::OptionsType *orig_options,
        google::protobuf::ServiceDescriptor *descriptor)
{
  google::protobuf::DescriptorPool::Tables *tables; // r14
  google::protobuf::ServiceOptions *v9; // rbp
  google::protobuf::Message **v10; // rdx
  std::forward_iterator_tag v11; // cl
  int current_size; // eax
  char *M_p; // rsi
  std::string::size_type M_string_length; // rdx
  std::forward_iterator_tag v15; // cl
  google::protobuf::`anonymous namespace'::OptionsToInterpret *v16; // rdx
  google::protobuf::`anonymous namespace'::OptionsToInterpret v18; // [rsp+10h] [rbp-88h] BYREF

  tables = this->tables_;
  v9 = (google::protobuf::ServiceOptions *)operator new(0x70uLL);
  google::protobuf::ServiceOptions::ServiceOptions(v9);
  v18.name_scope._M_dataplus._M_p = (std::string::pointer)v9;
  std::vector<google::protobuf::Message *>::emplace_back<google::protobuf::Message *>(
    &tables->messages_,
    (google::protobuf::Message **)&v18,
    v10);
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&v18, orig_options);
  google::protobuf::MessageLite::ParseFromString(v9, &v18);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
    operator delete(v18.name_scope._M_dataplus._M_p);
  current_size = v9->uninterpreted_option_.current_size_;
  descriptor->options_ = v9;
  if ( current_size > 0 )
  {
    M_p = name_scope->_M_dataplus._M_p;
    M_string_length = name_scope->_M_string_length;
    v18.name_scope._M_dataplus._M_p = v18.name_scope._anon_0._M_local_buf;
    std::string::_M_construct<char *>(&v18.name_scope, M_p, &M_p[M_string_length], v11);
    v18.element_name._M_dataplus._M_p = v18.element_name._anon_0._M_local_buf;
    std::string::_M_construct<char *>(
      &v18.element_name,
      element_name->_M_dataplus._M_p,
      &element_name->_M_dataplus._M_p[element_name->_M_string_length],
      v15);
    v18.original_options = orig_options;
    v18.options = v9;
    std::vector<google::protobuf::`anonymous namespace'::OptionsToInterpret>::emplace_back<google::protobuf::`anonymous namespace'::OptionsToInterpret>(
      &this->options_to_interpret_,
      &v18,
      v16);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.element_name._M_dataplus._M_p != &v18.element_name._anon_0 )
      operator delete(v18.element_name._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v18.name_scope._M_dataplus._M_p != &v18.name_scope._anon_0 )
      operator delete(v18.name_scope._M_dataplus._M_p);
  }
};

// Line 3993: range 000000000C8FA130-000000000C8FA234
void __fastcall google::protobuf::DescriptorBuilder::AddRecursiveImportError(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::FileDescriptorProto *a2,
        int a3,
        std::forward_iterator_tag a4)
{
  unsigned __int64 v4; // rbx
  google::protobuf::DescriptorPool::Tables *tables; // rdx
  std::_Vector_base<std::string>::pointer M_start; // rax
  google::protobuf::DescriptorPool::Tables *v7; // rdx
  std::string v8[2]; // [rsp+0h] [rbp-48h] BYREF

  v4 = a3;
  v8[0]._M_dataplus._M_p = v8[0]._anon_0._M_local_buf;
  std::string::_M_construct<char const*>(v8, "File recursively imports itself: ", "", a4);
  tables = this->tables_;
  M_start = tables->pending_files_._M_impl._M_start;
  if ( v4 < tables->pending_files_._M_impl._M_finish - tables->pending_files_._M_impl._M_start )
  {
    do
    {
      std::string::_M_append(v8, M_start[v4]._M_dataplus._M_p, M_start[v4]._M_string_length);
      if ( 0x3FFFFFFFFFFFFFFFLL - v8[0]._M_string_length <= 3 )
        std::__throw_length_error("basic_string::append");
      std::string::_M_append(v8, " -> ", 4LL);
      v7 = this->tables_;
      ++v4;
      M_start = v7->pending_files_._M_impl._M_start;
    }
    while ( v7->pending_files_._M_impl._M_finish - v7->pending_files_._M_impl._M_start > v4 );
  }
  std::string::_M_append(v8, a2->name_.ptr_->_M_dataplus._M_p, a2->name_.ptr_->_M_string_length);
  google::protobuf::DescriptorBuilder::AddError((__int64)this, a2->name_.ptr_, (__int64)a2, 9u, v8);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v8[0]._M_dataplus._M_p != &v8[0]._anon_0 )
    operator delete(v8[0]._M_dataplus._M_p);
};

// Line 4006: range 000000000C8F71E0-000000000C8F72E1
void __fastcall google::protobuf::DescriptorBuilder::AddTwiceListedError(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::FileDescriptorProto *a2,
        int a3)
{
  __int64 v4; // rax
  std::string::size_type v5; // rcx
  std::string *ptr; // rsi
  std::string v7; // [rsp+0h] [rbp-58h] BYREF
  std::string v8; // [rsp+20h] [rbp-38h] BYREF

  std::operator+<char>(&v7, "Import \"", (const std::string *)a2->dependency_.rep_->elements[a3]);
  if ( 0x3FFFFFFFFFFFFFFFLL - v7._M_string_length <= 0x12 )
    std::__throw_length_error("basic_string::append");
  v4 = std::string::_M_append(&v7, "\" was listed twice.", 19LL);
  v8._M_dataplus._M_p = v8._anon_0._M_local_buf;
  if ( *(_QWORD *)v4 == v4 + 16 )
  {
    v8._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v4 + 16));
  }
  else
  {
    v8._M_dataplus._M_p = *(std::string::pointer *)v4;
    v8._anon_0._M_allocated_capacity = *(_QWORD *)(v4 + 16);
  }
  v5 = *(_QWORD *)(v4 + 8);
  *(_BYTE *)(v4 + 16) = 0;
  ptr = a2->name_.ptr_;
  v8._M_string_length = v5;
  *(_QWORD *)v4 = v4 + 16;
  *(_QWORD *)(v4 + 8) = 0LL;
  google::protobuf::DescriptorBuilder::AddError((__int64)this, ptr, (__int64)a2, 9u, &v8);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v8._M_dataplus._M_p != &v8._anon_0 )
    operator delete(v8._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v7._M_dataplus._M_p != &v7._anon_0 )
    operator delete(v7._M_dataplus._M_p);
};

// Line 4012: range 000000000C8F7670-000000000C8F78E1
void __fastcall google::protobuf::DescriptorBuilder::AddImportError(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::FileDescriptorProto *a2,
        int a3)
{
  const google::protobuf::DescriptorPool *pool; // rcx
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *rep; // rax
  bool v7; // zf
  const std::string *v8; // rdx
  __int64 v9; // rax
  __int64 v10; // rdx
  void *v11; // rcx
  std::string *M_p; // rdi
  std::string::size_type M_allocated_capacity; // rsi
  std::string::size_type v14; // rdx
  std::string dest; // [rsp+0h] [rbp-88h] BYREF
  std::string v16; // [rsp+20h] [rbp-68h] BYREF
  void *v17; // [rsp+40h] [rbp-48h]
  size_t n; // [rsp+48h] [rbp-40h]
  __int128 src[3]; // [rsp+50h] [rbp-38h] BYREF

  pool = this->pool_;
  rep = a2->dependency_.rep_;
  dest._anon_0._M_local_buf[0] = 0;
  v7 = pool->fallback_database_ == 0LL;
  dest._M_dataplus._M_p = dest._anon_0._M_local_buf;
  dest._M_string_length = 0LL;
  v8 = (const std::string *)rep->elements[a3];
  if ( v7 )
  {
    std::operator+<char>(&v16, "Import \"", v8);
    if ( 0x3FFFFFFFFFFFFFFFLL - v16._M_string_length <= 0x15 )
      std::__throw_length_error("basic_string::append");
    v9 = std::string::_M_append(&v16, "\" has not been loaded.", 22LL);
    v10 = v9 + 16;
    v17 = src;
    v11 = *(void **)v9;
    if ( *(_QWORD *)v9 != v9 + 16 )
      goto LABEL_4;
  }
  else
  {
    std::operator+<char>(&v16, "Import \"", v8);
    if ( 0x3FFFFFFFFFFFFFFFLL - v16._M_string_length <= 0x1D )
      std::__throw_length_error("basic_string::append");
    v9 = std::string::_M_append(&v16, "\" was not found or had errors.", 30LL);
    v10 = v9 + 16;
    v17 = src;
    v11 = *(void **)v9;
    if ( *(_QWORD *)v9 != v9 + 16 )
    {
LABEL_4:
      v17 = v11;
      *(_QWORD *)&src[0] = *(_QWORD *)(v9 + 16);
      goto LABEL_5;
    }
  }
  src[0] = (__int128)_mm_loadu_si128((const __m128i *)(v9 + 16));
LABEL_5:
  n = *(_QWORD *)(v9 + 8);
  *(_QWORD *)v9 = v10;
  *(_BYTE *)(v9 + 16) = 0;
  M_p = (std::string *)dest._M_dataplus._M_p;
  *(_QWORD *)(v9 + 8) = 0LL;
  if ( v17 == src )
  {
    v14 = n;
    if ( n )
    {
      if ( n == 1 )
        LOBYTE(M_p->_M_dataplus._M_p) = src[0];
      else
        memcpy(M_p, src, n);
      v14 = n;
      M_p = (std::string *)dest._M_dataplus._M_p;
    }
    dest._M_string_length = v14;
    *((_BYTE *)&M_p->_M_dataplus._M_p + v14) = 0;
    M_p = (std::string *)v17;
  }
  else
  {
    if ( M_p == (std::string *)&dest._anon_0 )
    {
      dest._M_dataplus._M_p = (std::string::pointer)v17;
      dest._M_string_length = n;
      dest._anon_0._M_allocated_capacity = *(_QWORD *)&src[0];
    }
    else
    {
      M_allocated_capacity = dest._anon_0._M_allocated_capacity;
      dest._M_dataplus._M_p = (std::string::pointer)v17;
      dest._M_string_length = n;
      dest._anon_0._M_allocated_capacity = *(_QWORD *)&src[0];
      if ( M_p )
      {
        v17 = M_p;
        *(_QWORD *)&src[0] = M_allocated_capacity;
        goto LABEL_9;
      }
    }
    v17 = src;
    M_p = (std::string *)src;
  }
LABEL_9:
  n = 0LL;
  LOBYTE(M_p->_M_dataplus._M_p) = 0;
  if ( v17 != src )
    operator delete(v17);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v16._M_dataplus._M_p != &v16._anon_0 )
    operator delete(v16._M_dataplus._M_p);
  google::protobuf::DescriptorBuilder::AddError((__int64)this, a2->name_.ptr_, (__int64)a2, 9u, &dest);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)dest._M_dataplus._M_p != &dest._anon_0 )
    operator delete(dest._M_dataplus._M_p);
};

// Line 4025: range 000000000C908040-000000000C90829E
__int64 __fastcall google::protobuf::ExistingFileMatchesProto(
        google::protobuf::FileDescriptor *this,
        const google::protobuf::FileDescriptor *a2,
        const google::protobuf::FileDescriptorProto *a3)
{
  char *v3; // rbp
  unsigned int v4; // r12d
  const char *v6; // rax
  std::forward_iterator_tag v7; // cl
  const char *v8; // r13
  __int64 v9; // rdx
  std::string *ptr; // rbx
  std::string::$CFBEC286C7F52157F7E59FC354047095 *M_p; // rdi
  std::string::size_type M_string_length; // rdx
  std::string::size_type M_allocated_capacity; // rcx
  __int64 v14; // rax
  void *s1; // [rsp+0h] [rbp-148h] BYREF
  size_t n; // [rsp+8h] [rbp-140h]
  char v17; // [rsp+10h] [rbp-138h] BYREF
  std::string s2; // [rsp+20h] [rbp-128h] BYREF
  google::protobuf::FileDescriptorProto v19; // [rsp+40h] [rbp-108h] BYREF

  google::protobuf::FileDescriptorProto::FileDescriptorProto(&v19);
  google::protobuf::FileDescriptor::CopyTo(this, &v19);
  if ( this->syntax_ != SYNTAX_PROTO2 || ((__int64)a2->pool_ & 4) == 0 )
    goto LABEL_3;
  v6 = google::protobuf::FileDescriptor::SyntaxName(
         (google::protobuf::FileDescriptor *)2,
         (google::protobuf::FileDescriptor::Syntax)&v19);
  v19._has_bits_.has_bits_[0] |= 4u;
  v8 = v6;
  v9 = -1LL;
  s2._M_dataplus._M_p = s2._anon_0._M_local_buf;
  if ( v6 )
    v9 = (__int64)&v6[strlen(v6)];
  std::string::_M_construct<char const*>(&s2, v8, (const char *)v9, v7);
  ptr = v19.syntax_.ptr_;
  if ( (google::protobuf::internal::ExplicitlyConstructed<std::string > *)v19.syntax_.ptr_ == &google::protobuf::internal::fixed_address_empty_string[abi:cxx11] )
  {
    v14 = operator new(0x20uLL);
    *(_QWORD *)v14 = v14 + 16;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)s2._M_dataplus._M_p == &s2._anon_0 )
    {
      *(__m128i *)(v14 + 16) = _mm_load_si128((const __m128i *)&s2._anon_0);
    }
    else
    {
      *(_QWORD *)v14 = s2._M_dataplus._M_p;
      *(_QWORD *)(v14 + 16) = s2._anon_0._M_allocated_capacity;
    }
    v19.syntax_.ptr_ = (std::string *)v14;
    *(_QWORD *)(v14 + 8) = s2._M_string_length;
    goto LABEL_3;
  }
  M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v19.syntax_.ptr_->_M_dataplus._M_p;
  M_string_length = s2._M_string_length;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)s2._M_dataplus._M_p == &s2._anon_0 )
  {
    if ( s2._M_string_length )
    {
      if ( s2._M_string_length == 1 )
        M_p->_M_local_buf[0] = s2._anon_0._M_local_buf[0];
      else
        memcpy(M_p, &s2._anon_0, s2._M_string_length);
      M_string_length = s2._M_string_length;
      M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)ptr->_M_dataplus._M_p;
    }
    ptr->_M_string_length = M_string_length;
    M_p->_M_local_buf[M_string_length] = 0;
    M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)s2._M_dataplus._M_p;
    goto LABEL_18;
  }
  if ( M_p == &v19.syntax_.ptr_->_anon_0 )
  {
    v19.syntax_.ptr_->_M_dataplus._M_p = s2._M_dataplus._M_p;
    ptr->_M_string_length = M_string_length;
    ptr->_anon_0._M_allocated_capacity = s2._anon_0._M_allocated_capacity;
  }
  else
  {
    v19.syntax_.ptr_->_M_dataplus._M_p = s2._M_dataplus._M_p;
    M_allocated_capacity = ptr->_anon_0._M_allocated_capacity;
    ptr->_M_string_length = M_string_length;
    ptr->_anon_0._M_allocated_capacity = s2._anon_0._M_allocated_capacity;
    if ( M_p )
    {
      s2._M_dataplus._M_p = (std::string::pointer)M_p;
      s2._anon_0._M_allocated_capacity = M_allocated_capacity;
      goto LABEL_18;
    }
  }
  s2._M_dataplus._M_p = s2._anon_0._M_local_buf;
  M_p = &s2._anon_0;
LABEL_18:
  s2._M_string_length = 0LL;
  M_p->_M_local_buf[0] = 0;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)s2._M_dataplus._M_p != &s2._anon_0 )
    operator delete(s2._M_dataplus._M_p);
LABEL_3:
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&s2, a2);
  google::protobuf::MessageLite::SerializeAsString[abi:cxx11](&s1, &v19);
  v3 = (char *)s1;
  v4 = 0;
  if ( n == s2._M_string_length )
  {
    v4 = 1;
    if ( n )
      LOBYTE(v4) = memcmp(s1, s2._M_dataplus._M_p, n) == 0;
  }
  if ( v3 != &v17 )
    operator delete(v3);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)s2._M_dataplus._M_p != &s2._anon_0 )
    operator delete(s2._M_dataplus._M_p);
  google::protobuf::FileDescriptorProto::~FileDescriptorProto(&v19);
  return v4;
};

// Line 4040: range 000000000C9128F0-000000000C912B22
const google::protobuf::FileDescriptor *__fastcall google::protobuf::DescriptorBuilder::BuildFile(
        google::protobuf::DescriptorBuilder *const this,
        const google::protobuf::FileDescriptorProto *proto)
{
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v4; // rax
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v5; // rdx
  const google::protobuf::FileDescriptor *v6; // r13
  google::protobuf::DescriptorPool::Tables *tables; // rax
  std::_Vector_base<std::string>::pointer M_start; // rbp
  __int64 v9; // rcx
  __int64 v10; // rbx
  size_t M_string_length; // r13
  int v12; // eax
  std::string *ptr; // rdx
  int v15; // ebx
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v16; // rax
  google::protobuf::DescriptorPool *pool; // rdi
  std::string *v18; // rsi
  google::protobuf::DescriptorPool::Tables *v19; // rdx
  std::_Vector_base<std::string>::pointer M_finish; // rax
  std::string::$CFBEC286C7F52157F7E59FC354047095 *M_p; // rdi
  __int64 v22; // [rsp+0h] [rbp-68h]
  std::string *v23; // [rsp+8h] [rbp-60h]
  std::vector<std::string> *p_pending_files; // [rsp+10h] [rbp-58h]
  std::string *__position; // [rsp+18h] [rbp-50h]
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type __k[8]; // [rsp+28h] [rbp-40h] BYREF

  std::string::_M_assign(&this->filename_, proto->name_.ptr_);
  __k[0] = this->filename_._M_dataplus._M_p;
  v4._M_cur = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                &this->tables_->files_by_name_._M_h,
                __k)._M_cur;
  if ( v4._M_cur )
  {
    v6 = (const google::protobuf::FileDescriptor *)*((_QWORD *)&v4._M_cur->_M_storage._M_storage.1 + 1);
    if ( v6 )
    {
      if ( (unsigned __int8)google::protobuf::ExistingFileMatchesProto(
                              *((google::protobuf::FileDescriptor **)&v4._M_cur->_M_storage._M_storage.1 + 1),
                              (const google::protobuf::FileDescriptor *)proto,
                              (const google::protobuf::FileDescriptorProto *)v5._M_cur) )
        return v6;
    }
  }
  tables = this->tables_;
  M_start = tables->pending_files_._M_impl._M_start;
  p_pending_files = &tables->pending_files_;
  __position = tables->pending_files_._M_impl._M_finish;
  v9 = __position - tables->pending_files_._M_impl._M_start;
  if ( !v9 )
  {
LABEL_12:
    if ( this->pool_->lazily_build_dependencies_ || !this->pool_->fallback_database_ )
      return (const google::protobuf::FileDescriptor *)google::protobuf::DescriptorBuilder::BuildFileImpl(this, proto);
    ptr = proto->name_.ptr_;
    if ( p_pending_files->_M_impl._M_end_of_storage == __position )
    {
      std::vector<std::string>::_M_realloc_insert<std::string const&>(
        p_pending_files,
        (std::vector<std::string>::iterator)__position,
        ptr,
        (const std::string *)v9);
    }
    else
    {
      __position->_M_dataplus._M_p = __position->_anon_0._M_local_buf;
      std::string::_M_construct<char *>(
        __position,
        ptr->_M_dataplus._M_p,
        &ptr->_M_dataplus._M_p[ptr->_M_string_length],
        (std::forward_iterator_tag)v9);
      ++p_pending_files->_M_impl._M_finish;
    }
    v15 = 0;
    if ( proto->dependency_.current_size_ <= 0 )
    {
LABEL_25:
      v19 = this->tables_;
      M_finish = v19->pending_files_._M_impl._M_finish;
      M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)M_finish[-1]._M_dataplus._M_p;
      v19->pending_files_._M_impl._M_finish = M_finish - 1;
      if ( M_p != &M_finish[-1]._anon_0 )
        operator delete(M_p);
      return (const google::protobuf::FileDescriptor *)google::protobuf::DescriptorBuilder::BuildFileImpl(this, proto);
    }
    while ( 1 )
    {
      __k[0] = *(std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *)proto->dependency_.rep_->elements[v15];
      v16._M_cur = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                     &this->tables_->files_by_name_._M_h,
                     __k)._M_cur;
      if ( v16._M_cur && *((_QWORD *)&v16._M_cur->_M_storage._M_storage.1 + 1) )
        goto LABEL_18;
      pool = (google::protobuf::DescriptorPool *)this->pool_;
      v18 = (std::string *)proto->dependency_.rep_->elements[v15];
      if ( this->pool_->underlay_ )
      {
        if ( !google::protobuf::DescriptorPool::FindFileByName(
                (google::protobuf::DescriptorPool *)this->pool_->underlay_,
                v18) )
        {
          pool = (google::protobuf::DescriptorPool *)this->pool_;
          v18 = (std::string *)proto->dependency_.rep_->elements[v15];
          goto LABEL_24;
        }
LABEL_18:
        if ( ++v15 >= proto->dependency_.current_size_ )
          goto LABEL_25;
      }
      else
      {
LABEL_24:
        google::protobuf::DescriptorPool::TryFindFileInFallbackDatabase(pool, v18);
        if ( ++v15 >= proto->dependency_.current_size_ )
          goto LABEL_25;
      }
    }
  }
  v10 = 0LL;
  v23 = proto->name_.ptr_;
  M_string_length = v23->_M_string_length;
  while ( 1 )
  {
    if ( M_start->_M_string_length == M_string_length )
    {
      v22 = v9;
      if ( !M_string_length )
        break;
      v12 = memcmp(M_start->_M_dataplus._M_p, v23->_M_dataplus._M_p, M_string_length);
      v9 = v22;
      if ( !v12 )
        break;
    }
    ++v10;
    ++M_start;
    if ( v9 == v10 )
      goto LABEL_12;
  }
  v6 = 0LL;
  google::protobuf::DescriptorBuilder::AddRecursiveImportError(this, proto, v10, (std::forward_iterator_tag)v9);
  return v6;
};

// Line 4096: range 000000000C9112F0-000000000C9128EA
google::protobuf::FileDescriptor *__fastcall google::protobuf::DescriptorBuilder::BuildFileImpl(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::FileDescriptorProto *proto,
        google::protobuf::DescriptorPool::Tables::CheckPoint *a3)
{
  google::protobuf::DescriptorBuilder *v3; // r14
  const google::protobuf::FileDescriptorProto *v4; // r12
  std::vector<google::protobuf::DescriptorPool::Tables::CheckPoint> *tables; // rdi
  __int64 v6; // rax
  google::protobuf::DescriptorPool::Tables *v7; // rdi
  google::protobuf::FileDescriptor *v8; // rax
  google::protobuf::FileDescriptor *v9; // r15
  std::vector<google::protobuf::Message*> *v10; // rbx
  google::protobuf::SourceCodeInfo *v11; // rbp
  google::protobuf::Message **v12; // rdx
  google::protobuf::SourceCodeInfo *source_code_info; // rsi
  google::protobuf::FileDescriptorTables *FileTables; // rax
  std::forward_iterator_tag v15; // cl
  google::protobuf::FileDescriptor *file; // rdx
  std::string *ptr; // rdi
  std::forward_iterator_tag v18; // cl
  google::protobuf::DescriptorPool::Tables *v19; // rdi
  std::string *package; // rsi
  google::protobuf::DescriptorPool::Tables *v21; // rdi
  int current_size; // eax
  int v23; // eax
  int v24; // ebx
  int v25; // r13d
  std::pair<std::_Rb_tree_node_base*,std::_Rb_tree_node_base*> insert_unique_pos; // rax
  std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> >::_Alloc_node *v27; // r8
  __int64 i; // rbx
  std::pair<std::_Rb_tree_iterator<std::string >,bool> v29; // rax
  __int64 v30; // rbp
  std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v31; // rax
  google::protobuf::DescriptorBuilder *v32; // r9
  const google::protobuf::DescriptorPool *pool; // rax
  std::string *v34; // rdx
  std::_Rb_tree_header *v35; // rbx
  std::string::pointer M_p; // r12
  size_t M_string_length; // rbp
  std::_Rb_tree_node_base::_Base_ptr M_parent; // r13
  size_t v39; // r14
  size_t v40; // rdx
  int v41; // eax
  std::_Rb_tree_header *v42; // rax
  size_t v43; // r13
  std::string::pointer v44; // r11
  google::protobuf::DescriptorBuilder *v45; // r9
  size_t v46; // rcx
  size_t v47; // rdx
  int v48; // eax
  google::protobuf::DescriptorBuilder *v49; // rax
  bool lazily_build_dependencies; // dl
  const google::protobuf::DescriptorPool *v51; // rdi
  std::string **v52; // r13
  int *v53; // rax
  int v54; // r11d
  int v55; // ebx
  __int64 v56; // r13
  __int64 v57; // rbp
  google::protobuf::ProtobufOnceType *p_state; // rdi
  const google::protobuf::DescriptorPool *v59; // rax
  __int64 v60; // rbx
  google::protobuf::ProtobufOnceType *v61; // rdi
  int *v62; // rax
  int v63; // r10d
  int v64; // ebx
  int v65; // ebp
  __int64 v66; // rcx
  int v67; // eax
  int v68; // eax
  google::protobuf::DescriptorPool::Tables *v69; // rdi
  google::protobuf::Descriptor *message_types; // rax
  int v71; // r8d
  __int64 v72; // rbx
  int v73; // esi
  google::protobuf::DescriptorPool::Tables *v74; // rdi
  google::protobuf::EnumDescriptor *enum_types; // rax
  __int64 v76; // rbx
  int v77; // eax
  google::protobuf::DescriptorPool::Tables *v78; // rdi
  google::protobuf::ServiceDescriptor *services; // rax
  int v80; // esi
  __int64 v81; // rbx
  int v82; // esi
  google::protobuf::DescriptorPool::Tables *v83; // rdi
  google::protobuf::FieldDescriptor *extensions; // rax
  int v85; // ecx
  __int64 v86; // rbp
  int v87; // ebx
  __int64 v88; // rbp
  int v89; // ebx
  google::protobuf::DescriptorPool::Tables *v90; // rax
  __int64 v91; // rdx
  const google::protobuf::DescriptorPool *v92; // rdx
  std::vector<std::string*> *v94; // rbp
  std::string *String; // rax
  google::protobuf::DescriptorBuilder::OptionInterpreter *builder; // rdi
  std::_Rb_tree_node_base::_Base_ptr v97; // rax
  std::_Rb_tree_header *v98; // rdx
  bool v99; // zf
  google::protobuf::FileDescriptor *v100; // rax
  const std::string **Bytes; // rax
  __int64 v102; // rdx
  const google::protobuf::FileOptions *options; // rsi
  google::protobuf::Message *v104; // rbp
  const google::protobuf::Message *original_options; // r13
  const google::protobuf::Descriptor *v106; // rbx
  std::forward_iterator_tag v107; // cl
  const google::protobuf::FieldDescriptor *FieldByName; // rbx
  const google::protobuf::Message::Reflection *(__fastcall *v109)(const google::protobuf::Message *const); // rdx
  __int64 v110; // rdx
  __int64 v111; // rdi
  const google::protobuf::Descriptor *v112; // rbx
  std::forward_iterator_tag v113; // cl
  const google::protobuf::Message::Reflection *(__fastcall *v114)(const google::protobuf::Message *const); // rdx
  __int64 v115; // rdx
  __int64 v116; // rdi
  unsigned int v117; // ebx
  __int64 v118; // rdx
  __int64 v119; // rdi
  const google::protobuf::Message::Reflection *(__fastcall *v120)(const google::protobuf::Message *const); // rdx
  __int64 v121; // rax
  std::_Vector_base<google::protobuf::(anonymous namespace)::OptionsToInterpret,std::allocator<google::protobuf::(anonymous namespace)::OptionsToInterpret> >::pointer v122; // rbx
  const google::protobuf::`anonymous namespace'::OptionsToInterpret *v123; // rbp
  std::string::$CFBEC286C7F52157F7E59FC354047095 *v124; // rdi
  google::protobuf::internal::LogMessage_0 *v125; // rax
  google::protobuf::internal::LogMessage_0 *v126; // rsi
  google::protobuf::internal::LogMessage_0 *v127; // rax
  google::protobuf::internal::LogMessage_0 *v128; // rsi
  google::protobuf::internal::LogMessage_0 *v129; // rax
  google::protobuf::internal::LogMessage_0 *v130; // rax
  google::protobuf::internal::LogMessage_0 *v131; // rax
  google::protobuf::internal::LogMessage_0 *v132; // rsi
  const char **v133; // rdx
  const char **v134; // rdx
  std::pair<const google::protobuf::Descriptor*,int> *v135; // rdx
  std::_Rb_tree_header *v136; // [rsp+8h] [rbp-190h]
  google::protobuf::DescriptorBuilder *v137; // [rsp+8h] [rbp-190h]
  int v138; // [rsp+8h] [rbp-190h]
  const google::protobuf::FieldDescriptor *v139; // [rsp+8h] [rbp-190h]
  google::protobuf::DescriptorBuilder *v140; // [rsp+8h] [rbp-190h]
  google::protobuf::DescriptorBuilder *v141; // [rsp+10h] [rbp-188h]
  size_t v142; // [rsp+10h] [rbp-188h]
  int v143; // [rsp+10h] [rbp-188h]
  __int64 v144; // [rsp+18h] [rbp-180h]
  const google::protobuf::`anonymous namespace'::OptionsToInterpret *M_start; // [rsp+18h] [rbp-180h]
  google::protobuf::DescriptorBuilder *v146; // [rsp+20h] [rbp-178h]
  const google::protobuf::FileDescriptorProto *v147; // [rsp+28h] [rbp-170h]
  __int64 v148; // [rsp+30h] [rbp-168h]
  std::_Rb_tree<const google::protobuf::FileDescriptor*,const google::protobuf::FileDescriptor*,std::_Identity<const google::protobuf::FileDescriptor*>,std::less<const google::protobuf::FileDescriptor*>,std::allocator<const google::protobuf::FileDescriptor*> > *p_M_t; // [rsp+38h] [rbp-160h]
  void *v150[2]; // [rsp+40h] [rbp-158h] BYREF
  char v151[16]; // [rsp+50h] [rbp-148h] BYREF
  google::protobuf::internal::LogFinisher v152[8]; // [rsp+60h] [rbp-138h] BYREF
  char v153; // [rsp+70h] [rbp-128h] BYREF
  std::_Rb_tree<std::string,std::string,std::_Identity<std::string >,std::less<std::string >,std::allocator<std::string > > v154; // [rsp+80h] [rbp-118h] BYREF
  std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> > v155; // [rsp+B0h] [rbp-E8h] BYREF
  google::protobuf::internal::LogMessage_0 key; // [rsp+E0h] [rbp-B8h] BYREF
  google::protobuf::DescriptorBuilder::OptionInterpreter v157; // [rsp+120h] [rbp-78h] BYREF

  v3 = this;
  v4 = proto;
  tables = (std::vector<google::protobuf::DescriptorPool::Tables::CheckPoint> *)this->tables_;
  v6 = (char *)tables[8]._M_impl._M_finish - (char *)tables[8]._M_impl._M_start;
  tables = (std::vector<google::protobuf::DescriptorPool::Tables::CheckPoint> *)((char *)tables + 472);
  LODWORD(v157.builder_) = v6 >> 3;
  HIDWORD(v157.builder_) = ((char *)tables[-11]._M_impl._M_end_of_storage - (char *)tables[-11]._M_impl._M_finish) >> 3;
  LODWORD(v157.options_to_interpret_) = ((char *)tables[-10]._M_impl._M_end_of_storage
                                       - (char *)tables[-10]._M_impl._M_finish) >> 3;
  HIDWORD(v157.options_to_interpret_) = ((char *)tables[-9]._M_impl._M_end_of_storage
                                       - (char *)tables[-9]._M_impl._M_finish) >> 3;
  LODWORD(v157.uninterpreted_option_) = ((char *)tables[-8]._M_impl._M_end_of_storage
                                       - (char *)tables[-8]._M_impl._M_finish) >> 3;
  HIDWORD(v157.uninterpreted_option_) = ((char *)tables[1]._M_impl._M_finish - (char *)tables[1]._M_impl._M_start) >> 3;
  LODWORD(v157.dynamic_factory_._vptr_MessageFactory) = ((char *)tables[2]._M_impl._M_finish
                                                       - (char *)tables[2]._M_impl._M_start) >> 3;
  HIDWORD(v157.dynamic_factory_._vptr_MessageFactory) = ((char *)tables[3]._M_impl._M_finish
                                                       - (char *)tables[3]._M_impl._M_start) >> 4;
  std::vector<google::protobuf::DescriptorPool::Tables::CheckPoint>::emplace_back<google::protobuf::DescriptorPool::Tables::CheckPoint>(
    tables,
    (google::protobuf::DescriptorPool::Tables::CheckPoint *)&v157,
    a3);
  v7 = v3->tables_;
  v8 = google::protobuf::DescriptorPool::Tables::Allocate<google::protobuf::FileDescriptor>(v7);
  v3->file_ = v8;
  v9 = v8;
  *(_WORD *)&v8->is_placeholder_ = 0;
  if ( (proto->_has_bits_.has_bits_[0] & 0x10) != 0 )
  {
    v10 = (std::vector<google::protobuf::Message*> *)v3->tables_;
    v11 = (google::protobuf::SourceCodeInfo *)operator new(0x30uLL);
    google::protobuf::SourceCodeInfo::SourceCodeInfo(v11);
    v157.builder_ = (google::protobuf::DescriptorBuilder *)v11;
    std::vector<google::protobuf::Message *>::emplace_back<google::protobuf::Message *>(
      v10 + 9,
      (google::protobuf::Message **)&v157,
      v12);
    source_code_info = proto->source_code_info_;
    if ( !source_code_info )
      source_code_info = (google::protobuf::SourceCodeInfo *)&google::protobuf::_SourceCodeInfo_default_instance_;
    google::protobuf::SourceCodeInfo::CopyFrom(v11, source_code_info);
    v9->source_code_info_ = v11;
  }
  else
  {
    v8->source_code_info_ = (const google::protobuf::SourceCodeInfo *)google::protobuf::SourceCodeInfo::default_instance((google::protobuf::SourceCodeInfo *)v7);
  }
  FileTables = google::protobuf::DescriptorPool::Tables::AllocateFileTables(v3->tables_);
  file = v3->file_;
  v3->file_tables_ = FileTables;
  file->tables_ = FileTables;
  if ( (v4->_has_bits_.has_bits_[0] & 1) != 0
    || (v157.builder_ = (google::protobuf::DescriptorBuilder *)&v157.uninterpreted_option_,
        std::string::_M_construct<char const*>((std::string *const)&v157, &off_1B23A528[4], &off_1B23A528[4], v15),
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)v3,
          (const std::string *)&v157,
          (__int64)v4,
          9u,
          "Missing field: FileDescriptorProto.name."),
        (const google::protobuf::UninterpretedOption **)v157.builder_ == &v157.uninterpreted_option_) )
  {
    ptr = v4->syntax_.ptr_;
    if ( ptr->_M_string_length )
      goto LABEL_133;
LABEL_7:
    v3->file_->syntax_ = SYNTAX_PROTO2;
    goto LABEL_8;
  }
  operator delete(v157.builder_);
  ptr = v4->syntax_.ptr_;
  if ( !ptr->_M_string_length )
    goto LABEL_7;
LABEL_133:
  if ( !(unsigned int)std::string::compare(ptr, "proto2") )
    goto LABEL_7;
  v99 = (unsigned int)std::string::compare(v4->syntax_.ptr_, "proto3") == 0;
  v100 = v3->file_;
  if ( v99 )
  {
    v100->syntax_ = SYNTAX_PROTO3;
  }
  else
  {
    v100->syntax_ = SYNTAX_UNKNOWN;
    std::operator+<char>((std::string *)&v157, "Unrecognized syntax: ", v4->syntax_.ptr_);
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)v3,
      v4->name_.ptr_,
      (__int64)v4,
      9u,
      (const std::string *)&v157);
    if ( (const google::protobuf::UninterpretedOption **)v157.builder_ != &v157.uninterpreted_option_ )
      operator delete(v157.builder_);
  }
LABEL_8:
  v9->name_ = google::protobuf::DescriptorPool::Tables::AllocateString(
                (std::vector<std::string*> *)v3->tables_,
                (__int64)v4->name_.ptr_);
  if ( (v4->_has_bits_.has_bits_[0] & 2) != 0 )
  {
    v9->package_ = google::protobuf::DescriptorPool::Tables::AllocateString(
                     (std::vector<std::string*> *)v3->tables_,
                     (__int64)v4->package_.ptr_);
  }
  else
  {
    v94 = (std::vector<std::string*> *)v3->tables_;
    v157.builder_ = (google::protobuf::DescriptorBuilder *)&v157.uninterpreted_option_;
    std::string::_M_construct<char const*>((std::string *const)&v157, &off_1B23A528[4], &off_1B23A528[4], v18);
    String = google::protobuf::DescriptorPool::Tables::AllocateString(v94, (__int64)&v157);
    builder = (google::protobuf::DescriptorBuilder::OptionInterpreter *)v157.builder_;
    v9->package_ = String;
    if ( builder != (google::protobuf::DescriptorBuilder::OptionInterpreter *)&v157.uninterpreted_option_ )
      operator delete(builder);
  }
  v19 = v3->tables_;
  v9->pool_ = v3->pool_;
  if ( !(unsigned __int8)google::protobuf::DescriptorPool::Tables::AddFile(v19, v9) )
  {
    v9 = 0LL;
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)v3,
      v4->name_.ptr_,
      (__int64)v4,
      9u,
      "A file with this name is already in the pool.");
    google::protobuf::DescriptorPool::Tables::RollbackToLastCheckpoint(v3->tables_);
    return v9;
  }
  package = (std::string *)v9->package_;
  if ( package->_M_string_length )
    google::protobuf::DescriptorBuilder::AddPackage((__int64)v3, package, (__int64)v4, (__int64)v9);
  v21 = v3->tables_;
  v154._M_impl._M_node_count = 0LL;
  v154._M_impl._M_header._M_right = &v154._M_impl._M_header;
  v154._M_impl._M_header._M_left = &v154._M_impl._M_header;
  current_size = v4->dependency_.current_size_;
  v154._M_impl._M_header._M_color = _S_red;
  v9->dependency_count_ = current_size;
  v23 = v4->dependency_.current_size_;
  v154._M_impl._M_header._M_parent = 0LL;
  v9->dependencies_ = (const google::protobuf::FileDescriptor **)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                                   v21,
                                                                   8 * v23);
  if ( v3->pool_->lazily_build_dependencies_ )
  {
    v9->dependencies_once_ = google::protobuf::DescriptorPool::Tables::AllocateOnceDynamic(v3->tables_);
    Bytes = (const std::string **)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                    v3->tables_,
                                    8 * v4->dependency_.current_size_);
    v102 = v4->dependency_.current_size_;
    v9->dependencies_names_ = Bytes;
    memset(Bytes, 0, 8 * v102);
  }
  else
  {
    v9->dependencies_once_ = 0LL;
    v9->dependencies_names_ = 0LL;
  }
  v24 = 0;
  p_M_t = &v3->unused_dependency_._M_t;
  std::_Rb_tree<google::protobuf::FileDescriptor const*,google::protobuf::FileDescriptor const*,std::_Identity<google::protobuf::FileDescriptor const*>,std::less<google::protobuf::FileDescriptor const*>,std::allocator<google::protobuf::FileDescriptor const*>>::_M_erase(
    &v3->unused_dependency_._M_t,
    (std::_Rb_tree<const google::protobuf::FileDescriptor*,const google::protobuf::FileDescriptor*,std::_Identity<const google::protobuf::FileDescriptor*>,std::less<const google::protobuf::FileDescriptor*>,std::allocator<const google::protobuf::FileDescriptor*> >::_Link_type)v3->unused_dependency_._M_t._M_impl._M_header._M_parent);
  v25 = v4->weak_dependency_.current_size_;
  v3->unused_dependency_._M_t._M_impl._M_header._M_parent = 0LL;
  v3->unused_dependency_._M_t._M_impl._M_header._M_left = &v3->unused_dependency_._M_t._M_impl._M_header;
  v3->unused_dependency_._M_t._M_impl._M_header._M_right = &v3->unused_dependency_._M_t._M_impl._M_header;
  v3->unused_dependency_._M_t._M_impl._M_node_count = 0LL;
  v155._M_impl._M_header._M_color = _S_red;
  v155._M_impl._M_header._M_parent = 0LL;
  v155._M_impl._M_header._M_left = &v155._M_impl._M_header;
  v155._M_impl._M_header._M_right = &v155._M_impl._M_header;
  v155._M_impl._M_node_count = 0LL;
  if ( v25 > 0 )
  {
    do
    {
      LODWORD(v157.builder_) = v4->weak_dependency_.rep_->elements[v24];
      insert_unique_pos = std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int>>::_M_get_insert_unique_pos(
                            &v155,
                            (const std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> >::key_type *)&v157);
      if ( insert_unique_pos.second )
        std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int>>::_M_insert_<int,std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int>>::_Alloc_node>(
          &v155,
          insert_unique_pos.first,
          insert_unique_pos.second,
          (int *)&v157,
          v27);
      ++v24;
    }
    while ( v4->weak_dependency_.current_size_ > v24 );
  }
  for ( i = 0LL; v4->dependency_.current_size_ > (int)i; ++i )
  {
LABEL_23:
    v29 = std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string const&>(
            &v154,
            (const std::string *)v4->dependency_.rep_->elements[(int)i]);
    if ( !v29.second )
      google::protobuf::DescriptorBuilder::AddTwiceListedError(v3, v4, i);
    v30 = (int)i;
    v157.builder_ = *(google::protobuf::DescriptorBuilder **)v4->dependency_.rep_->elements[(int)i];
    v31._M_cur = std::_Hashtable<char const*,std::pair<char const* const,google::protobuf::FileDescriptor const*>,std::allocator<std::pair<char const* const,google::protobuf::FileDescriptor const*>>,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                   &v3->tables_->files_by_name_._M_h,
                   (const std::_Hashtable<char const*,std::pair<char const* const,const google::protobuf::FileDescriptor*>,std::allocator<std::pair<char const* const,const google::protobuf::FileDescriptor*> >,std::__detail::_Select1st,google::protobuf::streq,google::protobuf::hash<char const*>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *)&v157)._M_cur;
    if ( v31._M_cur )
    {
      v32 = (google::protobuf::DescriptorBuilder *)*((_QWORD *)&v31._M_cur->_M_storage._M_storage.1 + 1);
      v157.builder_ = v32;
      if ( v32 )
      {
        if ( v9 == (google::protobuf::FileDescriptor *)v32 )
          goto LABEL_116;
        pool = v3->pool_;
LABEL_29:
        if ( !pool->enforce_dependencies_ )
          goto LABEL_21;
        v34 = v4->name_.ptr_;
        v136 = &pool->unused_import_track_files_._M_t._M_impl.std::_Rb_tree_header;
        if ( !pool->unused_import_track_files_._M_t._M_impl._M_header._M_parent )
          goto LABEL_21;
        v144 = i;
        v35 = &pool->unused_import_track_files_._M_t._M_impl.std::_Rb_tree_header;
        v147 = v4;
        v148 = v30;
        M_p = v34->_M_dataplus._M_p;
        M_string_length = v34->_M_string_length;
        M_parent = pool->unused_import_track_files_._M_t._M_impl._M_header._M_parent;
        v141 = v32;
        v146 = v3;
LABEL_33:
        while ( 2 )
        {
          v39 = (size_t)M_parent[1]._M_parent;
          v40 = M_string_length;
          if ( v39 <= M_string_length )
            v40 = (size_t)M_parent[1]._M_parent;
          if ( v40 && (v41 = memcmp(*(const void **)&M_parent[1]._M_color, M_p, v40)) != 0 )
          {
LABEL_40:
            if ( v41 < 0 )
            {
LABEL_32:
              M_parent = M_parent->_M_right;
              if ( !M_parent )
                goto LABEL_42;
              continue;
            }
          }
          else if ( (__int64)(v39 - M_string_length) < 0x80000000LL )
          {
            if ( (__int64)(v39 - M_string_length) <= (__int64)0xFFFFFFFF7FFFFFFFLL )
              goto LABEL_32;
            v41 = v39 - M_string_length;
            goto LABEL_40;
          }
          break;
        }
        v35 = (std::_Rb_tree_header *)M_parent;
        M_parent = M_parent->_M_left;
        if ( !M_parent )
        {
LABEL_42:
          v42 = v35;
          v43 = M_string_length;
          v44 = M_p;
          v45 = v141;
          i = v144;
          v3 = v146;
          v4 = v147;
          v30 = v148;
          if ( v136 == v42 )
            goto LABEL_21;
          v46 = *(_QWORD *)&v42[1]._M_header._M_color;
          v47 = v46;
          if ( v43 <= v46 )
            v47 = v43;
          if ( v47
            && (v142 = *(_QWORD *)&v42[1]._M_header._M_color,
                v137 = v45,
                v48 = memcmp(v44, (const void *)v42->_M_node_count, v47),
                v45 = v137,
                v46 = v142,
                v48) )
          {
LABEL_50:
            if ( v48 < 0 )
              goto LABEL_21;
          }
          else if ( (__int64)(v43 - v46) < 0x80000000LL )
          {
            if ( (__int64)(v43 - v46) > (__int64)0xFFFFFFFF7FFFFFFFLL )
            {
              v48 = v43 - v46;
              goto LABEL_50;
            }
LABEL_21:
            v9->dependencies_[i] = (const google::protobuf::FileDescriptor *)v157.builder_;
LABEL_22:
            if ( v4->dependency_.current_size_ <= (int)++i )
              break;
            goto LABEL_23;
          }
          if ( HIDWORD(v45->options_to_interpret_._M_impl._M_finish) )
            goto LABEL_21;
          std::_Rb_tree<google::protobuf::FileDescriptor const*,google::protobuf::FileDescriptor const*,std::_Identity<google::protobuf::FileDescriptor const*>,std::less<google::protobuf::FileDescriptor const*>,std::allocator<google::protobuf::FileDescriptor const*>>::_M_insert_unique<google::protobuf::FileDescriptor const* const&>(
            p_M_t,
            (const google::protobuf::FileDescriptor *const *)&v157);
LABEL_53:
          v49 = v157.builder_;
          lazily_build_dependencies = v3->pool_->lazily_build_dependencies_;
          goto LABEL_62;
        }
        goto LABEL_33;
      }
    }
    else
    {
      v157.builder_ = 0LL;
    }
    v51 = v3->pool_;
    if ( v3->pool_->underlay_ )
    {
      v157.builder_ = (google::protobuf::DescriptorBuilder *)google::protobuf::DescriptorPool::FindFileByName(
                                                               (google::protobuf::DescriptorPool *)v3->pool_->underlay_,
                                                               (std::string *)v4->dependency_.rep_->elements[(int)i]);
      v32 = v157.builder_;
      if ( v9 == (google::protobuf::FileDescriptor *)v157.builder_ )
        goto LABEL_116;
      pool = v3->pool_;
      v51 = v3->pool_;
      if ( v157.builder_ )
        goto LABEL_29;
    }
    if ( v51->allow_unknown_ )
      goto LABEL_114;
    if ( v51->enforce_weak_ )
      goto LABEL_60;
    v97 = v155._M_impl._M_header._M_parent;
    if ( !v155._M_impl._M_header._M_parent )
      goto LABEL_60;
    v98 = &v155._M_impl.std::_Rb_tree_header;
    do
    {
      if ( v97[1]._M_color >= (int)i )
      {
        v98 = (std::_Rb_tree_header *)v97;
        v97 = v97->_M_left;
      }
      else
      {
        v97 = v97->_M_right;
      }
    }
    while ( v97 );
    if ( v98 == &v155._M_impl.std::_Rb_tree_header || SLODWORD(v98->_M_node_count) > (int)i )
    {
LABEL_60:
      lazily_build_dependencies = v51->lazily_build_dependencies_;
      if ( !lazily_build_dependencies )
      {
        google::protobuf::DescriptorBuilder::AddImportError(v3, v4, i);
        goto LABEL_53;
      }
      v49 = v157.builder_;
    }
    else
    {
LABEL_114:
      v49 = (google::protobuf::DescriptorBuilder *)google::protobuf::DescriptorPool::NewPlaceholderFileWithMutexHeld(
                                                     v51,
                                                     (__int64)v4->dependency_.rep_->elements[(int)i]);
      v92 = v3->pool_;
      v157.builder_ = v49;
      lazily_build_dependencies = v92->lazily_build_dependencies_;
    }
LABEL_62:
    v9->dependencies_[i] = (const google::protobuf::FileDescriptor *)v49;
    if ( v49 || !lazily_build_dependencies )
      goto LABEL_22;
    v52 = (std::string **)&v9->dependencies_names_[i];
    *v52 = google::protobuf::DescriptorPool::Tables::AllocateString(
             (std::vector<std::string*> *)v3->tables_,
             (__int64)v4->dependency_.rep_->elements[v30]);
  }
  v53 = (int *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                 v3->tables_,
                 4 * v4->public_dependency_.current_size_);
  v54 = v4->public_dependency_.current_size_;
  v9->public_dependencies_ = v53;
  v55 = 0;
  v56 = 0LL;
  if ( v54 <= 0 )
  {
    LODWORD(v56) = 0;
  }
  else
  {
    do
    {
      v57 = v4->public_dependency_.rep_->elements[v55];
      if ( (int)v57 < 0 || (int)v57 >= v4->dependency_.current_size_ )
      {
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)v3,
          v4->name_.ptr_,
          (__int64)v4,
          9u,
          "Invalid public dependency index.");
      }
      else
      {
        v138 = v56 + 1;
        v9->public_dependencies_[v56] = v57;
        if ( v3->pool_->lazily_build_dependencies_ )
        {
          v56 = v138;
        }
        else
        {
          p_state = &v9->dependencies_once_->state_;
          if ( p_state && *p_state != 2 )
          {
            LOBYTE(v157.uninterpreted_option_) = 0;
            v157.builder_ = (google::protobuf::DescriptorBuilder *)&off_1A17BFB8;
            v157.options_to_interpret_ = (const google::protobuf::`anonymous namespace'::OptionsToInterpret *)google::protobuf::FileDescriptor::DependenciesOnceInit;
            v157.dynamic_factory_._vptr_MessageFactory = (int (**)(...))v9;
            google::protobuf::GoogleOnceInitImpl(p_state, (google::protobuf::Closure *)&v157);
            v157.builder_ = (google::protobuf::DescriptorBuilder *)&off_1A17BFB8;
            google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&v157);
          }
          v157.builder_ = (google::protobuf::DescriptorBuilder *)v9->dependencies_[v57];
          std::_Rb_tree<google::protobuf::FileDescriptor const*,google::protobuf::FileDescriptor const*,std::_Identity<google::protobuf::FileDescriptor const*>,std::less<google::protobuf::FileDescriptor const*>,std::allocator<google::protobuf::FileDescriptor const*>>::erase(
            p_M_t,
            (const google::protobuf::FileDescriptor *const *)&v157);
          v56 = v138;
        }
      }
      ++v55;
    }
    while ( v55 < v4->public_dependency_.current_size_ );
  }
  v9->public_dependency_count_ = v56;
  std::_Rb_tree<google::protobuf::FileDescriptor const*,google::protobuf::FileDescriptor const*,std::_Identity<google::protobuf::FileDescriptor const*>,std::less<google::protobuf::FileDescriptor const*>,std::allocator<google::protobuf::FileDescriptor const*>>::_M_erase(
    &v3->dependencies_._M_t,
    (std::_Rb_tree<const google::protobuf::FileDescriptor*,const google::protobuf::FileDescriptor*,std::_Identity<const google::protobuf::FileDescriptor*>,std::less<const google::protobuf::FileDescriptor*>,std::allocator<const google::protobuf::FileDescriptor*> >::_Link_type)v3->dependencies_._M_t._M_impl._M_header._M_parent);
  v3->dependencies_._M_t._M_impl._M_header._M_parent = 0LL;
  v3->dependencies_._M_t._M_impl._M_header._M_left = &v3->dependencies_._M_t._M_impl._M_header;
  v3->dependencies_._M_t._M_impl._M_header._M_right = &v3->dependencies_._M_t._M_impl._M_header;
  v59 = v3->pool_;
  v3->dependencies_._M_t._M_impl._M_node_count = 0LL;
  if ( !v59->lazily_build_dependencies_ && v9->dependency_count_ > 0 )
  {
    v60 = 0LL;
    do
    {
      v61 = &v9->dependencies_once_->state_;
      if ( v61 && *v61 != 2 )
      {
        LOBYTE(v157.uninterpreted_option_) = 0;
        v157.builder_ = (google::protobuf::DescriptorBuilder *)&off_1A17BFB8;
        v157.options_to_interpret_ = (const google::protobuf::`anonymous namespace'::OptionsToInterpret *)google::protobuf::FileDescriptor::DependenciesOnceInit;
        v157.dynamic_factory_._vptr_MessageFactory = (int (**)(...))v9;
        google::protobuf::GoogleOnceInitImpl(v61, (google::protobuf::Closure *)&v157);
        v157.builder_ = (google::protobuf::DescriptorBuilder *)&off_1A17BFB8;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&v157);
      }
      google::protobuf::DescriptorBuilder::RecordPublicDependencies(
        v3,
        (google::protobuf::FileDescriptor *)v9->dependencies_[v60++]);
    }
    while ( v9->dependency_count_ > (int)v60 );
  }
  v62 = (int *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                 v3->tables_,
                 4 * v4->weak_dependency_.current_size_);
  v63 = v4->weak_dependency_.current_size_;
  v9->weak_dependencies_ = v62;
  v64 = 0;
  v65 = 0;
  if ( v63 > 0 )
  {
    do
    {
      while ( 1 )
      {
        v67 = v4->weak_dependency_.rep_->elements[v64];
        if ( v67 < 0 || v67 >= v4->dependency_.current_size_ )
          break;
        v66 = v65;
        ++v64;
        ++v65;
        v9->weak_dependencies_[v66] = v67;
        if ( v64 >= v4->weak_dependency_.current_size_ )
          goto LABEL_87;
      }
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)v3,
        v4->name_.ptr_,
        (__int64)v4,
        9u,
        "Invalid weak dependency index.");
      ++v64;
    }
    while ( v64 < v4->weak_dependency_.current_size_ );
  }
  else
  {
    v65 = 0;
  }
LABEL_87:
  v9->weak_dependency_count_ = v65;
  v68 = v4->message_type_.current_size_;
  v69 = v3->tables_;
  v9->message_type_count_ = v68;
  message_types = (google::protobuf::Descriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                    v69,
                                                    144 * v68);
  v71 = v4->message_type_.current_size_;
  v9->message_types_ = message_types;
  if ( v71 > 0 )
  {
    v72 = 0LL;
    while ( 1 )
    {
      google::protobuf::DescriptorBuilder::BuildMessage(
        v3,
        (const google::protobuf::DescriptorProto *)v4->message_type_.rep_->elements[(int)v72],
        0LL,
        &message_types[v72]);
      if ( v4->message_type_.current_size_ <= (int)++v72 )
        break;
      message_types = v9->message_types_;
    }
  }
  v73 = v4->enum_type_.current_size_;
  v74 = v3->tables_;
  v9->enum_type_count_ = v73;
  enum_types = (google::protobuf::EnumDescriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                     v74,
                                                     56 * v73);
  LODWORD(v74) = v4->enum_type_.current_size_;
  v9->enum_types_ = enum_types;
  if ( (int)v74 > 0 )
  {
    v76 = 0LL;
    while ( 1 )
    {
      google::protobuf::DescriptorBuilder::BuildEnum(
        v3,
        (const google::protobuf::EnumDescriptorProto *)v4->enum_type_.rep_->elements[(int)v76],
        0LL,
        &enum_types[v76]);
      if ( v4->enum_type_.current_size_ <= (int)++v76 )
        break;
      enum_types = v9->enum_types_;
    }
  }
  v77 = v4->service_.current_size_;
  v78 = v3->tables_;
  v9->service_count_ = v77;
  services = (google::protobuf::ServiceDescriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                      v78,
                                                      48 * v77);
  v80 = v4->service_.current_size_;
  v9->services_ = services;
  if ( v80 > 0 )
  {
    v81 = 0LL;
    while ( 1 )
    {
      google::protobuf::DescriptorBuilder::BuildService(
        v3,
        (const google::protobuf::ServiceDescriptorProto *)v4->service_.rep_->elements[(int)v81],
        0LL,
        &services[v81]);
      if ( v4->service_.current_size_ <= (int)++v81 )
        break;
      services = v9->services_;
    }
  }
  v82 = v4->extension_.current_size_;
  v83 = v3->tables_;
  v9->extension_count_ = v82;
  extensions = (google::protobuf::FieldDescriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                      v83,
                                                      152 * v82);
  v85 = v4->extension_.current_size_;
  v9->extensions_ = extensions;
  if ( v85 > 0 )
  {
    v86 = 0LL;
    v87 = 0;
    while ( 1 )
    {
      google::protobuf::DescriptorBuilder::BuildFieldOrExtension(
        v3,
        (const google::protobuf::FieldDescriptorProto *)v4->extension_.rep_->elements[v87++],
        0LL,
        &extensions[v86++],
        1);
      if ( v87 >= v4->extension_.current_size_ )
        break;
      extensions = v9->extensions_;
    }
  }
  if ( (v4->_has_bits_.has_bits_[0] & 8) != 0 )
  {
    options = v4->options_;
    if ( !options )
      options = (const google::protobuf::FileOptions *)&google::protobuf::_FileOptions_default_instance_;
    google::protobuf::DescriptorBuilder::AllocateOptions(v3, options, v9, (std::forward_iterator_tag)v85);
  }
  else
  {
    v9->options_ = 0LL;
  }
  google::protobuf::DescriptorBuilder::CrossLinkFile(v3, v9, v4);
  if ( v3->had_errors_ )
    goto LABEL_106;
  google::protobuf::DescriptorBuilder::OptionInterpreter::OptionInterpreter(&v157, v3);
  M_start = v3->options_to_interpret_._M_impl._M_start;
  if ( M_start != v3->options_to_interpret_._M_impl._M_finish )
  {
    do
    {
      v104 = M_start->options;
      original_options = M_start->original_options;
      v157.options_to_interpret_ = M_start;
      v106 = (const google::protobuf::Descriptor *)(*((__int64 (__fastcall **)(google::protobuf::Message *))v104->_vptr_MessageLite
                                                    + 24))(v104);
      *(_QWORD *)&key.level_ = &key.line_;
      std::string::_M_construct<char const*>((std::string *const)&key, "uninterpreted_option", "", v107);
      FieldByName = google::protobuf::Descriptor::FindFieldByName(v106, (const std::string *)&key);
      if ( *(google::protobuf::internal::LogMessage_0 **)&key.level_ != (google::protobuf::internal::LogMessage_0 *)&key.line_ )
        operator delete(*(void **)&key.level_);
      if ( !FieldByName )
      {
        google::protobuf::internal::LogMessage::LogMessage(
          &key,
          LOGLEVEL_FATAL_0,
          "google/protobuf/descriptor.cc",
          6017);
        v125 = google::protobuf::internal::LogMessage::operator<<(
                 &key,
                 "CHECK failed: uninterpreted_options_field != NULL: ");
        v126 = google::protobuf::internal::LogMessage::operator<<(
                 v125,
                 "No field named \"uninterpreted_option\" in the Options proto.");
        google::protobuf::internal::LogFinisher::operator=(v152, v126);
        google::protobuf::internal::LogMessage::~LogMessage(&key);
      }
      v109 = (const google::protobuf::Message::Reflection *(__fastcall *)(const google::protobuf::Message *const))*((_QWORD *)v104->_vptr_MessageLite + 23);
      if ( v109 == google::protobuf::Message::GetReflection )
      {
        (*((void (__fastcall **)(google::protobuf::Message *))v104->_vptr_MessageLite + 24))(v104);
        v111 = v110;
      }
      else
      {
        v111 = (__int64)v109(v104);
      }
      (*(void (__fastcall **)(__int64, google::protobuf::Message *, const google::protobuf::FieldDescriptor *))(*(_QWORD *)v111 + 56LL))(
        v111,
        v104,
        FieldByName);
      v112 = (const google::protobuf::Descriptor *)(*((__int64 (__fastcall **)(const google::protobuf::Message *))original_options->_vptr_MessageLite
                                                    + 24))(original_options);
      *(_QWORD *)&key.level_ = &key.line_;
      std::string::_M_construct<char const*>((std::string *const)&key, "uninterpreted_option", "", v113);
      v139 = google::protobuf::Descriptor::FindFieldByName(v112, (const std::string *)&key);
      if ( *(google::protobuf::internal::LogMessage_0 **)&key.level_ != (google::protobuf::internal::LogMessage_0 *)&key.line_ )
        operator delete(*(void **)&key.level_);
      if ( !v139 )
      {
        google::protobuf::internal::LogMessage::LogMessage(
          &key,
          LOGLEVEL_FATAL_0,
          "google/protobuf/descriptor.cc",
          6025);
        v127 = google::protobuf::internal::LogMessage::operator<<(
                 &key,
                 "CHECK failed: original_uninterpreted_options_field != NULL: ");
        v128 = google::protobuf::internal::LogMessage::operator<<(
                 v127,
                 "No field named \"uninterpreted_option\" in the Options proto.");
        google::protobuf::internal::LogFinisher::operator=(v152, v128);
        google::protobuf::internal::LogMessage::~LogMessage(&key);
      }
      v114 = (const google::protobuf::Message::Reflection *(__fastcall *)(const google::protobuf::Message *const))*((_QWORD *)original_options->_vptr_MessageLite + 23);
      if ( v114 == google::protobuf::Message::GetReflection )
      {
        (*((void (__fastcall **)(const google::protobuf::Message *))original_options->_vptr_MessageLite + 24))(original_options);
        v116 = v115;
      }
      else
      {
        v116 = (__int64)v114(original_options);
      }
      v143 = (*(__int64 (__fastcall **)(__int64, const google::protobuf::Message *, const google::protobuf::FieldDescriptor *))(*(_QWORD *)v116 + 48LL))(
               v116,
               original_options,
               v139);
      if ( v143 <= 0 )
      {
LABEL_164:
        v157.uninterpreted_option_ = 0LL;
        v157.options_to_interpret_ = 0LL;
        v150[0] = v151;
        v150[1] = 0LL;
        v151[0] = 0;
        if ( !(unsigned __int8)google::protobuf::MessageLite::AppendPartialToString((unsigned __int64)v104) )
        {
          google::protobuf::internal::LogMessage::LogMessage(
            &key,
            LOGLEVEL_FATAL_0,
            "google/protobuf/descriptor.cc",
            6054);
          v129 = google::protobuf::internal::LogMessage::operator<<(
                   &key,
                   "CHECK failed: options->AppendPartialToString(&buf): ");
          v130 = google::protobuf::internal::LogMessage::operator<<(v129, "Protocol message could not be serialized.");
          google::protobuf::internal::LogFinisher::operator=(v152, v130);
          google::protobuf::internal::LogMessage::~LogMessage(&key);
        }
        if ( !(unsigned __int8)google::protobuf::MessageLite::ParsePartialFromString(v104, v150) )
        {
          google::protobuf::internal::LogMessage::LogMessage(
            &key,
            LOGLEVEL_FATAL_0,
            "google/protobuf/descriptor.cc",
            6056);
          v131 = google::protobuf::internal::LogMessage::operator<<(
                   &key,
                   "CHECK failed: options->ParsePartialFromString(buf): ");
          v132 = google::protobuf::internal::LogMessage::operator<<(
                   v131,
                   "Protocol message serialized itself in invalid fashion.");
          google::protobuf::internal::LogFinisher::operator=(v152, v132);
          google::protobuf::internal::LogMessage::~LogMessage(&key);
        }
        if ( !(*((unsigned __int8 (__fastcall **)(google::protobuf::Message *))v104->_vptr_MessageLite + 8))(v104) )
        {
          v140 = v157.builder_;
          (*((void (__fastcall **)(google::protobuf::internal::LogFinisher *, google::protobuf::Message *))v104->_vptr_MessageLite
           + 9))(
            v152,
            v104);
          v121 = std::string::_M_replace(
                   v152,
                   0LL,
                   0LL,
                   "Options could not be fully parsed using the proto descriptors compiled into this binary. Missing required fields: ",
                   114LL);
          *(_QWORD *)&key.level_ = &key.line_;
          if ( *(_QWORD *)v121 == v121 + 16 )
          {
            *(__m128i *)&key.line_ = _mm_loadu_si128((const __m128i *)(v121 + 16));
          }
          else
          {
            *(_QWORD *)&key.level_ = *(_QWORD *)v121;
            *(_QWORD *)&key.line_ = *(_QWORD *)(v121 + 16);
          }
          key.filename_ = *(const char **)(v121 + 8);
          *(_QWORD *)v121 = v121 + 16;
          *(_QWORD *)(v121 + 8) = 0LL;
          *(_BYTE *)(v121 + 16) = 0;
          google::protobuf::DescriptorBuilder::AddWarning(
            (__int64)v140,
            &M_start->element_name,
            original_options,
            OTHER,
            (const std::string *)&key);
          if ( *(google::protobuf::internal::LogMessage_0 **)&key.level_ != (google::protobuf::internal::LogMessage_0 *)&key.line_ )
            operator delete(*(void **)&key.level_);
          if ( *(char **)v152[0].gap0 != &v153 )
            operator delete(*(void **)v152[0].gap0);
        }
        if ( v150[0] != v151 )
          operator delete(v150[0]);
      }
      else
      {
        v117 = 0;
        while ( 1 )
        {
          v120 = (const google::protobuf::Message::Reflection *(__fastcall *)(const google::protobuf::Message *const))*((_QWORD *)original_options->_vptr_MessageLite + 23);
          if ( v120 == google::protobuf::Message::GetReflection )
          {
            (*((void (__fastcall **)(const google::protobuf::Message *))original_options->_vptr_MessageLite + 24))(original_options);
            v119 = v118;
          }
          else
          {
            v119 = (__int64)v120(original_options);
          }
          v157.uninterpreted_option_ = (const google::protobuf::UninterpretedOption *)(*(__int64 (__fastcall **)(__int64, const google::protobuf::Message *, const google::protobuf::FieldDescriptor *, _QWORD))(*(_QWORD *)v119 + 416LL))(
                                                                                        v119,
                                                                                        original_options,
                                                                                        v139,
                                                                                        v117);
          if ( !(unsigned __int8)google::protobuf::DescriptorBuilder::OptionInterpreter::InterpretSingleOption(
                                   &v157,
                                   v104) )
            break;
          if ( v143 == ++v117 )
            goto LABEL_164;
        }
        v157.uninterpreted_option_ = 0LL;
        v157.options_to_interpret_ = 0LL;
      }
      ++M_start;
    }
    while ( v3->options_to_interpret_._M_impl._M_finish != M_start );
    v122 = v3->options_to_interpret_._M_impl._M_start;
    v123 = v122;
    if ( M_start != v122 )
    {
      do
      {
        v124 = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v123->element_name._M_dataplus._M_p;
        if ( v124 != &v123->element_name._anon_0 )
          operator delete(v124);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v123->name_scope._M_dataplus._M_p != &v123->name_scope._anon_0 )
          operator delete(v123->name_scope._M_dataplus._M_p);
        ++v123;
      }
      while ( M_start != v123 );
      v3->options_to_interpret_._M_impl._M_finish = v122;
    }
  }
  google::protobuf::DynamicMessageFactory::~DynamicMessageFactory(&v157.dynamic_factory_);
  if ( v3->had_errors_ )
    goto LABEL_106;
  if ( !v3->pool_->lazily_build_dependencies_ )
  {
    google::protobuf::DescriptorBuilder::ValidateFileOptions(v3, v9, v4);
    if ( !v3->had_errors_ )
    {
      if ( !v3->unused_dependency_._M_t._M_impl._M_node_count )
        goto LABEL_110;
LABEL_142:
      if ( !v3->pool_->lazily_build_dependencies_ )
        google::protobuf::DescriptorBuilder::LogUnusedDependency(v3, v4, v9);
      goto LABEL_109;
    }
LABEL_106:
    v88 = 0LL;
    v89 = 0;
    if ( v4->message_type_.current_size_ <= 0 )
    {
      if ( !v3->unused_dependency_._M_t._M_impl._M_node_count )
        goto LABEL_116;
    }
    else
    {
      do
        google::protobuf::DescriptorBuilder::DetectMapConflicts(
          v3,
          &v9->message_types_[v88++],
          (const google::protobuf::DescriptorProto *)v4->message_type_.rep_->elements[v89++]);
      while ( v89 < v4->message_type_.current_size_ );
      if ( !v3->unused_dependency_._M_t._M_impl._M_node_count )
        goto LABEL_109;
    }
    goto LABEL_142;
  }
  if ( !v3->unused_dependency_._M_t._M_impl._M_node_count )
    goto LABEL_110;
LABEL_109:
  if ( !v3->had_errors_ )
  {
LABEL_110:
    v90 = v3->tables_;
    v91 = (__int64)&v90->checkpoints_._M_impl._M_finish[-1];
    v90->checkpoints_._M_impl._M_finish = (std::_Vector_base<google::protobuf::DescriptorPool::Tables::CheckPoint>::pointer)v91;
    if ( (std::_Vector_base<google::protobuf::DescriptorPool::Tables::CheckPoint>::pointer)v91 == v90->checkpoints_._M_impl._M_start )
    {
      v133 = v90->symbols_after_checkpoint_._M_impl._M_start;
      if ( v133 != v90->symbols_after_checkpoint_._M_impl._M_finish )
        v90->symbols_after_checkpoint_._M_impl._M_finish = v133;
      v134 = v90->files_after_checkpoint_._M_impl._M_start;
      if ( v134 != v90->files_after_checkpoint_._M_impl._M_finish )
        v90->files_after_checkpoint_._M_impl._M_finish = v134;
      v135 = v90->extensions_after_checkpoint_._M_impl._M_start;
      if ( v135 != v90->extensions_after_checkpoint_._M_impl._M_finish )
        v90->extensions_after_checkpoint_._M_impl._M_finish = v135;
    }
    v9->finished_building_ = 1;
    goto LABEL_117;
  }
LABEL_116:
  google::protobuf::DescriptorPool::Tables::RollbackToLastCheckpoint(v3->tables_);
  v9 = 0LL;
LABEL_117:
  std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int>>::_M_erase(
    &v155,
    (std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> >::_Link_type)v155._M_impl._M_header._M_parent);
  std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_erase(
    &v154,
    (std::_Rb_tree<std::string,std::string,std::_Identity<std::string >,std::less<std::string >,std::allocator<std::string > >::_Link_type)v154._M_impl._M_header._M_parent);
  return v9;
};

// Line 4339: range 000000000C906980-000000000C907E7B
void __fastcall google::protobuf::DescriptorBuilder::BuildMessage(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::DescriptorProto *a2,
        const google::protobuf::Descriptor *a3,
        google::protobuf::Descriptor *a4)
{
  const std::string *full_name; // rsi
  std::string *String; // rax
  std::string::size_type M_string_length; // rsi
  const std::string *v10; // r15
  std::string *v11; // rax
  google::protobuf::FileDescriptor *file; // rax
  google::protobuf::DescriptorPool::Tables *tables; // rdi
  google::protobuf::OneofDescriptor *Bytes; // rax
  int current_size; // r8d
  __int64 v16; // rcx
  __int64 v17; // r15
  int v18; // eax
  google::protobuf::FieldDescriptor *v19; // rax
  int v20; // esi
  __int64 v21; // r14
  google::protobuf::FieldDescriptor *i; // rcx
  google::protobuf::FieldDescriptor *v23; // rcx
  int v24; // eax
  google::protobuf::Descriptor *nested_types; // rax
  int v26; // ecx
  __int64 v27; // rdx
  __int64 v28; // r15
  int v29; // eax
  google::protobuf::EnumDescriptor *enum_types; // rax
  int v31; // edx
  __int64 v32; // rdx
  __int64 v33; // r15
  int v34; // esi
  google::protobuf::Descriptor::ExtensionRange *extension_ranges; // rax
  int v36; // r15d
  __int64 v37; // rdx
  __int64 v38; // r15
  int v39; // eax
  google::protobuf::FieldDescriptor *v40; // rax
  int v41; // r14d
  __int64 v42; // r14
  google::protobuf::FieldDescriptor *j; // rcx
  google::protobuf::FieldDescriptor *v44; // rcx
  int v45; // eax
  google::protobuf::Descriptor::ReservedRange *reserved_ranges; // rax
  int v47; // r11d
  __int64 v48; // r15
  google::protobuf::Descriptor::ReservedRange *v49; // rcx
  _DWORD *v50; // rdx
  int v51; // eax
  int v52; // r15d
  const std::string **reserved_names; // rax
  __int64 v54; // r9
  int v55; // ecx
  int v56; // r14d
  google::protobuf::internal::RepeatedPtrFieldBase::Rep *rep; // rax
  __int64 v58; // rdx
  _DWORD *v59; // r13
  _DWORD *v60; // r15
  int v61; // eax
  int v62; // r8d
  int v63; // r13d
  char *M_p; // rax
  const std::string *v65; // r14
  google::protobuf::FieldDescriptor *n; // r13
  google::protobuf::int32 number; // edi
  google::protobuf::Descriptor::ExtensionRange *v68; // r14
  const char *v69; // rdx
  int end; // eax
  google::protobuf::int32 v71; // edi
  google::protobuf::Descriptor::ReservedRange *v72; // rax
  char *v73; // rdx
  char **p_M_p; // rax
  char *v75; // rdx
  char *v76; // rax
  __int64 v77; // r13
  google::protobuf::Descriptor::ReservedRange *v78; // r14
  int v79; // eax
  int v80; // r13d
  __int64 v81; // r15
  int extension_range_count; // eax
  google::protobuf::Descriptor::ExtensionRange *v83; // r14
  int v84; // ecx
  google::protobuf::MessageOptions *options; // rcx
  __int128 v86; // [rsp-10h] [rbp-2C0h]
  std::true_type v87; // [rsp+0h] [rbp-2B0h]
  __int64 v88; // [rsp+10h] [rbp-2A0h]
  __int64 v89; // [rsp+18h] [rbp-298h]
  int v90; // [rsp+20h] [rbp-290h]
  int m; // [rsp+20h] [rbp-290h]
  __int64 v92; // [rsp+20h] [rbp-290h]
  int v94; // [rsp+38h] [rbp-278h]
  int v95; // [rsp+38h] [rbp-278h]
  __int64 k; // [rsp+38h] [rbp-278h]
  int v97; // [rsp+38h] [rbp-278h]
  __int64 v98; // [rsp+38h] [rbp-278h]
  __int64 ii; // [rsp+38h] [rbp-278h]
  google::protobuf::Descriptor::ExtensionRange *jj; // [rsp+38h] [rbp-278h]
  std::string v101; // [rsp+40h] [rbp-270h] BYREF
  std::string v102; // [rsp+60h] [rbp-250h] BYREF
  char *v103; // [rsp+90h] [rbp-220h] BYREF
  int v104; // [rsp+98h] [rbp-218h]
  char v105[36]; // [rsp+9Ch] [rbp-214h] BYREF
  char *v106; // [rsp+C0h] [rbp-1F0h] BYREF
  int v107; // [rsp+C8h] [rbp-1E8h]
  char v108[36]; // [rsp+CCh] [rbp-1E4h] BYREF
  char *v109; // [rsp+F0h] [rbp-1C0h] BYREF
  int v110; // [rsp+F8h] [rbp-1B8h]
  char v111[36]; // [rsp+FCh] [rbp-1B4h] BYREF
  char *v112; // [rsp+120h] [rbp-190h] BYREF
  int v113; // [rsp+128h] [rbp-188h]
  char buffer[36]; // [rsp+12Ch] [rbp-184h] BYREF
  __int64 v115; // [rsp+150h] [rbp-160h] BYREF
  int v116; // [rsp+158h] [rbp-158h]
  __int64 v117; // [rsp+180h] [rbp-130h] BYREF
  int v118; // [rsp+188h] [rbp-128h]
  __int64 v119; // [rsp+1B0h] [rbp-100h] BYREF
  int v120; // [rsp+1B8h] [rbp-F8h]
  __int64 v121; // [rsp+1E0h] [rbp-D0h] BYREF
  int v122; // [rsp+1E8h] [rbp-C8h]
  std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::string,true> > > __node_gen; // [rsp+210h] [rbp-A0h] BYREF
  int v124; // [rsp+218h] [rbp-98h]
  std::_Hashtable<std::string,std::string,std::allocator<std::string >,std::__detail::_Identity,std::equal_to<std::string >,google::protobuf::hash<std::string >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true> > v125[2]; // [rsp+240h] [rbp-70h] BYREF

  if ( a3 )
    full_name = a3->full_name_;
  else
    full_name = this->file_->package_;
  String = google::protobuf::DescriptorPool::Tables::AllocateString(
             (std::vector<std::string*> *)this->tables_,
             (__int64)full_name);
  M_string_length = String->_M_string_length;
  v10 = String;
  if ( M_string_length )
    std::string::_M_replace_aux(String, M_string_length, 0LL, 1LL, 46LL);
  std::string::_M_append(v10, a2->name_.ptr_->_M_dataplus._M_p, a2->name_.ptr_->_M_string_length);
  google::protobuf::DescriptorBuilder::ValidateSymbolName((__int64)this, a2->name_.ptr_, v10, (__int64)a2);
  v11 = google::protobuf::DescriptorPool::Tables::AllocateString(
          (std::vector<std::string*> *)this->tables_,
          (__int64)a2->name_.ptr_);
  a4->full_name_ = v10;
  a4->name_ = v11;
  file = this->file_;
  *(_WORD *)&a4->is_placeholder_ = 0;
  tables = this->tables_;
  a4->file_ = file;
  LODWORD(file) = a2->oneof_decl_.current_size_;
  a4->containing_type_ = a3;
  a4->oneof_decl_count_ = (int)file;
  Bytes = (google::protobuf::OneofDescriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                 tables,
                                                 48 * a2->oneof_decl_.current_size_);
  current_size = a2->oneof_decl_.current_size_;
  a4->oneof_decls_ = Bytes;
  if ( current_size > 0 )
  {
    v16 = 0LL;
    while ( 1 )
    {
      v17 = v16 + 1;
      google::protobuf::DescriptorBuilder::BuildOneof(
        this,
        (const google::protobuf::OneofDescriptorProto *)a2->oneof_decl_.rep_->elements[(int)v16],
        a4,
        &Bytes[v16]);
      v16 = v17;
      if ( a2->oneof_decl_.current_size_ <= (int)v17 )
        break;
      Bytes = a4->oneof_decls_;
    }
  }
  v18 = a2->field_.current_size_;
  a4->field_count_ = v18;
  v19 = (google::protobuf::FieldDescriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                               this->tables_,
                                               152 * v18);
  v20 = a2->field_.current_size_;
  a4->fields_ = v19;
  if ( v20 > 0 )
  {
    v21 = 0LL;
    v94 = 0;
    for ( i = v19; ; i = a4->fields_ )
    {
      v23 = &i[v21++];
      google::protobuf::DescriptorBuilder::BuildFieldOrExtension(
        this,
        (const google::protobuf::FieldDescriptorProto *)a2->field_.rep_->elements[v94++],
        a4,
        v23,
        0);
      if ( a2->field_.current_size_ <= v94 )
        break;
    }
  }
  v24 = a2->nested_type_.current_size_;
  a4->nested_type_count_ = v24;
  nested_types = (google::protobuf::Descriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                   this->tables_,
                                                   144 * v24);
  v26 = a2->nested_type_.current_size_;
  a4->nested_types_ = nested_types;
  if ( v26 > 0 )
  {
    v27 = 0LL;
    while ( 1 )
    {
      v28 = v27 + 1;
      google::protobuf::DescriptorBuilder::BuildMessage(
        this,
        (const google::protobuf::DescriptorProto *)a2->nested_type_.rep_->elements[(int)v27],
        a4,
        &nested_types[v27]);
      v27 = v28;
      if ( a2->nested_type_.current_size_ <= (int)v28 )
        break;
      nested_types = a4->nested_types_;
    }
  }
  v29 = a2->enum_type_.current_size_;
  a4->enum_type_count_ = v29;
  enum_types = (google::protobuf::EnumDescriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                     this->tables_,
                                                     56 * v29);
  v31 = a2->enum_type_.current_size_;
  a4->enum_types_ = enum_types;
  if ( v31 > 0 )
  {
    v32 = 0LL;
    while ( 1 )
    {
      v33 = v32 + 1;
      google::protobuf::DescriptorBuilder::BuildEnum(
        this,
        (const google::protobuf::EnumDescriptorProto *)a2->enum_type_.rep_->elements[(int)v32],
        a4,
        &enum_types[v32]);
      v32 = v33;
      if ( a2->enum_type_.current_size_ <= (int)v33 )
        break;
      enum_types = a4->enum_types_;
    }
  }
  v34 = a2->extension_range_.current_size_;
  a4->extension_range_count_ = v34;
  extension_ranges = (google::protobuf::Descriptor::ExtensionRange *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                                       this->tables_,
                                                                       16 * v34);
  v36 = a2->extension_range_.current_size_;
  a4->extension_ranges_ = extension_ranges;
  if ( v36 > 0 )
  {
    v37 = 0LL;
    while ( 1 )
    {
      v38 = v37 + 1;
      google::protobuf::DescriptorBuilder::BuildExtensionRange(
        this,
        (const google::protobuf::DescriptorProto::ExtensionRange *)a2->extension_range_.rep_->elements[(int)v37],
        a4,
        &extension_ranges[v37]);
      v37 = v38;
      if ( a2->extension_range_.current_size_ <= (int)v38 )
        break;
      extension_ranges = a4->extension_ranges_;
    }
  }
  v39 = a2->extension_.current_size_;
  a4->extension_count_ = v39;
  v40 = (google::protobuf::FieldDescriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                               this->tables_,
                                               152 * v39);
  v41 = a2->extension_.current_size_;
  a4->extensions_ = v40;
  if ( v41 > 0 )
  {
    v42 = 0LL;
    v95 = 0;
    for ( j = v40; ; j = a4->extensions_ )
    {
      v44 = &j[v42++];
      google::protobuf::DescriptorBuilder::BuildFieldOrExtension(
        this,
        (const google::protobuf::FieldDescriptorProto *)a2->extension_.rep_->elements[v95++],
        a4,
        v44,
        1);
      if ( v95 >= a2->extension_.current_size_ )
        break;
    }
  }
  v45 = a2->reserved_range_.current_size_;
  a4->reserved_range_count_ = v45;
  reserved_ranges = (google::protobuf::Descriptor::ReservedRange *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                                     this->tables_,
                                                                     8 * v45);
  v47 = a2->reserved_range_.current_size_;
  a4->reserved_ranges_ = reserved_ranges;
  if ( v47 > 0 )
  {
    v48 = 0LL;
    while ( 1 )
    {
      v49 = &reserved_ranges[v48];
      v50 = a2->reserved_range_.rep_->elements[(int)v48];
      v51 = v50[6];
      v49->start = v51;
      v49->end = v50[7];
      if ( v51 <= 0 )
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)this,
          a4->full_name_,
          (__int64)v50,
          1u,
          "Reserved numbers must be positive integers.");
      if ( a2->reserved_range_.current_size_ <= (int)++v48 )
        break;
      reserved_ranges = a4->reserved_ranges_;
    }
  }
  v52 = a2->reserved_name_.current_size_;
  a4->reserved_name_count_ = v52;
  reserved_names = (const std::string **)google::protobuf::DescriptorPool::Tables::AllocateBytes(this->tables_, 8 * v52);
  a4->reserved_names_ = reserved_names;
  if ( v52 > 0 )
  {
    for ( k = 0LL; ; ++k )
    {
      reserved_names[k] = google::protobuf::DescriptorPool::Tables::AllocateString(
                            (std::vector<std::string*> *)this->tables_,
                            (__int64)a2->reserved_name_.rep_->elements[(int)k]);
      if ( v52 - 1 == k )
        break;
      reserved_names = a4->reserved_names_;
    }
  }
  if ( (a2->_has_bits_.has_bits_[0] & 2) != 0 )
  {
    options = a2->options_;
    if ( !options )
      options = (google::protobuf::MessageOptions *)&google::protobuf::_MessageOptions_default_instance_;
    google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::Descriptor>(
      this,
      a4->full_name_,
      a4->full_name_,
      options,
      a4);
  }
  else
  {
    a4->options_ = 0LL;
  }
  *((_QWORD *)&v86 + 1) = a4;
  *(_QWORD *)&v86 = 1LL;
  google::protobuf::DescriptorBuilder::AddSymbol(
    (__int64)this,
    (std::string *)a4->full_name_,
    (__int64)a3,
    (const char **)&a4->name_->_M_dataplus._M_p,
    (__int64)a2,
    v54,
    v86);
  v55 = a2->reserved_range_.current_size_;
  if ( v55 > 0 )
  {
    v56 = 0;
    do
    {
      rep = a2->reserved_range_.rep_;
      v58 = v56;
      v90 = v56++;
      v59 = rep->elements[v58];
      if ( v56 >= v55 )
        break;
      v97 = v56;
      while ( 1 )
      {
        v60 = rep->elements[v97];
        if ( v60[6] < v59[7] && v59[6] < v60[7] )
        {
          LODWORD(v125[0]._M_bucket_count) = -1;
          v124 = -1;
          v122 = -1;
          v120 = -1;
          v118 = -1;
          v116 = -1;
          v61 = v59[7];
          v125[0]._M_buckets = 0LL;
          __node_gen._M_h = 0LL;
          v121 = 0LL;
          v119 = 0LL;
          v117 = 0LL;
          v115 = 0LL;
          v112 = google::protobuf::FastInt32ToBuffer(v61 - 1, buffer);
          v113 = strlen(v112);
          v109 = google::protobuf::FastInt32ToBuffer(v59[6], v111);
          v110 = strlen(v109);
          v106 = google::protobuf::FastInt32ToBuffer(v60[7] - 1, v108);
          v107 = strlen(v106);
          v103 = google::protobuf::FastInt32ToBuffer(v60[6], v105);
          v104 = strlen(v103);
          google::protobuf::strings::Substitute[abi:cxx11](
            (unsigned int)&v102,
            (unsigned int)"Reserved range $0 to $1 overlaps with already-defined range $2 to $3.",
            (unsigned int)&v103,
            (unsigned int)&v106,
            (unsigned int)&v109,
            (unsigned int)&v112,
            (__int64)&v115,
            (__int64)&v117,
            (__int64)&v119,
            (__int64)&v121,
            (__int64)&__node_gen,
            (__int64)v125);
          google::protobuf::DescriptorBuilder::AddError(
            (__int64)this,
            a4->full_name_,
            (__int64)a2->reserved_range_.rep_->elements[v90],
            1u,
            &v102);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v102._M_dataplus._M_p != &v102._anon_0 )
            operator delete(v102._M_dataplus._M_p);
          v55 = a2->reserved_range_.current_size_;
        }
        if ( ++v97 >= v55 )
          break;
        rep = a2->reserved_range_.rep_;
      }
    }
    while ( v56 < v55 );
  }
  v62 = a2->reserved_name_.current_size_;
  v125[0]._M_bucket_count = 1LL;
  v63 = 0;
  v125[0]._M_buckets = &v125[0]._M_single_bucket;
  v125[0]._M_before_begin._M_nxt = 0LL;
  v125[0]._M_element_count = 0LL;
  v125[0]._M_rehash_policy._M_max_load_factor = 1.0;
  v125[0]._M_rehash_policy._M_next_resize = 0LL;
  v125[0]._M_single_bucket = 0LL;
  if ( v62 > 0 )
  {
    do
    {
      while ( 1 )
      {
        v65 = (const std::string *)a2->reserved_name_.rep_->elements[v63];
        if ( std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::find(
               v125,
               v65)._M_cur )
          break;
        __node_gen._M_h = (std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::string,true> > >::__hashtable_alloc *)v125;
        std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::_M_insert<std::string const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::string,true>>>>(
          v125,
          v65,
          &__node_gen,
          v87,
          1uLL);
        if ( ++v63 >= a2->reserved_name_.current_size_ )
          goto LABEL_60;
      }
      __node_gen._M_h = 0LL;
      v121 = 0LL;
      v119 = 0LL;
      v117 = 0LL;
      v115 = 0LL;
      v112 = 0LL;
      v109 = 0LL;
      v106 = 0LL;
      v103 = 0LL;
      M_p = v65->_M_dataplus._M_p;
      v124 = -1;
      v102._M_dataplus._M_p = M_p;
      LODWORD(v102._M_string_length) = v65->_M_string_length;
      v122 = -1;
      v120 = -1;
      v118 = -1;
      v116 = -1;
      v113 = -1;
      v110 = -1;
      v107 = -1;
      v104 = -1;
      google::protobuf::strings::Substitute[abi:cxx11](
        (unsigned int)&v101,
        (unsigned int)"Field name \"$0\" is reserved multiple times.",
        (unsigned int)&v102,
        (unsigned int)&v103,
        (unsigned int)&v106,
        (unsigned int)&v109,
        (__int64)&v112,
        (__int64)&v115,
        (__int64)&v117,
        (__int64)&v119,
        (__int64)&v121,
        (__int64)&__node_gen);
      google::protobuf::DescriptorBuilder::AddError((__int64)this, v65, (__int64)a2, 0, &v101);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v101._M_dataplus._M_p != &v101._anon_0 )
        operator delete(v101._M_dataplus._M_p);
      ++v63;
    }
    while ( v63 < a2->reserved_name_.current_size_ );
  }
LABEL_60:
  v89 = 0LL;
  for ( m = 0; m < a4->field_count_; ++v89 )
  {
    v98 = 0LL;
    for ( n = &a4->fields_[v89]; a4->extension_range_count_ > (int)v98; ++v98 )
    {
      number = n->number_;
      v68 = &a4->extension_ranges_[v98];
      if ( v68->start <= number && v68->end > number )
      {
        __node_gen._M_h = 0LL;
        v124 = -1;
        v121 = 0LL;
        v122 = -1;
        v119 = 0LL;
        v120 = -1;
        v117 = 0LL;
        v118 = -1;
        v115 = 0LL;
        v116 = -1;
        v112 = 0LL;
        v113 = -1;
        v109 = google::protobuf::FastInt32ToBuffer(number, v111);
        v110 = strlen(v109);
        v69 = n->name_->_M_dataplus._M_p;
        v107 = n->name_->_M_string_length;
        end = v68->end;
        v106 = (char *)v69;
        v103 = google::protobuf::FastInt32ToBuffer(end - 1, v105);
        v104 = strlen(v103);
        v102._M_dataplus._M_p = google::protobuf::FastInt32ToBuffer(v68->start, (char *)&v102._M_string_length + 4);
        LODWORD(v102._M_string_length) = strlen(v102._M_dataplus._M_p);
        google::protobuf::strings::Substitute[abi:cxx11](
          (unsigned int)&v101,
          (unsigned int)"Extension range $0 to $1 includes field \"$2\" ($3).",
          (unsigned int)&v102,
          (unsigned int)&v103,
          (unsigned int)&v106,
          (unsigned int)&v109,
          (__int64)&v112,
          (__int64)&v115,
          (__int64)&v117,
          (__int64)&v119,
          (__int64)&v121,
          (__int64)&__node_gen);
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)this,
          n->full_name_,
          (__int64)a2->extension_range_.rep_->elements[(int)v98],
          1u,
          &v101);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v101._M_dataplus._M_p != &v101._anon_0 )
          operator delete(v101._M_dataplus._M_p);
      }
    }
    for ( ii = 0LL; a4->reserved_range_count_ > (int)ii; ++ii )
    {
      v71 = n->number_;
      v72 = &a4->reserved_ranges_[ii];
      if ( v72->start <= v71 && v72->end > v71 )
      {
        __node_gen._M_h = 0LL;
        v124 = -1;
        v121 = 0LL;
        v122 = -1;
        v119 = 0LL;
        v120 = -1;
        v117 = 0LL;
        v118 = -1;
        v115 = 0LL;
        v116 = -1;
        v112 = 0LL;
        v113 = -1;
        v109 = 0LL;
        v110 = -1;
        v106 = 0LL;
        v107 = -1;
        v103 = google::protobuf::FastInt32ToBuffer(v71, v105);
        v104 = strlen(v103);
        v73 = n->name_->_M_dataplus._M_p;
        LODWORD(v102._M_string_length) = n->name_->_M_string_length;
        v102._M_dataplus._M_p = v73;
        google::protobuf::strings::Substitute[abi:cxx11](
          (unsigned int)&v101,
          (unsigned int)"Field \"$0\" uses reserved number $1.",
          (unsigned int)&v102,
          (unsigned int)&v103,
          (unsigned int)&v106,
          (unsigned int)&v109,
          (__int64)&v112,
          (__int64)&v115,
          (__int64)&v117,
          (__int64)&v119,
          (__int64)&v121,
          (__int64)&__node_gen);
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)this,
          n->full_name_,
          (__int64)a2->reserved_range_.rep_->elements[(int)ii],
          1u,
          &v101);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v101._M_dataplus._M_p != &v101._anon_0 )
          operator delete(v101._M_dataplus._M_p);
      }
    }
    if ( std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::find(
           v125,
           n->name_)._M_cur )
    {
      p_M_p = &n->name_->_M_dataplus._M_p;
      __node_gen._M_h = 0LL;
      v121 = 0LL;
      v119 = 0LL;
      v117 = 0LL;
      v115 = 0LL;
      v112 = 0LL;
      v109 = 0LL;
      v106 = 0LL;
      v103 = 0LL;
      v75 = *p_M_p;
      v124 = -1;
      v76 = p_M_p[1];
      v102._M_dataplus._M_p = v75;
      LODWORD(v102._M_string_length) = (_DWORD)v76;
      v122 = -1;
      v120 = -1;
      v118 = -1;
      v116 = -1;
      v113 = -1;
      v110 = -1;
      v107 = -1;
      v104 = -1;
      google::protobuf::strings::Substitute[abi:cxx11](
        (unsigned int)&v101,
        (unsigned int)"Field name \"$0\" is reserved.",
        (unsigned int)&v102,
        (unsigned int)&v103,
        (unsigned int)&v106,
        (unsigned int)&v109,
        (__int64)&v112,
        (__int64)&v115,
        (__int64)&v117,
        (__int64)&v119,
        (__int64)&v121,
        (__int64)&__node_gen);
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        n->full_name_,
        (__int64)a2->field_.rep_->elements[m],
        0,
        &v101);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v101._M_dataplus._M_p != &v101._anon_0 )
        operator delete(v101._M_dataplus._M_p);
    }
    ++m;
  }
  v88 = 1LL;
  v92 = 0LL;
  if ( a4->extension_range_count_ > 0 )
  {
    do
    {
      v77 = 0LL;
      for ( jj = &a4->extension_ranges_[v92]; a4->reserved_range_count_ > (int)v77; ++v77 )
      {
        while ( 1 )
        {
          v78 = &a4->reserved_ranges_[v77];
          if ( jj->end > v78->start && v78->end > jj->start )
          {
            v124 = -1;
            v122 = -1;
            v120 = -1;
            v118 = -1;
            v116 = -1;
            v113 = -1;
            v79 = v78->end;
            __node_gen._M_h = 0LL;
            v121 = 0LL;
            v119 = 0LL;
            v117 = 0LL;
            v115 = 0LL;
            v112 = 0LL;
            v109 = google::protobuf::FastInt32ToBuffer(v79 - 1, v111);
            v110 = strlen(v109);
            v106 = google::protobuf::FastInt32ToBuffer(v78->start, v108);
            v107 = strlen(v106);
            v103 = google::protobuf::FastInt32ToBuffer(jj->end - 1, v105);
            v104 = strlen(v103);
            v102._M_dataplus._M_p = google::protobuf::FastInt32ToBuffer(jj->start, (char *)&v102._M_string_length + 4);
            LODWORD(v102._M_string_length) = strlen(v102._M_dataplus._M_p);
            google::protobuf::strings::Substitute[abi:cxx11](
              (unsigned int)&v101,
              (unsigned int)"Extension range $0 to $1 overlaps with reserved range $2 to $3.",
              (unsigned int)&v102,
              (unsigned int)&v103,
              (unsigned int)&v106,
              (unsigned int)&v109,
              (__int64)&v112,
              (__int64)&v115,
              (__int64)&v117,
              (__int64)&v119,
              (__int64)&v121,
              (__int64)&__node_gen);
            google::protobuf::DescriptorBuilder::AddError(
              (__int64)this,
              a4->full_name_,
              (__int64)a2->extension_range_.rep_->elements[(int)v92],
              1u,
              &v101);
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v101._M_dataplus._M_p != &v101._anon_0 )
              break;
          }
          if ( a4->reserved_range_count_ <= (int)++v77 )
            goto LABEL_87;
        }
        operator delete(v101._M_dataplus._M_p);
      }
LABEL_87:
      v80 = v88;
      if ( a4->extension_range_count_ <= (int)v88 )
        break;
      v81 = v88;
      do
      {
        while ( 1 )
        {
          v83 = &a4->extension_ranges_[v81];
          if ( jj->end > v83->start && v83->end > jj->start )
          {
            v124 = -1;
            v122 = -1;
            v120 = -1;
            v118 = -1;
            v116 = -1;
            v113 = -1;
            v84 = jj->end;
            __node_gen._M_h = 0LL;
            v121 = 0LL;
            v119 = 0LL;
            v117 = 0LL;
            v115 = 0LL;
            v112 = 0LL;
            v109 = google::protobuf::FastInt32ToBuffer(v84 - 1, v111);
            v110 = strlen(v109);
            v106 = google::protobuf::FastInt32ToBuffer(jj->start, v108);
            v107 = strlen(v106);
            v103 = google::protobuf::FastInt32ToBuffer(v83->end - 1, v105);
            v104 = strlen(v103);
            v102._M_dataplus._M_p = google::protobuf::FastInt32ToBuffer(v83->start, (char *)&v102._M_string_length + 4);
            LODWORD(v102._M_string_length) = strlen(v102._M_dataplus._M_p);
            google::protobuf::strings::Substitute[abi:cxx11](
              (unsigned int)&v101,
              (unsigned int)"Extension range $0 to $1 overlaps with already-defined range $2 to $3.",
              (unsigned int)&v102,
              (unsigned int)&v103,
              (unsigned int)&v106,
              (unsigned int)&v109,
              (__int64)&v112,
              (__int64)&v115,
              (__int64)&v117,
              (__int64)&v119,
              (__int64)&v121,
              (__int64)&__node_gen);
            google::protobuf::DescriptorBuilder::AddError(
              (__int64)this,
              a4->full_name_,
              (__int64)a2->extension_range_.rep_->elements[(int)v92],
              1u,
              &v101);
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v101._M_dataplus._M_p != &v101._anon_0 )
              break;
          }
          extension_range_count = a4->extension_range_count_;
          ++v80;
          ++v81;
          if ( v80 >= extension_range_count )
            goto LABEL_94;
        }
        operator delete(v101._M_dataplus._M_p);
        extension_range_count = a4->extension_range_count_;
        ++v80;
        ++v81;
      }
      while ( v80 < extension_range_count );
LABEL_94:
      ++v92;
      ++v88;
    }
    while ( extension_range_count > (int)v92 );
  }
  std::_Hashtable<std::string,std::string,std::allocator<std::string>,std::__detail::_Identity,std::equal_to<std::string>,google::protobuf::hash<std::string>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,true,true>>::~_Hashtable(v125);
};

// Line 4476: range 000000000C9049D0-000000000C905C72
void __fastcall google::protobuf::DescriptorBuilder::BuildFieldOrExtension(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::FieldDescriptorProto *a2,
        const google::protobuf::Descriptor *a3,
        google::protobuf::FieldDescriptor *a4,
        bool a5,
        double a6,
        double a7)
{
  const std::string *full_name; // rsi
  std::string *String; // rax
  std::string::size_type M_string_length; // rsi
  const std::string *v12; // r12
  const google::protobuf::FieldDescriptorProto *v13; // r15
  std::string *v14; // rax
  google::protobuf::FileDescriptor *file; // rax
  std::forward_iterator_tag v16; // cl
  std::string::pointer M_p; // rax
  std::string::size_type v18; // rdx
  char *v19; // rsi
  char v20; // dl
  std::string *ptr; // rax
  google::protobuf::DescriptorPool::Tables *tables; // r12
  std::string *v23; // rax
  std::string *v24; // rdi
  google::protobuf::DescriptorPool::Tables *v25; // rdi
  __int64 v26; // r9
  bool v27; // zf
  int label; // eax
  google::protobuf::uint32 v29; // eax
  std::string *v30; // r15
  std::string::size_type v31; // r13
  std::string::pointer v32; // rax
  char v33; // r12
  std::string::size_type M_allocated_capacity; // rdx
  std::string *v35; // rax
  std::string *v36; // rdi
  int number; // eax
  google::protobuf::uint32 v38; // eax
  __int64 oneof_index; // rdi
  std::string *v40; // rsi
  std::string::size_type v41; // rdx
  google::protobuf::FieldOptions *options; // rcx
  google::protobuf::uint32 v43; // eax
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  const std::string *name; // rax
  const char *v46; // rdx
  std::string::size_type v47; // rax
  char *v48; // rax
  std::string *v49; // rdx
  __int64 v50; // rax
  const std::string *v51; // rsi
  google::protobuf::GoogleOnceDynamic *v52; // rdi
  google::protobuf::DescriptorPool::Tables *v53; // r12
  std::string *v54; // rax
  std::string *v55; // rdi
  char **v56; // rdx
  char **v57; // rdx
  float v58; // xmm0_4
  __int128 v59; // [rsp-10h] [rbp-290h]
  std::string::size_type v61; // [rsp+10h] [rbp-270h]
  std::string::size_type v62; // [rsp+18h] [rbp-268h]
  char v64; // [rsp+27h] [rbp-259h]
  std::string v66; // [rsp+30h] [rbp-250h] BYREF
  std::string v67; // [rsp+50h] [rbp-230h] BYREF
  char *v68; // [rsp+70h] [rbp-210h] BYREF
  int v69; // [rsp+78h] [rbp-208h]
  char buffer[36]; // [rsp+7Ch] [rbp-204h] BYREF
  char *v71; // [rsp+A0h] [rbp-1E0h] BYREF
  int v72; // [rsp+A8h] [rbp-1D8h]
  char v73[36]; // [rsp+ACh] [rbp-1D4h] BYREF
  __int64 v74; // [rsp+D0h] [rbp-1B0h] BYREF
  int v75; // [rsp+D8h] [rbp-1A8h]
  __int64 v76; // [rsp+100h] [rbp-180h] BYREF
  int v77; // [rsp+108h] [rbp-178h]
  __int64 v78; // [rsp+130h] [rbp-150h] BYREF
  int v79; // [rsp+138h] [rbp-148h]
  __int64 v80; // [rsp+160h] [rbp-120h] BYREF
  int v81; // [rsp+168h] [rbp-118h]
  __int64 v82; // [rsp+190h] [rbp-F0h] BYREF
  int v83; // [rsp+198h] [rbp-E8h]
  char *endptr; // [rsp+1C0h] [rbp-C0h] BYREF
  int v85; // [rsp+1C8h] [rbp-B8h]
  std::string v86; // [rsp+1F0h] [rbp-90h] BYREF
  std::string closure[3]; // [rsp+220h] [rbp-60h] BYREF

  if ( a3 )
    full_name = a3->full_name_;
  else
    full_name = this->file_->package_;
  String = google::protobuf::DescriptorPool::Tables::AllocateString(
             (std::vector<std::string*> *)this->tables_,
             (__int64)full_name);
  M_string_length = String->_M_string_length;
  v12 = String;
  if ( M_string_length )
    std::string::_M_replace_aux(String, M_string_length, 0LL, 1LL, 46LL);
  v13 = a2;
  std::string::_M_append(v12, a2->name_.ptr_->_M_dataplus._M_p, a2->name_.ptr_->_M_string_length);
  google::protobuf::DescriptorBuilder::ValidateSymbolName((__int64)this, v13->name_.ptr_, v12, (__int64)v13);
  v14 = google::protobuf::DescriptorPool::Tables::AllocateString(
          (std::vector<std::string*> *)this->tables_,
          (__int64)a2->name_.ptr_);
  a4->full_name_ = v12;
  a4->name_ = v14;
  file = this->file_;
  v66._M_dataplus._M_p = v66._anon_0._M_local_buf;
  a4->file_ = file;
  a4->number_ = a2->number_;
  a4->is_extension_ = a5;
  std::string::_M_construct<char *>(
    &v66,
    v13->name_.ptr_->_M_dataplus._M_p,
    &v13->name_.ptr_->_M_dataplus._M_p[v13->name_.ptr_->_M_string_length],
    v16);
  M_p = v66._M_dataplus._M_p;
  v18 = v66._M_string_length;
  v19 = &v66._M_dataplus._M_p[v66._M_string_length];
  if ( v66._M_dataplus._M_p != &v66._M_dataplus._M_p[v66._M_string_length] )
  {
    do
    {
      while ( 1 )
      {
        v20 = *M_p;
        if ( (unsigned __int8)(*M_p - 65) <= 0x19u )
          break;
        if ( v19 == ++M_p )
          goto LABEL_10;
      }
      *M_p++ = v20 + 32;
    }
    while ( v19 != M_p );
LABEL_10:
    v18 = v66._M_string_length;
  }
  ptr = a2->name_.ptr_;
  if ( v18 == ptr->_M_string_length && (!v18 || !memcmp(v66._M_dataplus._M_p, ptr->_M_dataplus._M_p, v18)) )
    a4->lowercase_name_ = a4->name_;
  else
    a4->lowercase_name_ = google::protobuf::DescriptorPool::Tables::AllocateString(
                            (std::vector<std::string*> *)this->tables_,
                            (__int64)&v66);
  tables = this->tables_;
  google::protobuf::`anonymous namespace'::ToCamelCase(
    &closure[0]._M_dataplus._M_p,
    &a2->name_.ptr_->_M_dataplus._M_p,
    1);
  v23 = google::protobuf::DescriptorPool::Tables::AllocateString((std::vector<std::string*> *)tables, (__int64)closure);
  v24 = (std::string *)closure[0]._M_dataplus._M_p;
  a4->camelcase_name_ = v23;
  if ( v24 != (std::string *)&closure[0]._anon_0 )
    operator delete(v24);
  v25 = this->tables_;
  if ( (a2->_has_bits_.has_bits_[0] & 0x10) != 0 )
  {
    a4->has_json_name_ = 1;
    a4->json_name_ = google::protobuf::DescriptorPool::Tables::AllocateString(
                       (std::vector<std::string*> *)v25,
                       (__int64)a2->json_name_.ptr_);
  }
  else
  {
    a4->has_json_name_ = 0;
    closure[0]._M_string_length = 0LL;
    v30 = a2->name_.ptr_;
    closure[0]._anon_0._M_local_buf[0] = 0;
    closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
    std::string::reserve(closure, v30->_M_string_length);
    if ( v30->_M_string_length )
    {
      v64 = 0;
      v31 = 0LL;
      do
      {
        while ( 1 )
        {
          v33 = v30->_M_dataplus._M_p[v31];
          if ( v33 != 95 )
            break;
          v64 = 1;
          if ( v30->_M_string_length <= ++v31 )
            goto LABEL_38;
        }
        v61 = closure[0]._M_string_length;
        v32 = closure[0]._M_dataplus._M_p;
        v62 = closure[0]._M_string_length + 1;
        if ( v64 )
        {
          if ( (unsigned __int8)(v33 - 97) < 0x1Au )
            v33 -= 32;
          M_allocated_capacity = 15LL;
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p != &closure[0]._anon_0 )
            M_allocated_capacity = closure[0]._anon_0._M_allocated_capacity;
          if ( M_allocated_capacity < closure[0]._M_string_length + 1 )
          {
            std::string::_M_mutate(closure, closure[0]._M_string_length, 0LL, 0LL, 1LL);
            v32 = closure[0]._M_dataplus._M_p;
          }
          v64 = 0;
          v32[v61] = v33;
          closure[0]._M_string_length = v62;
          closure[0]._M_dataplus._M_p[v61 + 1] = 0;
        }
        else
        {
          v41 = 15LL;
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p != &closure[0]._anon_0 )
            v41 = closure[0]._anon_0._M_allocated_capacity;
          if ( v41 < v62 )
          {
            std::string::_M_mutate(closure, closure[0]._M_string_length, 0LL, 0LL, 1LL);
            v32 = closure[0]._M_dataplus._M_p;
          }
          v32[v61] = v33;
          closure[0]._M_string_length = v62;
          closure[0]._M_dataplus._M_p[v61 + 1] = 0;
        }
        ++v31;
      }
      while ( v30->_M_string_length > v31 );
    }
LABEL_38:
    v35 = google::protobuf::DescriptorPool::Tables::AllocateString((std::vector<std::string*> *)v25, (__int64)closure);
    v36 = (std::string *)closure[0]._M_dataplus._M_p;
    a4->json_name_ = v35;
    if ( v36 != (std::string *)&closure[0]._anon_0 )
      operator delete(v36);
  }
  v27 = !a4->is_extension_;
  a4->type_ = a2->type_;
  label = a2->label_;
  a4->label_ = label;
  if ( !v27 && label == 2 )
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      a4->full_name_,
      (__int64)a2,
      2u,
      "Message extensions cannot have required fields.");
  a4->containing_type_ = 0LL;
  a4->_anon_0.default_value_int64_ = 0LL;
  v29 = a2->_has_bits_.has_bits_[0];
  a4->extension_scope_ = 0LL;
  a4->message_type_ = 0LL;
  a4->enum_type_ = 0LL;
  a4->type_name_ = 0LL;
  a4->type_once_ = 0LL;
  a4->default_value_enum_name_ = 0LL;
  a4->has_default_value_ = (v29 & 8) != 0;
  if ( (v29 & 8) == 0 )
  {
    if ( (v29 & 0x200) == 0 )
      goto LABEL_41;
    goto LABEL_65;
  }
  if ( a4->label_ != LABEL_REPEATED )
  {
    if ( (v29 & 0x200) == 0 )
      goto LABEL_41;
    endptr = 0LL;
    goto LABEL_24;
  }
  google::protobuf::DescriptorBuilder::AddError(
    (__int64)this,
    a4->full_name_,
    (__int64)a2,
    4u,
    "Repeated fields can't have default values.");
  v43 = a2->_has_bits_.has_bits_[0];
  if ( (v43 & 0x200) == 0 )
    goto LABEL_41;
  type_once = a4->type_once_;
  if ( (v43 & 8) == 0 )
  {
    if ( type_once && type_once->state_ != 2 )
    {
      closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
      closure[0]._anon_0._M_local_buf[0] = 0;
      *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a4;
      google::protobuf::GoogleOnceInitImpl(&type_once->state_, (google::protobuf::Closure *)closure);
      closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
    }
LABEL_65:
    switch ( a4->type_ )
    {
      case TYPE_DOUBLE_0:
        a4->_anon_0.default_value_int64_ = 0LL;
        break;
      case TYPE_FLOAT_0:
        a4->_anon_0.default_value_int32_ = 0;
        break;
      case TYPE_INT64_0:
      case TYPE_UINT64_0:
      case TYPE_FIXED64_0:
LABEL_86:
        a4->_anon_0.default_value_int64_ = 0LL;
        break;
      case TYPE_INT32_0:
      case TYPE_FIXED32_0:
        a4->_anon_0.default_value_int32_ = 0;
        break;
      case TYPE_BOOL_0:
        a4->_anon_0.default_value_bool_ = 0;
        break;
      case TYPE_STRING_0:
        if ( google::protobuf::internal::empty_string_once_init_ != 2 )
        {
          closure[0]._anon_0._M_local_buf[0] = 0;
          closure[0]._M_dataplus._M_p = (std::string::pointer)off_1A16E058;
          closure[0]._M_string_length = (std::string::size_type)google::protobuf::internal::InitEmptyString;
          google::protobuf::GoogleOnceInitImpl(
            &google::protobuf::internal::empty_string_once_init_,
            (google::protobuf::Closure *)closure);
          google::protobuf::internal::FunctionClosure0::~FunctionClosure0((google::protobuf::internal::FunctionClosure0 *const)closure);
        }
        a4->_anon_0.default_value_int64_ = (google::protobuf::int64)&google::protobuf::internal::fixed_address_empty_string[abi:cxx11];
        break;
      default:
        goto LABEL_41;
    }
    goto LABEL_41;
  }
  endptr = 0LL;
  if ( !type_once )
  {
LABEL_24:
    switch ( a4->type_ )
    {
      case TYPE_DOUBLE_0:
        goto LABEL_123;
      case TYPE_FLOAT_0:
        goto LABEL_128;
      case TYPE_INT64_0:
      case TYPE_SFIXED64_0:
      case TYPE_SINT64_0:
        goto LABEL_127;
      case TYPE_UINT64_0:
      case TYPE_FIXED64_0:
        goto LABEL_125;
      case TYPE_INT32_0:
      case TYPE_SFIXED32_0:
      case TYPE_SINT32_0:
        goto LABEL_126;
      case TYPE_FIXED32_0:
      case TYPE_UINT32_0:
        goto LABEL_122;
      case TYPE_BOOL_0:
        goto LABEL_120;
      case TYPE_STRING_0:
      case TYPE_BYTES_0:
        goto LABEL_115;
      case TYPE_GROUP_0:
      case TYPE_MESSAGE_0:
        goto LABEL_103;
      case TYPE_ENUM_0:
        goto LABEL_86;
      default:
        goto LABEL_41;
    }
    goto LABEL_41;
  }
  if ( type_once->state_ != 2 )
  {
    closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
    closure[0]._anon_0._M_local_buf[0] = 0;
    *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a4;
    google::protobuf::GoogleOnceInitImpl(&type_once->state_, (google::protobuf::Closure *)closure);
    closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
  }
  switch ( a4->type_ )
  {
    case TYPE_DOUBLE_0:
LABEL_123:
      if ( !(unsigned int)std::string::compare(a2->default_value_.ptr_, 441314807LL) )
      {
        a4->_anon_0.default_value_int64_ = 0x7FF0000000000000LL;
        v48 = endptr;
      }
      else if ( !(unsigned int)std::string::compare(a2->default_value_.ptr_, 441314812LL) )
      {
        a4->_anon_0.default_value_int64_ = 0xFFF0000000000000LL;
        v48 = endptr;
      }
      else if ( !(unsigned int)std::string::compare(a2->default_value_.ptr_, &off_1A173E0A) )
      {
        a4->_anon_0.default_value_int64_ = 0x7FF8000000000000LL;
        v48 = endptr;
      }
      else
      {
        google::protobuf::io::NoLocaleStrtod(
          (google::protobuf::io *)a2->default_value_.ptr_->_M_dataplus._M_p,
          (const char *)&endptr,
          v56);
        v48 = endptr;
        a4->_anon_0.default_value_double_ = a6;
      }
      break;
    case TYPE_FLOAT_0:
LABEL_128:
      if ( !(unsigned int)std::string::compare(a2->default_value_.ptr_, 441314807LL) )
      {
        a4->_anon_0.default_value_int32_ = 2139095040;
        v48 = endptr;
      }
      else if ( !(unsigned int)std::string::compare(a2->default_value_.ptr_, 441314812LL) )
      {
        a4->_anon_0.default_value_int32_ = -8388608;
        v48 = endptr;
      }
      else if ( !(unsigned int)std::string::compare(a2->default_value_.ptr_, &off_1A173E0A) )
      {
        a4->_anon_0.default_value_int32_ = 2143289344;
        v48 = endptr;
      }
      else
      {
        google::protobuf::io::NoLocaleStrtod(
          (google::protobuf::io *)a2->default_value_.ptr_->_M_dataplus._M_p,
          (const char *)&endptr,
          v57);
        v58 = google::protobuf::io::SafeDoubleToFloat(a7);
        v48 = endptr;
        a4->_anon_0.default_value_float_ = v58;
      }
      break;
    case TYPE_INT64_0:
    case TYPE_SFIXED64_0:
    case TYPE_SINT64_0:
LABEL_127:
      a4->_anon_0.default_value_int64_ = strtoll(a2->default_value_.ptr_->_M_dataplus._M_p, &endptr, 0);
      v48 = endptr;
      break;
    case TYPE_UINT64_0:
    case TYPE_FIXED64_0:
LABEL_125:
      a4->_anon_0.default_value_int64_ = strtoull(a2->default_value_.ptr_->_M_dataplus._M_p, &endptr, 0);
      v48 = endptr;
      break;
    case TYPE_INT32_0:
    case TYPE_SFIXED32_0:
    case TYPE_SINT32_0:
LABEL_126:
      a4->_anon_0.default_value_int32_ = strtol(a2->default_value_.ptr_->_M_dataplus._M_p, &endptr, 0);
      v48 = endptr;
      break;
    case TYPE_FIXED32_0:
    case TYPE_UINT32_0:
LABEL_122:
      a4->_anon_0.default_value_int32_ = strtoul(a2->default_value_.ptr_->_M_dataplus._M_p, &endptr, 0);
      v48 = endptr;
      break;
    case TYPE_BOOL_0:
LABEL_120:
      if ( !(unsigned int)std::string::compare(a2->default_value_.ptr_, "true") )
      {
        a4->_anon_0.default_value_bool_ = 1;
        v48 = endptr;
      }
      else
      {
        if ( (unsigned int)std::string::compare(a2->default_value_.ptr_, "false") )
        {
          google::protobuf::DescriptorBuilder::AddError(
            (__int64)this,
            a4->full_name_,
            (__int64)a2,
            4u,
            "Boolean default must be true or false.");
          goto LABEL_104;
        }
        a4->_anon_0.default_value_bool_ = 0;
        v48 = endptr;
      }
      break;
    case TYPE_STRING_0:
    case TYPE_BYTES_0:
LABEL_115:
      v52 = a4->type_once_;
      if ( v52 && v52->state_ != 2 )
      {
        closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
        closure[0]._anon_0._M_local_buf[0] = 0;
        *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a4;
        google::protobuf::GoogleOnceInitImpl(&v52->state_, (google::protobuf::Closure *)closure);
        closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
      }
      v53 = this->tables_;
      if ( a4->type_ == TYPE_BYTES_0 )
      {
        google::protobuf::UnescapeCEscapeString(closure);
        v54 = google::protobuf::DescriptorPool::Tables::AllocateString(
                (std::vector<std::string*> *)v53,
                (__int64)closure);
        v55 = (std::string *)closure[0]._M_dataplus._M_p;
        a4->_anon_0.default_value_int64_ = (google::protobuf::int64)v54;
        if ( v55 != (std::string *)&closure[0]._anon_0 )
          operator delete(v55);
        goto LABEL_104;
      }
      a4->_anon_0.default_value_int64_ = (google::protobuf::int64)google::protobuf::DescriptorPool::Tables::AllocateString(
                                                                    (std::vector<std::string*> *)this->tables_,
                                                                    (__int64)a2->default_value_.ptr_);
      v48 = endptr;
      break;
    case TYPE_GROUP_0:
    case TYPE_MESSAGE_0:
LABEL_103:
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        a4->full_name_,
        (__int64)a2,
        4u,
        "Messages can't have default values.");
      a4->has_default_value_ = 0;
      goto LABEL_104;
    case TYPE_ENUM_0:
      a4->_anon_0.default_value_int64_ = 0LL;
      v48 = endptr;
      break;
    default:
LABEL_104:
      v48 = endptr;
      break;
  }
  if ( v48 )
  {
    v49 = a2->default_value_.ptr_;
    if ( !v49->_M_string_length || *v48 )
    {
      std::operator+<char>(&v86, "Couldn't parse default value \"", v49);
      if ( v86._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v86._M_string_length == 4611686018427387902LL )
        std::__throw_length_error("basic_string::append");
      v50 = std::string::_M_append(&v86, "\".", 2LL);
      closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
      if ( *(_QWORD *)v50 == v50 + 16 )
      {
        closure[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v50 + 16));
      }
      else
      {
        closure[0]._M_dataplus._M_p = *(std::string::pointer *)v50;
        closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v50 + 16);
      }
      closure[0]._M_string_length = *(_QWORD *)(v50 + 8);
      *(_QWORD *)v50 = v50 + 16;
      *(_BYTE *)(v50 + 16) = 0;
      v51 = a4->full_name_;
      *(_QWORD *)(v50 + 8) = 0LL;
      google::protobuf::DescriptorBuilder::AddError((__int64)this, v51, (__int64)a2, 4u, closure);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p != &closure[0]._anon_0 )
        operator delete(closure[0]._M_dataplus._M_p);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v86._M_dataplus._M_p != &v86._anon_0 )
        operator delete(v86._M_dataplus._M_p);
    }
  }
LABEL_41:
  number = a4->number_;
  if ( number <= 0 )
  {
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      a4->full_name_,
      (__int64)a2,
      1u,
      "Field numbers must be positive integers.");
    goto LABEL_46;
  }
  if ( a5 )
  {
    if ( number <= 18999 )
      goto LABEL_54;
    goto LABEL_45;
  }
  if ( number > 0x1FFFFFFF )
  {
    closure[0]._M_dataplus._M_p = 0LL;
    LODWORD(closure[0]._M_string_length) = -1;
    v86._M_dataplus._M_p = 0LL;
    LODWORD(v86._M_string_length) = -1;
    endptr = 0LL;
    v85 = -1;
    v82 = 0LL;
    v83 = -1;
    v80 = 0LL;
    v81 = -1;
    v78 = 0LL;
    v79 = -1;
    v76 = 0LL;
    v77 = -1;
    v74 = 0LL;
    v75 = -1;
    v71 = 0LL;
    v72 = -1;
    v68 = google::protobuf::FastInt32ToBuffer(0x1FFFFFFF, buffer);
    v69 = strlen(v68);
    google::protobuf::strings::Substitute[abi:cxx11](
      (unsigned int)&v67,
      (unsigned int)"Field numbers cannot be greater than $0.",
      (unsigned int)&v68,
      (unsigned int)&v71,
      (unsigned int)&v74,
      (unsigned int)&v76,
      (__int64)&v78,
      (__int64)&v80,
      (__int64)&v82,
      (__int64)&endptr,
      (__int64)&v86,
      (__int64)closure);
    google::protobuf::DescriptorBuilder::AddError((__int64)this, a4->full_name_, (__int64)a2, 1u, &v67);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v67._M_dataplus._M_p != &v67._anon_0 )
      operator delete(v67._M_dataplus._M_p);
    goto LABEL_47;
  }
  if ( number > 18999 )
  {
LABEL_45:
    if ( number <= 19999 )
    {
      closure[0]._M_dataplus._M_p = 0LL;
      LODWORD(closure[0]._M_string_length) = -1;
      v86._M_dataplus._M_p = 0LL;
      LODWORD(v86._M_string_length) = -1;
      endptr = 0LL;
      v85 = -1;
      v82 = 0LL;
      v83 = -1;
      v80 = 0LL;
      v81 = -1;
      v78 = 0LL;
      v79 = -1;
      v76 = 0LL;
      v77 = -1;
      v74 = 0LL;
      v75 = -1;
      v71 = google::protobuf::FastInt32ToBuffer(19999, v73);
      v72 = strlen(v71);
      v68 = google::protobuf::FastInt32ToBuffer(19000, buffer);
      v69 = strlen(v68);
      google::protobuf::strings::Substitute[abi:cxx11](
        (unsigned int)&v67,
        (unsigned int)"Field numbers $0 through $1 are reserved for the protocol buffer library implementation.",
        (unsigned int)&v68,
        (unsigned int)&v71,
        (unsigned int)&v74,
        (unsigned int)&v76,
        (__int64)&v78,
        (__int64)&v80,
        (__int64)&v82,
        (__int64)&endptr,
        (__int64)&v86,
        (__int64)closure);
      google::protobuf::DescriptorBuilder::AddError((__int64)this, a4->full_name_, (__int64)a2, 1u, &v67);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v67._M_dataplus._M_p != &v67._anon_0 )
        operator delete(v67._M_dataplus._M_p);
    }
LABEL_46:
    if ( !a5 )
      goto LABEL_47;
LABEL_54:
    v40 = (std::string *)a4->full_name_;
    v38 = a2->_has_bits_.has_bits_[0];
    if ( (v38 & 2) != 0 )
    {
      a4->extension_scope_ = a3;
      if ( (v38 & 0x80u) == 0 )
      {
LABEL_56:
        a4->containing_oneof_ = 0LL;
        goto LABEL_57;
      }
    }
    else
    {
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        v40,
        (__int64)a2,
        3u,
        "FieldDescriptorProto.extendee not set for extension field.");
      v38 = a2->_has_bits_.has_bits_[0];
      v40 = (std::string *)a4->full_name_;
      a4->extension_scope_ = a3;
      if ( (v38 & 0x80u) == 0 )
        goto LABEL_56;
    }
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      v40,
      (__int64)a2,
      9u,
      "FieldDescriptorProto.oneof_index should not be set for extensions.");
    v38 = a2->_has_bits_.has_bits_[0];
    v40 = (std::string *)a4->full_name_;
    goto LABEL_56;
  }
LABEL_47:
  v38 = a2->_has_bits_.has_bits_[0];
  if ( (v38 & 2) != 0 )
  {
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      a4->full_name_,
      (__int64)a2,
      3u,
      "FieldDescriptorProto.extendee set for non-extension field.");
    v38 = a2->_has_bits_.has_bits_[0];
  }
  a4->containing_type_ = a3;
  if ( (v38 & 0x80u) == 0 )
  {
    a4->containing_oneof_ = 0LL;
    v40 = (std::string *)a4->full_name_;
  }
  else
  {
    oneof_index = a2->oneof_index_;
    if ( (int)oneof_index < 0 || a3->oneof_decl_count_ <= (int)oneof_index )
    {
      closure[0]._M_dataplus._M_p = 0LL;
      v86._M_dataplus._M_p = 0LL;
      name = a3->name_;
      endptr = 0LL;
      v82 = 0LL;
      v80 = 0LL;
      v78 = 0LL;
      v76 = 0LL;
      v74 = 0LL;
      v46 = name->_M_dataplus._M_p;
      v47 = name->_M_string_length;
      LODWORD(closure[0]._M_string_length) = -1;
      LODWORD(v86._M_string_length) = -1;
      v85 = -1;
      v83 = -1;
      v81 = -1;
      v79 = -1;
      v77 = -1;
      v75 = -1;
      v71 = (char *)v46;
      v72 = v47;
      v68 = google::protobuf::FastInt32ToBuffer(oneof_index, buffer);
      v69 = strlen(v68);
      google::protobuf::strings::Substitute[abi:cxx11](
        (unsigned int)&v67,
        (unsigned int)"FieldDescriptorProto.oneof_index $0 is out of range for type \"$1\".",
        (unsigned int)&v68,
        (unsigned int)&v71,
        (unsigned int)&v74,
        (unsigned int)&v76,
        (__int64)&v78,
        (__int64)&v80,
        (__int64)&v82,
        (__int64)&endptr,
        (__int64)&v86,
        (__int64)closure);
      google::protobuf::DescriptorBuilder::AddError((__int64)this, a4->full_name_, (__int64)a2, 9u, &v67);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v67._M_dataplus._M_p != &v67._anon_0 )
        operator delete(v67._M_dataplus._M_p);
      v40 = (std::string *)a4->full_name_;
      a4->containing_oneof_ = 0LL;
      v38 = a2->_has_bits_.has_bits_[0];
    }
    else
    {
      v40 = (std::string *)a4->full_name_;
      a4->containing_oneof_ = &a3->oneof_decls_[oneof_index];
    }
  }
LABEL_57:
  if ( (v38 & 0x20) != 0 )
  {
    options = a2->options_;
    if ( !options )
      options = (google::protobuf::FieldOptions *)&google::protobuf::_FieldOptions_default_instance_;
    google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::FieldDescriptor>(
      this,
      v40,
      v40,
      options,
      a4);
    v40 = (std::string *)a4->full_name_;
  }
  else
  {
    a4->options_ = 0LL;
  }
  *((_QWORD *)&v59 + 1) = a4;
  *(_QWORD *)&v59 = 2LL;
  google::protobuf::DescriptorBuilder::AddSymbol(
    (__int64)this,
    v40,
    (__int64)a3,
    (const char **)&a4->name_->_M_dataplus._M_p,
    (__int64)a2,
    v26,
    v59);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v66._M_dataplus._M_p != &v66._anon_0 )
    operator delete(v66._M_dataplus._M_p);
};

// Line 4769: range 000000000C902410-000000000C9024C5
void __fastcall google::protobuf::DescriptorBuilder::BuildExtensionRange(
        google::protobuf::DescriptorBuilder *const this,
        const google::protobuf::DescriptorProto::ExtensionRange *proto,
        const google::protobuf::Descriptor *parent,
        google::protobuf::Descriptor::ExtensionRange *result)
{
  int start; // eax
  int end; // edx
  google::protobuf::ExtensionRangeOptions *options; // rcx

  start = proto->start_;
  result->start = start;
  end = proto->end_;
  result->end = end;
  if ( start <= 0 )
  {
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      parent->full_name_,
      (__int64)proto,
      1u,
      "Extension numbers must be positive integers.");
    start = result->start;
    end = result->end;
  }
  if ( end <= start )
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      parent->full_name_,
      (__int64)proto,
      1u,
      "Extension range end number must be greater than start number.");
  if ( (proto->_has_bits_.has_bits_[0] & 1) != 0 )
  {
    options = proto->options_;
    if ( !options )
      options = (google::protobuf::ExtensionRangeOptions *)&google::protobuf::_ExtensionRangeOptions_default_instance_;
    google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::Descriptor::ExtensionRange>(
      this,
      parent->full_name_,
      parent->full_name_,
      options,
      result);
  }
  else
  {
    result->options_ = 0LL;
  }
};

// Line 4801: range 000000000C8FA0D0-000000000C8FA0FA
void __fastcall google::protobuf::DescriptorBuilder::BuildReservedRange(
        google::protobuf::DescriptorBuilder *const this,
        const google::protobuf::DescriptorProto::ReservedRange *proto,
        const google::protobuf::Descriptor *parent,
        google::protobuf::Descriptor::ReservedRange *result)
{
  int start; // eax

  start = proto->start_;
  result->start = start;
  result->end = proto->end_;
  if ( start <= 0 )
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      parent->full_name_,
      (__int64)proto,
      1u,
      "Reserved numbers must be positive integers.");
};

// Line 4812: range 000000000C905C80-000000000C905D81
void __fastcall google::protobuf::DescriptorBuilder::BuildOneof(
        google::protobuf::DescriptorBuilder *const this,
        const google::protobuf::OneofDescriptorProto *proto,
        google::protobuf::Descriptor *parent,
        google::protobuf::OneofDescriptor *result)
{
  std::string *String; // rbp
  std::string *v8; // rax
  __int64 v9; // r9
  std::string *name; // rcx
  google::protobuf::OneofOptions *options; // rcx
  __int128 v12; // [rsp-10h] [rbp-38h]

  String = google::protobuf::DescriptorPool::Tables::AllocateString(
             (std::vector<std::string*> *)this->tables_,
             (__int64)parent->full_name_);
  std::string::_M_replace_aux(String, String->_M_string_length, 0LL, 1LL, 46LL);
  std::string::_M_append(String, proto->name_.ptr_->_M_dataplus._M_p, proto->name_.ptr_->_M_string_length);
  google::protobuf::DescriptorBuilder::ValidateSymbolName((__int64)this, proto->name_.ptr_, String, (__int64)proto);
  v8 = google::protobuf::DescriptorPool::Tables::AllocateString(
         (std::vector<std::string*> *)this->tables_,
         (__int64)proto->name_.ptr_);
  result->full_name_ = String;
  result->name_ = v8;
  result->containing_type_ = parent;
  result->field_count_ = 0;
  result->fields_ = 0LL;
  if ( (proto->_has_bits_.has_bits_[0] & 2) != 0 )
  {
    options = proto->options_;
    if ( !options )
      options = (google::protobuf::OneofOptions *)&google::protobuf::_OneofOptions_default_instance_;
    google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::OneofDescriptor>(
      this,
      String,
      String,
      options,
      result);
    name = (std::string *)result->name_;
    String = (std::string *)result->full_name_;
  }
  else
  {
    result->options_ = 0LL;
    name = v8;
  }
  *((_QWORD *)&v12 + 1) = result;
  *(_QWORD *)&v12 = 3LL;
  google::protobuf::DescriptorBuilder::AddSymbol(
    (__int64)this,
    String,
    (__int64)parent,
    (const char **)&name->_M_dataplus._M_p,
    (__int64)proto,
    v9,
    v12);
};

// Line 4840: range 000000000C8FE9A0-000000000C8FF383
void __fastcall google::protobuf::DescriptorBuilder::CheckEnumValueUniqueness(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::EnumDescriptorProto *a2,
        const google::protobuf::EnumDescriptor *a3)
{
  signed __int64 M_string_length; // r14
  std::string::pointer M_p; // rbp
  char *v5; // r14
  char v6; // bl
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // rdx
  _BYTE *v9; // rax
  __int64 v10; // r15
  unsigned __int64 v11; // rcx
  std::string::size_type v12; // rsi
  const char *v13; // r8
  std::string::size_type i; // rax
  char v15; // dl
  const char *v16; // r9
  std::string::size_type v17; // rcx
  std::pair<std::string,const google::protobuf::EnumValueDescriptor*> *v18; // rdi
  std::string::size_type v19; // rbp
  char v20; // r14
  std::string::size_type v21; // r12
  char v22; // bl
  std::string::size_type M_allocated_capacity; // rax
  std::pair<std::string,const google::protobuf::EnumValueDescriptor*> *v24; // rdx
  std::pair<std::_Rb_tree_iterator<std::pair<const std::string,const google::protobuf::EnumValueDescriptor*> >,bool> v25; // rax
  const std::piecewise_construct_t *v26; // r9
  std::_Rb_tree_iterator<std::pair<const std::string,const google::protobuf::EnumValueDescriptor*> >::_Base_ptr M_node; // rbp
  bool second; // bl
  __int64 v29; // rbx
  size_t v30; // rdx
  std::_Rb_tree_node_base::_Base_ptr M_parent; // r12
  std::_Rb_tree_header *v32; // rbp
  std::string::size_type v33; // r15
  std::string::pointer v34; // r14
  std::_Rb_tree_node_base::_Base_ptr v35; // rbx
  size_t v36; // rdx
  int v37; // eax
  __int64 v38; // rbx
  std::string::pointer v39; // r8
  std::string::size_type v40; // r14
  size_t v41; // rbx
  size_t v42; // rdx
  int v43; // eax
  __int64 v44; // r14
  __int64 v45; // rbx
  __m128i *v46; // rax
  const char *v47; // rsi
  __int64 v48; // rax
  __int64 v49; // rax
  std::string::size_type v50; // rcx
  std::pair<std::string,const google::protobuf::EnumValueDescriptor*> *v51; // rdi
  const google::protobuf::Message *v52; // rdx
  const std::string *full_name; // rsi
  std::string::size_type v54; // r12
  std::string::pointer v55; // rdx
  std::string::size_type v56; // rax
  const char *v57; // rdx
  const char *v58; // rsi
  std::tuple<const std::string&> *v59; // [rsp+0h] [rbp-178h]
  google::protobuf::EnumValueDescriptor *v60; // [rsp+8h] [rbp-170h]
  __int64 v62; // [rsp+18h] [rbp-160h]
  std::string::size_type v63; // [rsp+18h] [rbp-160h]
  int v64; // [rsp+2Ch] [rbp-14Ch]
  void *v67; // [rsp+40h] [rbp-138h] BYREF
  unsigned __int64 v68; // [rsp+48h] [rbp-130h]
  __int64 v69[2]; // [rsp+50h] [rbp-128h] BYREF
  std::string __beg; // [rsp+60h] [rbp-118h] BYREF
  std::string v71; // [rsp+80h] [rbp-F8h] BYREF
  std::string v72; // [rsp+A0h] [rbp-D8h] BYREF
  std::tuple<> v73[8]; // [rsp+C0h] [rbp-B8h] BYREF
  __int64 v74; // [rsp+C8h] [rbp-B0h]
  __m128i v75; // [rsp+D0h] [rbp-A8h] BYREF
  std::pair<std::string,const google::protobuf::EnumValueDescriptor*> v76; // [rsp+E0h] [rbp-98h] BYREF
  std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::EnumValueDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::EnumValueDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::EnumValueDescriptor*> > > v77[2]; // [rsp+110h] [rbp-68h] BYREF

  M_string_length = a3->name_->_M_string_length;
  M_p = a3->name_->_M_dataplus._M_p;
  v67 = v69;
  v68 = 0LL;
  LOBYTE(v69[0]) = 0;
  if ( M_string_length > 0 )
  {
    v5 = &M_p[M_string_length];
    do
    {
      v6 = *M_p;
      if ( *M_p != 95 )
      {
        v7 = v68;
        v8 = 15LL;
        if ( (unsigned __int8)(v6 - 65) < 0x1Au )
          v6 += 32;
        v9 = v67;
        if ( v67 != v69 )
          v8 = v69[0];
        if ( v68 + 1 > v8 )
        {
          std::string::_M_mutate(&v67, v68, 0LL, 0LL, 1LL);
          v9 = v67;
        }
        v9[v7] = v6;
        v68 = v7 + 1;
        *((_BYTE *)v67 + v7 + 1) = 0;
      }
      ++M_p;
    }
    while ( v5 != M_p );
  }
  v77[0]._M_impl._M_header._M_color = _S_red;
  v77[0]._M_impl._M_header._M_left = &v77[0]._M_impl._M_header;
  v77[0]._M_impl._M_header._M_right = &v77[0]._M_impl._M_header;
  v77[0]._M_impl._M_header._M_parent = 0LL;
  v77[0]._M_impl._M_node_count = 0LL;
  if ( a3->value_count_ > 0 )
  {
    v10 = 0LL;
    while ( 1 )
    {
      LOBYTE(v11) = (_BYTE)a3;
      v64 = v10;
      v60 = &a3->values_[v10];
      v12 = v60->name_->_M_string_length;
      v13 = v60->name_->_M_dataplus._M_p;
      if ( !v12 )
        break;
      v11 = 0LL;
      for ( i = 0LL; i != v12; ++i )
      {
        if ( v11 >= v68 )
        {
          if ( v12 > i )
          {
            while ( 1 )
            {
              v16 = &v13[i];
              if ( v13[i] != 95 )
                goto LABEL_27;
              if ( v12 == ++i )
                goto LABEL_105;
            }
          }
          if ( v12 != i )
          {
            v16 = &v13[i];
            if ( !&v13[i] )
            {
              v76.first._M_dataplus._M_p = v76.first._anon_0._M_local_buf;
LABEL_113:
              v76.first._M_string_length = 0LL;
              v12 = 0LL;
              v76.first._anon_0._M_local_buf[0] = 0;
              goto LABEL_29;
            }
LABEL_27:
            v76.first._M_dataplus._M_p = v76.first._anon_0._M_local_buf;
            std::string::_M_construct<char const*>(&v76.first, v16, &v16[v12 - i], (std::forward_iterator_tag)v11);
            goto LABEL_28;
          }
LABEL_105:
          v76.first._M_dataplus._M_p = v76.first._anon_0._M_local_buf;
          if ( v13 )
          {
            std::string::_M_construct<char const*>(&v76.first, v13, &v13[v12], (std::forward_iterator_tag)v11);
            goto LABEL_28;
          }
          goto LABEL_113;
        }
        v15 = v13[i];
        if ( v15 != 95 )
        {
          if ( (unsigned __int8)(v15 - 65) < 0x1Au )
            v15 += 32;
          if ( *((_BYTE *)v67 + v11) != v15 )
            goto LABEL_103;
          ++v11;
        }
      }
      if ( v11 >= v68 )
        goto LABEL_105;
LABEL_103:
      v57 = &v13[v12];
      v58 = v60->name_->_M_dataplus._M_p;
      v76.first._M_dataplus._M_p = v76.first._anon_0._M_local_buf;
      std::string::_M_construct<char const*>(&v76.first, v58, v57, (std::forward_iterator_tag)v11);
LABEL_28:
      v12 = v76.first._M_string_length;
LABEL_29:
      __beg._anon_0._M_local_buf[0] = 0;
      __beg._M_dataplus._M_p = __beg._anon_0._M_local_buf;
      __beg._M_string_length = 0LL;
      std::string::reserve(&__beg, v12);
      v18 = (std::pair<std::string,const google::protobuf::EnumValueDescriptor*> *)v76.first._M_dataplus._M_p;
      if ( v76.first._M_string_length )
      {
        v19 = 0LL;
        v20 = 1;
        do
        {
          while ( 1 )
          {
            v22 = *((_BYTE *)&v18->first._M_dataplus._M_p + v19);
            if ( v22 != 95 )
              break;
            v20 = 1;
            if ( v76.first._M_string_length <= ++v19 )
              goto LABEL_42;
          }
          if ( v20 )
          {
            v21 = __beg._M_string_length;
            if ( (unsigned __int8)(v22 - 97) < 0x1Au )
              v22 -= 32;
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__beg._M_dataplus._M_p == &__beg._anon_0 )
              M_allocated_capacity = 15LL;
            else
              M_allocated_capacity = __beg._anon_0._M_allocated_capacity;
            if ( __beg._M_string_length + 1 > M_allocated_capacity )
              std::string::_M_mutate(&__beg, __beg._M_string_length, 0LL, 0LL, 1LL);
            __beg._M_dataplus._M_p[v21] = v22;
            __beg._M_string_length = v21 + 1;
            v20 = 0;
            __beg._M_dataplus._M_p[v21 + 1] = 0;
            v18 = (std::pair<std::string,const google::protobuf::EnumValueDescriptor*> *)v76.first._M_dataplus._M_p;
          }
          else
          {
            v54 = __beg._M_string_length;
            v55 = __beg._M_dataplus._M_p;
            if ( (unsigned __int8)(v22 - 65) < 0x1Au )
              v22 += 32;
            v56 = 15LL;
            v17 = __beg._M_string_length + 1;
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__beg._M_dataplus._M_p != &__beg._anon_0 )
              v56 = __beg._anon_0._M_allocated_capacity;
            v63 = __beg._M_string_length + 1;
            if ( v17 > v56 )
            {
              std::string::_M_mutate(&__beg, __beg._M_string_length, 0LL, 0LL, 1LL);
              v55 = __beg._M_dataplus._M_p;
            }
            v55[v54] = v22;
            __beg._M_string_length = v63;
            __beg._M_dataplus._M_p[v54 + 1] = 0;
            v18 = (std::pair<std::string,const google::protobuf::EnumValueDescriptor*> *)v76.first._M_dataplus._M_p;
          }
          ++v19;
        }
        while ( v76.first._M_string_length > v19 );
      }
LABEL_42:
      if ( v18 != (std::pair<std::string,const google::protobuf::EnumValueDescriptor*> *)&v76.first._anon_0 )
        operator delete(v18);
      v76.first._M_dataplus._M_p = v76.first._anon_0._M_local_buf;
      std::string::_M_construct<char *>(
        &v76.first,
        __beg._M_dataplus._M_p,
        &__beg._M_dataplus._M_p[__beg._M_string_length],
        (std::forward_iterator_tag)v17);
      v76.second = v60;
      v25 = std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>>>::_M_emplace_unique<std::pair<std::string,google::protobuf::EnumValueDescriptor const*>>(
              v77,
              &v76,
              v24);
      M_node = v25.first._M_node;
      second = v25.second;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v76.first._M_dataplus._M_p != &v76.first._anon_0 )
        operator delete(v76.first._M_dataplus._M_p);
      if ( second )
        goto LABEL_88;
      v29 = *(_QWORD *)&M_node[2]._M_color;
      v30 = *(_QWORD *)(*(_QWORD *)v29 + 8LL);
      if ( v30 == v60->name_->_M_string_length
        && (!v30 || !memcmp(**(const void ***)v29, v60->name_->_M_dataplus._M_p, v30)) )
      {
        goto LABEL_88;
      }
      if ( *(_DWORD *)(v29 + 16) == v60->number_ )
        goto LABEL_88;
      M_parent = v77[0]._M_impl._M_header._M_parent;
      if ( !v77[0]._M_impl._M_header._M_parent )
      {
        v32 = &v77[0]._M_impl.std::_Rb_tree_header;
        goto LABEL_115;
      }
      v62 = v10;
      v32 = &v77[0]._M_impl.std::_Rb_tree_header;
      v33 = __beg._M_string_length;
      v34 = __beg._M_dataplus._M_p;
      while ( 2 )
      {
        while ( 2 )
        {
          v35 = M_parent[1]._M_parent;
          v36 = v33;
          if ( (unsigned __int64)v35 <= v33 )
            v36 = (size_t)M_parent[1]._M_parent;
          if ( !v36 || (v37 = memcmp(*(const void **)&M_parent[1]._M_color, v34, v36)) == 0 )
          {
            v38 = (__int64)v35 - v33;
            if ( v38 >= 0x80000000LL )
              goto LABEL_60;
            if ( v38 > (__int64)0xFFFFFFFF7FFFFFFFLL )
            {
              v37 = v38;
              break;
            }
LABEL_51:
            M_parent = M_parent->_M_right;
            if ( !M_parent )
              goto LABEL_61;
            continue;
          }
          break;
        }
        if ( v37 < 0 )
          goto LABEL_51;
LABEL_60:
        v32 = (std::_Rb_tree_header *)M_parent;
        M_parent = M_parent->_M_left;
        if ( M_parent )
          continue;
        break;
      }
LABEL_61:
      v39 = v34;
      v40 = v33;
      v10 = v62;
      if ( v32 == &v77[0]._M_impl.std::_Rb_tree_header )
        goto LABEL_115;
      v41 = *(_QWORD *)&v32[1]._M_header._M_color;
      v42 = v41;
      if ( v40 <= v41 )
        v42 = v40;
      if ( v42 && (v43 = memcmp(v39, (const void *)v32->_M_node_count, v42)) != 0 )
      {
LABEL_69:
        if ( v43 < 0 )
          goto LABEL_115;
      }
      else
      {
        v44 = v40 - v41;
        if ( v44 < 0x80000000LL )
        {
          if ( v44 > (__int64)0xFFFFFFFF7FFFFFFFLL )
          {
            v43 = v44;
            goto LABEL_69;
          }
LABEL_115:
          v76.first._M_dataplus._M_p = (std::string::pointer)&__beg;
          v32 = (std::_Rb_tree_header *)std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>>>::_M_emplace_hint_unique<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(
                                          v77,
                                          (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::EnumValueDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::EnumValueDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::EnumValueDescriptor*> > >::const_iterator)v32,
                                          &std::piecewise_construct,
                                          (std::tuple<const std::string&> *)&v76,
                                          v73,
                                          v26,
                                          v59,
                                          (std::tuple<> *)v60)._M_node;
        }
      }
      v45 = *(_QWORD *)v32[1]._M_header._M_right;
      std::operator+<char>(&v72, "When enum name is stripped and label is PascalCased (", &__beg);
      if ( 0x3FFFFFFFFFFFFFFFLL - v72._M_string_length <= 0x22 )
        std::__throw_length_error("basic_string::append");
      v46 = (__m128i *)std::string::_M_append(&v72, "), this value label conflicts with ", 35LL);
      *(_QWORD *)v73[0].gap0 = &v75;
      if ( (__m128i *)v46->m128i_i64[0] == &v46[1] )
      {
        v75 = _mm_loadu_si128(v46 + 1);
      }
      else
      {
        *(_QWORD *)v73[0].gap0 = v46->m128i_i64[0];
        v75.m128i_i64[0] = v46[1].m128i_i64[0];
      }
      v74 = v46->m128i_i64[1];
      v46->m128i_i64[0] = (__int64)v46[1].m128i_i64;
      v46[1].m128i_i8[0] = 0;
      v47 = *(const char **)v45;
      v46->m128i_i64[1] = 0LL;
      v48 = std::string::_M_append(v73, v47, *(_QWORD *)(v45 + 8));
      v76.first._M_dataplus._M_p = v76.first._anon_0._M_local_buf;
      if ( *(_QWORD *)v48 == v48 + 16 )
      {
        v76.first._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v48 + 16));
      }
      else
      {
        v76.first._M_dataplus._M_p = *(std::string::pointer *)v48;
        v76.first._anon_0._M_allocated_capacity = *(_QWORD *)(v48 + 16);
      }
      v76.first._M_string_length = *(_QWORD *)(v48 + 8);
      *(_QWORD *)(v48 + 8) = 0LL;
      *(_BYTE *)(v48 + 16) = 0;
      *(_QWORD *)v48 = v48 + 16;
      if ( 0x3FFFFFFFFFFFFFFFLL - v76.first._M_string_length <= 0x49 )
        std::__throw_length_error("basic_string::append");
      v49 = std::string::_M_append(
              &v76,
              ". This will make the proto fail to compile for some languages, such as C#.",
              74LL);
      v71._M_dataplus._M_p = v71._anon_0._M_local_buf;
      if ( *(_QWORD *)v49 == v49 + 16 )
      {
        v71._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v49 + 16));
      }
      else
      {
        v71._M_dataplus._M_p = *(std::string::pointer *)v49;
        v71._anon_0._M_allocated_capacity = *(_QWORD *)(v49 + 16);
      }
      v50 = *(_QWORD *)(v49 + 8);
      *(_BYTE *)(v49 + 16) = 0;
      v71._M_string_length = v50;
      *(_QWORD *)v49 = v49 + 16;
      v51 = (std::pair<std::string,const google::protobuf::EnumValueDescriptor*> *)v76.first._M_dataplus._M_p;
      *(_QWORD *)(v49 + 8) = 0LL;
      if ( v51 != (std::pair<std::string,const google::protobuf::EnumValueDescriptor*> *)&v76.first._anon_0 )
        operator delete(v51);
      if ( *(__m128i **)v73[0].gap0 != &v75 )
        operator delete(*(void **)v73[0].gap0);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v72._M_dataplus._M_p != &v72._anon_0 )
        operator delete(v72._M_dataplus._M_p);
      v52 = (const google::protobuf::Message *)a2->value_.rep_->elements[v64];
      full_name = v60->full_name_;
      if ( a3->file_->syntax_ == SYNTAX_PROTO2 )
        google::protobuf::DescriptorBuilder::AddWarning((__int64)this, full_name, v52, NAME, &v71);
      else
        google::protobuf::DescriptorBuilder::AddError((__int64)this, full_name, (__int64)v52, 0, &v71);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v71._M_dataplus._M_p != &v71._anon_0 )
        operator delete(v71._M_dataplus._M_p);
LABEL_88:
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__beg._M_dataplus._M_p != &__beg._anon_0 )
        operator delete(__beg._M_dataplus._M_p);
      if ( a3->value_count_ <= (int)++v10 )
      {
        std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>>>::_M_erase(
          v77,
          (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::EnumValueDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::EnumValueDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::EnumValueDescriptor*> > >::_Link_type)v77[0]._M_impl._M_header._M_parent);
        goto LABEL_92;
      }
    }
    if ( v68 )
    {
      if ( v13 )
        goto LABEL_103;
      v76.first._anon_0._M_local_buf[0] = 0;
      v76.first._M_dataplus._M_p = v76.first._anon_0._M_local_buf;
      v76.first._M_string_length = 0LL;
      goto LABEL_29;
    }
    goto LABEL_105;
  }
  std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::EnumValueDescriptor const*>>>::_M_erase(
    v77,
    0LL);
LABEL_92:
  if ( v67 != v69 )
    operator delete(v67);
};

// Line 4906: range 000000000C9067B0-000000000C906978
void __fastcall google::protobuf::DescriptorBuilder::BuildEnum(
        google::protobuf::DescriptorBuilder *const this,
        const google::protobuf::EnumDescriptorProto *proto,
        const google::protobuf::Descriptor *parent,
        google::protobuf::EnumDescriptor *result)
{
  const std::string *full_name; // rsi
  std::string *String; // rax
  std::string::size_type M_string_length; // rsi
  const std::string *v10; // r15
  std::string *v11; // rax
  google::protobuf::FileDescriptor *file; // rax
  int current_size; // eax
  google::protobuf::EnumValueDescriptor *Bytes; // rax
  int v15; // edx
  __int64 v16; // rbx
  google::protobuf::EnumValueDescriptor *v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // r9
  google::protobuf::EnumOptions *options; // rcx
  __int128 v21; // [rsp-10h] [rbp-48h]

  if ( parent )
    full_name = parent->full_name_;
  else
    full_name = this->file_->package_;
  String = google::protobuf::DescriptorPool::Tables::AllocateString(
             (std::vector<std::string*> *)this->tables_,
             (__int64)full_name);
  M_string_length = String->_M_string_length;
  v10 = String;
  if ( M_string_length )
    std::string::_M_replace_aux(String, M_string_length, 0LL, 1LL, 46LL);
  std::string::_M_append(v10, proto->name_.ptr_->_M_dataplus._M_p, proto->name_.ptr_->_M_string_length);
  google::protobuf::DescriptorBuilder::ValidateSymbolName((__int64)this, proto->name_.ptr_, v10, (__int64)proto);
  v11 = google::protobuf::DescriptorPool::Tables::AllocateString(
          (std::vector<std::string*> *)this->tables_,
          (__int64)proto->name_.ptr_);
  result->full_name_ = v10;
  result->name_ = v11;
  file = this->file_;
  result->containing_type_ = parent;
  result->file_ = file;
  current_size = proto->value_.current_size_;
  *(_WORD *)&result->is_placeholder_ = 0;
  if ( !current_size )
  {
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      v10,
      (__int64)proto,
      0,
      "Enums must contain at least one value.");
    current_size = proto->value_.current_size_;
  }
  result->value_count_ = current_size;
  Bytes = (google::protobuf::EnumValueDescriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                     this->tables_,
                                                     40 * current_size);
  v15 = proto->value_.current_size_;
  result->values_ = Bytes;
  if ( v15 > 0 )
  {
    v16 = 0LL;
    while ( 1 )
    {
      v17 = &Bytes[v16];
      v18 = (int)v16++;
      google::protobuf::DescriptorBuilder::BuildEnumValue(
        this,
        (const google::protobuf::EnumValueDescriptorProto *)proto->value_.rep_->elements[v18],
        result,
        v17);
      if ( proto->value_.current_size_ <= (int)v16 )
        break;
      Bytes = result->values_;
    }
  }
  google::protobuf::DescriptorBuilder::CheckEnumValueUniqueness(this, proto, result);
  if ( (proto->_has_bits_.has_bits_[0] & 2) != 0 )
  {
    options = proto->options_;
    if ( !options )
      options = (google::protobuf::EnumOptions *)&google::protobuf::_EnumOptions_default_instance_;
    google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::EnumDescriptor>(
      this,
      result->full_name_,
      result->full_name_,
      options,
      result);
  }
  else
  {
    result->options_ = 0LL;
  }
  *((_QWORD *)&v21 + 1) = result;
  *(_QWORD *)&v21 = 4LL;
  google::protobuf::DescriptorBuilder::AddSymbol(
    (__int64)this,
    (std::string *)result->full_name_,
    (__int64)parent,
    (const char **)&result->name_->_M_dataplus._M_p,
    (__int64)proto,
    v19,
    v21);
};

// Line 4947: range 000000000C906030-000000000C9067A3
__int64 __fastcall google::protobuf::DescriptorBuilder::BuildEnumValue(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::EnumValueDescriptorProto *a2,
        google::protobuf::EnumDescriptor *a3,
        google::protobuf::EnumValueDescriptor *a4)
{
  std::string *String; // rax
  const std::string *full_name; // rsi
  google::protobuf::DescriptorPool::Tables *tables; // rdi
  std::string *v11; // r13
  char v12; // al
  google::protobuf::FileDescriptorTables *file_tables; // rdi
  char v14; // r13
  std::string::pointer M_p; // rax
  char v16; // dl
  const google::protobuf::Descriptor *containing_type; // rax
  const std::string *name; // r13
  __int64 v19; // rax
  void *v20; // rcx
  const char *v21; // rsi
  __int64 v22; // rax
  __int64 v23; // rcx
  __int64 v24; // rax
  void *v25; // rcx
  const char *v26; // rsi
  __int64 v27; // rax
  __int64 v28; // rax
  const std::string *v29; // rsi
  google::protobuf::FileDescriptorTables *v30; // rdi
  int number; // eax
  char *type; // rdx
  google::protobuf::EnumValueOptions *options; // rcx
  __int64 v35; // rax
  std::string *p_anon_0; // rdi
  std::string::size_type M_allocated_capacity; // rsi
  std::string::size_type M_string_length; // rdx
  __int128 v39; // [rsp-10h] [rbp-128h]
  std::string dest; // [rsp+0h] [rbp-118h] BYREF
  std::string v41; // [rsp+20h] [rbp-F8h] BYREF
  void *v42[2]; // [rsp+40h] [rbp-D8h] BYREF
  __m128i v43; // [rsp+50h] [rbp-C8h] BYREF
  void *v44; // [rsp+60h] [rbp-B8h] BYREF
  __int64 v45; // [rsp+68h] [rbp-B0h]
  __m128i v46; // [rsp+70h] [rbp-A8h] BYREF
  void *v47[2]; // [rsp+80h] [rbp-98h] BYREF
  __m128i v48; // [rsp+90h] [rbp-88h] BYREF
  std::string v49; // [rsp+A0h] [rbp-78h] BYREF
  std::string __k[2]; // [rsp+C0h] [rbp-58h] BYREF

  String = google::protobuf::DescriptorPool::Tables::AllocateString(
             (std::vector<std::string*> *)this->tables_,
             (__int64)a2->name_.ptr_);
  full_name = a3->full_name_;
  tables = this->tables_;
  a4->name_ = String;
  LODWORD(String) = a2->number_;
  a4->type_ = a3;
  a4->number_ = (int)String;
  v11 = google::protobuf::DescriptorPool::Tables::AllocateString(
          (std::vector<std::string*> *)tables,
          (__int64)full_name);
  std::string::resize(v11, v11->_M_string_length - a3->name_->_M_string_length, 0LL);
  std::string::_M_append(v11, a4->name_->_M_dataplus._M_p, a4->name_->_M_string_length);
  a4->full_name_ = v11;
  google::protobuf::DescriptorBuilder::ValidateSymbolName((__int64)this, a2->name_.ptr_, v11, (__int64)a2);
  if ( (a2->_has_bits_.has_bits_[0] & 2) != 0 )
  {
    options = a2->options_;
    if ( !options )
      options = (google::protobuf::EnumValueOptions *)&google::protobuf::_EnumValueOptions_default_instance_;
    google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::EnumValueDescriptor>(
      this,
      a4->full_name_,
      a4->full_name_,
      options,
      a4);
  }
  else
  {
    a4->options_ = 0LL;
  }
  *((_QWORD *)&v39 + 1) = a4;
  *(_QWORD *)&v39 = 5LL;
  v12 = google::protobuf::DescriptorBuilder::AddSymbol(
          (__int64)this,
          (std::string *)a4->full_name_,
          (__int64)a3->containing_type_,
          (const char **)&a4->name_->_M_dataplus._M_p,
          (__int64)a2,
          (__int64)a3->containing_type_,
          v39);
  file_tables = this->file_tables_;
  v14 = v12;
  M_p = a4->name_->_M_dataplus._M_p;
  __k[0]._M_dataplus._M_p = (std::string::pointer)a3;
  *(_DWORD *)__k[0]._anon_0._M_local_buf = 5;
  __k[0]._M_string_length = (std::string::size_type)M_p;
  *(&__k[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a4;
  std::_Hashtable<std::pair<void const*,char const*>,std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,std::allocator<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>>,std::__detail::_Select1st,google::protobuf::`anonymous namespace'::PointerStringPairEqual,google::protobuf::`anonymous namespace'::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<void const*,char const*> const,google::protobuf::Symbol>,true>>>>(
    &file_tables->symbols_by_parent_._M_h,
    (std::_Hashtable<std::pair<void const*,char const*>,std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol>,std::allocator<std::pair<const std::pair<void const*,char const*>,google::protobuf::Symbol> >,std::__detail::_Select1st,google::protobuf::(anonymous namespace)::PointerStringPairEqual,google::protobuf::(anonymous namespace)::PointerStringPairHash,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *)__k);
  if ( v14 != 1 && v16 )
  {
    containing_type = a3->containing_type_;
    dest._anon_0._M_local_buf[0] = 0;
    dest._M_dataplus._M_p = dest._anon_0._M_local_buf;
    dest._M_string_length = 0LL;
    if ( containing_type )
    {
      std::string::_M_assign(&dest, containing_type->full_name_);
      if ( !dest._M_string_length )
      {
LABEL_7:
        std::string::_M_replace(&dest, 0LL, 0LL, "the global scope", 16LL);
LABEL_8:
        name = a3->name_;
        std::operator+<char>(
          &v41,
          "Note that enum values use C++ scoping rules, meaning that enum values are siblings of their type, not children"
          " of it.  Therefore, \"",
          a4->name_);
        if ( 0x3FFFFFFFFFFFFFFFLL - v41._M_string_length <= 0x17 )
          std::__throw_length_error("basic_string::append");
        v19 = std::string::_M_append(&v41, "\" must be unique within ", 24LL);
        v42[0] = &v43;
        if ( *(_QWORD *)v19 == v19 + 16 )
        {
          v43 = _mm_loadu_si128((const __m128i *)(v19 + 16));
        }
        else
        {
          v42[0] = *(void **)v19;
          v43.m128i_i64[0] = *(_QWORD *)(v19 + 16);
        }
        v20 = *(void **)(v19 + 8);
        *(_BYTE *)(v19 + 16) = 0;
        v42[1] = v20;
        *(_QWORD *)v19 = v19 + 16;
        v21 = dest._M_dataplus._M_p;
        *(_QWORD *)(v19 + 8) = 0LL;
        v22 = std::string::_M_append(v42, v21, dest._M_string_length);
        v44 = &v46;
        if ( *(_QWORD *)v22 == v22 + 16 )
        {
          v46 = _mm_loadu_si128((const __m128i *)(v22 + 16));
        }
        else
        {
          v44 = *(void **)v22;
          v46.m128i_i64[0] = *(_QWORD *)(v22 + 16);
        }
        v23 = *(_QWORD *)(v22 + 8);
        *(_BYTE *)(v22 + 16) = 0;
        v45 = v23;
        *(_QWORD *)(v22 + 8) = 0LL;
        *(_QWORD *)v22 = v22 + 16;
        if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v45) <= 0x12 )
          std::__throw_length_error("basic_string::append");
        v24 = std::string::_M_append(&v44, ", not just within \"", 19LL);
        v47[0] = &v48;
        if ( *(_QWORD *)v24 == v24 + 16 )
        {
          v48 = _mm_loadu_si128((const __m128i *)(v24 + 16));
        }
        else
        {
          v47[0] = *(void **)v24;
          v48.m128i_i64[0] = *(_QWORD *)(v24 + 16);
        }
        v25 = *(void **)(v24 + 8);
        *(_BYTE *)(v24 + 16) = 0;
        v47[1] = v25;
        *(_QWORD *)v24 = v24 + 16;
        v26 = name->_M_dataplus._M_p;
        *(_QWORD *)(v24 + 8) = 0LL;
        v27 = std::string::_M_append(v47, v26, name->_M_string_length);
        v49._M_dataplus._M_p = v49._anon_0._M_local_buf;
        if ( *(_QWORD *)v27 == v27 + 16 )
        {
          v49._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v27 + 16));
        }
        else
        {
          v49._M_dataplus._M_p = *(std::string::pointer *)v27;
          v49._anon_0._M_allocated_capacity = *(_QWORD *)(v27 + 16);
        }
        v49._M_string_length = *(_QWORD *)(v27 + 8);
        *(_QWORD *)(v27 + 8) = 0LL;
        *(_BYTE *)(v27 + 16) = 0;
        *(_QWORD *)v27 = v27 + 16;
        if ( v49._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v49._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        v28 = std::string::_M_append(&v49, "\".", 2LL);
        __k[0]._M_dataplus._M_p = __k[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v28 == v28 + 16 )
        {
          __k[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v28 + 16));
        }
        else
        {
          __k[0]._M_dataplus._M_p = *(std::string::pointer *)v28;
          __k[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v28 + 16);
        }
        __k[0]._M_string_length = *(_QWORD *)(v28 + 8);
        *(_QWORD *)v28 = v28 + 16;
        *(_BYTE *)(v28 + 16) = 0;
        v29 = a4->full_name_;
        *(_QWORD *)(v28 + 8) = 0LL;
        google::protobuf::DescriptorBuilder::AddError((__int64)this, v29, (__int64)a2, 0, __k);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__k[0]._M_dataplus._M_p != &__k[0]._anon_0 )
          operator delete(__k[0]._M_dataplus._M_p);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v49._M_dataplus._M_p != &v49._anon_0 )
          operator delete(v49._M_dataplus._M_p);
        if ( v47[0] != &v48 )
          operator delete(v47[0]);
        if ( v44 != &v46 )
          operator delete(v44);
        if ( v42[0] != &v43 )
          operator delete(v42[0]);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v41._M_dataplus._M_p != &v41._anon_0 )
          operator delete(v41._M_dataplus._M_p);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)dest._M_dataplus._M_p != &dest._anon_0 )
          operator delete(dest._M_dataplus._M_p);
        goto LABEL_35;
      }
    }
    else
    {
      std::string::_M_assign(&dest, this->file_->package_);
      if ( !dest._M_string_length )
        goto LABEL_7;
    }
    std::operator+<char>(&v49, "\"", &dest);
    if ( v49._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
      std::__throw_length_error("basic_string::append");
    v35 = std::string::_M_append(&v49, "\"", 1LL);
    __k[0]._M_dataplus._M_p = __k[0]._anon_0._M_local_buf;
    if ( *(_QWORD *)v35 == v35 + 16 )
    {
      __k[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v35 + 16));
    }
    else
    {
      __k[0]._M_dataplus._M_p = *(std::string::pointer *)v35;
      __k[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v35 + 16);
    }
    __k[0]._M_string_length = *(_QWORD *)(v35 + 8);
    *(_QWORD *)v35 = v35 + 16;
    p_anon_0 = (std::string *)dest._M_dataplus._M_p;
    *(_QWORD *)(v35 + 8) = 0LL;
    *(_BYTE *)(v35 + 16) = 0;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__k[0]._M_dataplus._M_p == &__k[0]._anon_0 )
    {
      M_string_length = __k[0]._M_string_length;
      if ( __k[0]._M_string_length )
      {
        if ( __k[0]._M_string_length == 1 )
          LOBYTE(p_anon_0->_M_dataplus._M_p) = __k[0]._anon_0._M_local_buf[0];
        else
          memcpy(p_anon_0, &__k[0]._anon_0, __k[0]._M_string_length);
        M_string_length = __k[0]._M_string_length;
        p_anon_0 = (std::string *)dest._M_dataplus._M_p;
      }
      dest._M_string_length = M_string_length;
      *((_BYTE *)&p_anon_0->_M_dataplus._M_p + M_string_length) = 0;
      p_anon_0 = (std::string *)__k[0]._M_dataplus._M_p;
      goto LABEL_47;
    }
    if ( p_anon_0 == (std::string *)&dest._anon_0 )
    {
      dest._M_dataplus._M_p = __k[0]._M_dataplus._M_p;
      dest._M_string_length = __k[0]._M_string_length;
      dest._anon_0._M_allocated_capacity = __k[0]._anon_0._M_allocated_capacity;
    }
    else
    {
      M_allocated_capacity = dest._anon_0._M_allocated_capacity;
      dest._M_dataplus._M_p = __k[0]._M_dataplus._M_p;
      dest._M_string_length = __k[0]._M_string_length;
      dest._anon_0._M_allocated_capacity = __k[0]._anon_0._M_allocated_capacity;
      if ( p_anon_0 )
      {
        __k[0]._M_dataplus._M_p = (std::string::pointer)p_anon_0;
        __k[0]._anon_0._M_allocated_capacity = M_allocated_capacity;
LABEL_47:
        __k[0]._M_string_length = 0LL;
        LOBYTE(p_anon_0->_M_dataplus._M_p) = 0;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__k[0]._M_dataplus._M_p != &__k[0]._anon_0 )
          operator delete(__k[0]._M_dataplus._M_p);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v49._M_dataplus._M_p != &v49._anon_0 )
          operator delete(v49._M_dataplus._M_p);
        goto LABEL_8;
      }
    }
    __k[0]._M_dataplus._M_p = __k[0]._anon_0._M_local_buf;
    p_anon_0 = (std::string *)&__k[0]._anon_0;
    goto LABEL_47;
  }
LABEL_35:
  v30 = this->file_tables_;
  number = a4->number_;
  __k[0]._anon_0._M_allocated_capacity = (std::string::size_type)a4;
  type = (char *)a4->type_;
  LODWORD(__k[0]._M_string_length) = number;
  __k[0]._M_dataplus._M_p = type;
  return std::_Hashtable<std::pair<google::protobuf::EnumDescriptor const*,int>,std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::EnumDescriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::EnumDescriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<google::protobuf::EnumDescriptor const*,int> const,google::protobuf::EnumValueDescriptor const*>,true>>>>(
           &v30->enum_values_by_number_,
           __k);
};

// Line 5015: range 000000000C905ED0-000000000C906025
void __fastcall google::protobuf::DescriptorBuilder::BuildService(
        google::protobuf::DescriptorBuilder *const this,
        const google::protobuf::ServiceDescriptorProto *proto,
        const void *a3,
        google::protobuf::ServiceDescriptor *result)
{
  std::string *String; // rax
  std::string::size_type M_string_length; // rsi
  const std::string *v9; // rbx
  std::string *v10; // rax
  google::protobuf::DescriptorPool::Tables *tables; // rdi
  google::protobuf::MethodDescriptor *Bytes; // rax
  __int64 v13; // r9
  int current_size; // ecx
  __int64 v15; // r13
  int v16; // ebx
  google::protobuf::MethodDescriptor *v17; // rcx
  __int64 v18; // rdx
  google::protobuf::ServiceOptions *options; // rcx
  __int128 v20; // [rsp-10h] [rbp-38h]

  String = google::protobuf::DescriptorPool::Tables::AllocateString(
             (std::vector<std::string*> *)this->tables_,
             (__int64)this->file_->package_);
  M_string_length = String->_M_string_length;
  v9 = String;
  if ( M_string_length )
    std::string::_M_replace_aux(String, M_string_length, 0LL, 1LL, 46LL);
  std::string::_M_append(v9, proto->name_.ptr_->_M_dataplus._M_p, proto->name_.ptr_->_M_string_length);
  google::protobuf::DescriptorBuilder::ValidateSymbolName((__int64)this, proto->name_.ptr_, v9, (__int64)proto);
  v10 = google::protobuf::DescriptorPool::Tables::AllocateString(
          (std::vector<std::string*> *)this->tables_,
          (__int64)proto->name_.ptr_);
  result->full_name_ = v9;
  tables = this->tables_;
  result->name_ = v10;
  result->file_ = this->file_;
  result->method_count_ = proto->method_.current_size_;
  Bytes = (google::protobuf::MethodDescriptor *)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                  tables,
                                                  104 * proto->method_.current_size_);
  current_size = proto->method_.current_size_;
  result->methods_ = Bytes;
  if ( current_size > 0 )
  {
    v15 = 0LL;
    v16 = 0;
    while ( 1 )
    {
      v17 = &Bytes[v15];
      v18 = v16++;
      ++v15;
      google::protobuf::DescriptorBuilder::BuildMethod(
        this,
        (const google::protobuf::MethodDescriptorProto *)proto->method_.rep_->elements[v18],
        result,
        v17);
      if ( v16 >= proto->method_.current_size_ )
        break;
      Bytes = result->methods_;
    }
  }
  if ( (proto->_has_bits_.has_bits_[0] & 2) != 0 )
  {
    options = proto->options_;
    if ( !options )
      options = (google::protobuf::ServiceOptions *)&google::protobuf::_ServiceOptions_default_instance_;
    google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::ServiceDescriptor>(
      this,
      result->full_name_,
      result->full_name_,
      options,
      result);
  }
  else
  {
    result->options_ = 0LL;
  }
  *((_QWORD *)&v20 + 1) = result;
  *(_QWORD *)&v20 = 6LL;
  google::protobuf::DescriptorBuilder::AddSymbol(
    (__int64)this,
    (std::string *)result->full_name_,
    0LL,
    (const char **)&result->name_->_M_dataplus._M_p,
    (__int64)proto,
    v13,
    v20);
};

// Line 5041: range 000000000C905D90-000000000C905EC2
void __fastcall google::protobuf::DescriptorBuilder::BuildMethod(
        google::protobuf::DescriptorBuilder *const this,
        const google::protobuf::MethodDescriptorProto *proto,
        const google::protobuf::ServiceDescriptor *parent,
        google::protobuf::MethodDescriptor *result)
{
  std::string *String; // rax
  google::protobuf::DescriptorPool::Tables *tables; // rdi
  std::string *v9; // r12
  __int64 v10; // r9
  google::protobuf::MethodOptions *options; // rcx
  __int128 v12; // [rsp-10h] [rbp-38h]

  String = google::protobuf::DescriptorPool::Tables::AllocateString(
             (std::vector<std::string*> *)this->tables_,
             (__int64)proto->name_.ptr_);
  result->service_ = parent;
  tables = this->tables_;
  result->name_ = String;
  v9 = google::protobuf::DescriptorPool::Tables::AllocateString(
         (std::vector<std::string*> *)tables,
         (__int64)parent->full_name_);
  std::string::_M_replace_aux(v9, v9->_M_string_length, 0LL, 1LL, 46LL);
  std::string::_M_append(v9, result->name_->_M_dataplus._M_p, result->name_->_M_string_length);
  result->full_name_ = v9;
  google::protobuf::DescriptorBuilder::ValidateSymbolName((__int64)this, proto->name_.ptr_, v9, (__int64)proto);
  result->input_type_.descriptor_ = 0LL;
  result->input_type_.name_ = 0LL;
  result->input_type_.once_ = 0LL;
  result->input_type_.file_ = 0LL;
  result->output_type_.descriptor_ = 0LL;
  result->output_type_.name_ = 0LL;
  result->output_type_.once_ = 0LL;
  result->output_type_.file_ = 0LL;
  if ( (proto->_has_bits_.has_bits_[0] & 8) != 0 )
  {
    options = proto->options_;
    if ( !options )
      options = (google::protobuf::MethodOptions *)&google::protobuf::_MethodOptions_default_instance_;
    google::protobuf::DescriptorBuilder::AllocateOptionsImpl<google::protobuf::MethodDescriptor>(
      this,
      result->full_name_,
      result->full_name_,
      options,
      result);
  }
  else
  {
    result->options_ = 0LL;
  }
  *((_QWORD *)&v12 + 1) = result;
  result->client_streaming_ = proto->client_streaming_;
  result->server_streaming_ = proto->server_streaming_;
  *(_QWORD *)&v12 = 7LL;
  google::protobuf::DescriptorBuilder::AddSymbol(
    (__int64)this,
    (std::string *)result->full_name_,
    (__int64)parent,
    (const char **)&result->name_->_M_dataplus._M_p,
    (__int64)proto,
    v10,
    v12);
};

// Line 5075: range 000000000C916850-000000000C916984
void __fastcall google::protobuf::DescriptorBuilder::CrossLinkFile(
        google::protobuf::DescriptorBuilder *const this,
        google::protobuf::FileDescriptor *file,
        const google::protobuf::FileDescriptorProto *proto)
{
  __int64 v5; // r14
  int v6; // r13d
  __int64 v7; // rdx
  google::protobuf::Descriptor *v8; // rsi
  __int64 v9; // r14
  int v10; // r13d
  __int64 v11; // rdx
  google::protobuf::FieldDescriptor *v12; // rsi
  __int64 v13; // r14
  int v14; // r13d
  __int64 v15; // rdx
  google::protobuf::EnumDescriptor *v16; // rsi
  __int64 v17; // r14
  int v18; // r13d
  __int64 v19; // rdx
  google::protobuf::ServiceDescriptor *v20; // rsi

  if ( !file->options_ )
    file->options_ = (const google::protobuf::FileOptions *)google::protobuf::FileOptions::default_instance((google::protobuf::FileOptions *)this);
  v5 = 0LL;
  v6 = 0;
  while ( v6 < file->message_type_count_ )
  {
    v7 = v6++;
    v8 = &file->message_types_[v5++];
    google::protobuf::DescriptorBuilder::CrossLinkMessage(
      this,
      v8,
      (const google::protobuf::DescriptorProto *)proto->message_type_.rep_->elements[v7]);
  }
  v9 = 0LL;
  v10 = 0;
  while ( v10 < file->extension_count_ )
  {
    v11 = v10++;
    v12 = &file->extensions_[v9++];
    google::protobuf::DescriptorBuilder::CrossLinkField(
      this,
      v12,
      (const google::protobuf::FieldDescriptorProto *)proto->extension_.rep_->elements[v11]);
  }
  v13 = 0LL;
  v14 = 0;
  while ( v14 < file->enum_type_count_ )
  {
    v15 = v14++;
    v16 = &file->enum_types_[v13++];
    google::protobuf::DescriptorBuilder::CrossLinkEnum(
      this,
      v16,
      (const google::protobuf::EnumDescriptorProto *)proto->enum_type_.rep_->elements[v15]);
  }
  v17 = 0LL;
  v18 = 0;
  while ( v18 < file->service_count_ )
  {
    v19 = v18++;
    v20 = &file->services_[v17++];
    google::protobuf::DescriptorBuilder::CrossLinkService(
      this,
      v20,
      (const google::protobuf::ServiceDescriptorProto *)proto->service_.rep_->elements[v19]);
  }
};

// Line 5098: range 000000000C916140-000000000C916844
google::protobuf::OneofDescriptor *__fastcall google::protobuf::DescriptorBuilder::CrossLinkMessage(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::Descriptor *a2,
        const google::protobuf::DescriptorProto *a3)
{
  __int64 v6; // r12
  int v7; // ebp
  __int64 v8; // rdx
  google::protobuf::Descriptor *v9; // rsi
  __int64 v10; // r12
  int v11; // ebp
  __int64 v12; // rdx
  google::protobuf::EnumDescriptor *v13; // rsi
  __int64 v14; // r12
  int v15; // ebp
  __int64 v16; // rdx
  google::protobuf::FieldDescriptor *v17; // rsi
  __int64 v18; // r12
  int v19; // ebp
  __int64 v20; // rdx
  google::protobuf::FieldDescriptor *v21; // rsi
  google::protobuf::ExtensionRangeOptions *extension_range_count; // rdi
  __int64 v23; // r12
  google::protobuf::Descriptor::ExtensionRange *v24; // rbp
  __int64 v25; // r12
  int v26; // r15d
  google::protobuf::FieldDescriptor *fields; // rax
  const google::protobuf::OneofDescriptor *containing_oneof; // rbp
  __int64 v29; // rax
  __int64 *name; // rdx
  __int64 *v31; // rax
  __int64 v32; // rcx
  __int64 v33; // rdx
  __int64 v34; // rdx
  __int64 v35; // rax
  const std::string *v36; // rax
  __int64 v37; // rax
  std::string::size_type v38; // rcx
  google::protobuf::OneofDescriptor *v39; // rax
  google::protobuf::OneofDescriptor *result; // rax
  __int64 v41; // r12
  google::protobuf::OneofDescriptor *v42; // rbp
  int field_count; // esi
  const std::string *v44; // r15
  void *v45; // rax
  __int64 v46; // rax
  google::protobuf::DescriptorPool::Tables *tables; // rdi
  const google::protobuf::FieldDescriptor **Bytes; // rax
  bool v49; // zf
  __int64 v50; // rdi
  int v51; // esi
  google::protobuf::FieldDescriptor *v52; // rcx
  __int64 v53; // rdx
  const google::protobuf::FieldDescriptor **v54; // r9
  void *v55; // [rsp+0h] [rbp-288h]
  __int64 v56; // [rsp+0h] [rbp-288h]
  const std::string *v57; // [rsp+8h] [rbp-280h]
  std::string v58; // [rsp+10h] [rbp-278h] BYREF
  std::string v59; // [rsp+30h] [rbp-258h] BYREF
  std::string v60; // [rsp+50h] [rbp-238h] BYREF
  __int64 v61; // [rsp+70h] [rbp-218h] BYREF
  int v62; // [rsp+78h] [rbp-210h]
  __int64 v63; // [rsp+A0h] [rbp-1E8h] BYREF
  int v64; // [rsp+A8h] [rbp-1E0h]
  __int64 v65; // [rsp+D0h] [rbp-1B8h] BYREF
  int v66; // [rsp+D8h] [rbp-1B0h]
  __int64 v67; // [rsp+100h] [rbp-188h] BYREF
  int v68; // [rsp+108h] [rbp-180h]
  __int64 v69; // [rsp+130h] [rbp-158h] BYREF
  int v70; // [rsp+138h] [rbp-150h]
  __int64 v71; // [rsp+160h] [rbp-128h] BYREF
  int v72; // [rsp+168h] [rbp-120h]
  __int64 v73; // [rsp+190h] [rbp-F8h] BYREF
  int v74; // [rsp+198h] [rbp-F0h]
  __int64 v75; // [rsp+1C0h] [rbp-C8h] BYREF
  int v76; // [rsp+1C8h] [rbp-C0h]
  std::string v77; // [rsp+1F0h] [rbp-98h] BYREF
  std::string v78[3]; // [rsp+220h] [rbp-68h] BYREF

  if ( !a2->options_ )
    a2->options_ = (const google::protobuf::MessageOptions *)google::protobuf::MessageOptions::default_instance((google::protobuf::MessageOptions *)this);
  v6 = 0LL;
  v7 = 0;
  while ( v7 < a2->nested_type_count_ )
  {
    v8 = v7++;
    v9 = &a2->nested_types_[v6++];
    google::protobuf::DescriptorBuilder::CrossLinkMessage(
      this,
      v9,
      (const google::protobuf::DescriptorProto *)a3->nested_type_.rep_->elements[v8]);
  }
  v10 = 0LL;
  v11 = 0;
  while ( v11 < a2->enum_type_count_ )
  {
    v12 = v11++;
    v13 = &a2->enum_types_[v10++];
    google::protobuf::DescriptorBuilder::CrossLinkEnum(
      this,
      v13,
      (const google::protobuf::EnumDescriptorProto *)a3->enum_type_.rep_->elements[v12]);
  }
  v14 = 0LL;
  v15 = 0;
  while ( v15 < a2->field_count_ )
  {
    v16 = v15++;
    v17 = &a2->fields_[v14++];
    google::protobuf::DescriptorBuilder::CrossLinkField(
      this,
      v17,
      (const google::protobuf::FieldDescriptorProto *)a3->field_.rep_->elements[v16]);
  }
  v18 = 0LL;
  v19 = 0;
  while ( v19 < a2->extension_count_ )
  {
    v20 = v19++;
    v21 = &a2->extensions_[v18++];
    google::protobuf::DescriptorBuilder::CrossLinkField(
      this,
      v21,
      (const google::protobuf::FieldDescriptorProto *)a3->extension_.rep_->elements[v20]);
  }
  extension_range_count = (google::protobuf::ExtensionRangeOptions *)(unsigned int)a2->extension_range_count_;
  v23 = 0LL;
  if ( (int)extension_range_count > 0 )
  {
    do
    {
      while ( 1 )
      {
        v24 = &a2->extension_ranges_[v23];
        if ( !v24->options_ )
          break;
        if ( a2->extension_range_count_ <= (int)++v23 )
          goto LABEL_16;
      }
      ++v23;
      v24->options_ = (const google::protobuf::ExtensionRangeOptions *)google::protobuf::ExtensionRangeOptions::default_instance(extension_range_count);
    }
    while ( a2->extension_range_count_ > (int)v23 );
  }
LABEL_16:
  v25 = 0LL;
  v26 = 0;
  if ( a2->field_count_ <= 0 )
  {
    result = (google::protobuf::OneofDescriptor *)(unsigned int)a2->oneof_decl_count_;
    if ( (int)result <= 0 )
      return result;
    goto LABEL_32;
  }
  do
  {
    fields = a2->fields_;
    containing_oneof = fields[v25].containing_oneof_;
    if ( containing_oneof )
    {
      if ( containing_oneof->field_count_ > 0 )
      {
        v29 = (__int64)&fields[v25 - 1];
        if ( containing_oneof != *(const google::protobuf::OneofDescriptor **)(v29 + 88) )
        {
          name = (__int64 *)containing_oneof->name_;
          v31 = *(__int64 **)v29;
          v78[0]._M_dataplus._M_p = 0LL;
          v77._M_dataplus._M_p = 0LL;
          v75 = 0LL;
          v73 = 0LL;
          v71 = 0LL;
          v69 = 0LL;
          v67 = 0LL;
          v65 = 0LL;
          v32 = *name;
          LODWORD(v78[0]._M_string_length) = -1;
          v33 = name[1];
          v63 = v32;
          v64 = v33;
          v34 = *v31;
          LODWORD(v77._M_string_length) = -1;
          v35 = v31[1];
          v61 = v34;
          v62 = v35;
          v76 = -1;
          v74 = -1;
          v72 = -1;
          v70 = -1;
          v68 = -1;
          v66 = -1;
          google::protobuf::strings::Substitute[abi:cxx11](
            (unsigned int)&v60,
            (unsigned int)"Fields in the same oneof must be defined consecutively. \"$0\" cannot be defined before the co"
                          "mpletion of the \"$1\" oneof definition.",
            (unsigned int)&v61,
            (unsigned int)&v63,
            (unsigned int)&v65,
            (unsigned int)&v67,
            (__int64)&v69,
            (__int64)&v71,
            (__int64)&v73,
            (__int64)&v75,
            (__int64)&v77,
            (__int64)v78);
          v55 = a3->field_.rep_->elements[v26 - 1];
          v36 = a2->fields_[v25 - 1].name_;
          v58._M_dataplus._M_p = v58._anon_0._M_local_buf;
          v57 = v36;
          std::string::_M_construct<char *>(
            &v58,
            a2->full_name_->_M_dataplus._M_p,
            &a2->full_name_->_M_dataplus._M_p[a2->full_name_->_M_string_length],
            (std::forward_iterator_tag)&v58._anon_0);
          if ( v58._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
            std::__throw_length_error("basic_string::append");
          std::string::_M_append(&v58, ".", 1LL);
          v37 = std::string::_M_append(&v58, v57->_M_dataplus._M_p, v57->_M_string_length);
          v59._M_dataplus._M_p = v59._anon_0._M_local_buf;
          if ( *(_QWORD *)v37 == v37 + 16 )
          {
            v59._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v37 + 16));
          }
          else
          {
            v59._M_dataplus._M_p = *(std::string::pointer *)v37;
            v59._anon_0._M_allocated_capacity = *(_QWORD *)(v37 + 16);
          }
          v38 = *(_QWORD *)(v37 + 8);
          *(_BYTE *)(v37 + 16) = 0;
          v59._M_string_length = v38;
          *(_QWORD *)v37 = v37 + 16;
          *(_QWORD *)(v37 + 8) = 0LL;
          google::protobuf::DescriptorBuilder::AddError((__int64)this, &v59, (__int64)v55, 9u, &v60);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v59._M_dataplus._M_p != &v59._anon_0 )
            operator delete(v59._M_dataplus._M_p);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v58._M_dataplus._M_p != &v58._anon_0 )
            operator delete(v58._M_dataplus._M_p);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v60._M_dataplus._M_p != &v60._anon_0 )
            operator delete(v60._M_dataplus._M_p);
        }
      }
      v39 = &a2->oneof_decls_[(int)(-1431655765
                                  * (((char *)containing_oneof - (char *)containing_oneof->containing_type_->oneof_decls_) >> 4))];
      ++v39->field_count_;
    }
    result = (google::protobuf::OneofDescriptor *)(unsigned int)a2->field_count_;
    ++v26;
    ++v25;
  }
  while ( v26 < (int)result );
  if ( a2->oneof_decl_count_ > 0 )
  {
LABEL_32:
    v41 = 0LL;
    do
    {
      while ( 1 )
      {
        v42 = &a2->oneof_decls_[v41];
        field_count = v42->field_count_;
        if ( !field_count )
        {
          v44 = v42->name_;
          v45 = a3->oneof_decl_.rep_->elements[(int)v41];
          v77._M_dataplus._M_p = v77._anon_0._M_local_buf;
          v56 = (__int64)v45;
          std::string::_M_construct<char *>(
            &v77,
            a2->full_name_->_M_dataplus._M_p,
            &a2->full_name_->_M_dataplus._M_p[a2->full_name_->_M_string_length],
            (std::forward_iterator_tag)&v77._anon_0);
          if ( v77._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
            std::__throw_length_error("basic_string::append");
          std::string::_M_append(&v77, ".", 1LL);
          v46 = std::string::_M_append(&v77, v44->_M_dataplus._M_p, v44->_M_string_length);
          v78[0]._M_dataplus._M_p = v78[0]._anon_0._M_local_buf;
          if ( *(_QWORD *)v46 == v46 + 16 )
          {
            v78[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v46 + 16));
          }
          else
          {
            v78[0]._M_dataplus._M_p = *(std::string::pointer *)v46;
            v78[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v46 + 16);
          }
          v78[0]._M_string_length = *(_QWORD *)(v46 + 8);
          *(_QWORD *)v46 = v46 + 16;
          *(_QWORD *)(v46 + 8) = 0LL;
          *(_BYTE *)(v46 + 16) = 0;
          google::protobuf::DescriptorBuilder::AddError(
            (__int64)this,
            v78,
            v56,
            0,
            "Oneof must have at least one field.");
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v78[0]._M_dataplus._M_p != &v78[0]._anon_0 )
            operator delete(v78[0]._M_dataplus._M_p);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v77._M_dataplus._M_p != &v77._anon_0 )
            operator delete(v77._M_dataplus._M_p);
          field_count = v42->field_count_;
        }
        tables = this->tables_;
        Bytes = (const google::protobuf::FieldDescriptor **)google::protobuf::DescriptorPool::Tables::AllocateBytes(
                                                              tables,
                                                              8 * field_count);
        v49 = v42->options_ == 0LL;
        v42->field_count_ = 0;
        v42->fields_ = Bytes;
        if ( v49 )
          break;
        if ( a2->oneof_decl_count_ <= (int)++v41 )
          goto LABEL_45;
      }
      ++v41;
      v42->options_ = (const google::protobuf::OneofOptions *)google::protobuf::OneofOptions::default_instance((google::protobuf::OneofOptions *)tables);
    }
    while ( a2->oneof_decl_count_ > (int)v41 );
LABEL_45:
    result = (google::protobuf::OneofDescriptor *)(unsigned int)a2->field_count_;
  }
  v50 = 0LL;
  v51 = 0;
  if ( (int)result > 0 )
  {
    do
    {
      v52 = &a2->fields_[v50];
      result = (google::protobuf::OneofDescriptor *)v52->containing_oneof_;
      if ( result )
      {
        result = &a2->oneof_decls_[(int)(-1431655765
                                       * (((char *)result - (char *)result->containing_type_->oneof_decls_) >> 4))];
        v53 = result->field_count_;
        v54 = result->fields_;
        v52->index_in_oneof_ = v53;
        result->field_count_ = v53 + 1;
        v54[v53] = v52;
      }
      ++v51;
      ++v50;
    }
    while ( v51 < a2->field_count_ );
  }
  return result;
};

// Line 5189: range 000000000C8F5D40-000000000C8F5D5E
void __fastcall google::protobuf::DescriptorBuilder::CrossLinkExtensionRange(
        google::protobuf::DescriptorBuilder *const this,
        google::protobuf::Descriptor::ExtensionRange *range,
        const google::protobuf::DescriptorProto::ExtensionRange *proto)
{
  if ( !range->options_ )
    range->options_ = (const google::protobuf::ExtensionRangeOptions *)google::protobuf::ExtensionRangeOptions::default_instance((google::protobuf::ExtensionRangeOptions *)this);
};

// Line 5195: range 000000000C9149F0-000000000C91613B
void __fastcall google::protobuf::DescriptorBuilder::CrossLinkField(
        google::protobuf::DescriptorBuilder *this,
        std::string::size_type a2,
        const google::protobuf::FieldDescriptorProto *a3)
{
  google::protobuf::uint32 v5; // ecx
  int v6; // r10d
  google::protobuf::Symbol v7; // rax
  google::protobuf::FieldOptionsDefaultTypeInternal *v8; // rcx
  google::protobuf::Symbol::Type type; // ebx
  const google::protobuf::DescriptorPool *pool; // rax
  google::protobuf::FieldOptions *options; // rdx
  std::string *ptr; // r8
  std::string::size_type v13; // rdx
  google::protobuf::FieldOptions *v14; // rax
  google::protobuf::GoogleOnceDynamic *OnceDynamic; // rax
  google::protobuf::DescriptorPool::Tables *tables; // rdi
  int v17; // eax
  char *v18; // rdx
  google::protobuf::FileDescriptorTables *file_tables; // rax
  std::string::pointer M_p; // rdi
  google::protobuf::GoogleOnceDynamic *v21; // rdi
  google::protobuf::FieldDescriptor::CppType v22; // eax
  google::protobuf::GoogleOnceDynamic *v23; // rdi
  int v24; // eax
  char *v25; // rdx
  google::protobuf::FileDescriptorTables *v26; // rax
  char v27; // dl
  google::protobuf::Symbol v28; // rax
  int extension_range_count; // ecx
  int v30; // edi
  google::protobuf::Descriptor::ExtensionRange *extension_ranges; // rax
  __int64 v32; // rdx
  const std::string *v33; // rax
  const char *v34; // rdx
  google::protobuf::GoogleOnceDynamic *v35; // rdi
  google::protobuf::FieldDescriptor::CppType v36; // eax
  google::protobuf::GoogleOnceDynamic *v37; // rdi
  google::protobuf::GoogleOnceDynamic *v38; // rdi
  google::protobuf::GoogleOnceDynamic *v39; // rdi
  int v40; // eax
  google::protobuf::int64 v41; // rdx
  google::protobuf::int64 v42; // rbx
  std::string *v43; // rbx
  google::protobuf::GoogleOnceDynamic *v44; // rdi
  const google::protobuf::EnumDescriptor *v45; // rax
  __int64 v46; // rax
  const char *v47; // rsi
  __int64 v48; // rax
  __int64 v49; // rax
  __int64 v50; // rax
  char *v51; // rdx
  google::protobuf::FileDescriptorTables *v52; // rax
  std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::const_iterator v53; // rax
  std::forward_iterator_tag v54; // cl
  std::__detail::_Node_iterator_base<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,true>::__node_type *M_cur; // rbx
  const google::protobuf::Descriptor *v56; // rax
  const std::string *v57; // rax
  bool v58; // zf
  __int64 *v59; // rax
  int v60; // edi
  __int64 v61; // rdx
  google::protobuf::DescriptorPool::Tables *v62; // rbx
  int v63; // eax
  std::_Rb_tree<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::less<std::pair<const google::protobuf::Descriptor*,int> >,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> > >::iterator v64; // rax
  std::_Rb_tree_node_base::_Base_ptr v65; // rdx
  __int64 **M_parent; // rax
  __int64 *v67; // rax
  int v68; // edi
  __int64 v69; // rcx
  __int64 v70; // rax
  __int64 *v71; // rax
  __int64 v72; // rdx
  __int64 v73; // rax
  const google::protobuf::Descriptor *v74; // rax
  const std::string *full_name; // rax
  const char *v76; // rdx
  std::string::size_type v77; // rax
  __int64 M_nxt; // rdx
  google::protobuf::Symbol Symbol; // rax
  google::protobuf::Symbol::Type v80; // r14d
  __int64 v81; // rax
  const char *v82; // r8
  const std::string *v83; // rsi
  google::protobuf::GoogleOnceDynamic *v84; // rdi
  google::protobuf::GoogleOnceDynamic *v85; // rdi
  const google::protobuf::EnumDescriptor *v86; // r15
  google::protobuf::GoogleOnceDynamic *v87; // rdi
  const google::protobuf::Descriptor *descriptor; // [rsp+0h] [rbp-260h]
  std::string v90; // [rsp+10h] [rbp-250h] BYREF
  std::string v91; // [rsp+30h] [rbp-230h] BYREF
  char *v92; // [rsp+50h] [rbp-210h] BYREF
  int M_string_length; // [rsp+58h] [rbp-208h]
  char v94[36]; // [rsp+5Ch] [rbp-204h] BYREF
  char *v95; // [rsp+80h] [rbp-1E0h] BYREF
  int v96; // [rsp+88h] [rbp-1D8h]
  char buffer[36]; // [rsp+8Ch] [rbp-1D4h] BYREF
  __int64 v98; // [rsp+B0h] [rbp-1B0h] BYREF
  int v99; // [rsp+B8h] [rbp-1A8h]
  __int64 v100; // [rsp+E0h] [rbp-180h] BYREF
  int v101; // [rsp+E8h] [rbp-178h]
  __int64 v102; // [rsp+110h] [rbp-150h] BYREF
  int v103; // [rsp+118h] [rbp-148h]
  __int64 v104; // [rsp+140h] [rbp-120h] BYREF
  int v105; // [rsp+148h] [rbp-118h]
  std::string v106; // [rsp+170h] [rbp-F0h] BYREF
  void *v107; // [rsp+1A0h] [rbp-C0h] BYREF
  __int64 v108; // [rsp+1A8h] [rbp-B8h]
  __int128 v109[2]; // [rsp+1B0h] [rbp-B0h] BYREF
  std::string v110; // [rsp+1D0h] [rbp-90h] BYREF
  std::string name; // [rsp+200h] [rbp-60h] BYREF

  if ( !*(_QWORD *)(a2 + 120) )
    *(_QWORD *)(a2 + 120) = google::protobuf::FieldOptions::default_instance((google::protobuf::FieldOptions *)this);
  google::protobuf::FileDescriptorTables::AddFieldByStylizedNames(
    this->file_tables_,
    (const google::protobuf::FieldDescriptor *)a2);
  if ( (a3->_has_bits_.has_bits_[0] & 2) != 0 )
  {
    v28 = google::protobuf::DescriptorBuilder::LookupSymbol(
            this,
            a3->extendee_.ptr_,
            (const std::string *)*(_QWORD *)(a2 + 8),
            PLACEHOLDER_EXTENDABLE_MESSAGE,
            LOOKUP_ALL,
            1);
    if ( v28.type == NULL_SYMBOL )
    {
      google::protobuf::DescriptorBuilder::AddNotDefinedError(
        (__int64)this,
        *(const std::string **)(a2 + 8),
        (__int64)a3,
        3u,
        a3->extendee_.ptr_);
      return;
    }
    if ( v28.type != MESSAGE_0 )
    {
      std::operator+<char>(&v110, "\"", a3->extendee_.ptr_);
      if ( 0x3FFFFFFFFFFFFFFFLL - v110._M_string_length <= 0x17 )
        std::__throw_length_error("basic_string::append");
      v50 = std::string::_M_append(&v110, "\" is not a message type.", 24LL);
      name._M_dataplus._M_p = name._anon_0._M_local_buf;
      if ( *(_QWORD *)v50 == v50 + 16 )
      {
        name._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v50 + 16));
      }
      else
      {
        name._M_dataplus._M_p = *(std::string::pointer *)v50;
        name._anon_0._M_allocated_capacity = *(_QWORD *)(v50 + 16);
      }
      name._M_string_length = *(_QWORD *)(v50 + 8);
      *(_QWORD *)v50 = v50 + 16;
      *(_QWORD *)(v50 + 8) = 0LL;
      *(_BYTE *)(v50 + 16) = 0;
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        *(const std::string **)(a2 + 8),
        (__int64)a3,
        3u,
        &name);
LABEL_100:
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)name._M_dataplus._M_p != &name._anon_0 )
        operator delete(name._M_dataplus._M_p);
      M_p = v110._M_dataplus._M_p;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v110._M_dataplus._M_p != &v110._anon_0 )
        goto LABEL_25;
      return;
    }
    extension_range_count = v28._anon_0.descriptor->extension_range_count_;
    *(_QWORD *)(a2 + 80) = v28._anon_0.descriptor;
    v30 = *(_DWORD *)(a2 + 68);
    if ( extension_range_count <= 0 )
    {
LABEL_48:
      name._M_dataplus._M_p = 0LL;
      LODWORD(name._M_string_length) = -1;
      v110._M_dataplus._M_p = 0LL;
      LODWORD(v110._M_string_length) = -1;
      v107 = 0LL;
      LODWORD(v108) = -1;
      v106._M_dataplus._M_p = 0LL;
      LODWORD(v106._M_string_length) = -1;
      v104 = 0LL;
      v105 = -1;
      v102 = 0LL;
      v103 = -1;
      v100 = 0LL;
      v101 = -1;
      v98 = 0LL;
      v99 = -1;
      v95 = google::protobuf::FastInt32ToBuffer(v30, buffer);
      v96 = strlen(v95);
      v33 = *(const std::string **)(*(_QWORD *)(a2 + 80) + 8LL);
      v34 = v33->_M_dataplus._M_p;
      M_string_length = v33->_M_string_length;
      v92 = (char *)v34;
      google::protobuf::strings::Substitute[abi:cxx11](
        (unsigned int)&v91,
        (unsigned int)"\"$0\" does not declare $1 as an extension number.",
        (unsigned int)&v92,
        (unsigned int)&v95,
        (unsigned int)&v98,
        (unsigned int)&v100,
        (__int64)&v102,
        (__int64)&v104,
        (__int64)&v106,
        (__int64)&v107,
        (__int64)&v110,
        (__int64)&name);
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        *(const std::string **)(a2 + 8),
        (__int64)a3,
        1u,
        &v91);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v91._M_dataplus._M_p != &v91._anon_0 )
        operator delete(v91._M_dataplus._M_p);
    }
    else
    {
      extension_ranges = v28._anon_0.descriptor->extension_ranges_;
      v32 = (__int64)&extension_ranges[(unsigned int)(extension_range_count - 1) + 1];
      while ( extension_ranges->start > v30 || extension_ranges->end <= v30 )
      {
        if ( ++extension_ranges == (google::protobuf::Descriptor::ExtensionRange *)v32 )
          goto LABEL_48;
      }
    }
  }
  if ( !*(_QWORD *)(a2 + 88) || *(_DWORD *)(a2 + 60) == 1 )
  {
    v5 = a3->_has_bits_.has_bits_[0];
    if ( (v5 & 4) != 0 )
      goto LABEL_7;
LABEL_26:
    v21 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
    if ( v21 )
    {
      if ( v21->state_ != 2 )
      {
        name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        name._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
        name._anon_0._M_local_buf[0] = 0;
        *(&name._anon_0._M_allocated_capacity + 1) = a2;
        google::protobuf::GoogleOnceInitImpl(&v21->state_, (google::protobuf::Closure *)&name);
        name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&name);
      }
      v22 = google::protobuf::FieldDescriptor::kTypeToCppTypeMap[*(int *)(a2 + 56)];
      if ( v22 != CPPTYPE_MESSAGE_0 )
      {
        v23 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
        if ( v23 )
        {
          if ( v23->state_ != 2 )
          {
            name._anon_0._M_local_buf[0] = 0;
            name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
            name._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
            *(&name._anon_0._M_allocated_capacity + 1) = a2;
            google::protobuf::GoogleOnceInitImpl(&v23->state_, (google::protobuf::Closure *)&name);
            name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
            google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&name);
          }
          v22 = google::protobuf::FieldDescriptor::kTypeToCppTypeMap[*(int *)(a2 + 56)];
        }
LABEL_34:
        if ( v22 != CPPTYPE_ENUM_0 )
          goto LABEL_36;
      }
    }
    else
    {
      v22 = google::protobuf::FieldDescriptor::kTypeToCppTypeMap[*(int *)(a2 + 56)];
      if ( v22 != CPPTYPE_MESSAGE_0 )
        goto LABEL_34;
    }
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      *(const std::string **)(a2 + 8),
      (__int64)a3,
      2u,
      "Field with message or enum type missing type_name.");
    goto LABEL_36;
  }
  google::protobuf::DescriptorBuilder::AddError(
    (__int64)this,
    *(const std::string **)(a2 + 8),
    (__int64)a3,
    0,
    "Fields of oneofs must themselves have label LABEL_OPTIONAL.");
  v5 = a3->_has_bits_.has_bits_[0];
  if ( (v5 & 4) == 0 )
    goto LABEL_26;
LABEL_7:
  v6 = 1;
  if ( a3->type_ != 14 )
    v6 = (v5 >> 3) & 1;
  v7 = google::protobuf::DescriptorBuilder::LookupSymbol(
         this,
         a3->type_name_.ptr_,
         (const std::string *)*(_QWORD *)(a2 + 8),
         (google::protobuf::DescriptorPool::PlaceholderType)v6,
         LOOKUP_TYPES,
         !this->pool_->lazily_build_dependencies_);
  type = v7.type;
  if ( v7.type )
  {
    descriptor = v7._anon_0.descriptor;
  }
  else
  {
    pool = this->pool_;
    if ( this->pool_->enforce_weak_ )
      goto LABEL_14;
    options = a3->options_;
    v8 = &google::protobuf::_FieldOptions_default_instance_;
    if ( !options )
      options = (google::protobuf::FieldOptions *)&google::protobuf::_FieldOptions_default_instance_;
    if ( !options->weak_ )
    {
LABEL_14:
      ptr = a3->type_name_.ptr_;
      if ( pool->lazily_build_dependencies_ )
      {
        v13 = ptr->_M_string_length;
        name._M_dataplus._M_p = name._anon_0._M_local_buf;
        std::string::_M_construct<char *>(
          &name,
          ptr->_M_dataplus._M_p,
          &ptr->_M_dataplus._M_p[v13],
          (std::forward_iterator_tag)v8);
        if ( !this->pool_->enforce_weak_ )
        {
          v14 = a3->options_;
          if ( !v14 )
            v14 = (google::protobuf::FieldOptions *)&google::protobuf::_FieldOptions_default_instance_;
          if ( v14->weak_ )
            std::string::_M_replace(&name, 0LL, name._M_string_length, "google.protobuf.Empty", 21LL);
        }
        OnceDynamic = google::protobuf::DescriptorPool::Tables::AllocateOnceDynamic(this->tables_);
        tables = this->tables_;
        *(_QWORD *)(a2 + 48) = OnceDynamic;
        *(_QWORD *)(a2 + 128) = google::protobuf::DescriptorPool::Tables::AllocateString(
                                  (std::vector<std::string*> *)tables,
                                  (__int64)&name);
        if ( (a3->_has_bits_.has_bits_[0] & 8) != 0 )
          *(_QWORD *)(a2 + 136) = google::protobuf::DescriptorPool::Tables::AllocateString(
                                    (std::vector<std::string*> *)this->tables_,
                                    (__int64)a3->default_value_.ptr_);
        v17 = *(_DWORD *)(a2 + 68);
        v18 = *(char **)(a2 + 80);
        v110._anon_0._M_allocated_capacity = a2;
        LODWORD(v110._M_string_length) = v17;
        file_tables = this->file_tables_;
        v110._M_dataplus._M_p = v18;
        std::_Hashtable<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::Descriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::Descriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,true>>>>(
          &file_tables->fields_by_number_,
          &v110);
        if ( *(_BYTE *)(a2 + 66) )
          google::protobuf::DescriptorPool::Tables::AddExtension(
            this->tables_,
            (const google::protobuf::FieldDescriptor *)a2);
        M_p = name._M_dataplus._M_p;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)name._M_dataplus._M_p != &name._anon_0 )
          goto LABEL_25;
      }
      else
      {
        google::protobuf::DescriptorBuilder::AddNotDefinedError(
          (__int64)this,
          *(const std::string **)(a2 + 8),
          (__int64)a3,
          2u,
          ptr);
      }
      return;
    }
    name._M_dataplus._M_p = name._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(
      &name,
      "google.protobuf.Empty",
      "",
      (std::forward_iterator_tag)&google::protobuf::_FieldOptions_default_instance_);
    Symbol = google::protobuf::DescriptorBuilder::FindSymbol(this, &name, 1);
    descriptor = Symbol._anon_0.descriptor;
    v80 = Symbol.type;
    type = Symbol.type;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)name._M_dataplus._M_p != &name._anon_0 )
      operator delete(name._M_dataplus._M_p);
    if ( v80 == NULL_SYMBOL )
    {
      pool = this->pool_;
      goto LABEL_14;
    }
  }
  if ( (a3->_has_bits_.has_bits_[0] & 0x200) != 0 )
  {
    v35 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
    if ( !v35 )
    {
      v36 = google::protobuf::FieldDescriptor::kTypeToCppTypeMap[*(int *)(a2 + 56)];
      if ( v36 != CPPTYPE_MESSAGE_0 )
        goto LABEL_60;
      goto LABEL_138;
    }
  }
  else if ( type == MESSAGE_0 )
  {
    v35 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
    *(_DWORD *)(a2 + 56) = 11;
    if ( !v35 )
      goto LABEL_139;
  }
  else
  {
    if ( type != ENUM )
    {
      std::operator+<char>(&v110, "\"", a3->type_name_.ptr_);
      if ( 0x3FFFFFFFFFFFFFFFLL - v110._M_string_length <= 0xF )
        std::__throw_length_error("basic_string::append");
      v81 = std::string::_M_append(&v110, "\" is not a type.", 16LL);
      name._M_dataplus._M_p = name._anon_0._M_local_buf;
      if ( *(_QWORD *)v81 != v81 + 16 )
      {
        name._M_dataplus._M_p = *(std::string::pointer *)v81;
        name._anon_0._M_allocated_capacity = *(_QWORD *)(v81 + 16);
LABEL_158:
        name._M_string_length = *(_QWORD *)(v81 + 8);
        *(_QWORD *)v81 = v81 + 16;
        *(_QWORD *)(v81 + 8) = 0LL;
        *(_BYTE *)(v81 + 16) = 0;
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)this,
          *(const std::string **)(a2 + 8),
          (__int64)a3,
          2u,
          &name);
        goto LABEL_100;
      }
LABEL_161:
      name._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v81 + 16));
      goto LABEL_158;
    }
    v35 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
    *(_DWORD *)(a2 + 56) = 14;
    if ( !v35 )
    {
      v36 = google::protobuf::FieldDescriptor::kTypeToCppTypeMap[14];
      goto LABEL_60;
    }
  }
  if ( v35->state_ != 2 )
  {
    name._anon_0._M_local_buf[0] = 0;
    name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    name._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
    *(&name._anon_0._M_allocated_capacity + 1) = a2;
    google::protobuf::GoogleOnceInitImpl(&v35->state_, (google::protobuf::Closure *)&name);
    name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&name);
  }
  v36 = google::protobuf::FieldDescriptor::kTypeToCppTypeMap[*(int *)(a2 + 56)];
  if ( v36 == CPPTYPE_MESSAGE_0 )
  {
LABEL_138:
    if ( type != MESSAGE_0 )
    {
      std::operator+<char>(&v110, "\"", a3->type_name_.ptr_);
      if ( 0x3FFFFFFFFFFFFFFFLL - v110._M_string_length <= 0x17 )
        std::__throw_length_error("basic_string::append");
      v81 = std::string::_M_append(&v110, "\" is not a message type.", 24LL);
      name._M_dataplus._M_p = name._anon_0._M_local_buf;
      if ( *(_QWORD *)v81 != v81 + 16 )
      {
        name._M_dataplus._M_p = *(std::string::pointer *)v81;
        name._anon_0._M_allocated_capacity = *(_QWORD *)(v81 + 16);
        goto LABEL_158;
      }
      goto LABEL_161;
    }
LABEL_139:
    v58 = *(_BYTE *)(a2 + 64) == 0;
    *(_QWORD *)(a2 + 104) = descriptor;
    if ( v58 )
      goto LABEL_36;
    v82 = "Messages can't have default values.";
    v83 = *(const std::string **)(a2 + 8);
    goto LABEL_141;
  }
  v37 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
  if ( v37 )
  {
    if ( v37->state_ != 2 )
    {
      name._anon_0._M_local_buf[0] = 0;
      name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      name._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
      *(&name._anon_0._M_allocated_capacity + 1) = a2;
      google::protobuf::GoogleOnceInitImpl(&v37->state_, (google::protobuf::Closure *)&name);
      name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&name);
    }
    v36 = google::protobuf::FieldDescriptor::kTypeToCppTypeMap[*(int *)(a2 + 56)];
  }
LABEL_60:
  if ( v36 != CPPTYPE_ENUM_0 )
  {
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      *(const std::string **)(a2 + 8),
      (__int64)a3,
      2u,
      "Field with primitive type has type_name.");
    goto LABEL_36;
  }
  if ( type != ENUM )
  {
    std::operator+<char>(&v110, "\"", a3->type_name_.ptr_);
    if ( 0x3FFFFFFFFFFFFFFFLL - v110._M_string_length <= 0x15 )
      std::__throw_length_error("basic_string::append");
    v81 = std::string::_M_append(&v110, "\" is not an enum type.", 22LL);
    name._M_dataplus._M_p = name._anon_0._M_local_buf;
    if ( *(_QWORD *)v81 != v81 + 16 )
    {
      name._M_dataplus._M_p = *(std::string::pointer *)v81;
      name._anon_0._M_allocated_capacity = *(_QWORD *)(v81 + 16);
      goto LABEL_158;
    }
    goto LABEL_161;
  }
  v38 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
  *(_QWORD *)(a2 + 112) = descriptor;
  if ( v38 )
  {
    if ( v38->state_ != 2 )
    {
      name._anon_0._M_local_buf[0] = 0;
      name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      name._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
      *(&name._anon_0._M_allocated_capacity + 1) = a2;
      google::protobuf::GoogleOnceInitImpl(&v38->state_, (google::protobuf::Closure *)&name);
      name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&name);
    }
    descriptor = *(const google::protobuf::Descriptor **)(a2 + 112);
  }
  if ( LOBYTE(descriptor->fields_) )
  {
    *(_BYTE *)(a2 + 64) = 0;
  }
  else if ( *(_BYTE *)(a2 + 64) )
  {
    if ( google::protobuf::io::Tokenizer::IsIdentifier(a3->default_value_.ptr_) )
    {
      v39 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
      if ( v39 && v39->state_ != 2 )
      {
        name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        name._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
        name._anon_0._M_local_buf[0] = 0;
        *(&name._anon_0._M_allocated_capacity + 1) = a2;
        google::protobuf::GoogleOnceInitImpl(&v39->state_, (google::protobuf::Closure *)&name);
        name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&name);
      }
      v40 = google::protobuf::DescriptorBuilder::LookupSymbolNoPlaceholder(
              this,
              a3->default_value_.ptr_,
              *(_QWORD *)(*(_QWORD *)(a2 + 112) + 8LL),
              0,
              1);
      v42 = v41;
      if ( v40 != 5 )
        goto LABEL_73;
      v86 = *(const google::protobuf::EnumDescriptor **)(v41 + 24);
      v87 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
      if ( v87 )
      {
        if ( v87->state_ != 2 )
        {
          name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
          name._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
          name._anon_0._M_local_buf[0] = 0;
          *(&name._anon_0._M_allocated_capacity + 1) = a2;
          google::protobuf::GoogleOnceInitImpl(&v87->state_, (google::protobuf::Closure *)&name);
          name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
          google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&name);
        }
        if ( v86 != *(const google::protobuf::EnumDescriptor **)(a2 + 112) )
        {
LABEL_73:
          v43 = a3->default_value_.ptr_;
          v44 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
          if ( !v44 || v44->state_ == 2 )
          {
            v45 = *(const google::protobuf::EnumDescriptor **)(a2 + 112);
          }
          else
          {
            name._anon_0._M_local_buf[0] = 0;
            name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
            name._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
            *(&name._anon_0._M_allocated_capacity + 1) = a2;
            google::protobuf::GoogleOnceInitImpl(&v44->state_, (google::protobuf::Closure *)&name);
            name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
            google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&name);
            v45 = *(const google::protobuf::EnumDescriptor **)(a2 + 112);
          }
          goto LABEL_76;
        }
      }
      else
      {
        v45 = *(const google::protobuf::EnumDescriptor **)(a2 + 112);
        if ( v45 != v86 )
        {
          v43 = a3->default_value_.ptr_;
LABEL_76:
          std::operator+<char>(&v106, "Enum type \"", v45->full_name_);
          if ( 0x3FFFFFFFFFFFFFFFLL - v106._M_string_length <= 0x15 )
            std::__throw_length_error("basic_string::append");
          v46 = std::string::_M_append(&v106, "\" has no value named \"", 22LL);
          v107 = v109;
          if ( *(_QWORD *)v46 == v46 + 16 )
          {
            v109[0] = (__int128)_mm_loadu_si128((const __m128i *)(v46 + 16));
          }
          else
          {
            v107 = *(void **)v46;
            *(_QWORD *)&v109[0] = *(_QWORD *)(v46 + 16);
          }
          v108 = *(_QWORD *)(v46 + 8);
          *(_QWORD *)v46 = v46 + 16;
          *(_BYTE *)(v46 + 16) = 0;
          v47 = v43->_M_dataplus._M_p;
          *(_QWORD *)(v46 + 8) = 0LL;
          v48 = std::string::_M_append(&v107, v47, v43->_M_string_length);
          v110._M_dataplus._M_p = v110._anon_0._M_local_buf;
          if ( *(_QWORD *)v48 == v48 + 16 )
          {
            v110._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v48 + 16));
          }
          else
          {
            v110._M_dataplus._M_p = *(std::string::pointer *)v48;
            v110._anon_0._M_allocated_capacity = *(_QWORD *)(v48 + 16);
          }
          v110._M_string_length = *(_QWORD *)(v48 + 8);
          *(_QWORD *)(v48 + 8) = 0LL;
          *(_BYTE *)(v48 + 16) = 0;
          *(_QWORD *)v48 = v48 + 16;
          if ( v110._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v110._M_string_length == 4611686018427387902LL )
            std::__throw_length_error("basic_string::append");
          v49 = std::string::_M_append(&v110, "\".", 2LL);
          name._M_dataplus._M_p = name._anon_0._M_local_buf;
          if ( *(_QWORD *)v49 == v49 + 16 )
          {
            name._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v49 + 16));
          }
          else
          {
            name._M_dataplus._M_p = *(std::string::pointer *)v49;
            name._anon_0._M_allocated_capacity = *(_QWORD *)(v49 + 16);
          }
          name._M_string_length = *(_QWORD *)(v49 + 8);
          *(_QWORD *)v49 = v49 + 16;
          *(_QWORD *)(v49 + 8) = 0LL;
          *(_BYTE *)(v49 + 16) = 0;
          google::protobuf::DescriptorBuilder::AddError(
            (__int64)this,
            *(const std::string **)(a2 + 8),
            (__int64)a3,
            4u,
            &name);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)name._M_dataplus._M_p != &name._anon_0 )
            operator delete(name._M_dataplus._M_p);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v110._M_dataplus._M_p != &v110._anon_0 )
            operator delete(v110._M_dataplus._M_p);
          if ( v107 != v109 )
            operator delete(v107);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v106._M_dataplus._M_p != &v106._anon_0 )
            operator delete(v106._M_dataplus._M_p);
          goto LABEL_36;
        }
      }
      *(_QWORD *)(a2 + 144) = v42;
      goto LABEL_36;
    }
    v82 = "Default value for an enum field must be an identifier.";
    v83 = *(const std::string **)(a2 + 8);
LABEL_141:
    google::protobuf::DescriptorBuilder::AddError((__int64)this, v83, (__int64)a3, 4u, v82);
    goto LABEL_36;
  }
  v84 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
  if ( !v84 )
  {
    if ( SHIDWORD(descriptor->fields_) <= 0 )
      goto LABEL_36;
LABEL_153:
    *(_QWORD *)(a2 + 144) = descriptor->oneof_decls_;
    goto LABEL_36;
  }
  if ( v84->state_ != 2 )
  {
    name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    name._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
    name._anon_0._M_local_buf[0] = 0;
    *(&name._anon_0._M_allocated_capacity + 1) = a2;
    google::protobuf::GoogleOnceInitImpl(&v84->state_, (google::protobuf::Closure *)&name);
    name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&name);
  }
  descriptor = *(const google::protobuf::Descriptor **)(a2 + 112);
  if ( SHIDWORD(descriptor->fields_) > 0 )
  {
    v85 = *(google::protobuf::GoogleOnceDynamic **)(a2 + 48);
    if ( v85 )
    {
      if ( v85->state_ != 2 )
      {
        name._anon_0._M_local_buf[0] = 0;
        name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        name._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
        *(&name._anon_0._M_allocated_capacity + 1) = a2;
        google::protobuf::GoogleOnceInitImpl(&v85->state_, (google::protobuf::Closure *)&name);
        name._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&name);
      }
      descriptor = *(const google::protobuf::Descriptor **)(a2 + 112);
    }
    goto LABEL_153;
  }
LABEL_36:
  v24 = *(_DWORD *)(a2 + 68);
  v25 = *(char **)(a2 + 80);
  name._anon_0._M_allocated_capacity = a2;
  LODWORD(name._M_string_length) = v24;
  v26 = this->file_tables_;
  name._M_dataplus._M_p = v25;
  std::_Hashtable<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::Descriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::Descriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::_M_insert<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*> const&,std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,true>>>>(
    &v26->fields_by_number_,
    &name);
  if ( v27 )
  {
    if ( *(_BYTE *)(a2 + 66)
      && !google::protobuf::DescriptorPool::Tables::AddExtension(
            this->tables_,
            (const google::protobuf::FieldDescriptor *)a2) )
    {
      v62 = this->tables_;
      v63 = *(_DWORD *)(a2 + 68);
      name._M_dataplus._M_p = *(std::string::pointer *)(a2 + 80);
      LODWORD(name._M_string_length) = v63;
      v64._M_node = std::_Rb_tree<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::less<std::pair<google::protobuf::Descriptor const*,int>>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>>::find(
                      &v62->extensions_._M_t,
                      (const std::pair<const google::protobuf::Descriptor*,int> *)&name)._M_node;
      v65 = (std::_Rb_tree_header *)v64._M_node == &v62->extensions_._M_t._M_impl.std::_Rb_tree_header
          ? 0LL
          : v64._M_node[1]._M_left;
      M_parent = (__int64 **)v65[1]._M_parent;
      name._M_dataplus._M_p = 0LL;
      v110._M_dataplus._M_p = 0LL;
      v67 = *M_parent;
      v107 = 0LL;
      v106._M_dataplus._M_p = 0LL;
      v68 = *(_DWORD *)(a2 + 68);
      v104 = 0LL;
      v102 = 0LL;
      v69 = *v67;
      v70 = v67[1];
      LODWORD(name._M_string_length) = -1;
      v100 = v69;
      v101 = v70;
      v71 = (__int64 *)v65->_M_parent;
      LODWORD(v110._M_string_length) = -1;
      LODWORD(v108) = -1;
      v72 = *v71;
      LODWORD(v106._M_string_length) = -1;
      v73 = v71[1];
      v98 = v72;
      v99 = v73;
      v74 = *(const google::protobuf::Descriptor **)(a2 + 80);
      v105 = -1;
      v103 = -1;
      full_name = v74->full_name_;
      v76 = full_name->_M_dataplus._M_p;
      v77 = full_name->_M_string_length;
      v95 = (char *)v76;
      v96 = v77;
      v92 = google::protobuf::FastInt32ToBuffer(v68, v94);
      M_string_length = strlen(v92);
      google::protobuf::strings::Substitute[abi:cxx11](
        (unsigned int)&v91,
        (unsigned int)"Extension number $0 has already been used in \"$1\" by extension \"$2\" defined in $3.",
        (unsigned int)&v92,
        (unsigned int)&v95,
        (unsigned int)&v98,
        (unsigned int)&v100,
        (__int64)&v102,
        (__int64)&v104,
        (__int64)&v106,
        (__int64)&v107,
        (__int64)&v110,
        (__int64)&name);
      google::protobuf::DescriptorBuilder::AddWarning((__int64)this, *(const std::string **)(a2 + 8), a3, NUMBER, &v91);
      M_p = v91._M_dataplus._M_p;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v91._M_dataplus._M_p != &v91._anon_0 )
LABEL_25:
        operator delete(M_p);
    }
  }
  else
  {
    v51 = *(char **)(a2 + 80);
    LODWORD(name._M_string_length) = *(_DWORD *)(a2 + 68);
    v52 = this->file_tables_;
    name._M_dataplus._M_p = v51;
    v53._M_cur = std::_Hashtable<std::pair<google::protobuf::Descriptor const*,int>,std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>,std::allocator<std::pair<std::pair<google::protobuf::Descriptor const*,int> const,google::protobuf::FieldDescriptor const*>>,std::__detail::_Select1st,std::equal_to<std::pair<google::protobuf::Descriptor const*,int>>,google::protobuf::`anonymous namespace'::PointerIntegerPairHash<std::pair<google::protobuf::Descriptor const*,int>>,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true>>::find(
                   &v52->fields_by_number_._M_h,
                   (const std::_Hashtable<std::pair<const google::protobuf::Descriptor*,int>,std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,std::allocator<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*> >,std::__detail::_Select1st,std::equal_to<std::pair<const google::protobuf::Descriptor*,int> >,google::protobuf::(anonymous namespace)::PointerIntegerPairHash<std::pair<const google::protobuf::Descriptor*,int> >,std::__detail::_Mod_range_hashing,std::__detail::_Default_ranged_hash,std::__detail::_Prime_rehash_policy,std::__detail::_Hashtable_traits<true,false,true> >::key_type *)&name)._M_cur;
    M_cur = v53._M_cur;
    if ( v53._M_cur )
      M_cur = (std::__detail::_Node_iterator_base<std::pair<const std::pair<const google::protobuf::Descriptor*,int>,const google::protobuf::FieldDescriptor*>,true>::__node_type *)*((_QWORD *)&v53._M_cur->_M_storage._M_storage.1 + 2);
    v56 = *(const google::protobuf::Descriptor **)(a2 + 80);
    if ( v56 )
    {
      v57 = v56->full_name_;
      v90._M_dataplus._M_p = v90._anon_0._M_local_buf;
      std::string::_M_construct<char *>(&v90, v57->_M_dataplus._M_p, &v57->_M_dataplus._M_p[v57->_M_string_length], v54);
    }
    else
    {
      v90._M_dataplus._M_p = v90._anon_0._M_local_buf;
      std::string::_M_construct<char const*>(&v90, "unknown", "", v54);
    }
    v58 = *(_BYTE *)(a2 + 66) == 0;
    name._M_dataplus._M_p = 0LL;
    LODWORD(name._M_string_length) = -1;
    v110._M_dataplus._M_p = 0LL;
    LODWORD(v110._M_string_length) = -1;
    v107 = 0LL;
    LODWORD(v108) = -1;
    v106._M_dataplus._M_p = 0LL;
    LODWORD(v106._M_string_length) = -1;
    v104 = 0LL;
    v105 = -1;
    v102 = 0LL;
    v103 = -1;
    v100 = 0LL;
    v101 = -1;
    if ( v58 )
    {
      M_nxt = (__int64)M_cur->_M_nxt->_M_nxt;
      v99 = (int)M_cur->_M_nxt[1]._M_nxt;
      v98 = M_nxt;
      v95 = v90._M_dataplus._M_p;
      v96 = v90._M_string_length;
      v92 = google::protobuf::FastInt32ToBuffer(*(_DWORD *)(a2 + 68), v94);
      M_string_length = strlen(v92);
      google::protobuf::strings::Substitute[abi:cxx11](
        (unsigned int)&v91,
        (unsigned int)"Field number $0 has already been used in \"$1\" by field \"$2\".",
        (unsigned int)&v92,
        (unsigned int)&v95,
        (unsigned int)&v98,
        (unsigned int)&v100,
        (__int64)&v102,
        (__int64)&v104,
        (__int64)&v106,
        (__int64)&v107,
        (__int64)&v110,
        (__int64)&name);
    }
    else
    {
      v59 = *(__int64 **)M_cur->_M_storage._M_storage.__data;
      v60 = *(_DWORD *)(a2 + 68);
      v61 = *v59;
      v99 = v59[1];
      v98 = v61;
      v95 = v90._M_dataplus._M_p;
      v96 = v90._M_string_length;
      v92 = google::protobuf::FastInt32ToBuffer(v60, v94);
      M_string_length = strlen(v92);
      google::protobuf::strings::Substitute[abi:cxx11](
        (unsigned int)&v91,
        (unsigned int)"Extension number $0 has already been used in \"$1\" by extension \"$2\".",
        (unsigned int)&v92,
        (unsigned int)&v95,
        (unsigned int)&v98,
        (unsigned int)&v100,
        (__int64)&v102,
        (__int64)&v104,
        (__int64)&v106,
        (__int64)&v107,
        (__int64)&v110,
        (__int64)&name);
    }
    google::protobuf::DescriptorBuilder::AddError((__int64)this, *(const std::string **)(a2 + 8), (__int64)a3, 1u, &v91);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v91._M_dataplus._M_p != &v91._anon_0 )
      operator delete(v91._M_dataplus._M_p);
    M_p = v90._M_dataplus._M_p;
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v90._M_dataplus._M_p != &v90._anon_0 )
      goto LABEL_25;
  }
};

// Line 5440: range 000000000C8F5D60-000000000C8F5DC1
void __fastcall google::protobuf::DescriptorBuilder::CrossLinkEnum(
        google::protobuf::DescriptorBuilder *const this,
        google::protobuf::EnumDescriptor *enum_type,
        const google::protobuf::EnumDescriptorProto *proto)
{
  __int64 v3; // rbx
  google::protobuf::EnumValueDescriptor *v4; // r12

  if ( !enum_type->options_ )
    enum_type->options_ = (const google::protobuf::EnumOptions *)google::protobuf::EnumOptions::default_instance((google::protobuf::EnumOptions *)this);
  if ( enum_type->value_count_ > 0 )
  {
    v3 = 0LL;
    do
    {
      while ( 1 )
      {
        v4 = &enum_type->values_[v3];
        if ( !v4->options_ )
          break;
        if ( enum_type->value_count_ <= (int)++v3 )
          return;
      }
      ++v3;
      v4->options_ = (const google::protobuf::EnumValueOptions *)google::protobuf::EnumValueOptions::default_instance((google::protobuf::EnumValueOptions *)this);
    }
    while ( enum_type->value_count_ > (int)v3 );
  }
};

// Line 5452: range 000000000C8F5DD0-000000000C8F5DEE
void __fastcall google::protobuf::DescriptorBuilder::CrossLinkEnumValue(
        google::protobuf::DescriptorBuilder *const this,
        google::protobuf::EnumValueDescriptor *enum_value,
        const google::protobuf::EnumValueDescriptorProto *a3)
{
  if ( !enum_value->options_ )
    enum_value->options_ = (const google::protobuf::EnumValueOptions *)google::protobuf::EnumValueOptions::default_instance((google::protobuf::EnumValueOptions *)this);
};

// Line 5458: range 000000000C914980-000000000C9149EA
void __fastcall google::protobuf::DescriptorBuilder::CrossLinkService(
        google::protobuf::DescriptorBuilder *const this,
        google::protobuf::ServiceDescriptor *service,
        const google::protobuf::ServiceDescriptorProto *proto)
{
  __int64 v5; // rbp
  int v6; // ebx
  __int64 v7; // rdx
  google::protobuf::MethodDescriptor *v8; // rsi

  if ( !service->options_ )
    service->options_ = (const google::protobuf::ServiceOptions *)google::protobuf::ServiceOptions::default_instance((google::protobuf::ServiceOptions *)this);
  if ( service->method_count_ > 0 )
  {
    v5 = 0LL;
    v6 = 0;
    do
    {
      v7 = v6++;
      v8 = &service->methods_[v5++];
      google::protobuf::DescriptorBuilder::CrossLinkMethod(
        this,
        v8,
        (const google::protobuf::MethodDescriptorProto *)proto->method_.rep_->elements[v7]);
    }
    while ( v6 < service->method_count_ );
  }
};

// Line 5469: range 000000000C914610-000000000C91496E
void __fastcall google::protobuf::DescriptorBuilder::CrossLinkMethod(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::MethodDescriptor *a2,
        const google::protobuf::MethodDescriptorProto *a3)
{
  google::protobuf::Symbol v5; // rax
  google::protobuf::Symbol v6; // rax
  __int64 v7; // rax
  const std::string *full_name; // rsi
  __int64 v9; // rax
  const std::string *v10; // rsi
  std::string v11; // [rsp+0h] [rbp-68h] BYREF
  std::string v12[2]; // [rsp+20h] [rbp-48h] BYREF

  if ( !a2->options_ )
    a2->options_ = (const google::protobuf::MethodOptions *)google::protobuf::MethodOptions::default_instance((google::protobuf::MethodOptions *)this);
  v5 = google::protobuf::DescriptorBuilder::LookupSymbol(
         this,
         a3->input_type_.ptr_,
         a2->full_name_,
         PLACEHOLDER_MESSAGE,
         LOOKUP_ALL,
         !this->pool_->lazily_build_dependencies_);
  if ( v5.type )
  {
    if ( v5.type == MESSAGE_0 )
    {
      google::protobuf::internal::LazyDescriptor::Set(&a2->input_type_, v5._anon_0.descriptor);
    }
    else
    {
      std::operator+<char>(&v11, "\"", a3->input_type_.ptr_);
      if ( 0x3FFFFFFFFFFFFFFFLL - v11._M_string_length <= 0x17 )
        std::__throw_length_error("basic_string::append");
      v7 = std::string::_M_append(&v11, "\" is not a message type.", 24LL);
      v12[0]._M_dataplus._M_p = v12[0]._anon_0._M_local_buf;
      if ( *(_QWORD *)v7 == v7 + 16 )
      {
        v12[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v7 + 16));
      }
      else
      {
        v12[0]._M_dataplus._M_p = *(std::string::pointer *)v7;
        v12[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v7 + 16);
      }
      v12[0]._M_string_length = *(_QWORD *)(v7 + 8);
      *(_QWORD *)v7 = v7 + 16;
      *(_BYTE *)(v7 + 16) = 0;
      full_name = a2->full_name_;
      *(_QWORD *)(v7 + 8) = 0LL;
      google::protobuf::DescriptorBuilder::AddError((__int64)this, full_name, (__int64)a3, 5u, v12);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v12[0]._M_dataplus._M_p != &v12[0]._anon_0 )
        operator delete(v12[0]._M_dataplus._M_p);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v11._M_dataplus._M_p != &v11._anon_0 )
        operator delete(v11._M_dataplus._M_p);
    }
  }
  else if ( this->pool_->lazily_build_dependencies_ )
  {
    google::protobuf::internal::LazyDescriptor::SetLazy(&a2->input_type_, a3->input_type_.ptr_, this->file_);
  }
  else
  {
    google::protobuf::DescriptorBuilder::AddNotDefinedError(
      (__int64)this,
      a2->full_name_,
      (__int64)a3,
      5u,
      a3->input_type_.ptr_);
  }
  v6 = google::protobuf::DescriptorBuilder::LookupSymbol(
         this,
         a3->output_type_.ptr_,
         a2->full_name_,
         PLACEHOLDER_MESSAGE,
         LOOKUP_ALL,
         !this->pool_->lazily_build_dependencies_);
  if ( v6.type )
  {
    if ( v6.type == MESSAGE_0 )
    {
      google::protobuf::internal::LazyDescriptor::Set(&a2->output_type_, v6._anon_0.descriptor);
    }
    else
    {
      std::operator+<char>(&v11, "\"", a3->output_type_.ptr_);
      if ( 0x3FFFFFFFFFFFFFFFLL - v11._M_string_length <= 0x17 )
        std::__throw_length_error("basic_string::append");
      v9 = std::string::_M_append(&v11, "\" is not a message type.", 24LL);
      v12[0]._M_dataplus._M_p = v12[0]._anon_0._M_local_buf;
      if ( *(_QWORD *)v9 == v9 + 16 )
      {
        v12[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v9 + 16));
      }
      else
      {
        v12[0]._M_dataplus._M_p = *(std::string::pointer *)v9;
        v12[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v9 + 16);
      }
      v12[0]._M_string_length = *(_QWORD *)(v9 + 8);
      *(_QWORD *)v9 = v9 + 16;
      *(_BYTE *)(v9 + 16) = 0;
      v10 = a2->full_name_;
      *(_QWORD *)(v9 + 8) = 0LL;
      google::protobuf::DescriptorBuilder::AddError((__int64)this, v10, (__int64)a3, 6u, v12);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v12[0]._M_dataplus._M_p != &v12[0]._anon_0 )
        operator delete(v12[0]._M_dataplus._M_p);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v11._M_dataplus._M_p != &v11._anon_0 )
        operator delete(v11._M_dataplus._M_p);
    }
  }
  else if ( this->pool_->lazily_build_dependencies_ )
  {
    google::protobuf::internal::LazyDescriptor::SetLazy(&a2->output_type_, a3->output_type_.ptr_, this->file_);
  }
  else
  {
    google::protobuf::DescriptorBuilder::AddNotDefinedError(
      (__int64)this,
      a2->full_name_,
      (__int64)a3,
      6u,
      a3->output_type_.ptr_);
  }
};

// Line 5529: range 000000000C8F35E0-000000000C8F3632
bool __fastcall google::protobuf::IsLite(const google::protobuf::FileDescriptor *file)
{
  const google::protobuf::FileOptions *options; // rbp

  if ( !file )
    return 0;
  options = file->options_;
  return options != (const google::protobuf::FileOptions *)google::protobuf::FileOptions::default_instance((google::protobuf::FileOptions *)file)
      && file->options_->optimize_for_ == 3;
};

// Line 5534: range 000000000C903770-000000000C903A77
void __fastcall google::protobuf::DescriptorBuilder::ValidateFileOptions(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::FileDescriptor *file,
        const google::protobuf::FileDescriptorProto *proto)
{
  __int64 v3; // r14
  int v7; // ebx
  __int64 v8; // rdx
  google::protobuf::Descriptor *v9; // rsi
  __int64 v10; // r14
  int v11; // ebx
  __int64 v12; // rdx
  google::protobuf::EnumDescriptor *v13; // rsi
  __int64 v14; // r14
  int v15; // ebx
  __int64 v16; // rdx
  google::protobuf::ServiceDescriptor *v17; // rsi
  __int64 v18; // r14
  int v19; // ebx
  __int64 v20; // rdx
  google::protobuf::FieldDescriptor *v21; // rsi
  __int64 v22; // rbx
  google::protobuf::GoogleOnceDynamic *dependencies_once; // rdi
  google::protobuf::GoogleOnceDynamic *v24; // rdi
  __int64 v25; // rax
  const std::string *name; // rsi
  std::string v27; // [rsp+0h] [rbp-68h] BYREF
  std::string closure[2]; // [rsp+20h] [rbp-48h] BYREF

  v3 = 0LL;
  v7 = 0;
  while ( v7 < file->message_type_count_ )
  {
    v8 = v7++;
    v9 = &file->message_types_[v3++];
    google::protobuf::DescriptorBuilder::ValidateMessageOptions(
      this,
      v9,
      (const google::protobuf::DescriptorProto *)proto->message_type_.rep_->elements[v8]);
  }
  v10 = 0LL;
  v11 = 0;
  while ( v11 < file->enum_type_count_ )
  {
    v12 = v11++;
    v13 = &file->enum_types_[v10++];
    google::protobuf::DescriptorBuilder::ValidateEnumOptions(
      this,
      v13,
      (const google::protobuf::EnumDescriptorProto *)proto->enum_type_.rep_->elements[v12]);
  }
  v14 = 0LL;
  v15 = 0;
  while ( v15 < file->service_count_ )
  {
    v16 = v15++;
    v17 = &file->services_[v14++];
    google::protobuf::DescriptorBuilder::ValidateServiceOptions(
      this,
      v17,
      (const google::protobuf::ServiceDescriptorProto *)proto->service_.rep_->elements[v16]);
  }
  v18 = 0LL;
  v19 = 0;
  while ( v19 < file->extension_count_ )
  {
    v20 = v19++;
    v21 = &file->extensions_[v18++];
    google::protobuf::DescriptorBuilder::ValidateFieldOptions(
      this,
      v21,
      (const google::protobuf::FieldDescriptorProto *)proto->extension_.rep_->elements[v20]);
  }
  if ( !google::protobuf::IsLite(file) && file->dependency_count_ > 0 )
  {
    v22 = 0LL;
    while ( 1 )
    {
      dependencies_once = file->dependencies_once_;
      if ( dependencies_once && dependencies_once->state_ != 2 )
      {
        closure[0]._anon_0._M_local_buf[0] = 0;
        closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFB8;
        closure[0]._M_string_length = (std::string::size_type)google::protobuf::FileDescriptor::DependenciesOnceInit;
        *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)file;
        google::protobuf::GoogleOnceInitImpl(&dependencies_once->state_, (google::protobuf::Closure *)closure);
        closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFB8;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
      }
      if ( google::protobuf::IsLite(file->dependencies_[v22]) )
        break;
      if ( file->dependency_count_ <= (int)++v22 )
        goto LABEL_27;
    }
    v24 = file->dependencies_once_;
    if ( v24 && v24->state_ != 2 )
    {
      closure[0]._anon_0._M_local_buf[0] = 0;
      closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFB8;
      closure[0]._M_string_length = (std::string::size_type)google::protobuf::FileDescriptor::DependenciesOnceInit;
      *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)file;
      google::protobuf::GoogleOnceInitImpl(&v24->state_, (google::protobuf::Closure *)closure);
      closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BFB8;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
    }
    std::operator+<char>(
      &v27,
      "Files that do not use optimize_for = LITE_RUNTIME cannot import files which do use this option.  This file is not "
      "lite, but it imports \"",
      file->dependencies_[v22]->name_);
    if ( 0x3FFFFFFFFFFFFFFFLL - v27._M_string_length <= 0xA )
      std::__throw_length_error("basic_string::append");
    v25 = std::string::_M_append(&v27, "\" which is.", 11LL);
    closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
    if ( *(_QWORD *)v25 == v25 + 16 )
    {
      closure[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v25 + 16));
    }
    else
    {
      closure[0]._M_dataplus._M_p = *(std::string::pointer *)v25;
      closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v25 + 16);
    }
    closure[0]._M_string_length = *(_QWORD *)(v25 + 8);
    *(_QWORD *)v25 = v25 + 16;
    *(_BYTE *)(v25 + 16) = 0;
    name = file->name_;
    *(_QWORD *)(v25 + 8) = 0LL;
    google::protobuf::DescriptorBuilder::AddError((__int64)this, name, (__int64)proto, 9u, closure);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p != &closure[0]._anon_0 )
      operator delete(closure[0]._M_dataplus._M_p);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v27._M_dataplus._M_p != &v27._anon_0 )
      operator delete(v27._M_dataplus._M_p);
  }
LABEL_27:
  if ( file->syntax_ == SYNTAX_PROTO3 )
    google::protobuf::DescriptorBuilder::ValidateProto3(this, file, proto);
};

// Line 5560: range 000000000C902EB0-000000000C902FAC
void __fastcall google::protobuf::DescriptorBuilder::ValidateProto3(
        google::protobuf::DescriptorBuilder *const this,
        google::protobuf::FileDescriptor *file,
        const google::protobuf::FileDescriptorProto *proto)
{
  __int64 v4; // r12
  int v5; // ebp
  __int64 v7; // rdx
  google::protobuf::FieldDescriptor *v8; // rsi
  __int64 v9; // r12
  int v10; // ebp
  __int64 v11; // rdx
  google::protobuf::Descriptor *v12; // rsi
  __int64 v13; // r12
  int i; // ebp
  google::protobuf::EnumDescriptor *v15; // rax
  __int64 v16; // rcx

  v4 = 0LL;
  v5 = 0;
  while ( v5 < file->extension_count_ )
  {
    v7 = v5++;
    v8 = &file->extensions_[v4++];
    google::protobuf::DescriptorBuilder::ValidateProto3Field(
      this,
      v8,
      (const google::protobuf::FieldDescriptorProto *)proto->extension_.rep_->elements[v7]);
  }
  v9 = 0LL;
  v10 = 0;
  while ( v10 < file->message_type_count_ )
  {
    v11 = v10++;
    v12 = &file->message_types_[v9++];
    google::protobuf::DescriptorBuilder::ValidateProto3Message(
      this,
      v12,
      (const google::protobuf::DescriptorProto *)proto->message_type_.rep_->elements[v11]);
  }
  v13 = 0LL;
  for ( i = 0; i < file->enum_type_count_; ++i )
  {
    while ( 1 )
    {
      v15 = &file->enum_types_[v13];
      if ( v15->value_count_ > 0 )
      {
        if ( v15->values_->number_ )
          break;
      }
      ++i;
      ++v13;
      if ( i >= file->enum_type_count_ )
        return;
    }
    v16 = i;
    ++v13;
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      v15->full_name_,
      (__int64)proto->enum_type_.rep_->elements[v16],
      9u,
      "The first enum value must be zero in proto3.");
  }
};

// Line 5587: range 000000000C9024D0-000000000C902E9D
void __fastcall google::protobuf::DescriptorBuilder::ValidateProto3Message(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::Descriptor *a2,
        const google::protobuf::DescriptorProto *a3)
{
  __int64 v4; // rbp
  int v5; // ebx
  __int64 v6; // rdx
  google::protobuf::Descriptor *v7; // rsi
  const std::piecewise_construct_t *enum_type_count; // r9
  __int64 v9; // rbp
  int v10; // ebx
  google::protobuf::EnumDescriptor *v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rbp
  int v14; // ebx
  __int64 v15; // rdx
  google::protobuf::FieldDescriptor *v16; // rsi
  __int64 v17; // rbp
  int v18; // ebx
  __int64 v19; // rdx
  google::protobuf::FieldDescriptor *v20; // rsi
  int field_count; // eax
  const std::string *name; // r14
  bool v23; // zf
  __int64 v24; // r13
  char v25; // bp
  size_t v26; // rbx
  _BYTE *v27; // rax
  size_t v28; // r12
  unsigned __int64 v29; // rdx
  unsigned __int64 v30; // rdx
  std::_Rb_tree_node_base::_Base_ptr M_parent; // r12
  size_t v32; // rbp
  void *v33; // rbx
  std::_Rb_tree_header *v34; // r13
  std::_Rb_tree_node_base::_Base_ptr v35; // r14
  size_t v36; // rdx
  signed __int64 v37; // rax
  std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *v38; // rcx
  void *v39; // r13
  std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *M_left; // rbx
  std::size_t M_node_count; // r12
  size_t v42; // rdx
  signed __int64 v43; // rax
  const void *v44; // r14
  std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *v45; // r12
  size_t v46; // r13
  std::size_t v47; // rbp
  size_t v48; // rdx
  signed __int64 v49; // rax
  __int64 *v50; // r8
  std::size_t v51; // rbx
  size_t v52; // rdx
  int v53; // eax
  std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > >::iterator v54; // rax
  std::_Rb_tree_header *M_node; // r12
  size_t v56; // r14
  size_t v57; // rdx
  signed __int64 v58; // rax
  size_t v59; // rbx
  size_t v60; // rdx
  int v61; // eax
  __int64 v62; // rbp
  __int64 v63; // rbp
  __int64 v64; // rax
  void *v65; // rcx
  const char *v66; // rsi
  __int64 v67; // rax
  __int64 v68; // rcx
  __m128i *v69; // rax
  __int64 v70; // rax
  const std::string *full_name; // rsi
  __int64 v72; // [rsp+0h] [rbp-158h]
  std::tuple<> *v73; // [rsp+8h] [rbp-150h]
  std::_Rb_tree_node_base::_Base_ptr v74; // [rsp+10h] [rbp-148h]
  __int64 *v75; // [rsp+10h] [rbp-148h]
  void *s2; // [rsp+30h] [rbp-128h] BYREF
  size_t n; // [rsp+38h] [rbp-120h]
  __int64 v79[2]; // [rsp+40h] [rbp-118h] BYREF
  std::string v80; // [rsp+50h] [rbp-108h] BYREF
  void *v81[2]; // [rsp+70h] [rbp-E8h] BYREF
  __m128i v82; // [rsp+80h] [rbp-D8h] BYREF
  void *v83; // [rsp+90h] [rbp-C8h] BYREF
  __int64 v84; // [rsp+98h] [rbp-C0h]
  __m128i v85; // [rsp+A0h] [rbp-B8h] BYREF
  std::tuple<> v86[8]; // [rsp+B0h] [rbp-A8h] BYREF
  __int64 v87; // [rsp+B8h] [rbp-A0h]
  __m128i v88; // [rsp+C0h] [rbp-98h] BYREF
  std::string v89; // [rsp+D0h] [rbp-88h] BYREF
  std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > v90[2]; // [rsp+F0h] [rbp-68h] BYREF

  if ( a2->nested_type_count_ > 0 )
  {
    v4 = 0LL;
    v5 = 0;
    do
    {
      v6 = v5++;
      v7 = &a2->nested_types_[v4++];
      google::protobuf::DescriptorBuilder::ValidateProto3Message(
        this,
        v7,
        (const google::protobuf::DescriptorProto *)a3->nested_type_.rep_->elements[v6]);
    }
    while ( v5 < a2->nested_type_count_ );
  }
  enum_type_count = (const std::piecewise_construct_t *)(unsigned int)a2->enum_type_count_;
  v9 = 0LL;
  v10 = 0;
  if ( (int)enum_type_count > 0 )
  {
    do
    {
      while ( 1 )
      {
        v11 = &a2->enum_types_[v9];
        if ( v11->value_count_ > 0 )
        {
          if ( v11->values_->number_ )
            break;
        }
        ++v10;
        ++v9;
        if ( v10 >= a2->enum_type_count_ )
          goto LABEL_10;
      }
      v12 = v10++;
      ++v9;
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        v11->full_name_,
        (__int64)a3->enum_type_.rep_->elements[v12],
        9u,
        "The first enum value must be zero in proto3.");
    }
    while ( v10 < a2->enum_type_count_ );
  }
LABEL_10:
  v13 = 0LL;
  v14 = 0;
  while ( v14 < a2->field_count_ )
  {
    v15 = v14++;
    v16 = &a2->fields_[v13++];
    google::protobuf::DescriptorBuilder::ValidateProto3Field(
      this,
      v16,
      (const google::protobuf::FieldDescriptorProto *)a3->field_.rep_->elements[v15]);
  }
  v17 = 0LL;
  v18 = 0;
  while ( v18 < a2->extension_count_ )
  {
    v19 = v18++;
    v20 = &a2->extensions_[v17++];
    google::protobuf::DescriptorBuilder::ValidateProto3Field(
      this,
      v20,
      (const google::protobuf::FieldDescriptorProto *)a3->extension_.rep_->elements[v19]);
  }
  if ( a2->extension_range_count_ > 0 )
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      a2->full_name_,
      (__int64)a3,
      9u,
      "Extension ranges are not allowed in proto3.");
  if ( a2->options_->message_set_wire_format_ )
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      a2->full_name_,
      (__int64)a3,
      9u,
      "MessageSet is not supported in proto3.");
  v90[0]._M_impl._M_header._M_color = _S_red;
  v90[0]._M_impl._M_header._M_left = &v90[0]._M_impl._M_header;
  v90[0]._M_impl._M_header._M_right = &v90[0]._M_impl._M_header;
  field_count = a2->field_count_;
  v90[0]._M_impl._M_header._M_parent = 0LL;
  v90[0]._M_impl._M_node_count = 0LL;
  if ( field_count > 0 )
  {
    v72 = 0LL;
    HIDWORD(v73) = 0;
    while ( 1 )
    {
      name = a2->fields_[v72].name_;
      LOBYTE(v79[0]) = 0;
      n = 0LL;
      v23 = name->_M_string_length == 0;
      s2 = v79;
      if ( !v23 )
      {
        v24 = 0LL;
        while ( 2 )
        {
          v25 = name->_M_dataplus._M_p[v24];
          if ( v25 == 95 )
            goto LABEL_23;
          v26 = n;
          v27 = s2;
          v28 = n + 1;
          if ( (unsigned __int8)(v25 - 65) <= 0x19u )
          {
            v25 += 32;
            v30 = 15LL;
            if ( s2 != v79 )
              v30 = v79[0];
            if ( v30 < v28 )
            {
LABEL_29:
              std::string::_M_mutate(&s2, n, 0LL, 0LL, 1LL);
              v27 = s2;
            }
          }
          else
          {
            v29 = 15LL;
            if ( s2 != v79 )
              v29 = v79[0];
            if ( v29 < v28 )
              goto LABEL_29;
          }
          v27[v26] = v25;
          n = v28;
          *((_BYTE *)s2 + v26 + 1) = 0;
LABEL_23:
          if ( ++v24 >= name->_M_string_length )
            break;
          continue;
        }
      }
      if ( !v90[0]._M_impl._M_header._M_parent )
      {
        v45 = (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)&v90[0]._M_impl.std::_Rb_tree_header;
        goto LABEL_72;
      }
      M_parent = v90[0]._M_impl._M_header._M_parent;
      v32 = n;
      v74 = v90[0]._M_impl._M_header._M_parent;
      v33 = s2;
      v34 = &v90[0]._M_impl.std::_Rb_tree_header;
      do
      {
        while ( 1 )
        {
          v35 = M_parent[1]._M_parent;
          v36 = v32;
          if ( (unsigned __int64)v35 <= v32 )
            v36 = (size_t)M_parent[1]._M_parent;
          if ( v36 )
          {
            LODWORD(v37) = memcmp(*(const void **)&M_parent[1]._M_color, v33, v36);
            if ( (_DWORD)v37 )
              goto LABEL_43;
          }
          v37 = (signed __int64)v35 - v32;
          if ( (__int64)((__int64)v35 - v32) >= 0x80000000LL )
            break;
          if ( v37 > (__int64)0xFFFFFFFF7FFFFFFFLL )
          {
LABEL_43:
            if ( (int)v37 >= 0 )
              break;
          }
          M_parent = M_parent->_M_right;
          if ( !M_parent )
            goto LABEL_45;
        }
        v34 = (std::_Rb_tree_header *)M_parent;
        M_parent = M_parent->_M_left;
      }
      while ( M_parent );
LABEL_45:
      v38 = (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)v34;
      v39 = v33;
      M_left = (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)v74;
      if ( v38 == (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)&v90[0]._M_impl.std::_Rb_tree_header )
        goto LABEL_53;
      M_node_count = v38->_M_impl._M_node_count;
      v42 = M_node_count;
      if ( v32 <= M_node_count )
        v42 = v32;
      if ( v42 )
      {
        LODWORD(v43) = memcmp(v39, v38->_M_impl._M_header._M_right, v42);
        if ( (_DWORD)v43 )
        {
LABEL_52:
          if ( (int)v43 < 0 )
            goto LABEL_53;
LABEL_74:
          M_node = &v90[0]._M_impl.std::_Rb_tree_header;
          while ( 2 )
          {
            while ( 2 )
            {
              v56 = M_left->_M_impl._M_node_count;
              v57 = v56;
              if ( v32 <= v56 )
                v57 = v32;
              if ( v57 && (LODWORD(v58) = memcmp(M_left->_M_impl._M_header._M_right, v39, v57), (_DWORD)v58) )
              {
LABEL_82:
                if ( (int)v58 < 0 )
                {
LABEL_75:
                  M_left = (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)M_left->_M_impl._M_header._M_left;
                  if ( !M_left )
                    goto LABEL_84;
                  continue;
                }
              }
              else
              {
                v58 = v56 - v32;
                if ( (__int64)(v56 - v32) < 0x80000000LL )
                {
                  if ( v58 <= (__int64)0xFFFFFFFF7FFFFFFFLL )
                    goto LABEL_75;
                  goto LABEL_82;
                }
              }
              break;
            }
            M_node = (std::_Rb_tree_header *)M_left;
            M_left = (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)M_left->_M_impl._M_header._M_parent;
            if ( !M_left )
            {
LABEL_84:
              if ( M_node == &v90[0]._M_impl.std::_Rb_tree_header )
                goto LABEL_93;
              v59 = *(_QWORD *)&M_node[1]._M_header._M_color;
              v60 = v59;
              if ( v32 <= v59 )
                v60 = v32;
              if ( v60 && (v61 = memcmp(v39, (const void *)M_node->_M_node_count, v60)) != 0 )
              {
LABEL_92:
                if ( v61 < 0 )
                  goto LABEL_93;
              }
              else
              {
                v62 = v32 - v59;
                if ( v62 < 0x80000000LL )
                {
                  if ( v62 > (__int64)0xFFFFFFFF7FFFFFFFLL )
                  {
                    v61 = v62;
                    goto LABEL_92;
                  }
LABEL_93:
                  v89._M_dataplus._M_p = (std::string::pointer)&s2;
                  M_node = (std::_Rb_tree_header *)std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::FieldDescriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::FieldDescriptor const*>>>::_M_emplace_hint_unique<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(
                                                     v90,
                                                     (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > >::const_iterator)M_node,
                                                     &std::piecewise_construct,
                                                     (std::tuple<const std::string&> *)&v89,
                                                     v86,
                                                     enum_type_count,
                                                     (std::tuple<const std::string&> *)(v72 * 152),
                                                     v73)._M_node;
                }
              }
              v63 = *(_QWORD *)M_node[1]._M_header._M_right;
              std::operator+<char>(&v80, "The JSON camel-case name of field \"", a2->fields_[v72].name_);
              if ( 0x3FFFFFFFFFFFFFFFLL - v80._M_string_length <= 0x17 )
                std::__throw_length_error("basic_string::append");
              v64 = std::string::_M_append(&v80, "\" conflicts with field \"", 24LL);
              v81[0] = &v82;
              if ( *(_QWORD *)v64 == v64 + 16 )
              {
                v82 = _mm_loadu_si128((const __m128i *)(v64 + 16));
              }
              else
              {
                v81[0] = *(void **)v64;
                v82.m128i_i64[0] = *(_QWORD *)(v64 + 16);
              }
              v65 = *(void **)(v64 + 8);
              *(_BYTE *)(v64 + 16) = 0;
              v81[1] = v65;
              *(_QWORD *)v64 = v64 + 16;
              v66 = *(const char **)v63;
              *(_QWORD *)(v64 + 8) = 0LL;
              v67 = std::string::_M_append(v81, v66, *(_QWORD *)(v63 + 8));
              v83 = &v85;
              if ( *(_QWORD *)v67 == v67 + 16 )
              {
                v85 = _mm_loadu_si128((const __m128i *)(v67 + 16));
              }
              else
              {
                v83 = *(void **)v67;
                v85.m128i_i64[0] = *(_QWORD *)(v67 + 16);
              }
              v68 = *(_QWORD *)(v67 + 8);
              *(_BYTE *)(v67 + 16) = 0;
              v84 = v68;
              *(_QWORD *)(v67 + 8) = 0LL;
              *(_QWORD *)v67 = v67 + 16;
              if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v84) <= 0xE )
                std::__throw_length_error("basic_string::append");
              v69 = (__m128i *)std::string::_M_append(&v83, "\". This is not ", 15LL);
              *(_QWORD *)v86[0].gap0 = &v88;
              if ( (__m128i *)v69->m128i_i64[0] == &v69[1] )
              {
                v88 = _mm_loadu_si128(v69 + 1);
              }
              else
              {
                *(_QWORD *)v86[0].gap0 = v69->m128i_i64[0];
                v88.m128i_i64[0] = v69[1].m128i_i64[0];
              }
              v87 = v69->m128i_i64[1];
              v69->m128i_i64[1] = 0LL;
              v69[1].m128i_i8[0] = 0;
              v69->m128i_i64[0] = (__int64)v69[1].m128i_i64;
              if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v87) <= 0x11 )
                std::__throw_length_error("basic_string::append");
              v70 = std::string::_M_append(v86, "allowed in proto3.", 18LL);
              v89._M_dataplus._M_p = v89._anon_0._M_local_buf;
              if ( *(_QWORD *)v70 == v70 + 16 )
              {
                v89._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v70 + 16));
              }
              else
              {
                v89._M_dataplus._M_p = *(std::string::pointer *)v70;
                v89._anon_0._M_allocated_capacity = *(_QWORD *)(v70 + 16);
              }
              v89._M_string_length = *(_QWORD *)(v70 + 8);
              *(_QWORD *)v70 = v70 + 16;
              *(_BYTE *)(v70 + 16) = 0;
              full_name = a2->full_name_;
              *(_QWORD *)(v70 + 8) = 0LL;
              google::protobuf::DescriptorBuilder::AddError((__int64)this, full_name, (__int64)a3, 9u, &v89);
              if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v89._M_dataplus._M_p != &v89._anon_0 )
                operator delete(v89._M_dataplus._M_p);
              if ( *(__m128i **)v86[0].gap0 != &v88 )
                operator delete(*(void **)v86[0].gap0);
              if ( v83 != &v85 )
                operator delete(v83);
              if ( v81[0] != &v82 )
                operator delete(v81[0]);
              if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v80._M_dataplus._M_p != &v80._anon_0 )
                operator delete(v80._M_dataplus._M_p);
              v50 = (__int64 *)s2;
              goto LABEL_116;
            }
            continue;
          }
        }
      }
      v43 = v32 - M_node_count;
      if ( (__int64)(v32 - M_node_count) >= 0x80000000LL )
        goto LABEL_74;
      if ( v43 > (__int64)0xFFFFFFFF7FFFFFFFLL )
        goto LABEL_52;
LABEL_53:
      v75 = (__int64 *)v39;
      v44 = v39;
      v45 = (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)&v90[0]._M_impl.std::_Rb_tree_header;
      v46 = v32;
      while ( 1 )
      {
LABEL_55:
        v47 = M_left->_M_impl._M_node_count;
        v48 = v46;
        if ( v47 <= v46 )
          v48 = M_left->_M_impl._M_node_count;
        if ( v48 )
        {
          LODWORD(v49) = memcmp(M_left->_M_impl._M_header._M_right, v44, v48);
          if ( (_DWORD)v49 )
            goto LABEL_61;
        }
        v49 = v47 - v46;
        if ( (__int64)(v47 - v46) >= 0x80000000LL )
          break;
        if ( v49 > (__int64)0xFFFFFFFF7FFFFFFFLL )
        {
LABEL_61:
          if ( (int)v49 >= 0 )
            break;
        }
        M_left = (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)M_left->_M_impl._M_header._M_left;
        if ( !M_left )
          goto LABEL_63;
      }
      v45 = M_left;
      M_left = (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)M_left->_M_impl._M_header._M_parent;
      if ( M_left )
        goto LABEL_55;
LABEL_63:
      v50 = v75;
      if ( v45 == (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)&v90[0]._M_impl.std::_Rb_tree_header )
        goto LABEL_72;
      v51 = v45->_M_impl._M_node_count;
      v52 = v51;
      if ( v46 <= v51 )
        v52 = v46;
      if ( v52 && (v53 = memcmp(v44, v45->_M_impl._M_header._M_right, v52), v50 = v75, v53) )
      {
LABEL_71:
        if ( v53 < 0 )
          goto LABEL_72;
      }
      else if ( (__int64)(v46 - v51) < 0x80000000LL )
      {
        if ( (__int64)(v46 - v51) > (__int64)0xFFFFFFFF7FFFFFFFLL )
        {
          v53 = v46 - v51;
          goto LABEL_71;
        }
LABEL_72:
        v89._M_dataplus._M_p = (std::string::pointer)&s2;
        v54._M_node = std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::FieldDescriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::FieldDescriptor const*>>>::_M_emplace_hint_unique<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(
                        v90,
                        (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > >::const_iterator)v45,
                        &std::piecewise_construct,
                        (std::tuple<const std::string&> *)&v89,
                        v86,
                        enum_type_count,
                        (std::tuple<const std::string&> *)(v72 * 152),
                        v73)._M_node;
        v50 = (__int64 *)s2;
        v45 = (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > > *)v54._M_node;
      }
      v45[1]._M_impl._M_header._M_parent = (std::_Rb_tree_node_base::_Base_ptr)&a2->fields_[v72];
LABEL_116:
      if ( v50 != v79 )
        operator delete(v50);
      ++HIDWORD(v73);
      ++v72;
      if ( SHIDWORD(v73) >= a2->field_count_ )
      {
        std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::FieldDescriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::FieldDescriptor const*>>>::_M_erase(
          v90,
          (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::FieldDescriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::FieldDescriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::FieldDescriptor*> > >::_Link_type)v90[0]._M_impl._M_header._M_parent);
        return;
      }
    }
  }
  std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::FieldDescriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::FieldDescriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::FieldDescriptor const*>>>::_M_erase(
    v90,
    0LL);
};

// Line 5635: range 000000000C8F9B00-000000000C8FA0BE
void __fastcall google::protobuf::DescriptorBuilder::ValidateProto3Field(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::FieldDescriptor *a2,
        const google::protobuf::FieldDescriptorProto *a3)
{
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  google::protobuf::GoogleOnceDynamic *v7; // rdi
  google::protobuf::FieldDescriptor::Type type; // eax
  google::protobuf::FieldDescriptor::Type v9; // edx
  const google::protobuf::EnumDescriptor *enum_type; // rdx
  const std::string *v11; // r14
  __int64 v12; // rax
  void *v13; // rcx
  const char *M_p; // rsi
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rax
  const std::string *v18; // rsi
  const std::string *full_name; // r14
  std::_Rb_tree_header *v20; // r13
  std::string v21; // [rsp+0h] [rbp-B8h] BYREF
  void *v22[2]; // [rsp+20h] [rbp-98h] BYREF
  __m128i v23; // [rsp+30h] [rbp-88h] BYREF
  void *v24; // [rsp+40h] [rbp-78h] BYREF
  __int64 v25; // [rsp+48h] [rbp-70h]
  __m128i v26; // [rsp+50h] [rbp-68h] BYREF
  std::string closure[2]; // [rsp+60h] [rbp-58h] BYREF

  if ( !a2->is_extension_ )
    goto LABEL_2;
  full_name = a2->containing_type_->full_name_;
  if ( google::protobuf::`anonymous namespace'::allowed_proto3_extendees_init_ != 2 )
  {
    closure[0]._M_dataplus._M_p = (std::string::pointer)off_1A16E058;
    closure[0]._anon_0._M_local_buf[0] = 0;
    closure[0]._M_string_length = (std::string::size_type)google::protobuf::`anonymous namespace'::InitAllowedProto3Extendee;
    google::protobuf::GoogleOnceInitImpl(
      &google::protobuf::`anonymous namespace'::allowed_proto3_extendees_init_,
      (google::protobuf::Closure *)closure);
    google::protobuf::internal::FunctionClosure0::~FunctionClosure0((google::protobuf::internal::FunctionClosure0 *const)closure);
  }
  v20 = &google::protobuf::`anonymous namespace'::allowed_proto3_extendees_->_M_t._M_impl.std::_Rb_tree_header;
  if ( v20 == (std::_Rb_tree_header *)std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::find(
                                        &google::protobuf::`anonymous namespace'::allowed_proto3_extendees_->_M_t,
                                        full_name)._M_node )
  {
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      a2->full_name_,
      (__int64)a3,
      9u,
      "Extensions in proto3 are only allowed for defining options.");
    if ( a2->label_ != LABEL_REQUIRED )
      goto LABEL_3;
  }
  else
  {
LABEL_2:
    if ( a2->label_ != LABEL_REQUIRED )
      goto LABEL_3;
  }
  google::protobuf::DescriptorBuilder::AddError(
    (__int64)this,
    a2->full_name_,
    (__int64)a3,
    9u,
    "Required fields are not allowed in proto3.");
LABEL_3:
  if ( a2->has_default_value_ )
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      a2->full_name_,
      (__int64)a3,
      9u,
      "Explicit default values are not allowed in proto3.");
  type_once = a2->type_once_;
  if ( !type_once )
  {
    type = a2->type_;
    v9 = type;
    if ( google::protobuf::FieldDescriptor::kTypeToCppTypeMap[type] != CPPTYPE_ENUM_0 )
      goto LABEL_13;
    goto LABEL_16;
  }
  if ( type_once->state_ != 2 )
  {
    closure[0]._anon_0._M_local_buf[0] = 0;
    *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
    closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
    google::protobuf::GoogleOnceInitImpl(&type_once->state_, (google::protobuf::Closure *)closure);
    closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
  }
  v7 = a2->type_once_;
  type = a2->type_;
  if ( google::protobuf::FieldDescriptor::kTypeToCppTypeMap[type] == CPPTYPE_ENUM_0 )
  {
    if ( v7 )
    {
      if ( v7->state_ != 2 )
      {
        closure[0]._anon_0._M_local_buf[0] = 0;
        *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
        closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
        google::protobuf::GoogleOnceInitImpl(&v7->state_, (google::protobuf::Closure *)closure);
        closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
      }
      enum_type = a2->enum_type_;
      v7 = a2->type_once_;
      if ( !enum_type )
        goto LABEL_9;
      if ( v7 )
      {
        if ( v7->state_ != 2 )
        {
          closure[0]._anon_0._M_local_buf[0] = 0;
          *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
          closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
          closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
          google::protobuf::GoogleOnceInitImpl(&v7->state_, (google::protobuf::Closure *)closure);
          closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
          google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
        }
        enum_type = a2->enum_type_;
        v7 = a2->type_once_;
        if ( enum_type->file_->syntax_ == SYNTAX_PROTO3 )
          goto LABEL_9;
        v11 = a2->containing_type_->full_name_;
        if ( v7 )
        {
          if ( v7->state_ != 2 )
          {
            closure[0]._anon_0._M_local_buf[0] = 0;
            *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
            closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
            closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
            google::protobuf::GoogleOnceInitImpl(&v7->state_, (google::protobuf::Closure *)closure);
            closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
            google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
          }
          enum_type = a2->enum_type_;
        }
LABEL_19:
        std::operator+<char>(&v21, "Enum type \"", enum_type->full_name_);
        if ( 0x3FFFFFFFFFFFFFFFLL - v21._M_string_length <= 0x27 )
          std::__throw_length_error("basic_string::append");
        v12 = std::string::_M_append(&v21, "\" is not a proto3 enum, but is used in \"", 40LL);
        v22[0] = &v23;
        if ( *(_QWORD *)v12 == v12 + 16 )
        {
          v23 = _mm_loadu_si128((const __m128i *)(v12 + 16));
        }
        else
        {
          v22[0] = *(void **)v12;
          v23.m128i_i64[0] = *(_QWORD *)(v12 + 16);
        }
        v13 = *(void **)(v12 + 8);
        *(_BYTE *)(v12 + 16) = 0;
        v22[1] = v13;
        *(_QWORD *)v12 = v12 + 16;
        M_p = v11->_M_dataplus._M_p;
        *(_QWORD *)(v12 + 8) = 0LL;
        v15 = std::string::_M_append(v22, M_p, v11->_M_string_length);
        v24 = &v26;
        if ( *(_QWORD *)v15 == v15 + 16 )
        {
          v26 = _mm_loadu_si128((const __m128i *)(v15 + 16));
        }
        else
        {
          v24 = *(void **)v15;
          v26.m128i_i64[0] = *(_QWORD *)(v15 + 16);
        }
        v16 = *(_QWORD *)(v15 + 8);
        *(_BYTE *)(v15 + 16) = 0;
        v25 = v16;
        *(_QWORD *)(v15 + 8) = 0LL;
        *(_QWORD *)v15 = v15 + 16;
        if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v25) <= 0x20 )
          std::__throw_length_error("basic_string::append");
        v17 = std::string::_M_append(&v24, "\" which is a proto3 message type.", 33LL);
        closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v17 == v17 + 16 )
        {
          closure[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v17 + 16));
        }
        else
        {
          closure[0]._M_dataplus._M_p = *(std::string::pointer *)v17;
          closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v17 + 16);
        }
        closure[0]._M_string_length = *(_QWORD *)(v17 + 8);
        *(_QWORD *)v17 = v17 + 16;
        *(_BYTE *)(v17 + 16) = 0;
        v18 = a2->full_name_;
        *(_QWORD *)(v17 + 8) = 0LL;
        google::protobuf::DescriptorBuilder::AddError((__int64)this, v18, (__int64)a3, 2u, closure);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p != &closure[0]._anon_0 )
          operator delete(closure[0]._M_dataplus._M_p);
        if ( v24 != &v26 )
          operator delete(v24);
        if ( v22[0] != &v23 )
          operator delete(v22[0]);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v21._M_dataplus._M_p != &v21._anon_0 )
          operator delete(v21._M_dataplus._M_p);
        v7 = a2->type_once_;
        goto LABEL_9;
      }
LABEL_17:
      if ( enum_type->file_->syntax_ == SYNTAX_PROTO3 )
        goto LABEL_54;
      v11 = a2->containing_type_->full_name_;
      goto LABEL_19;
    }
LABEL_16:
    enum_type = a2->enum_type_;
    if ( !enum_type )
    {
LABEL_55:
      v9 = type;
      goto LABEL_13;
    }
    goto LABEL_17;
  }
LABEL_9:
  if ( !v7 )
  {
LABEL_54:
    type = a2->type_;
    goto LABEL_55;
  }
  if ( v7->state_ != 2 )
  {
    closure[0]._anon_0._M_local_buf[0] = 0;
    *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
    closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
    google::protobuf::GoogleOnceInitImpl(&v7->state_, (google::protobuf::Closure *)closure);
    closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
  }
  v9 = a2->type_;
LABEL_13:
  if ( v9 == TYPE_GROUP_0 )
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      a2->full_name_,
      (__int64)a3,
      2u,
      "Groups are not supported in proto3 syntax.");
};

// Line 5673: range 000000000C8FA100-000000000C8FA127
void __fastcall google::protobuf::DescriptorBuilder::ValidateProto3Enum(
        google::protobuf::DescriptorBuilder *const this,
        google::protobuf::EnumDescriptor *enm,
        const google::protobuf::EnumDescriptorProto *proto)
{
  if ( enm->value_count_ > 0 )
  {
    if ( enm->values_->number_ )
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        enm->full_name_,
        (__int64)proto,
        9u,
        "The first enum value must be zero in proto3.");
  }
};

// Line 5681: range 000000000C903470-000000000C903767
void __fastcall google::protobuf::DescriptorBuilder::ValidateMessageOptions(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::Descriptor *a2,
        const google::protobuf::DescriptorProto *a3)
{
  __int64 v3; // r14
  int v5; // ebp
  __int64 v7; // rdx
  google::protobuf::FieldDescriptor *v8; // rsi
  __int64 v9; // r14
  int v10; // ebp
  __int64 v11; // rdx
  google::protobuf::Descriptor *v12; // rsi
  __int64 v13; // r14
  int v14; // ebp
  __int64 v15; // rdx
  google::protobuf::EnumDescriptor *v16; // rsi
  __int64 v17; // r14
  int v18; // ebp
  __int64 v19; // rdx
  google::protobuf::FieldDescriptor *v20; // rsi
  __int64 v21; // rbp
  google::protobuf::int64 v22; // r15
  signed __int64 i; // r14
  std::string v24; // [rsp+0h] [rbp-238h] BYREF
  char *v25; // [rsp+20h] [rbp-218h] BYREF
  int v26; // [rsp+28h] [rbp-210h]
  char buffer[36]; // [rsp+2Ch] [rbp-20Ch] BYREF
  __int64 v28; // [rsp+50h] [rbp-1E8h] BYREF
  int v29; // [rsp+58h] [rbp-1E0h]
  __int64 v30; // [rsp+80h] [rbp-1B8h] BYREF
  int v31; // [rsp+88h] [rbp-1B0h]
  __int64 v32; // [rsp+B0h] [rbp-188h] BYREF
  int v33; // [rsp+B8h] [rbp-180h]
  __int64 v34; // [rsp+E0h] [rbp-158h] BYREF
  int v35; // [rsp+E8h] [rbp-150h]
  __int64 v36; // [rsp+110h] [rbp-128h] BYREF
  int v37; // [rsp+118h] [rbp-120h]
  __int64 v38; // [rsp+140h] [rbp-F8h] BYREF
  int v39; // [rsp+148h] [rbp-F0h]
  __int64 v40; // [rsp+170h] [rbp-C8h] BYREF
  int v41; // [rsp+178h] [rbp-C0h]
  __int64 v42; // [rsp+1A0h] [rbp-98h] BYREF
  int v43; // [rsp+1A8h] [rbp-90h]
  __int64 v44; // [rsp+1D0h] [rbp-68h] BYREF
  int v45; // [rsp+1D8h] [rbp-60h]

  v3 = 0LL;
  v5 = 0;
  while ( v5 < a2->field_count_ )
  {
    v7 = v5++;
    v8 = &a2->fields_[v3++];
    google::protobuf::DescriptorBuilder::ValidateFieldOptions(
      this,
      v8,
      (const google::protobuf::FieldDescriptorProto *)a3->field_.rep_->elements[v7]);
  }
  v9 = 0LL;
  v10 = 0;
  while ( v10 < a2->nested_type_count_ )
  {
    v11 = v10++;
    v12 = &a2->nested_types_[v9++];
    google::protobuf::DescriptorBuilder::ValidateMessageOptions(
      this,
      v12,
      (const google::protobuf::DescriptorProto *)a3->nested_type_.rep_->elements[v11]);
  }
  v13 = 0LL;
  v14 = 0;
  while ( v14 < a2->enum_type_count_ )
  {
    v15 = v14++;
    v16 = &a2->enum_types_[v13++];
    google::protobuf::DescriptorBuilder::ValidateEnumOptions(
      this,
      v16,
      (const google::protobuf::EnumDescriptorProto *)a3->enum_type_.rep_->elements[v15]);
  }
  v17 = 0LL;
  v18 = 0;
  while ( v18 < a2->extension_count_ )
  {
    v19 = v18++;
    v20 = &a2->extensions_[v17++];
    google::protobuf::DescriptorBuilder::ValidateFieldOptions(
      this,
      v20,
      (const google::protobuf::FieldDescriptorProto *)a3->extension_.rep_->elements[v19]);
  }
  v21 = 0LL;
  v22 = (-(__int64)!a2->options_->message_set_wire_format_ & 0xFFFFFFFFA0000000LL) + 0x7FFFFFFF;
  for ( i = (-(__int64)!a2->options_->message_set_wire_format_ & 0xFFFFFFFFA0000000LL) + 0x80000000;
        a2->extension_range_count_ > (int)v21;
        ++v21 )
  {
    while ( 1 )
    {
      if ( a2->extension_ranges_[v21].end > i )
      {
        v44 = 0LL;
        v45 = -1;
        v42 = 0LL;
        v43 = -1;
        v40 = 0LL;
        v41 = -1;
        v38 = 0LL;
        v39 = -1;
        v36 = 0LL;
        v37 = -1;
        v34 = 0LL;
        v35 = -1;
        v32 = 0LL;
        v33 = -1;
        v30 = 0LL;
        v31 = -1;
        v28 = 0LL;
        v29 = -1;
        v25 = google::protobuf::FastInt64ToBuffer(v22, buffer);
        v26 = strlen(v25);
        google::protobuf::strings::Substitute[abi:cxx11](
          (unsigned int)&v24,
          (unsigned int)"Extension numbers cannot be greater than $0.",
          (unsigned int)&v25,
          (unsigned int)&v28,
          (unsigned int)&v30,
          (unsigned int)&v32,
          (__int64)&v34,
          (__int64)&v36,
          (__int64)&v38,
          (__int64)&v40,
          (__int64)&v42,
          (__int64)&v44);
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)this,
          a2->full_name_,
          (__int64)a3->extension_range_.rep_->elements[(int)v21],
          1u,
          &v24);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v24._M_dataplus._M_p != &v24._anon_0 )
          break;
      }
      if ( a2->extension_range_count_ <= (int)++v21 )
        return;
    }
    operator delete(v24._M_dataplus._M_p);
  }
};

// Line 5704: range 000000000C8F97B0-000000000C8F9AF3
void __fastcall google::protobuf::DescriptorBuilder::ValidateFieldOptions(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::FieldDescriptor *a2,
        const google::protobuf::FieldDescriptorProto *a3)
{
  google::protobuf::DescriptorBuilder *v4; // r12
  const google::protobuf::FieldOptions *options; // rax
  const google::protobuf::Descriptor *containing_type; // rax
  const google::protobuf::MessageOptions *v7; // rbx
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  const google::protobuf::Descriptor *v9; // rax
  google::protobuf::Closure v10; // [rsp+0h] [rbp-48h] BYREF
  void (__fastcall *v11)(const google::protobuf::FieldDescriptor *); // [rsp+8h] [rbp-40h]
  char v12; // [rsp+10h] [rbp-38h]
  google::protobuf::FieldDescriptor *v13; // [rsp+18h] [rbp-30h]

  v4 = this;
  if ( this->pool_->lazily_build_dependencies_ )
  {
    if ( !a2 )
      return;
    this = (google::protobuf::DescriptorBuilder *)a2->type_once_;
    if ( this && this->pool_ != (const google::protobuf::DescriptorPool *)2 )
    {
      v13 = a2;
      v10._vptr_Closure = (int (**)(...))&off_1A17BF90;
      v11 = google::protobuf::FieldDescriptor::TypeOnceInit;
      v12 = 0;
      google::protobuf::GoogleOnceInitImpl((google::protobuf::ProtobufOnceType *)this, &v10);
      this = (google::protobuf::DescriptorBuilder *)&v10;
      v10._vptr_Closure = (int (**)(...))&off_1A17BF90;
      google::protobuf::Closure::~Closure(&v10);
      if ( !a2->message_type_ )
        return;
    }
    else if ( !a2->message_type_ )
    {
      return;
    }
  }
  options = a2->options_;
  if ( options->lazy_ )
  {
    this = (google::protobuf::DescriptorBuilder *)a2->type_once_;
    if ( this && this->pool_ != (const google::protobuf::DescriptorPool *)2 )
    {
      v10._vptr_Closure = (int (**)(...))&off_1A17BF90;
      v12 = 0;
      v11 = google::protobuf::FieldDescriptor::TypeOnceInit;
      v13 = a2;
      google::protobuf::GoogleOnceInitImpl((google::protobuf::ProtobufOnceType *)this, &v10);
      this = (google::protobuf::DescriptorBuilder *)&v10;
      v10._vptr_Closure = (int (**)(...))&off_1A17BF90;
      google::protobuf::Closure::~Closure(&v10);
    }
    if ( a2->type_ != TYPE_MESSAGE_0 )
    {
      this = v4;
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)v4,
        a2->full_name_,
        (__int64)a3,
        2u,
        "[lazy = true] can only be specified for submessage fields.");
    }
    options = a2->options_;
  }
  if ( options->packed_ )
  {
    if ( a2->label_ != LABEL_REPEATED )
      goto LABEL_15;
    this = (google::protobuf::DescriptorBuilder *)a2->type_once_;
    if ( this && this->pool_ != (const google::protobuf::DescriptorPool *)2 )
    {
      v10._vptr_Closure = (int (**)(...))&off_1A17BF90;
      v12 = 0;
      v11 = google::protobuf::FieldDescriptor::TypeOnceInit;
      v13 = a2;
      google::protobuf::GoogleOnceInitImpl((google::protobuf::ProtobufOnceType *)this, &v10);
      this = (google::protobuf::DescriptorBuilder *)&v10;
      v10._vptr_Closure = (int (**)(...))&off_1A17BF90;
      google::protobuf::Closure::~Closure(&v10);
    }
    if ( (unsigned int)(a2->type_ - 9) <= 3 )
    {
LABEL_15:
      this = v4;
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)v4,
        a2->full_name_,
        (__int64)a3,
        2u,
        "[packed = true] can only be specified for repeated primitive fields.");
    }
  }
  containing_type = a2->containing_type_;
  if ( containing_type )
  {
    v7 = containing_type->options_;
    if ( v7 != (const google::protobuf::MessageOptions *)google::protobuf::MessageOptions::default_instance((google::protobuf::MessageOptions *)this)
      && a2->containing_type_->options_->message_set_wire_format_ )
    {
      if ( a2->is_extension_ )
      {
        if ( a2->label_ != LABEL_OPTIONAL )
          goto LABEL_25;
        type_once = a2->type_once_;
        if ( type_once && type_once->state_ != 2 )
        {
          v10._vptr_Closure = (int (**)(...))&off_1A17BF90;
          v12 = 0;
          v11 = google::protobuf::FieldDescriptor::TypeOnceInit;
          v13 = a2;
          google::protobuf::GoogleOnceInitImpl(&type_once->state_, &v10);
          v10._vptr_Closure = (int (**)(...))&off_1A17BF90;
          google::protobuf::Closure::~Closure(&v10);
        }
        if ( a2->type_ != TYPE_MESSAGE_0 )
LABEL_25:
          google::protobuf::DescriptorBuilder::AddError(
            (__int64)v4,
            a2->full_name_,
            (__int64)a3,
            2u,
            "Extensions of MessageSets must be optional messages.");
      }
      else
      {
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)v4,
          a2->full_name_,
          (__int64)a3,
          0,
          "MessageSets cannot have fields, only extensions.");
      }
    }
  }
  if ( google::protobuf::IsLite(a2->file_) )
  {
    v9 = a2->containing_type_;
    if ( v9 )
    {
      if ( !google::protobuf::IsLite(v9->file_) )
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)v4,
          a2->full_name_,
          (__int64)a3,
          3u,
          "Extensions to non-lite types can only be declared in non-lite files.  Note that you cannot extend a non-lite t"
          "ype to contain a lite type, but the reverse is allowed.");
    }
  }
  if ( google::protobuf::FieldDescriptor::is_map(a2)
    && !(unsigned __int8)google::protobuf::DescriptorBuilder::ValidateMapEntry(v4, a2, a3) )
  {
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)v4,
      a2->full_name_,
      (__int64)a3,
      9u,
      "map_entry should not be set explicitly. Use map<KeyType, ValueType> instead.");
  }
  google::protobuf::DescriptorBuilder::ValidateJSType(v4, a2, a3);
};

// Line 5771: range 000000000C902FB0-000000000C903467
void __fastcall google::protobuf::DescriptorBuilder::ValidateEnumOptions(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::EnumDescriptor *a2,
        const google::protobuf::EnumDescriptorProto *a3,
        __int64 a4,
        __int64 a5,
        const std::piecewise_construct_t *a6)
{
  const google::protobuf::EnumOptions *options; // rax
  int value_count; // eax
  __int64 v9; // rbx
  __int64 v10; // rsi
  google::protobuf::EnumValueDescriptor *v11; // r14
  int number; // edx
  __int64 v13; // rax
  int *v14; // rcx
  const std::string *full_name; // r13
  int *v16; // r9
  std::_Rb_tree_iterator<std::pair<int const,std::string > >::_Base_ptr M_node; // r13
  __m128i *v18; // rax
  const char *M_parent; // rsi
  __int64 v20; // rax
  __int64 v21; // rax
  std::string::size_type v22; // rcx
  google::protobuf::internal::LogMessage_0 *v23; // rdi
  google::protobuf::internal::LogMessage_0 *v24; // rax
  std::tuple<int&&> *v25; // [rsp+0h] [rbp-138h]
  std::_Rb_tree<int,std::pair<int const,std::string >,std::_Select1st<std::pair<int const,std::string > >,std::less<int>,std::allocator<std::pair<int const,std::string > > > *v26; // [rsp+8h] [rbp-130h]
  int v29; // [rsp+2Ch] [rbp-10Ch] BYREF
  std::string value; // [rsp+30h] [rbp-108h] BYREF
  std::string v31; // [rsp+50h] [rbp-E8h] BYREF
  std::tuple<> v32[8]; // [rsp+70h] [rbp-C8h] BYREF
  __int64 v33; // [rsp+78h] [rbp-C0h]
  __m128i v34; // [rsp+80h] [rbp-B8h] BYREF
  char v35; // [rsp+90h] [rbp-A8h] BYREF
  int v36; // [rsp+98h] [rbp-A0h] BYREF
  __int64 v37; // [rsp+A0h] [rbp-98h]
  int *v38; // [rsp+A8h] [rbp-90h]
  int *v39; // [rsp+B0h] [rbp-88h]
  __int64 v40; // [rsp+B8h] [rbp-80h]
  google::protobuf::internal::LogMessage_0 v41[2]; // [rsp+C0h] [rbp-78h] BYREF

  options = a2->options_;
  if ( (options->_has_bits_.has_bits_[0] & 1) == 0 || !options->allow_alias_ )
  {
    value_count = a2->value_count_;
    v36 = 0;
    v37 = 0LL;
    v38 = &v36;
    v39 = &v36;
    v40 = 0LL;
    if ( value_count > 0 )
    {
      v9 = 0LL;
      v10 = 0LL;
      v26 = (std::_Rb_tree<int,std::pair<int const,std::string >,std::_Select1st<std::pair<int const,std::string > >,std::less<int>,std::allocator<std::pair<int const,std::string > > > *)&v35;
      while ( 1 )
      {
        v11 = &a2->values_[v9];
        number = v11->number_;
        if ( !v10 )
          break;
        v13 = v10;
        v14 = &v36;
        do
        {
          while ( *(_DWORD *)(v13 + 32) >= number )
          {
            v14 = (int *)v13;
            v13 = *(_QWORD *)(v13 + 16);
            if ( !v13 )
              goto LABEL_10;
          }
          v13 = *(_QWORD *)(v13 + 24);
        }
        while ( v13 );
LABEL_10:
        if ( v14 != &v36 && number >= v14[8] )
        {
          v29 = v11->number_;
          M_node = (std::_Rb_tree_iterator<std::pair<int const,std::string > >::_Base_ptr)&v36;
          do
          {
            while ( number <= *(_DWORD *)(v10 + 32) )
            {
              M_node = (std::_Rb_tree_iterator<std::pair<int const,std::string > >::_Base_ptr)v10;
              v10 = *(_QWORD *)(v10 + 16);
              if ( !v10 )
                goto LABEL_27;
            }
            v10 = *(_QWORD *)(v10 + 24);
          }
          while ( v10 );
LABEL_27:
          if ( M_node == (std::_Rb_tree_iterator<std::pair<int const,std::string > >::_Base_ptr)&v36
            || number < M_node[1]._M_color )
          {
            *(_QWORD *)&v41[0].level_ = &v29;
            M_node = std::_Rb_tree<int,std::pair<int const,std::string>,std::_Select1st<std::pair<int const,std::string>>,std::less<int>,std::allocator<std::pair<int const,std::string>>>::_M_emplace_hint_unique<std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(
                       v26,
                       (std::_Rb_tree<int,std::pair<int const,std::string >,std::_Select1st<std::pair<int const,std::string > >,std::less<int>,std::allocator<std::pair<int const,std::string > > >::const_iterator)M_node,
                       &std::piecewise_construct,
                       (std::tuple<int&&> *)v41,
                       v32,
                       a6,
                       v25,
                       (std::tuple<> *)v26)._M_node;
          }
          std::operator+<char>(&v31, "\"", v11->full_name_);
          if ( 0x3FFFFFFFFFFFFFFFLL - v31._M_string_length <= 0x1E )
            std::__throw_length_error("basic_string::append");
          v18 = (__m128i *)std::string::_M_append(&v31, "\" uses the same enum value as \"", 31LL);
          *(_QWORD *)v32[0].gap0 = &v34;
          if ( (__m128i *)v18->m128i_i64[0] == &v18[1] )
          {
            v34 = _mm_loadu_si128(v18 + 1);
          }
          else
          {
            *(_QWORD *)v32[0].gap0 = v18->m128i_i64[0];
            v34.m128i_i64[0] = v18[1].m128i_i64[0];
          }
          v33 = v18->m128i_i64[1];
          v18->m128i_i64[0] = (__int64)v18[1].m128i_i64;
          v18[1].m128i_i8[0] = 0;
          M_parent = (const char *)M_node[1]._M_parent;
          v18->m128i_i64[1] = 0LL;
          v20 = std::string::_M_append(v32, M_parent, M_node[1]._M_left);
          *(_QWORD *)&v41[0].level_ = &v41[0].line_;
          if ( *(_QWORD *)v20 == v20 + 16 )
          {
            *(__m128i *)&v41[0].line_ = _mm_loadu_si128((const __m128i *)(v20 + 16));
          }
          else
          {
            *(_QWORD *)&v41[0].level_ = *(_QWORD *)v20;
            *(_QWORD *)&v41[0].line_ = *(_QWORD *)(v20 + 16);
          }
          v41[0].filename_ = *(const char **)(v20 + 8);
          *(_QWORD *)(v20 + 8) = 0LL;
          *(_BYTE *)(v20 + 16) = 0;
          *(_QWORD *)v20 = v20 + 16;
          if ( 0x3FFFFFFFFFFFFFFFLL - (unsigned __int64)v41[0].filename_ <= 0x4F )
            std::__throw_length_error("basic_string::append");
          v21 = std::string::_M_append(
                  v41,
                  "\". If this is intended, set 'option allow_alias = true;' to the enum definition.",
                  80LL);
          value._M_dataplus._M_p = value._anon_0._M_local_buf;
          if ( *(_QWORD *)v21 == v21 + 16 )
          {
            value._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v21 + 16));
          }
          else
          {
            value._M_dataplus._M_p = *(std::string::pointer *)v21;
            value._anon_0._M_allocated_capacity = *(_QWORD *)(v21 + 16);
          }
          v22 = *(_QWORD *)(v21 + 8);
          *(_BYTE *)(v21 + 16) = 0;
          value._M_string_length = v22;
          *(_QWORD *)v21 = v21 + 16;
          v23 = *(google::protobuf::internal::LogMessage_0 **)&v41[0].level_;
          *(_QWORD *)(v21 + 8) = 0LL;
          if ( v23 != (google::protobuf::internal::LogMessage_0 *)&v41[0].line_ )
            operator delete(v23);
          if ( *(__m128i **)v32[0].gap0 != &v34 )
            operator delete(*(void **)v32[0].gap0);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v31._M_dataplus._M_p != &v31._anon_0 )
            operator delete(v31._M_dataplus._M_p);
          if ( a2->options_->allow_alias_ )
          {
            google::protobuf::internal::LogMessage::LogMessage(
              v41,
              LOGLEVEL_ERROR_0,
              "google/protobuf/descriptor.cc",
              5791);
            v24 = google::protobuf::internal::LogMessage::operator<<(v41, &value);
            google::protobuf::internal::LogFinisher::operator=((google::protobuf::internal::LogFinisher *const)v32, v24);
            google::protobuf::internal::LogMessage::~LogMessage(v41);
          }
          else
          {
            google::protobuf::DescriptorBuilder::AddError((__int64)this, a2->full_name_, (__int64)a3, 1u, &value);
          }
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)value._M_dataplus._M_p != &value._anon_0 )
            operator delete(value._M_dataplus._M_p);
          goto LABEL_48;
        }
        full_name = v11->full_name_;
        v16 = &v36;
        *(_DWORD *)v32[0].gap0 = v11->number_;
        do
        {
          while ( number <= *(_DWORD *)(v10 + 32) )
          {
            v16 = (int *)v10;
            v10 = *(_QWORD *)(v10 + 16);
            if ( !v10 )
              goto LABEL_16;
          }
          v10 = *(_QWORD *)(v10 + 24);
        }
        while ( v10 );
LABEL_16:
        if ( v16 == &v36 || number < v16[8] )
          goto LABEL_18;
LABEL_19:
        std::string::_M_assign(v16 + 10, full_name);
LABEL_48:
        v10 = v37;
        if ( a2->value_count_ <= (int)++v9 )
          goto LABEL_21;
      }
      full_name = v11->full_name_;
      v16 = &v36;
      *(_DWORD *)v32[0].gap0 = v11->number_;
LABEL_18:
      *(_QWORD *)&v41[0].level_ = v32;
      v16 = (int *)std::_Rb_tree<int,std::pair<int const,std::string>,std::_Select1st<std::pair<int const,std::string>>,std::less<int>,std::allocator<std::pair<int const,std::string>>>::_M_emplace_hint_unique<std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(
                     v26,
                     (std::_Rb_tree<int,std::pair<int const,std::string >,std::_Select1st<std::pair<int const,std::string > >,std::less<int>,std::allocator<std::pair<int const,std::string > > >::const_iterator)v16,
                     &std::piecewise_construct,
                     (std::tuple<int&&> *)v41,
                     (std::tuple<> *)&v31,
                     (const std::piecewise_construct_t *)v16,
                     v25,
                     (std::tuple<> *)v26)._M_node;
      goto LABEL_19;
    }
    v10 = 0LL;
    v26 = (std::_Rb_tree<int,std::pair<int const,std::string >,std::_Select1st<std::pair<int const,std::string > >,std::less<int>,std::allocator<std::pair<int const,std::string > > > *)&v35;
LABEL_21:
    std::_Rb_tree<int,std::pair<int const,std::string>,std::_Select1st<std::pair<int const,std::string>>,std::less<int>,std::allocator<std::pair<int const,std::string>>>::_M_erase(
      v26,
      (std::_Rb_tree<int,std::pair<int const,std::string >,std::_Select1st<std::pair<int const,std::string > >,std::less<int>,std::allocator<std::pair<int const,std::string > > >::_Link_type)v10);
  }
};

// Line 5804: range 000000000C8F5DF0-000000000C8F5E00
void __fastcall google::protobuf::DescriptorBuilder::ValidateEnumValueOptions(
        google::protobuf::DescriptorBuilder *const this,
        google::protobuf::EnumValueDescriptor *a2,
        const google::protobuf::EnumValueDescriptorProto *a3)
{
  ;
};

// Line 5806: range 000000000C8F9210-000000000C8F926C
void __fastcall google::protobuf::DescriptorBuilder::ValidateServiceOptions(
        google::protobuf::DescriptorBuilder *const this,
        google::protobuf::ServiceDescriptor *service,
        const google::protobuf::ServiceDescriptorProto *proto)
{
  if ( google::protobuf::IsLite(service->file_) )
  {
    if ( *(_WORD *)&service->file_->options_->cc_generic_services_ )
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        service->full_name_,
        (__int64)proto,
        0,
        "Files with optimize_for = LITE_RUNTIME cannot define services unless you set both options cc_generic_services an"
        "d java_generic_sevices to false.");
  }
};

// Line 5826: range 000000000C8F9270-000000000C8F9680
__int64 __fastcall google::protobuf::DescriptorBuilder::ValidateMapEntry(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::FieldDescriptor *a2,
        const google::protobuf::FieldDescriptorProto *a3)
{
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  const google::protobuf::Descriptor *message_type; // r12
  __int64 v8; // rax
  bool v9; // r14
  int (**vptr_Closure)(...); // r15
  size_t M_string_length; // rdx
  google::protobuf::FieldDescriptor *fields; // r12
  google::protobuf::ProtobufOnceType *p_state; // rdi
  unsigned int type; // eax
  google::protobuf::ProtobufOnceType *v15; // rdi
  google::protobuf::ProtobufOnceType *v16; // rdi
  void *v17[2]; // [rsp+0h] [rbp-78h] BYREF
  char v18; // [rsp+10h] [rbp-68h] BYREF
  google::protobuf::Closure closure; // [rsp+20h] [rbp-58h] BYREF
  void (__fastcall *v20)(const google::protobuf::FieldDescriptor *); // [rsp+28h] [rbp-50h]
  __m128i v21; // [rsp+30h] [rbp-48h] BYREF

  type_once = a2->type_once_;
  if ( type_once && type_once->state_ != 2 )
  {
    v21.m128i_i64[1] = (__int64)a2;
    v21.m128i_i8[0] = 0;
    closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
    v20 = google::protobuf::FieldDescriptor::TypeOnceInit;
    google::protobuf::GoogleOnceInitImpl(&type_once->state_, &closure);
    closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
    google::protobuf::Closure::~Closure(&closure);
  }
  message_type = a2->message_type_;
  if ( message_type->extension_count_
    || a2->label_ != LABEL_REPEATED
    || message_type->extension_range_count_
    || message_type->nested_type_count_
    || message_type->enum_type_count_
    || message_type->field_count_ != 2 )
  {
    return 0LL;
  }
  google::protobuf::`anonymous namespace'::ToCamelCase((char **)v17, &a2->name_->_M_dataplus._M_p, 0);
  if ( 0x3FFFFFFFFFFFFFFFLL - (unsigned __int64)v17[1] <= 4 )
    std::__throw_length_error("basic_string::append");
  v8 = std::string::_M_append(v17, "Entry", 5LL);
  closure._vptr_Closure = (int (**)(...))&v21;
  if ( *(_QWORD *)v8 == v8 + 16 )
  {
    v21 = _mm_loadu_si128((const __m128i *)(v8 + 16));
  }
  else
  {
    closure._vptr_Closure = *(int (***)(...))v8;
    v21.m128i_i64[0] = *(_QWORD *)(v8 + 16);
  }
  v9 = 1;
  v20 = *(void (__fastcall **)(const google::protobuf::FieldDescriptor *))(v8 + 8);
  *(_QWORD *)v8 = v8 + 16;
  *(_QWORD *)(v8 + 8) = 0LL;
  *(_BYTE *)(v8 + 16) = 0;
  vptr_Closure = closure._vptr_Closure;
  M_string_length = message_type->name_->_M_string_length;
  if ( (void (__fastcall *)(const google::protobuf::FieldDescriptor *))M_string_length == v20 )
  {
    if ( !M_string_length
      || (v9 = 1, !memcmp(message_type->name_->_M_dataplus._M_p, closure._vptr_Closure, M_string_length)) )
    {
      v9 = message_type->containing_type_ != a2->containing_type_;
    }
  }
  if ( vptr_Closure != (int (**)(...))&v21 )
    operator delete(vptr_Closure);
  if ( v17[0] != &v18 )
    operator delete(v17[0]);
  if ( v9 )
    return 0LL;
  fields = message_type->fields_;
  if ( fields->label_ != LABEL_OPTIONAL
    || fields->number_ != 1
    || (unsigned int)std::string::compare(fields->name_, off_1A19A99E)
    || fields[1].label_ != LABEL_OPTIONAL
    || fields[1].number_ != 2
    || (unsigned int)std::string::compare(fields[1].name_, 455333713LL) )
  {
    return 0LL;
  }
  p_state = &fields->type_once_->state_;
  if ( p_state && *p_state != 2 )
  {
    v21.m128i_i8[0] = 0;
    v21.m128i_i64[1] = (__int64)fields;
    closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
    v20 = google::protobuf::FieldDescriptor::TypeOnceInit;
    google::protobuf::GoogleOnceInitImpl(p_state, &closure);
    closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
    google::protobuf::Closure::~Closure(&closure);
  }
  type = fields->type_;
  if ( type > 0xC )
  {
    if ( type == 14 )
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        a2->full_name_,
        (__int64)a3,
        2u,
        "Key in map fields cannot be enum types.");
  }
  else if ( type > 9 || type - 1 <= 1 )
  {
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this,
      a2->full_name_,
      (__int64)a3,
      2u,
      "Key in map fields cannot be float/double, bytes or message types.");
  }
  v15 = &fields[1].type_once_->state_;
  if ( v15 )
  {
    if ( *v15 != 2 )
    {
      v21.m128i_i8[0] = 0;
      v21.m128i_i64[1] = (__int64)&fields[1];
      closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
      v20 = google::protobuf::FieldDescriptor::TypeOnceInit;
      google::protobuf::GoogleOnceInitImpl(v15, &closure);
      closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
      google::protobuf::Closure::~Closure(&closure);
    }
    if ( fields[1].type_ != TYPE_ENUM_0 )
      return 1LL;
    v16 = &fields[1].type_once_->state_;
    if ( v16 && *v16 != 2 )
    {
      v21.m128i_i8[0] = 0;
      v21.m128i_i64[1] = (__int64)&fields[1];
      closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
      v20 = google::protobuf::FieldDescriptor::TypeOnceInit;
      google::protobuf::GoogleOnceInitImpl(v16, &closure);
      closure._vptr_Closure = (int (**)(...))&off_1A17BF90;
      google::protobuf::Closure::~Closure(&closure);
    }
    goto LABEL_41;
  }
  if ( fields[1].type_ == TYPE_ENUM_0 )
  {
LABEL_41:
    if ( fields[1].enum_type_->values_->number_ )
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        a2->full_name_,
        (__int64)a3,
        2u,
        "Enum value in map must define 0 as the first value.");
  }
  return 1LL;
};

// Line 5900: range 000000000C8FE350-000000000C8FE980
void __fastcall google::protobuf::DescriptorBuilder::DetectMapConflicts(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::Descriptor *a2,
        const google::protobuf::DescriptorProto *a3,
        std::forward_iterator_tag a4)
{
  int nested_type_count; // esi
  __int64 v6; // r14
  const std::string *name; // rax
  std::pair<std::string,const google::protobuf::Descriptor*> *v8; // rdx
  std::pair<std::_Rb_tree_iterator<std::pair<const std::string,const google::protobuf::Descriptor*> >,bool> v9; // rax
  bool second; // r15
  __int64 v11; // rax
  const std::string *full_name; // rsi
  __int64 i; // r14
  std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::Descriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::Descriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::Descriptor*> > >::iterator v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  const std::string *v17; // rsi
  __int64 j; // r14
  std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::Descriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::Descriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::Descriptor*> > >::iterator v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  const std::string *v22; // rsi
  __int64 k; // r14
  std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::Descriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::Descriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::Descriptor*> > >::iterator v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  const std::string *v27; // rsi
  int v28; // [rsp+4h] [rbp-E4h]
  int v29; // [rsp+4h] [rbp-E4h]
  google::protobuf::Descriptor *v31; // [rsp+20h] [rbp-C8h]
  std::_Rb_tree_node_base *M_node; // [rsp+28h] [rbp-C0h]
  std::string v33; // [rsp+30h] [rbp-B8h] BYREF
  std::pair<std::string,const google::protobuf::Descriptor*> v34; // [rsp+50h] [rbp-98h] BYREF
  std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::Descriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::Descriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::Descriptor*> > > v35; // [rsp+80h] [rbp-68h] BYREF

  nested_type_count = a2->nested_type_count_;
  v35._M_impl._M_header._M_color = _S_red;
  v35._M_impl._M_header._M_parent = 0LL;
  v35._M_impl._M_header._M_left = &v35._M_impl._M_header;
  v35._M_impl._M_header._M_right = &v35._M_impl._M_header;
  v35._M_impl._M_node_count = 0LL;
  if ( nested_type_count > 0 )
  {
    v6 = 0LL;
    do
    {
      name = a2->nested_types_[v6].name_;
      v31 = &a2->nested_types_[v6];
      v34.first._M_dataplus._M_p = v34.first._anon_0._M_local_buf;
      std::string::_M_construct<char *>(
        &v34.first,
        name->_M_dataplus._M_p,
        &name->_M_dataplus._M_p[name->_M_string_length],
        a4);
      v34.second = v31;
      v9 = std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::Descriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::Descriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::Descriptor const*>>>::_M_emplace_unique<std::pair<std::string,google::protobuf::Descriptor const*>>(
             &v35,
             &v34,
             v8);
      second = v9.second;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v34.first._M_dataplus._M_p != &v34.first._anon_0 )
      {
        M_node = v9.first._M_node;
        operator delete(v34.first._M_dataplus._M_p);
        v9.first._M_node = M_node;
      }
      if ( !second
        && (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)&v9.first._M_node[2]._M_color + 32LL) + 107LL) || v31->options_->map_entry_) )
      {
        std::operator+<char>(&v33, "Expanded map entry type ", v31->name_);
        if ( 0x3FFFFFFFFFFFFFFFLL - v33._M_string_length <= 0x2F )
          std::__throw_length_error("basic_string::append");
        v11 = std::string::_M_append(&v33, " conflicts with an existing nested message type.", 48LL);
        v34.first._M_dataplus._M_p = v34.first._anon_0._M_local_buf;
        if ( *(_QWORD *)v11 == v11 + 16 )
        {
          v34.first._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v11 + 16));
        }
        else
        {
          v34.first._M_dataplus._M_p = *(std::string::pointer *)v11;
          v34.first._anon_0._M_allocated_capacity = *(_QWORD *)(v11 + 16);
        }
        v34.first._M_string_length = *(_QWORD *)(v11 + 8);
        *(_QWORD *)v11 = v11 + 16;
        *(_BYTE *)(v11 + 16) = 0;
        full_name = a2->full_name_;
        *(_QWORD *)(v11 + 8) = 0LL;
        google::protobuf::DescriptorBuilder::AddError((__int64)this, full_name, (__int64)a3, 0, &v34.first);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v34.first._M_dataplus._M_p != &v34.first._anon_0 )
          operator delete(v34.first._M_dataplus._M_p);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v33._M_dataplus._M_p != &v33._anon_0 )
          operator delete(v33._M_dataplus._M_p);
      }
      google::protobuf::DescriptorBuilder::DetectMapConflicts(
        this,
        &a2->nested_types_[v6],
        (const google::protobuf::DescriptorProto *)a3->nested_type_.rep_->elements[(int)v6]);
      ++v6;
    }
    while ( a2->nested_type_count_ > (int)v6 );
  }
  v28 = 0;
  for ( i = 0LL; v28 < a2->field_count_; ++i )
  {
    v14._M_node = std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::Descriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::Descriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::Descriptor const*>>>::find(
                    &v35,
                    a2->fields_[i].name_)._M_node;
    if ( (std::_Rb_tree_header *)v14._M_node != &v35._M_impl.std::_Rb_tree_header )
    {
      v15 = *(_QWORD *)&v14._M_node[2]._M_color;
      if ( *(_BYTE *)(*(_QWORD *)(v15 + 32) + 107LL) )
      {
        std::operator+<char>(&v33, "Expanded map entry type ", *(const std::string **)v15);
        if ( 0x3FFFFFFFFFFFFFFFLL - v33._M_string_length <= 0x21 )
          std::__throw_length_error("basic_string::append");
        v16 = std::string::_M_append(&v33, " conflicts with an existing field.", 34LL);
        v34.first._M_dataplus._M_p = v34.first._anon_0._M_local_buf;
        if ( *(_QWORD *)v16 == v16 + 16 )
        {
          v34.first._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v16 + 16));
        }
        else
        {
          v34.first._M_dataplus._M_p = *(std::string::pointer *)v16;
          v34.first._anon_0._M_allocated_capacity = *(_QWORD *)(v16 + 16);
        }
        v34.first._M_string_length = *(_QWORD *)(v16 + 8);
        *(_QWORD *)v16 = v16 + 16;
        *(_BYTE *)(v16 + 16) = 0;
        v17 = a2->full_name_;
        *(_QWORD *)(v16 + 8) = 0LL;
        google::protobuf::DescriptorBuilder::AddError((__int64)this, v17, (__int64)a3, 0, &v34.first);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v34.first._M_dataplus._M_p != &v34.first._anon_0 )
          operator delete(v34.first._M_dataplus._M_p);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v33._M_dataplus._M_p != &v33._anon_0 )
          operator delete(v33._M_dataplus._M_p);
      }
    }
    ++v28;
  }
  v29 = 0;
  for ( j = 0LL; v29 < a2->enum_type_count_; ++j )
  {
    v19._M_node = std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::Descriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::Descriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::Descriptor const*>>>::find(
                    &v35,
                    a2->enum_types_[j].name_)._M_node;
    if ( (std::_Rb_tree_header *)v19._M_node != &v35._M_impl.std::_Rb_tree_header )
    {
      v20 = *(_QWORD *)&v19._M_node[2]._M_color;
      if ( *(_BYTE *)(*(_QWORD *)(v20 + 32) + 107LL) )
      {
        std::operator+<char>(&v33, "Expanded map entry type ", *(const std::string **)v20);
        if ( 0x3FFFFFFFFFFFFFFFLL - v33._M_string_length <= 0x25 )
          std::__throw_length_error("basic_string::append");
        v21 = std::string::_M_append(&v33, " conflicts with an existing enum type.", 38LL);
        v34.first._M_dataplus._M_p = v34.first._anon_0._M_local_buf;
        if ( *(_QWORD *)v21 == v21 + 16 )
        {
          v34.first._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v21 + 16));
        }
        else
        {
          v34.first._M_dataplus._M_p = *(std::string::pointer *)v21;
          v34.first._anon_0._M_allocated_capacity = *(_QWORD *)(v21 + 16);
        }
        v34.first._M_string_length = *(_QWORD *)(v21 + 8);
        *(_QWORD *)v21 = v21 + 16;
        *(_BYTE *)(v21 + 16) = 0;
        v22 = a2->full_name_;
        *(_QWORD *)(v21 + 8) = 0LL;
        google::protobuf::DescriptorBuilder::AddError((__int64)this, v22, (__int64)a3, 0, &v34.first);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v34.first._M_dataplus._M_p != &v34.first._anon_0 )
          operator delete(v34.first._M_dataplus._M_p);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v33._M_dataplus._M_p != &v33._anon_0 )
          operator delete(v33._M_dataplus._M_p);
      }
    }
    ++v29;
  }
  for ( k = 0LL; a2->oneof_decl_count_ > (int)k; ++k )
  {
    while ( 1 )
    {
      v24._M_node = std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::Descriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::Descriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::Descriptor const*>>>::find(
                      &v35,
                      a2->oneof_decls_[k].name_)._M_node;
      if ( (std::_Rb_tree_header *)v24._M_node != &v35._M_impl.std::_Rb_tree_header )
      {
        v25 = *(_QWORD *)&v24._M_node[2]._M_color;
        if ( *(_BYTE *)(*(_QWORD *)(v25 + 32) + 107LL) )
        {
          std::operator+<char>(&v33, "Expanded map entry type ", *(const std::string **)v25);
          if ( 0x3FFFFFFFFFFFFFFFLL - v33._M_string_length <= 0x26 )
            std::__throw_length_error("basic_string::append");
          v26 = std::string::_M_append(&v33, " conflicts with an existing oneof type.", 39LL);
          v34.first._M_dataplus._M_p = v34.first._anon_0._M_local_buf;
          if ( *(_QWORD *)v26 == v26 + 16 )
          {
            v34.first._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v26 + 16));
          }
          else
          {
            v34.first._M_dataplus._M_p = *(std::string::pointer *)v26;
            v34.first._anon_0._M_allocated_capacity = *(_QWORD *)(v26 + 16);
          }
          v34.first._M_string_length = *(_QWORD *)(v26 + 8);
          *(_QWORD *)v26 = v26 + 16;
          *(_BYTE *)(v26 + 16) = 0;
          v27 = a2->full_name_;
          *(_QWORD *)(v26 + 8) = 0LL;
          google::protobuf::DescriptorBuilder::AddError((__int64)this, v27, (__int64)a3, 0, &v34.first);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v34.first._M_dataplus._M_p != &v34.first._anon_0 )
            operator delete(v34.first._M_dataplus._M_p);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v33._M_dataplus._M_p != &v33._anon_0 )
            break;
        }
      }
      if ( a2->oneof_decl_count_ <= (int)++k )
        goto LABEL_52;
    }
    operator delete(v33._M_dataplus._M_p);
  }
LABEL_52:
  std::_Rb_tree<std::string,std::pair<std::string const,google::protobuf::Descriptor const*>,std::_Select1st<std::pair<std::string const,google::protobuf::Descriptor const*>>,std::less<std::string>,std::allocator<std::pair<std::string const,google::protobuf::Descriptor const*>>>::_M_erase(
    &v35,
    (std::_Rb_tree<std::string,std::pair<const std::string,const google::protobuf::Descriptor*>,std::_Select1st<std::pair<const std::string,const google::protobuf::Descriptor*> >,std::less<std::string >,std::allocator<std::pair<const std::string,const google::protobuf::Descriptor*> > >::_Link_type)v35._M_impl._M_header._M_parent);
};

// Line 5957: range 000000000C8F9690-000000000C8F97AB
void __fastcall google::protobuf::DescriptorBuilder::ValidateJSType(
        google::protobuf::DescriptorBuilder *this,
        google::protobuf::FieldDescriptor *a2,
        const google::protobuf::FieldDescriptorProto *a3)
{
  __int64 jstype; // r13
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  google::protobuf::FieldDescriptor::Type type; // ecx
  __int64 v8; // rax
  std::string v9[2]; // [rsp+0h] [rbp-48h] BYREF

  jstype = a2->options_->jstype_;
  if ( (_DWORD)jstype )
  {
    type_once = a2->type_once_;
    if ( type_once && type_once->state_ != 2 )
    {
      *(&v9[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
      v9[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      v9[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
      v9[0]._anon_0._M_local_buf[0] = 0;
      google::protobuf::GoogleOnceInitImpl(&type_once->state_, (google::protobuf::Closure *)v9);
      type_once = (google::protobuf::GoogleOnceDynamic *)v9;
      v9[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v9);
    }
    type = a2->type_;
    if ( (unsigned int)type <= TYPE_SINT64_0 && ((1LL << type) & 0x50058) != 0 )
    {
      if ( (unsigned int)(jstype - 1) > 1 )
      {
        v8 = google::protobuf::FieldOptions_JSType_descriptor((google::protobuf *)type_once);
        std::operator+<char>(
          v9,
          "Illegal jstype for int64, uint64, sint64, fixed64 or sfixed64 field: ",
          *(const std::string **)(*(_QWORD *)(v8 + 48) + 40 * jstype));
        google::protobuf::DescriptorBuilder::AddError((__int64)this, a2->full_name_, (__int64)a3, 2u, v9);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v9[0]._M_dataplus._M_p != &v9[0]._anon_0 )
          operator delete(v9[0]._M_dataplus._M_p);
      }
    }
    else
    {
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)this,
        a2->full_name_,
        (__int64)a3,
        2u,
        "jstype is only allowed on int64, uint64, sint64, fixed64 or sfixed64 fields.");
    }
  }
};

// Line 5995: range 000000000C9082B0-000000000C90833B
void __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::OptionInterpreter(
        google::protobuf::DescriptorBuilder::OptionInterpreter *this,
        google::protobuf::DescriptorBuilder *a2)
{
  google::protobuf::internal::LogMessage_0 *v2; // rax
  google::protobuf::internal::LogFinisher v3; // [rsp+Fh] [rbp-59h] BYREF
  google::protobuf::internal::LogMessage_0 v4; // [rsp+10h] [rbp-58h] BYREF

  this->builder_ = a2;
  google::protobuf::DynamicMessageFactory::DynamicMessageFactory(&this->dynamic_factory_);
  if ( !this->builder_ )
  {
    google::protobuf::internal::LogMessage::LogMessage(&v4, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 5997);
    v2 = google::protobuf::internal::LogMessage::operator<<(&v4, "CHECK failed: builder_: ");
    google::protobuf::internal::LogFinisher::operator=(&v3, v2);
    google::protobuf::internal::LogMessage::~LogMessage(&v4);
  }
};

// Line 5997: range 000000000C72EF3A-000000000C72EF4F
void __fastcall __noreturn google::protobuf::DescriptorBuilder::OptionInterpreter::OptionInterpreter(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  google::protobuf::DynamicMessageFactory *v8; // rbp
  struct _Unwind_Exception *v9; // r12

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  google::protobuf::DynamicMessageFactory::~DynamicMessageFactory(v8);
  _Unwind_Resume(v9);
};

// Line 6000: range 000000000C908340-000000000C908344
void __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::~OptionInterpreter(
        google::protobuf::DescriptorBuilder::OptionInterpreter *const this)
{
  google::protobuf::DynamicMessageFactory::~DynamicMessageFactory(&this->dynamic_factory_);
};

// Line 6071: range 000000000C90FE60-000000000C9112E5
__int64 __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::InterpretSingleOption(
        google::protobuf::DescriptorBuilder::OptionInterpreter *this,
        google::protobuf::Message *a2)
{
  const google::protobuf::UninterpretedOption *uninterpreted_option; // rax
  unsigned int is_placeholder; // r15d
  std::forward_iterator_tag v7; // cl
  google::protobuf::DescriptorBuilder *builder; // rbp
  __int64 v9; // rax
  google::protobuf::Symbol SymbolNotEnforcingDeps; // rax
  std::forward_iterator_tag v11; // cl
  const google::protobuf::Descriptor *descriptor; // r13
  const google::protobuf::UninterpretedOption *v13; // rax
  int v14; // ebp
  __int64 v15; // rax
  const char *v16; // rsi
  google::protobuf::Symbol v17; // rax
  std::forward_iterator_tag v18; // cl
  int *v19; // rbx
  const google::protobuf::Descriptor *v20; // rax
  int current_size; // edx
  const google::protobuf::FieldDescriptor *const *v22; // rcx
  google::protobuf::ProtobufOnceType *v23; // rdi
  std::_Vector_base<const google::protobuf::FieldDescriptor*>::pointer M_finish; // rsi
  google::protobuf::FieldDescriptor *v25; // rbx
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  const std::string *v27; // r15
  const google::protobuf::Message::Reflection *(__fastcall *v28)(const google::protobuf::Message *const); // rdx
  __int64 v29; // rdx
  __int64 v30; // rdi
  int v31; // eax
  google::protobuf::UnknownFieldSet *v32; // rax
  const google::protobuf::FieldDescriptor **v33; // rbp
  char *v34; // rax
  __int64 v35; // rbx
  google::protobuf::ProtobufOnceType *v36; // rdi
  int v37; // eax
  std::string *v38; // rax
  google::protobuf::UnknownFieldSet *v39; // rbx
  google::protobuf::UnknownFieldSet *v40; // r12
  std::string::pointer v41; // r12
  const google::protobuf::Message::Reflection *(__fastcall *v42)(const google::protobuf::Message *const); // rax
  __int64 v43; // rdx
  __int64 v44; // rdi
  google::protobuf::UnknownFieldSet *v45; // rax
  google::protobuf::UnknownFieldSet *v46; // rbp
  google::protobuf::DescriptorBuilder *v47; // rbx
  __m128i *v48; // rax
  const char *v49; // rsi
  __int64 v50; // rax
  __int64 v51; // rax
  std::string *v52; // r9
  std::string::size_type v53; // rax
  std::string::size_type M_allocated_capacity; // rdi
  std::string::size_type v55; // rcx
  __int64 v56; // rax
  __int64 v57; // rax
  google::protobuf::DescriptorBuilder *v58; // rdi
  const google::protobuf::UninterpretedOption *v59; // rdx
  std::string::pointer v60; // rdi
  const std::string *name; // rbx
  __int64 v62; // rax
  const char *M_p; // rsi
  __int64 v64; // rax
  __int64 v65; // rax
  google::protobuf::DescriptorBuilder *v66; // rdi
  const google::protobuf::UninterpretedOption *v67; // rdx
  google::protobuf::internal::LogMessage_0 *v68; // rax
  __int64 v69; // rax
  google::protobuf::DescriptorBuilder *v70; // rdi
  const google::protobuf::UninterpretedOption *v71; // rdx
  __int64 v72; // rax
  google::protobuf::DescriptorBuilder *v73; // rdi
  const google::protobuf::UninterpretedOption *v74; // rdx
  google::protobuf::internal::LogMessage_0 *v75; // rax
  std::string::size_type v76; // rbp
  google::protobuf::internal::LogMessage_0 *v77; // r12
  google::protobuf::ProtobufOnceType *v78; // rdi
  google::protobuf::internal::LogMessage_0 *v79; // rax
  std::string::pointer v80; // rbp
  google::protobuf::UnknownFieldSet *v81; // rax
  google::protobuf::internal::LogMessage_0 *v82; // rax
  google::protobuf::internal::LogMessage_0 *v83; // rax
  google::protobuf::internal::LogMessage_0 *v84; // rax
  google::protobuf::internal::LogMessage_0 *v85; // rsi
  google::protobuf::FieldDescriptor *FieldByName; // [rsp+8h] [rbp-180h] BYREF
  std::vector<const google::protobuf::FieldDescriptor*> v87; // [rsp+10h] [rbp-178h] BYREF
  std::string __rhs; // [rsp+30h] [rbp-158h] BYREF
  std::string v89; // [rsp+50h] [rbp-138h] BYREF
  google::protobuf::internal::LogFinisher v90[8]; // [rsp+70h] [rbp-118h] BYREF
  __int64 v91; // [rsp+78h] [rbp-110h]
  __m128i v92; // [rsp+80h] [rbp-108h] BYREF
  google::protobuf::UnknownFieldSet *unknown_fields; // [rsp+90h] [rbp-F8h] BYREF
  __int64 v94; // [rsp+98h] [rbp-F0h]
  __m128i v95; // [rsp+A0h] [rbp-E8h] BYREF
  std::string v96; // [rsp+B0h] [rbp-D8h] BYREF
  std::string v97; // [rsp+D0h] [rbp-B8h] BYREF
  std::string v98; // [rsp+F0h] [rbp-98h] BYREF
  google::protobuf::internal::LogMessage_0 v99[2]; // [rsp+110h] [rbp-78h] BYREF

  uninterpreted_option = this->uninterpreted_option_;
  if ( !uninterpreted_option->name_.current_size_ )
  {
    *(_QWORD *)&v99[0].level_ = &v99[0].line_;
    std::string::_M_construct<char const*>((std::string *const)v99, "Option must have a name.", "", 0);
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this->builder_,
      &this->options_to_interpret_->element_name,
      (__int64)this->uninterpreted_option_,
      7u,
      (const std::string *)v99);
LABEL_3:
    if ( *(google::protobuf::internal::LogMessage_0 **)&v99[0].level_ != (google::protobuf::internal::LogMessage_0 *)&v99[0].line_ )
      operator delete(*(void **)&v99[0].level_);
    return 0;
  }
  if ( !(unsigned int)std::string::compare(
                        *((_QWORD *)uninterpreted_option->name_.rep_->elements[0] + 3),
                        "uninterpreted_option") )
  {
    *(_QWORD *)&v99[0].level_ = &v99[0].line_;
    std::string::_M_construct<char const*>(
      (std::string *const)v99,
      "Option must not use reserved name \"uninterpreted_option\".",
      "",
      v7);
    google::protobuf::DescriptorBuilder::AddError(
      (__int64)this->builder_,
      &this->options_to_interpret_->element_name,
      (__int64)this->uninterpreted_option_,
      7u,
      (const std::string *)v99);
    goto LABEL_3;
  }
  builder = this->builder_;
  v9 = (*((__int64 (__fastcall **)(google::protobuf::Message *))a2->_vptr_MessageLite + 24))(a2);
  SymbolNotEnforcingDeps = google::protobuf::DescriptorBuilder::FindSymbolNotEnforcingDeps(
                             builder,
                             (const std::string *)*(_QWORD *)(v9 + 8),
                             1);
  descriptor = SymbolNotEnforcingDeps._anon_0.descriptor;
  if ( SymbolNotEnforcingDeps.type != MESSAGE_0 )
    descriptor = (const google::protobuf::Descriptor *)(*((__int64 (__fastcall **)(google::protobuf::Message *))a2->_vptr_MessageLite
                                                        + 24))(a2);
  if ( !descriptor )
  {
    google::protobuf::internal::LogMessage::LogMessage(v99, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6104);
    v68 = google::protobuf::internal::LogMessage::operator<<(v99, "CHECK failed: options_descriptor: ");
    google::protobuf::internal::LogFinisher::operator=((google::protobuf::internal::LogFinisher *const)&v98, v68);
    google::protobuf::internal::LogMessage::~LogMessage(v99);
  }
  FieldByName = 0LL;
  __rhs._M_dataplus._M_p = __rhs._anon_0._M_local_buf;
  memset(&v87, 0, sizeof(v87));
  std::string::_M_construct<char const*>(&__rhs, &off_1B23A528[4], &off_1B23A528[4], v11);
  v13 = this->uninterpreted_option_;
  v14 = 0;
  if ( v13->name_.current_size_ > 0 )
  {
    while ( 1 )
    {
      v27 = (const std::string *)*((_QWORD *)v13->name_.rep_->elements[v14] + 3);
      if ( __rhs._M_string_length )
      {
        if ( __rhs._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
          std::__throw_length_error("basic_string::append");
        std::string::_M_append(&__rhs, ".", 1LL);
        v13 = this->uninterpreted_option_;
      }
      if ( *((_BYTE *)v13->name_.rep_->elements[v14] + 32) )
      {
        std::operator+<char>(&v98, "(", v27);
        if ( v98._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
          std::__throw_length_error("basic_string::append");
        v15 = std::string::_M_append(&v98, ")", 1LL);
        *(_QWORD *)&v99[0].level_ = &v99[0].line_;
        if ( *(_QWORD *)v15 == v15 + 16 )
        {
          *(__m128i *)&v99[0].line_ = _mm_loadu_si128((const __m128i *)(v15 + 16));
        }
        else
        {
          *(_QWORD *)&v99[0].level_ = *(_QWORD *)v15;
          *(_QWORD *)&v99[0].line_ = *(_QWORD *)(v15 + 16);
        }
        v99[0].filename_ = *(const char **)(v15 + 8);
        *(_QWORD *)v15 = v15 + 16;
        *(_BYTE *)(v15 + 16) = 0;
        v16 = *(const char **)&v99[0].level_;
        *(_QWORD *)(v15 + 8) = 0LL;
        std::string::_M_append(&__rhs, v16, v99[0].filename_);
        if ( *(google::protobuf::internal::LogMessage_0 **)&v99[0].level_ != (google::protobuf::internal::LogMessage_0 *)&v99[0].line_ )
          operator delete(*(void **)&v99[0].level_);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v98._M_dataplus._M_p != &v98._anon_0 )
          operator delete(v98._M_dataplus._M_p);
        v17 = google::protobuf::DescriptorBuilder::LookupSymbol(
                this->builder_,
                v27,
                &this->options_to_interpret_->name_scope,
                PLACEHOLDER_MESSAGE,
                LOOKUP_ALL,
                1);
        if ( v17.type == FIELD )
        {
          FieldByName = (google::protobuf::FieldDescriptor *)v17._anon_0.descriptor;
          v19 = (int *)v17._anon_0.descriptor;
        }
        else
        {
          v19 = (int *)FieldByName;
        }
      }
      else
      {
        std::string::_M_append(&__rhs, v27->_M_dataplus._M_p, v27->_M_string_length);
        FieldByName = (google::protobuf::FieldDescriptor *)google::protobuf::Descriptor::FindFieldByName(
                                                             descriptor,
                                                             v27);
        v19 = (int *)FieldByName;
      }
      if ( !v19 )
        break;
      v20 = (const google::protobuf::Descriptor *)*((_QWORD *)v19 + 10);
      if ( v20 != descriptor )
      {
        is_placeholder = v20->is_placeholder_;
        if ( !(_BYTE)is_placeholder )
        {
          name = descriptor->name_;
          std::operator+<char>(&v96, "Option field \"", &__rhs);
          if ( 0x3FFFFFFFFFFFFFFFLL - v96._M_string_length <= 0x29 )
            std::__throw_length_error("basic_string::append");
          v62 = std::string::_M_append(&v96, "\" is not a field or extension of message \"", 42LL);
          v97._M_dataplus._M_p = v97._anon_0._M_local_buf;
          if ( *(_QWORD *)v62 == v62 + 16 )
          {
            v97._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v62 + 16));
          }
          else
          {
            v97._M_dataplus._M_p = *(std::string::pointer *)v62;
            v97._anon_0._M_allocated_capacity = *(_QWORD *)(v62 + 16);
          }
          v97._M_string_length = *(_QWORD *)(v62 + 8);
          *(_QWORD *)v62 = v62 + 16;
          *(_BYTE *)(v62 + 16) = 0;
          M_p = name->_M_dataplus._M_p;
          *(_QWORD *)(v62 + 8) = 0LL;
          v64 = std::string::_M_append(&v97, M_p, name->_M_string_length);
          v98._M_dataplus._M_p = v98._anon_0._M_local_buf;
          if ( *(_QWORD *)v64 == v64 + 16 )
          {
            v98._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v64 + 16));
          }
          else
          {
            v98._M_dataplus._M_p = *(std::string::pointer *)v64;
            v98._anon_0._M_allocated_capacity = *(_QWORD *)(v64 + 16);
          }
          v98._M_string_length = *(_QWORD *)(v64 + 8);
          *(_QWORD *)(v64 + 8) = 0LL;
          *(_BYTE *)(v64 + 16) = 0;
          *(_QWORD *)v64 = v64 + 16;
          if ( v98._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v98._M_string_length == 4611686018427387902LL )
            std::__throw_length_error("basic_string::append");
          v65 = std::string::_M_append(&v98, "\".", 2LL);
          *(_QWORD *)&v99[0].level_ = &v99[0].line_;
          if ( *(_QWORD *)v65 == v65 + 16 )
          {
            *(__m128i *)&v99[0].line_ = _mm_loadu_si128((const __m128i *)(v65 + 16));
          }
          else
          {
            *(_QWORD *)&v99[0].level_ = *(_QWORD *)v65;
            *(_QWORD *)&v99[0].line_ = *(_QWORD *)(v65 + 16);
          }
          v99[0].filename_ = *(const char **)(v65 + 8);
          *(_BYTE *)(v65 + 16) = 0;
          v66 = this->builder_;
          *(_QWORD *)v65 = v65 + 16;
          v67 = this->uninterpreted_option_;
          *(_QWORD *)(v65 + 8) = 0LL;
          google::protobuf::DescriptorBuilder::AddError(
            (__int64)v66,
            &this->options_to_interpret_->element_name,
            (__int64)v67,
            7u,
            (const std::string *)v99);
          if ( *(google::protobuf::internal::LogMessage_0 **)&v99[0].level_ != (google::protobuf::internal::LogMessage_0 *)&v99[0].line_ )
            operator delete(*(void **)&v99[0].level_);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v98._M_dataplus._M_p != &v98._anon_0 )
            operator delete(v98._M_dataplus._M_p);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v97._M_dataplus._M_p != &v97._anon_0 )
            operator delete(v97._M_dataplus._M_p);
          v60 = v96._M_dataplus._M_p;
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v96._M_dataplus._M_p == &v96._anon_0 )
            goto LABEL_77;
          goto LABEL_134;
        }
        goto LABEL_143;
      }
      v13 = this->uninterpreted_option_;
      current_size = v13->name_.current_size_;
      v22 = (const google::protobuf::FieldDescriptor *const *)(unsigned int)(current_size - 1);
      if ( (int)v22 > v14 )
      {
        v23 = (google::protobuf::ProtobufOnceType *)*((_QWORD *)v19 + 6);
        if ( v23 && *v23 != 2 )
        {
          LOBYTE(v99[0].line_) = 0;
          v99[0].message_._M_dataplus._M_p = (std::string::pointer)v19;
          *(_QWORD *)&v99[0].level_ = &off_1A17BF90;
          v99[0].filename_ = (const char *)google::protobuf::FieldDescriptor::TypeOnceInit;
          google::protobuf::GoogleOnceInitImpl(v23, (google::protobuf::Closure *)v99);
          *(_QWORD *)&v99[0].level_ = &off_1A17BF90;
          google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v99);
        }
        if ( google::protobuf::FieldDescriptor::kTypeToCppTypeMap[v19[14]] != CPPTYPE_MESSAGE_0 )
        {
          std::operator+<char>(&v98, "Option \"", &__rhs);
          if ( 0x3FFFFFFFFFFFFFFFLL - v98._M_string_length <= 0x22 )
            std::__throw_length_error("basic_string::append");
          v72 = std::string::_M_append(&v98, "\" is an atomic type, not a message.", 35LL);
          *(_QWORD *)&v99[0].level_ = &v99[0].line_;
          if ( *(_QWORD *)v72 != v72 + 16 )
          {
            *(_QWORD *)&v99[0].level_ = *(_QWORD *)v72;
            *(_QWORD *)&v99[0].line_ = *(_QWORD *)(v72 + 16);
LABEL_147:
            v99[0].filename_ = *(const char **)(v72 + 8);
            *(_BYTE *)(v72 + 16) = 0;
            v73 = this->builder_;
            *(_QWORD *)v72 = v72 + 16;
            v74 = this->uninterpreted_option_;
            *(_QWORD *)(v72 + 8) = 0LL;
            google::protobuf::DescriptorBuilder::AddError(
              (__int64)v73,
              &this->options_to_interpret_->element_name,
              (__int64)v74,
              7u,
              (const std::string *)v99);
            if ( *(google::protobuf::internal::LogMessage_0 **)&v99[0].level_ != (google::protobuf::internal::LogMessage_0 *)&v99[0].line_ )
              operator delete(*(void **)&v99[0].level_);
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v98._M_dataplus._M_p != &v98._anon_0 )
              operator delete(v98._M_dataplus._M_p);
            is_placeholder = 0;
            goto LABEL_77;
          }
LABEL_168:
          *(__m128i *)&v99[0].line_ = _mm_loadu_si128((const __m128i *)(v72 + 16));
          goto LABEL_147;
        }
        if ( FieldByName->label_ == LABEL_REPEATED )
        {
          std::operator+<char>(&v98, "Option field \"", &__rhs);
          if ( 0x3FFFFFFFFFFFFFFFLL - v98._M_string_length <= 0x5E )
            std::__throw_length_error("basic_string::append");
          v72 = std::string::_M_append(
                  &v98,
                  "\" is a repeated message. Repeated message options must be initialized using an aggregate value.",
                  95LL);
          *(_QWORD *)&v99[0].level_ = &v99[0].line_;
          if ( *(_QWORD *)v72 != v72 + 16 )
          {
            *(_QWORD *)&v99[0].level_ = *(_QWORD *)v72;
            *(_QWORD *)&v99[0].line_ = *(_QWORD *)(v72 + 16);
            goto LABEL_147;
          }
          goto LABEL_168;
        }
        M_finish = v87._M_impl._M_finish;
        if ( v87._M_impl._M_finish == v87._M_impl._M_end_of_storage )
        {
          std::vector<google::protobuf::FieldDescriptor const*>::_M_realloc_insert<google::protobuf::FieldDescriptor const* const&>(
            &v87,
            (std::vector<const google::protobuf::FieldDescriptor*>::iterator)v87._M_impl._M_finish,
            (const google::protobuf::FieldDescriptor *const *)&FieldByName,
            v22);
        }
        else
        {
          *v87._M_impl._M_finish = FieldByName;
          v87._M_impl._M_finish = M_finish + 1;
        }
        v25 = FieldByName;
        type_once = FieldByName->type_once_;
        if ( type_once && type_once->state_ != 2 )
        {
          LOBYTE(v99[0].line_) = 0;
          v99[0].message_._M_dataplus._M_p = (std::string::pointer)FieldByName;
          *(_QWORD *)&v99[0].level_ = &off_1A17BF90;
          v99[0].filename_ = (const char *)google::protobuf::FieldDescriptor::TypeOnceInit;
          google::protobuf::GoogleOnceInitImpl(&type_once->state_, (google::protobuf::Closure *)v99);
          *(_QWORD *)&v99[0].level_ = &off_1A17BF90;
          google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v99);
        }
        v13 = this->uninterpreted_option_;
        descriptor = v25->message_type_;
        current_size = v13->name_.current_size_;
      }
      if ( ++v14 >= current_size )
        goto LABEL_47;
    }
    is_placeholder = this->builder_->pool_->allow_unknown_;
    if ( !(_BYTE)is_placeholder )
    {
      if ( this->builder_->undefine_resolved_name_._M_string_length )
      {
        if ( !__rhs._M_string_length )
          std::__throw_out_of_range_fmt(
            "%s: __pos (which is %zu) > this->size() (which is %zu)",
            "basic_string::substr",
            1uLL,
            0LL);
        v97._M_dataplus._M_p = v97._anon_0._M_local_buf;
        std::string::_M_construct<char const*>(
          &v97,
          (const char *)__rhs._M_dataplus._M_p + 1,
          &__rhs._M_dataplus._M_p[__rhs._M_string_length],
          v18);
        v47 = this->builder_;
        std::operator+<char>(&v89, "Option \"", &__rhs);
        if ( 0x3FFFFFFFFFFFFFFFLL - v89._M_string_length <= 0x12 )
          std::__throw_length_error("basic_string::append");
        v48 = (__m128i *)std::string::_M_append(&v89, "\" is resolved to \"(", 19LL);
        *(_QWORD *)v90[0].gap0 = &v92;
        if ( (__m128i *)v48->m128i_i64[0] == &v48[1] )
        {
          v92 = _mm_loadu_si128(v48 + 1);
        }
        else
        {
          *(_QWORD *)v90[0].gap0 = v48->m128i_i64[0];
          v92.m128i_i64[0] = v48[1].m128i_i64[0];
        }
        v91 = v48->m128i_i64[1];
        v48->m128i_i64[0] = (__int64)v48[1].m128i_i64;
        v48[1].m128i_i8[0] = 0;
        v49 = v47->undefine_resolved_name_._M_dataplus._M_p;
        v48->m128i_i64[1] = 0LL;
        v50 = std::string::_M_append(v90, v49, v47->undefine_resolved_name_._M_string_length);
        unknown_fields = (google::protobuf::UnknownFieldSet *)&v95;
        if ( *(_QWORD *)v50 == v50 + 16 )
        {
          v95 = _mm_loadu_si128((const __m128i *)(v50 + 16));
        }
        else
        {
          unknown_fields = *(google::protobuf::UnknownFieldSet **)v50;
          v95.m128i_i64[0] = *(_QWORD *)(v50 + 16);
        }
        v94 = *(_QWORD *)(v50 + 8);
        *(_QWORD *)(v50 + 8) = 0LL;
        *(_BYTE *)(v50 + 16) = 0;
        *(_QWORD *)v50 = v50 + 16;
        if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v94) <= 0x79 )
          std::__throw_length_error("basic_string::append");
        v51 = std::string::_M_append(
                &unknown_fields,
                ")\", which is not defined. The innermost scope is searched first in name resolution. Consider using a le"
                "ading '.'(i.e., \"(.",
                122LL);
        v96._M_dataplus._M_p = v96._anon_0._M_local_buf;
        if ( *(_QWORD *)v51 == v51 + 16 )
        {
          v96._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v51 + 16));
        }
        else
        {
          v96._M_dataplus._M_p = *(std::string::pointer *)v51;
          v96._anon_0._M_allocated_capacity = *(_QWORD *)(v51 + 16);
        }
        v96._M_string_length = *(_QWORD *)(v51 + 8);
        *(_BYTE *)(v51 + 16) = 0;
        *(_QWORD *)v51 = v51 + 16;
        v52 = (std::string *)v96._M_dataplus._M_p;
        *(_QWORD *)(v51 + 8) = 0LL;
        v53 = 15LL;
        M_allocated_capacity = 15LL;
        if ( v52 != (std::string *)&v96._anon_0 )
          M_allocated_capacity = v96._anon_0._M_allocated_capacity;
        v55 = v96._M_string_length + v97._M_string_length;
        if ( v96._M_string_length + v97._M_string_length <= M_allocated_capacity )
          goto LABEL_98;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v97._M_dataplus._M_p != &v97._anon_0 )
          v53 = v97._anon_0._M_allocated_capacity;
        if ( v55 <= v53 )
          v56 = std::string::_M_replace(&v97, 0LL, 0LL, (const char *)v52, v96._M_string_length);
        else
LABEL_98:
          v56 = std::string::_M_append(&v96, v97._M_dataplus._M_p, v97._M_string_length, v55, v96._M_string_length);
        v98._M_dataplus._M_p = v98._anon_0._M_local_buf;
        if ( *(_QWORD *)v56 == v56 + 16 )
        {
          v98._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v56 + 16));
        }
        else
        {
          v98._M_dataplus._M_p = *(std::string::pointer *)v56;
          v98._anon_0._M_allocated_capacity = *(_QWORD *)(v56 + 16);
        }
        v98._M_string_length = *(_QWORD *)(v56 + 8);
        *(_QWORD *)(v56 + 8) = 0LL;
        *(_BYTE *)(v56 + 16) = 0;
        *(_QWORD *)v56 = v56 + 16;
        if ( 0x3FFFFFFFFFFFFFFFLL - v98._M_string_length <= 0x24 )
          std::__throw_length_error("basic_string::append");
        v57 = std::string::_M_append(&v98, "\") to start from the outermost scope.", 37LL);
        *(_QWORD *)&v99[0].level_ = &v99[0].line_;
        if ( *(_QWORD *)v57 == v57 + 16 )
        {
          *(__m128i *)&v99[0].line_ = _mm_loadu_si128((const __m128i *)(v57 + 16));
        }
        else
        {
          *(_QWORD *)&v99[0].level_ = *(_QWORD *)v57;
          *(_QWORD *)&v99[0].line_ = *(_QWORD *)(v57 + 16);
        }
        v99[0].filename_ = *(const char **)(v57 + 8);
        *(_BYTE *)(v57 + 16) = 0;
        v58 = this->builder_;
        *(_QWORD *)v57 = v57 + 16;
        v59 = this->uninterpreted_option_;
        *(_QWORD *)(v57 + 8) = 0LL;
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)v58,
          &this->options_to_interpret_->element_name,
          (__int64)v59,
          7u,
          (const std::string *)v99);
        if ( *(google::protobuf::internal::LogMessage_0 **)&v99[0].level_ != (google::protobuf::internal::LogMessage_0 *)&v99[0].line_ )
          operator delete(*(void **)&v99[0].level_);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v98._M_dataplus._M_p != &v98._anon_0 )
          operator delete(v98._M_dataplus._M_p);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v96._M_dataplus._M_p != &v96._anon_0 )
          operator delete(v96._M_dataplus._M_p);
        if ( unknown_fields != (google::protobuf::UnknownFieldSet *)&v95 )
          operator delete(unknown_fields);
        if ( *(__m128i **)v90[0].gap0 != &v92 )
          operator delete(*(void **)v90[0].gap0);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v89._M_dataplus._M_p != &v89._anon_0 )
          operator delete(v89._M_dataplus._M_p);
        v60 = v97._M_dataplus._M_p;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v97._M_dataplus._M_p == &v97._anon_0 )
          goto LABEL_77;
      }
      else
      {
        std::operator+<char>(&v98, "Option \"", &__rhs);
        if ( 0x3FFFFFFFFFFFFFFFLL - v98._M_string_length <= 9 )
          std::__throw_length_error("basic_string::append");
        v69 = std::string::_M_append(&v98, "\" unknown.", 10LL);
        *(_QWORD *)&v99[0].level_ = &v99[0].line_;
        if ( *(_QWORD *)v69 == v69 + 16 )
        {
          *(__m128i *)&v99[0].line_ = _mm_loadu_si128((const __m128i *)(v69 + 16));
        }
        else
        {
          *(_QWORD *)&v99[0].level_ = *(_QWORD *)v69;
          *(_QWORD *)&v99[0].line_ = *(_QWORD *)(v69 + 16);
        }
        v99[0].filename_ = *(const char **)(v69 + 8);
        *(_BYTE *)(v69 + 16) = 0;
        v70 = this->builder_;
        *(_QWORD *)v69 = v69 + 16;
        v71 = this->uninterpreted_option_;
        *(_QWORD *)(v69 + 8) = 0LL;
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)v70,
          &this->options_to_interpret_->element_name,
          (__int64)v71,
          7u,
          (const std::string *)v99);
        if ( *(google::protobuf::internal::LogMessage_0 **)&v99[0].level_ != (google::protobuf::internal::LogMessage_0 *)&v99[0].line_ )
          operator delete(*(void **)&v99[0].level_);
        v60 = v98._M_dataplus._M_p;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v98._M_dataplus._M_p == &v98._anon_0 )
          goto LABEL_77;
      }
LABEL_134:
      operator delete(v60);
      goto LABEL_77;
    }
LABEL_143:
    google::protobuf::DescriptorBuilder::OptionInterpreter::AddWithoutInterpreting(
      this,
      this->uninterpreted_option_,
      a2);
    is_placeholder = 1;
    goto LABEL_77;
  }
LABEL_47:
  if ( FieldByName->label_ != LABEL_REPEATED )
  {
    v28 = (const google::protobuf::Message::Reflection *(__fastcall *)(const google::protobuf::Message *const))*((_QWORD *)a2->_vptr_MessageLite + 23);
    if ( v28 == google::protobuf::Message::GetReflection )
    {
      (*((void (__fastcall **)(google::protobuf::Message *))a2->_vptr_MessageLite + 24))(a2);
      v30 = v29;
    }
    else
    {
      v30 = (__int64)v28(a2);
    }
    v31 = (*(__int64 (__fastcall **)(__int64, google::protobuf::Message *))(*(_QWORD *)v30 + 16LL))(v30, a2);
    is_placeholder = google::protobuf::DescriptorBuilder::OptionInterpreter::ExamineIfOptionIsSet(
                       (_DWORD)this,
                       v87._M_impl._M_start,
                       v87._M_impl._M_finish,
                       (_DWORD)FieldByName,
                       (unsigned int)&__rhs,
                       v31);
    if ( !(_BYTE)is_placeholder )
      goto LABEL_77;
  }
  v32 = (google::protobuf::UnknownFieldSet *)operator new(8uLL);
  v32->fields_ = 0LL;
  unknown_fields = v32;
  is_placeholder = google::protobuf::DescriptorBuilder::OptionInterpreter::SetOptionValue(this, FieldByName, v32);
  if ( !(_BYTE)is_placeholder )
    goto LABEL_73;
  v33 = v87._M_impl._M_finish;
  if ( v87._M_impl._M_start == v87._M_impl._M_finish )
  {
LABEL_70:
    v42 = (const google::protobuf::Message::Reflection *(__fastcall *)(const google::protobuf::Message *const))*((_QWORD *)a2->_vptr_MessageLite + 23);
    if ( v42 == google::protobuf::Message::GetReflection )
    {
      (*((void (__fastcall **)(google::protobuf::Message *))a2->_vptr_MessageLite + 24))(a2);
      v44 = v43;
    }
    else
    {
      v44 = (__int64)v42(a2);
    }
    v45 = (google::protobuf::UnknownFieldSet *)(*(__int64 (__fastcall **)(__int64, google::protobuf::Message *))(*(_QWORD *)v44 + 24LL))(
                                                 v44,
                                                 a2);
    google::protobuf::UnknownFieldSet::MergeFrom(v45, unknown_fields);
    goto LABEL_73;
  }
  while ( 1 )
  {
    v34 = (char *)operator new(8uLL);
    v35 = (__int64)*(v33 - 1);
    *(_QWORD *)v34 = 0LL;
    v96._M_dataplus._M_p = v34;
    v36 = *(google::protobuf::ProtobufOnceType **)(v35 + 48);
    if ( v36 && *v36 != 2 )
    {
      LOBYTE(v99[0].line_) = 0;
      *(_QWORD *)&v99[0].level_ = &off_1A17BF90;
      v99[0].filename_ = (const char *)google::protobuf::FieldDescriptor::TypeOnceInit;
      v99[0].message_._M_dataplus._M_p = (std::string::pointer)v35;
      google::protobuf::GoogleOnceInitImpl(v36, (google::protobuf::Closure *)v99);
      *(_QWORD *)&v99[0].level_ = &off_1A17BF90;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)v99);
    }
    v37 = *(_DWORD *)(v35 + 56);
    if ( v37 != 10 )
      break;
    v81 = google::protobuf::UnknownFieldSet::AddGroup(
            (google::protobuf::UnknownFieldSet *const)v96._M_dataplus._M_p,
            (*(v33 - 1))->number_);
    google::protobuf::UnknownFieldSet::MergeFrom(v81, unknown_fields);
LABEL_61:
    v39 = (google::protobuf::UnknownFieldSet *)v96._M_dataplus._M_p;
    v40 = unknown_fields;
    v96._M_dataplus._M_p = 0LL;
    if ( v39 != unknown_fields )
    {
      if ( unknown_fields )
      {
        if ( unknown_fields->fields_ )
          google::protobuf::UnknownFieldSet::ClearFallback(unknown_fields);
        operator delete(v40, 8uLL);
        v41 = v96._M_dataplus._M_p;
        unknown_fields = v39;
        if ( v96._M_dataplus._M_p )
        {
          if ( *(_QWORD *)v96._M_dataplus._M_p )
            google::protobuf::UnknownFieldSet::ClearFallback((google::protobuf::UnknownFieldSet *const)v96._M_dataplus._M_p);
          operator delete(v41, 8uLL);
        }
      }
      else
      {
        unknown_fields = v39;
      }
    }
    if ( v87._M_impl._M_start == --v33 )
      goto LABEL_70;
  }
  if ( v37 == 11 )
  {
    v38 = google::protobuf::UnknownFieldSet::AddLengthDelimited[abi:cxx11](
            (google::protobuf::UnknownFieldSet *const)v96._M_dataplus._M_p,
            (*(v33 - 1))->number_);
    google::protobuf::io::StringOutputStream::StringOutputStream(
      (google::protobuf::io::StringOutputStream *const)&v97,
      v38);
    google::protobuf::io::CodedOutputStream::CodedOutputStream(
      (google::protobuf::io::CodedOutputStream *const)&v98,
      (google::protobuf::io::ZeroCopyOutputStream *)&v97);
    google::protobuf::internal::WireFormat::SerializeUnknownFields(
      unknown_fields,
      (google::protobuf::io::CodedOutputStream *)&v98);
    if ( v98._anon_0._M_local_buf[8] )
    {
      google::protobuf::internal::LogMessage::LogMessage(v99, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6233);
      v82 = google::protobuf::internal::LogMessage::operator<<(v99, "CHECK failed: !out.HadError(): ");
      v83 = google::protobuf::internal::LogMessage::operator<<(
              v82,
              "Unexpected failure while serializing option submessage ");
      v84 = google::protobuf::internal::LogMessage::operator<<(v83, &__rhs);
      v85 = google::protobuf::internal::LogMessage::operator<<(v84, "\".");
      google::protobuf::internal::LogFinisher::operator=(v90, v85);
      google::protobuf::internal::LogMessage::~LogMessage(v99);
    }
    google::protobuf::io::CodedOutputStream::~CodedOutputStream((google::protobuf::io::CodedOutputStream *const)&v98);
    goto LABEL_61;
  }
  google::protobuf::internal::LogMessage::LogMessage(v99, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6246);
  v75 = google::protobuf::internal::LogMessage::operator<<(v99, "Invalid wire type for CPPTYPE_MESSAGE: ");
  v76 = (std::string::size_type)*(v33 - 1);
  v77 = v75;
  v78 = *(google::protobuf::ProtobufOnceType **)(v76 + 48);
  if ( v78 && *v78 != 2 )
  {
    v98._anon_0._M_local_buf[0] = 0;
    *(&v98._anon_0._M_allocated_capacity + 1) = v76;
    v98._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    v98._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
    google::protobuf::GoogleOnceInitImpl(v78, (google::protobuf::Closure *)&v98);
    v98._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&v98);
  }
  v79 = google::protobuf::internal::LogMessage::operator<<(v77, *(_DWORD *)(v76 + 56));
  google::protobuf::internal::LogFinisher::operator=((google::protobuf::internal::LogFinisher *const)&v98, v79);
  google::protobuf::internal::LogMessage::~LogMessage(v99);
  v80 = v96._M_dataplus._M_p;
  if ( v96._M_dataplus._M_p )
  {
    if ( *(_QWORD *)v96._M_dataplus._M_p )
      google::protobuf::UnknownFieldSet::ClearFallback((google::protobuf::UnknownFieldSet *const)v96._M_dataplus._M_p);
    operator delete(v80, 8uLL);
  }
  is_placeholder = 0;
LABEL_73:
  v46 = unknown_fields;
  if ( unknown_fields )
  {
    if ( unknown_fields->fields_ )
      google::protobuf::UnknownFieldSet::ClearFallback(unknown_fields);
    operator delete(v46, 8uLL);
  }
LABEL_77:
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__rhs._M_dataplus._M_p != &__rhs._anon_0 )
    operator delete(__rhs._M_dataplus._M_p);
  if ( v87._M_impl._M_start )
    operator delete(v87._M_impl._M_start);
  return is_placeholder;
};

// Line 6262: range 000000000C8FA350-000000000C8FA467
__int64 __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::AddWithoutInterpreting(
        google::protobuf::DescriptorBuilder::OptionInterpreter *this,
        const google::protobuf::UninterpretedOption *a2,
        google::protobuf::Message *a3)
{
  const google::protobuf::Descriptor *v5; // r13
  std::forward_iterator_tag v6; // cl
  const google::protobuf::FieldDescriptor *FieldByName; // r13
  const google::protobuf::Message::Reflection *(__fastcall *v8)(const google::protobuf::Message *const); // rdx
  __int64 v9; // rdx
  __int64 v10; // rdi
  __int64 v11; // rax
  google::protobuf::internal::LogMessage_0 *v13; // rsi
  google::protobuf::internal::LogFinisher v14; // [rsp+Fh] [rbp-69h] BYREF
  google::protobuf::internal::LogMessage_0 key; // [rsp+10h] [rbp-68h] BYREF

  v5 = (const google::protobuf::Descriptor *)(*((__int64 (__fastcall **)(google::protobuf::Message *))a3->_vptr_MessageLite
                                              + 24))(a3);
  *(_QWORD *)&key.level_ = &key.line_;
  std::string::_M_construct<char const*>((std::string *const)&key, "uninterpreted_option", "", v6);
  FieldByName = google::protobuf::Descriptor::FindFieldByName(v5, (const std::string *)&key);
  if ( *(google::protobuf::internal::LogMessage_0 **)&key.level_ != (google::protobuf::internal::LogMessage_0 *)&key.line_ )
    operator delete(*(void **)&key.level_);
  if ( !FieldByName )
  {
    google::protobuf::internal::LogMessage::LogMessage(&key, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6265);
    v13 = google::protobuf::internal::LogMessage::operator<<(&key, "CHECK failed: field != NULL: ");
    google::protobuf::internal::LogFinisher::operator=(&v14, v13);
    google::protobuf::internal::LogMessage::~LogMessage(&key);
  }
  v8 = (const google::protobuf::Message::Reflection *(__fastcall *)(const google::protobuf::Message *const))*((_QWORD *)a3->_vptr_MessageLite + 23);
  if ( v8 == google::protobuf::Message::GetReflection )
  {
    (*((void (__fastcall **)(google::protobuf::Message *))a3->_vptr_MessageLite + 24))(a3);
    v10 = v9;
  }
  else
  {
    v10 = (__int64)v8(a3);
  }
  v11 = (*(__int64 (__fastcall **)(__int64, google::protobuf::Message *, const google::protobuf::FieldDescriptor *, _QWORD))(*(_QWORD *)v10 + 600LL))(
          v10,
          a3,
          FieldByName,
          0LL);
  return (*(__int64 (__fastcall **)(__int64, const google::protobuf::UninterpretedOption *))(*(_QWORD *)v11 + 144LL))(
           v11,
           a2);
};

// Line 6265: range 000000000C72DD58-000000000C72DD65
void __fastcall __noreturn google::protobuf::DescriptorBuilder::OptionInterpreter::AddWithoutInterpreting(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 6276: range 000000000C8F72F0-000000000C8F7669
__int64 __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::ExamineIfOptionIsSet(
        __int64 *a1,
        __int64 *a2,
        __int64 *a3,
        __int64 a4,
        const std::string *a5,
        int ***a6)
{
  int **v9; // rdx
  __int64 v10; // rbp
  __int64 v11; // r12
  __int64 v12; // rbx
  __int64 result; // rax
  google::protobuf::ProtobufOnceType *v14; // rdi
  int v15; // r12d
  google::protobuf::internal::LogMessage_0 *v16; // rax
  google::protobuf::internal::LogMessage_0 *v17; // rax
  int *v18; // rax
  int *v19; // rsi
  int v20; // edx
  __int64 v21; // rsi
  int v22; // ecx
  __int64 v23; // rax
  __int64 v24; // rax
  int v26; // [rsp+10h] [rbp-B8h]
  int __rhs; // [rsp+18h] [rbp-B0h]
  int v28; // [rsp+20h] [rbp-A8h]
  int v29; // [rsp+28h] [rbp-A0h]
  std::string v30; // [rsp+30h] [rbp-98h] BYREF
  google::protobuf::internal::LogMessage_0 closure[2]; // [rsp+50h] [rbp-78h] BYREF

  v28 = (int)a3;
  v9 = *a6;
  v26 = (int)a1;
  __rhs = (int)a5;
  if ( a2 == a3 )
  {
    if ( v9 )
    {
      v18 = *v9;
      v19 = v9[1];
      v20 = 0;
      v21 = ((char *)v19 - (char *)v18) >> 4;
      while ( (int)v21 > v20 )
      {
        v22 = *v18;
        v18 += 4;
        if ( v22 == *(_DWORD *)(a4 + 68) )
        {
          std::operator+<char>(&v30, "Option \"", a5);
          if ( 0x3FFFFFFFFFFFFFFFLL - v30._M_string_length <= 0x11 )
            std::__throw_length_error("basic_string::append");
          v23 = std::string::_M_append(&v30, "\" was already set.", 18LL);
          *(_QWORD *)&closure[0].level_ = &closure[0].line_;
          if ( *(_QWORD *)v23 == v23 + 16 )
          {
            *(__m128i *)&closure[0].line_ = _mm_loadu_si128((const __m128i *)(v23 + 16));
          }
          else
          {
            *(_QWORD *)&closure[0].level_ = *(_QWORD *)v23;
            *(_QWORD *)&closure[0].line_ = *(_QWORD *)(v23 + 16);
          }
          closure[0].filename_ = *(const char **)(v23 + 8);
          *(_QWORD *)v23 = v23 + 16;
          *(_QWORD *)(v23 + 8) = 0LL;
          *(_BYTE *)(v23 + 16) = 0;
          google::protobuf::DescriptorBuilder::AddError(
            *a1,
            (const std::string *)(a1[1] + 32),
            a1[2],
            7u,
            (const std::string *)closure);
          if ( *(google::protobuf::internal::LogMessage_0 **)&closure[0].level_ != (google::protobuf::internal::LogMessage_0 *)&closure[0].line_ )
            operator delete(*(void **)&closure[0].level_);
          if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v30._M_dataplus._M_p == &v30._anon_0 )
            return 0LL;
          operator delete(v30._M_dataplus._M_p);
          return 0LL;
        }
        ++v20;
      }
    }
  }
  else if ( v9 )
  {
    v10 = 0LL;
    v29 = (_DWORD)a2 + 8;
    do
    {
      if ( (int)v10 >= (int)(((char *)v9[1] - (char *)*v9) >> 4) )
        return 1LL;
      v11 = *a2;
      v12 = (__int64)&(*v9)[4 * v10];
      if ( *(_DWORD *)(*a2 + 68) == *(_DWORD *)v12 )
      {
        v14 = *(google::protobuf::ProtobufOnceType **)(v11 + 48);
        if ( v14 && *v14 != 2 )
        {
          LOBYTE(closure[0].line_) = 0;
          closure[0].message_._M_dataplus._M_p = (std::string::pointer)v11;
          *(_QWORD *)&closure[0].level_ = &off_1A17BF90;
          closure[0].filename_ = (const char *)google::protobuf::FieldDescriptor::TypeOnceInit;
          google::protobuf::GoogleOnceInitImpl(v14, (google::protobuf::Closure *)closure);
          *(_QWORD *)&closure[0].level_ = &off_1A17BF90;
          google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
        }
        v15 = *(_DWORD *)(v11 + 56);
        if ( v15 == 10 )
        {
          if ( *(_DWORD *)(v12 + 4) == 4 )
          {
            result = google::protobuf::DescriptorBuilder::OptionInterpreter::ExamineIfOptionIsSet(
                       v26,
                       v29,
                       v28,
                       a4,
                       __rhs,
                       *(_QWORD *)(v12 + 8));
            if ( !(_BYTE)result )
              return result;
          }
        }
        else
        {
          if ( v15 != 11 )
          {
            google::protobuf::internal::LogMessage::LogMessage(
              closure,
              LOGLEVEL_FATAL_0,
              "google/protobuf/descriptor.cc",
              6325);
            v16 = google::protobuf::internal::LogMessage::operator<<(closure, "Invalid wire type for CPPTYPE_MESSAGE: ");
            v17 = google::protobuf::internal::LogMessage::operator<<(v16, v15);
            google::protobuf::internal::LogFinisher::operator=(
              (google::protobuf::internal::LogFinisher *const)&v30,
              v17);
            google::protobuf::internal::LogMessage::~LogMessage(closure);
            return 0LL;
          }
          if ( *(_DWORD *)(v12 + 4) == 3 )
          {
            v24 = *(_QWORD *)(v12 + 8);
            *(_QWORD *)&closure[0].level_ = 0LL;
            if ( google::protobuf::UnknownFieldSet::ParseFromArray(
                   (google::protobuf::UnknownFieldSet *const)closure,
                   *(const void **)v24,
                   *(_DWORD *)(v24 + 8)) )
            {
              result = google::protobuf::DescriptorBuilder::OptionInterpreter::ExamineIfOptionIsSet(
                         v26,
                         v29,
                         v28,
                         a4,
                         __rhs,
                         (unsigned int)closure);
              if ( !(_BYTE)result )
              {
                if ( *(_QWORD *)&closure[0].level_ )
                {
                  google::protobuf::UnknownFieldSet::ClearFallback((google::protobuf::UnknownFieldSet *const)closure);
                  return 0LL;
                }
                return result;
              }
            }
            if ( *(_QWORD *)&closure[0].level_ )
            {
              google::protobuf::UnknownFieldSet::ClearFallback((google::protobuf::UnknownFieldSet *const)closure);
              v9 = *a6;
              goto LABEL_6;
            }
          }
        }
        v9 = *a6;
      }
LABEL_6:
      ++v10;
    }
    while ( v9 );
  }
  return 1LL;
};

// Line 6335: range 000000000C90E0D0-000000000C90FE55
__int64 __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::SetOptionValue(
        google::protobuf::DescriptorBuilder::OptionInterpreter *this,
        const google::protobuf::FieldDescriptor *a2,
        google::protobuf::UnknownFieldSet *a3)
{
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  google::protobuf::FieldDescriptor::Type type; // ecx
  unsigned int v7; // r14d
  const google::protobuf::UninterpretedOption *v9; // rax
  google::protobuf::uint32 v10; // edx
  signed __int64 v11; // rdx
  google::protobuf::GoogleOnceDynamic *v12; // rdi
  const google::protobuf::UninterpretedOption *v13; // rax
  google::protobuf::uint32 v14; // edx
  google::protobuf::GoogleOnceDynamic *v15; // rdi
  __int64 negative_int_value; // rdx
  const google::protobuf::UninterpretedOption *v17; // rax
  google::protobuf::uint64 v18; // rdx
  google::protobuf::GoogleOnceDynamic *v19; // rdi
  const google::protobuf::UninterpretedOption *v20; // rax
  google::protobuf::GoogleOnceDynamic *v21; // rdi
  const google::protobuf::UninterpretedOption *uninterpreted_option; // rax
  google::protobuf::uint32 v23; // edx
  __int64 positive_int_value; // rdx
  double double_value; // rdx
  const google::protobuf::UninterpretedOption *v26; // rax
  google::protobuf::uint32 v27; // edx
  __int64 v28; // rdx
  __m128i v29; // xmm4
  google::protobuf::uint32 v30; // edx
  const google::protobuf::UninterpretedOption *v31; // rax
  __int64 v32; // rax
  google::protobuf::DescriptorBuilder *v33; // rdi
  const google::protobuf::UninterpretedOption *v34; // rdx
  const google::protobuf::UninterpretedOption *v35; // rax
  google::protobuf::GoogleOnceDynamic *v36; // rdi
  const google::protobuf::EnumDescriptor *enum_type; // rbx
  const std::string *full_name; // rax
  google::protobuf::Symbol::Type v39; // r8d
  google::protobuf::Symbol SymbolNotEnforcingDeps; // rax
  google::protobuf::uint64 v41; // rdx
  const google::protobuf::UninterpretedOption *v42; // rax
  __int64 v43; // rax
  google::protobuf::DescriptorBuilder *builder; // rdi
  const google::protobuf::UninterpretedOption *v45; // rdx
  std::string::pointer M_p; // rdi
  std::string *ptr; // r12
  std::string *v48; // rax
  int v49; // eax
  __m128i v50; // xmm1
  google::protobuf::GoogleOnceDynamic *v51; // rdi
  google::protobuf::GoogleOnceDynamic *v52; // rdi
  google::protobuf::GoogleOnceDynamic *v53; // rdi
  const std::string *v54; // rbx
  __int64 v55; // rax
  __int64 v56; // rax
  __int64 v57; // rax
  const char *v58; // rsi
  __int64 v59; // rax
  __int64 v60; // rax
  google::protobuf::DescriptorBuilder *v61; // rdi
  const google::protobuf::UninterpretedOption *v62; // rdx
  __m128i v63; // xmm2
  __m128i v64; // xmm0
  __int64 v65; // rax
  __int64 v66; // rax
  const std::string *v67; // r14
  __int64 v68; // rax
  __int64 v69; // rax
  __int64 v70; // rax
  const char *v71; // rsi
  __int64 v72; // rax
  __int64 v73; // rax
  google::protobuf::DescriptorBuilder *v74; // rdi
  const google::protobuf::UninterpretedOption *v75; // rdx
  std::string *key; // [rsp+0h] [rbp-128h]
  google::protobuf::DescriptorPool *pool; // [rsp+8h] [rbp-120h]
  __int64 v78; // [rsp+8h] [rbp-120h]
  std::string name; // [rsp+10h] [rbp-118h] BYREF
  std::string v80; // [rsp+30h] [rbp-F8h] BYREF
  void *v81; // [rsp+50h] [rbp-D8h] BYREF
  __int64 v82; // [rsp+58h] [rbp-D0h]
  __m128i v83; // [rsp+60h] [rbp-C8h] BYREF
  void *v84; // [rsp+70h] [rbp-B8h] BYREF
  __int64 v85; // [rsp+78h] [rbp-B0h]
  __m128i v86; // [rsp+80h] [rbp-A8h] BYREF
  void *v87; // [rsp+90h] [rbp-98h] BYREF
  __int64 v88; // [rsp+98h] [rbp-90h]
  __m128i v89; // [rsp+A0h] [rbp-88h] BYREF
  std::string v90; // [rsp+B0h] [rbp-78h] BYREF
  std::string closure[2]; // [rsp+D0h] [rbp-58h] BYREF

  type_once = a2->type_once_;
  if ( type_once && type_once->state_ != 2 )
  {
    *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
    closure[0]._anon_0._M_local_buf[0] = 0;
    closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
    google::protobuf::GoogleOnceInitImpl(&type_once->state_, (google::protobuf::Closure *)closure);
    closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
    google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
  }
  type = a2->type_;
  switch ( type )
  {
    case TYPE_DOUBLE_0:
      uninterpreted_option = this->uninterpreted_option_;
      v23 = uninterpreted_option->_has_bits_.has_bits_[0];
      if ( (v23 & 0x20) != 0 )
      {
        double_value = uninterpreted_option->double_value_;
      }
      else if ( (v23 & 8) != 0 )
      {
        positive_int_value = uninterpreted_option->positive_int_value_;
        if ( positive_int_value < 0 )
        {
          v66 = uninterpreted_option->positive_int_value_ & 1 | (uninterpreted_option->positive_int_value_ >> 1);
          double_value = (double)(int)v66 + (double)(int)v66;
        }
        else
        {
          double_value = (double)(int)positive_int_value;
        }
      }
      else
      {
        if ( (v23 & 0x10) == 0 )
        {
          std::operator+<char>(&v90, "Value must be number for double option \"", a2->full_name_);
          if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
            std::__throw_length_error("basic_string::append");
          v43 = std::string::_M_append(&v90, "\".", 2LL);
          closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
          if ( *(_QWORD *)v43 != v43 + 16 )
          {
            closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
            closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
            goto LABEL_72;
          }
          goto LABEL_203;
        }
        double_value = (double)(int)uninterpreted_option->negative_int_value_;
      }
      v7 = 1;
      google::protobuf::UnknownFieldSet::AddFixed64(a3, a2->number_, *(google::protobuf::uint64 *)&double_value);
      return v7;
    case TYPE_FLOAT_0:
      v26 = this->uninterpreted_option_;
      v27 = v26->_has_bits_.has_bits_[0];
      if ( (v27 & 0x20) != 0 )
      {
        v50 = 0LL;
        *(float *)v50.m128i_i32 = v26->double_value_;
        v30 = _mm_cvtsi128_si32(v50);
      }
      else if ( (v27 & 8) != 0 )
      {
        v28 = v26->positive_int_value_;
        if ( v28 < 0 )
        {
          v64 = 0LL;
          v65 = v26->positive_int_value_ & 1 | (v26->positive_int_value_ >> 1);
          *(float *)v64.m128i_i32 = (float)(int)v65 + (float)(int)v65;
          v30 = _mm_cvtsi128_si32(v64);
        }
        else
        {
          v29 = 0LL;
          *(float *)v29.m128i_i32 = (float)(int)v28;
          v30 = _mm_cvtsi128_si32(v29);
        }
      }
      else
      {
        if ( (v27 & 0x10) == 0 )
        {
          std::operator+<char>(&v90, "Value must be number for float option \"", a2->full_name_);
          if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
            std::__throw_length_error("basic_string::append");
          v43 = std::string::_M_append(&v90, "\".", 2LL);
          closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
          if ( *(_QWORD *)v43 != v43 + 16 )
          {
            closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
            closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
            goto LABEL_72;
          }
          goto LABEL_203;
        }
        v63 = 0LL;
        *(float *)v63.m128i_i32 = (float)(int)v26->negative_int_value_;
        v30 = _mm_cvtsi128_si32(v63);
      }
      v7 = 1;
      google::protobuf::UnknownFieldSet::AddFixed32(a3, a2->number_, v30);
      return v7;
    case TYPE_INT64_0:
    case TYPE_SFIXED64_0:
    case TYPE_SINT64_0:
      v13 = this->uninterpreted_option_;
      v14 = v13->_has_bits_.has_bits_[0];
      if ( (v14 & 8) != 0 )
      {
        negative_int_value = v13->positive_int_value_;
        if ( negative_int_value >= 0 )
        {
          v51 = a2->type_once_;
          if ( v51 )
          {
            if ( v51->state_ != 2 )
            {
              closure[0]._anon_0._M_local_buf[0] = 0;
              *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
              closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
              closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
              google::protobuf::GoogleOnceInitImpl(&v51->state_, (google::protobuf::Closure *)closure);
              closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
              google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
            }
            type = a2->type_;
            negative_int_value = this->uninterpreted_option_->positive_int_value_;
          }
          goto LABEL_22;
        }
        std::operator+<char>(&v90, "Value out of range for int64 option \"", a2->full_name_);
        if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        v43 = std::string::_M_append(&v90, "\".", 2LL);
        closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v43 != v43 + 16 )
        {
          closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
          closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
          goto LABEL_72;
        }
      }
      else
      {
        if ( (v14 & 0x10) != 0 )
        {
          v15 = a2->type_once_;
          if ( v15 )
          {
            if ( v15->state_ != 2 )
            {
              closure[0]._anon_0._M_local_buf[0] = 0;
              *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
              closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
              closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
              google::protobuf::GoogleOnceInitImpl(&v15->state_, (google::protobuf::Closure *)closure);
              closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
              google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
            }
            v13 = this->uninterpreted_option_;
            type = a2->type_;
          }
          negative_int_value = v13->negative_int_value_;
LABEL_22:
          google::protobuf::DescriptorBuilder::OptionInterpreter::SetInt64(
            this,
            a2->number_,
            negative_int_value,
            type,
            a3);
          return 1;
        }
        std::operator+<char>(&v90, "Value must be integer for int64 option \"", a2->full_name_);
        if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        v43 = std::string::_M_append(&v90, "\".", 2LL);
        closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v43 != v43 + 16 )
        {
          closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
          closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
          goto LABEL_72;
        }
      }
      goto LABEL_203;
    case TYPE_UINT64_0:
    case TYPE_FIXED64_0:
      v20 = this->uninterpreted_option_;
      if ( (v20->_has_bits_.has_bits_[0] & 8) != 0 )
      {
        v21 = a2->type_once_;
        if ( v21 )
        {
          if ( v21->state_ != 2 )
          {
            closure[0]._anon_0._M_local_buf[0] = 0;
            *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
            closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
            closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
            google::protobuf::GoogleOnceInitImpl(&v21->state_, (google::protobuf::Closure *)closure);
            closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
            google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
          }
          v20 = this->uninterpreted_option_;
          type = a2->type_;
        }
        v7 = 1;
        google::protobuf::DescriptorBuilder::OptionInterpreter::SetUInt64(
          this,
          a2->number_,
          v20->positive_int_value_,
          type,
          a3);
        return v7;
      }
      std::operator+<char>(&v90, "Value must be non-negative integer for uint64 option \"", a2->full_name_);
      if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
        std::__throw_length_error("basic_string::append");
      v43 = std::string::_M_append(&v90, "\".", 2LL);
      closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
      if ( *(_QWORD *)v43 != v43 + 16 )
      {
        closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
        closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
        goto LABEL_72;
      }
      goto LABEL_203;
    case TYPE_INT32_0:
    case TYPE_SFIXED32_0:
    case TYPE_SINT32_0:
      v9 = this->uninterpreted_option_;
      v10 = v9->_has_bits_.has_bits_[0];
      if ( (v10 & 8) != 0 )
      {
        v11 = v9->positive_int_value_;
        if ( (unsigned __int64)v11 <= 0x7FFFFFFF )
        {
          v52 = a2->type_once_;
          if ( v52 )
          {
            if ( v52->state_ != 2 )
            {
              closure[0]._anon_0._M_local_buf[0] = 0;
              *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
              closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
              closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
              google::protobuf::GoogleOnceInitImpl(&v52->state_, (google::protobuf::Closure *)closure);
              closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
              google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
            }
            type = a2->type_;
            v11 = this->uninterpreted_option_->positive_int_value_;
          }
          goto LABEL_14;
        }
        std::operator+<char>(&v90, "Value out of range for int32 option \"", a2->full_name_);
        if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        v43 = std::string::_M_append(&v90, "\".", 2LL);
        closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v43 != v43 + 16 )
        {
          closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
          closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
          goto LABEL_72;
        }
      }
      else if ( (v10 & 0x10) != 0 )
      {
        v11 = v9->negative_int_value_;
        if ( v11 >= (__int64)0xFFFFFFFF80000000LL )
        {
          v12 = a2->type_once_;
          if ( v12 )
          {
            if ( v12->state_ != 2 )
            {
              closure[0]._anon_0._M_local_buf[0] = 0;
              *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
              closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
              closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
              google::protobuf::GoogleOnceInitImpl(&v12->state_, (google::protobuf::Closure *)closure);
              closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
              google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
            }
            type = a2->type_;
            v11 = this->uninterpreted_option_->negative_int_value_;
          }
LABEL_14:
          v7 = 1;
          google::protobuf::DescriptorBuilder::OptionInterpreter::SetInt32(this, a2->number_, v11, type, a3);
          return v7;
        }
        std::operator+<char>(&v90, "Value out of range for int32 option \"", a2->full_name_);
        if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        v43 = std::string::_M_append(&v90, "\".", 2LL);
        closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v43 != v43 + 16 )
        {
          closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
          closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
          goto LABEL_72;
        }
      }
      else
      {
        std::operator+<char>(&v90, "Value must be integer for int32 option \"", a2->full_name_);
        if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        v43 = std::string::_M_append(&v90, "\".", 2LL);
        closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v43 != v43 + 16 )
        {
          closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
          closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
          goto LABEL_72;
        }
      }
LABEL_203:
      closure[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v43 + 16));
LABEL_72:
      closure[0]._M_string_length = *(_QWORD *)(v43 + 8);
      *(_BYTE *)(v43 + 16) = 0;
      builder = this->builder_;
      *(_QWORD *)v43 = v43 + 16;
      v45 = this->uninterpreted_option_;
      *(_QWORD *)(v43 + 8) = 0LL;
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)builder,
        &this->options_to_interpret_->element_name,
        (__int64)v45,
        8u,
        closure);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p != &closure[0]._anon_0 )
        operator delete(closure[0]._M_dataplus._M_p);
      M_p = v90._M_dataplus._M_p;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v90._M_dataplus._M_p != &v90._anon_0 )
LABEL_75:
        operator delete(M_p);
      return 0;
    case TYPE_FIXED32_0:
    case TYPE_UINT32_0:
      v17 = this->uninterpreted_option_;
      if ( (v17->_has_bits_.has_bits_[0] & 8) != 0 )
      {
        v18 = v17->positive_int_value_;
        if ( v18 <= 0xFFFFFFFF )
        {
          v19 = a2->type_once_;
          if ( v19 )
          {
            if ( v19->state_ != 2 )
            {
              closure[0]._anon_0._M_local_buf[0] = 0;
              *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
              closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
              closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
              google::protobuf::GoogleOnceInitImpl(&v19->state_, (google::protobuf::Closure *)closure);
              closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
              google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
            }
            type = a2->type_;
            v18 = this->uninterpreted_option_->positive_int_value_;
          }
          v7 = 1;
          google::protobuf::DescriptorBuilder::OptionInterpreter::SetUInt32(this, a2->number_, v18, type, a3);
          return v7;
        }
        std::operator+<char>(&v90, "Value out of range for uint32 option \"", a2->name_);
        if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        v43 = std::string::_M_append(&v90, "\".", 2LL);
        closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v43 != v43 + 16 )
        {
          closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
          closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
          goto LABEL_72;
        }
      }
      else
      {
        std::operator+<char>(&v90, "Value must be non-negative integer for uint32 option \"", a2->full_name_);
        if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        v43 = std::string::_M_append(&v90, "\".", 2LL);
        closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v43 != v43 + 16 )
        {
          closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
          closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
          goto LABEL_72;
        }
      }
      goto LABEL_203;
    case TYPE_BOOL_0:
      v31 = this->uninterpreted_option_;
      v7 = v31->_has_bits_.has_bits_[0] & 1;
      if ( (v31->_has_bits_.has_bits_[0] & 1) == 0 )
      {
        std::operator+<char>(&v90, "Value must be identifier for boolean option \"", a2->full_name_);
        if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        v32 = std::string::_M_append(&v90, "\".", 2LL);
        closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v32 != v32 + 16 )
        {
          closure[0]._M_dataplus._M_p = *(std::string::pointer *)v32;
          closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v32 + 16);
          goto LABEL_51;
        }
        goto LABEL_148;
      }
      if ( !(unsigned int)std::string::compare(v31->identifier_value_.ptr_, "true") )
      {
        v41 = 1LL;
        goto LABEL_80;
      }
      v49 = std::string::compare(this->uninterpreted_option_->identifier_value_.ptr_, "false");
      v41 = 0LL;
      if ( !v49 )
        goto LABEL_80;
      std::operator+<char>(&v90, "Value must be \"true\" or \"false\" for boolean option \"", a2->full_name_);
      if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
        std::__throw_length_error("basic_string::append");
      v43 = std::string::_M_append(&v90, "\".", 2LL);
      closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
      if ( *(_QWORD *)v43 != v43 + 16 )
      {
        closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
        closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
        goto LABEL_72;
      }
      goto LABEL_203;
    case TYPE_STRING_0:
    case TYPE_BYTES_0:
      v42 = this->uninterpreted_option_;
      if ( (v42->_has_bits_.has_bits_[0] & 2) != 0 )
      {
        ptr = v42->string_value_.ptr_;
        v7 = 1;
        v48 = google::protobuf::UnknownFieldSet::AddLengthDelimited[abi:cxx11](a3, a2->number_);
        std::string::_M_assign(v48, ptr);
        return v7;
      }
      std::operator+<char>(&v90, "Value must be quoted string for string option \"", a2->full_name_);
      if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
        std::__throw_length_error("basic_string::append");
      v43 = std::string::_M_append(&v90, "\".", 2LL);
      closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
      if ( *(_QWORD *)v43 != v43 + 16 )
      {
        closure[0]._M_dataplus._M_p = *(std::string::pointer *)v43;
        closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v43 + 16);
        goto LABEL_72;
      }
      goto LABEL_203;
    case TYPE_GROUP_0:
    case TYPE_MESSAGE_0:
      return (unsigned int)google::protobuf::DescriptorBuilder::OptionInterpreter::SetAggregateOption(this, a2, a3);
    case TYPE_ENUM_0:
      v35 = this->uninterpreted_option_;
      v7 = v35->_has_bits_.has_bits_[0] & 1;
      if ( (v35->_has_bits_.has_bits_[0] & 1) == 0 )
      {
        std::operator+<char>(&v90, "Value must be identifier for enum-valued option \"", a2->full_name_);
        if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
          std::__throw_length_error("basic_string::append");
        v32 = std::string::_M_append(&v90, "\".", 2LL);
        closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
        if ( *(_QWORD *)v32 == v32 + 16 )
        {
LABEL_148:
          closure[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v32 + 16));
        }
        else
        {
          closure[0]._M_dataplus._M_p = *(std::string::pointer *)v32;
          closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v32 + 16);
        }
LABEL_51:
        closure[0]._M_string_length = *(_QWORD *)(v32 + 8);
        *(_BYTE *)(v32 + 16) = 0;
        v33 = this->builder_;
        *(_QWORD *)v32 = v32 + 16;
        v34 = this->uninterpreted_option_;
        *(_QWORD *)(v32 + 8) = 0LL;
        google::protobuf::DescriptorBuilder::AddError(
          (__int64)v33,
          &this->options_to_interpret_->element_name,
          (__int64)v34,
          8u,
          closure);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p != &closure[0]._anon_0 )
          operator delete(closure[0]._M_dataplus._M_p);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v90._M_dataplus._M_p != &v90._anon_0 )
          operator delete(v90._M_dataplus._M_p);
        return v7;
      }
      v36 = a2->type_once_;
      if ( v36 )
      {
        if ( v36->state_ != 2 )
        {
          closure[0]._anon_0._M_local_buf[0] = 0;
          *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
          closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
          closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
          google::protobuf::GoogleOnceInitImpl(&v36->state_, (google::protobuf::Closure *)closure);
          closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
          google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
        }
        v35 = this->uninterpreted_option_;
      }
      enum_type = a2->enum_type_;
      key = v35->identifier_value_.ptr_;
      pool = (google::protobuf::DescriptorPool *)enum_type->file_->pool_;
      if ( google::protobuf::`anonymous namespace'::generated_pool_init_ != 2 )
      {
        closure[0]._M_dataplus._M_p = (std::string::pointer)off_1A16E058;
        closure[0]._anon_0._M_local_buf[0] = 0;
        closure[0]._M_string_length = (std::string::size_type)google::protobuf::`anonymous namespace'::InitGeneratedPool;
        google::protobuf::GoogleOnceInitImpl(
          &google::protobuf::`anonymous namespace'::generated_pool_init_,
          (google::protobuf::Closure *)closure);
        google::protobuf::internal::FunctionClosure0::~FunctionClosure0((google::protobuf::internal::FunctionClosure0 *const)closure);
      }
      if ( pool == google::protobuf::`anonymous namespace'::generated_pool_ )
      {
        *(_QWORD *)&SymbolNotEnforcingDeps.type = google::protobuf::EnumDescriptor::FindValueByName(enum_type, key);
      }
      else
      {
        full_name = enum_type->full_name_;
        name._M_dataplus._M_p = name._anon_0._M_local_buf;
        std::string::_M_construct<char *>(
          &name,
          full_name->_M_dataplus._M_p,
          &full_name->_M_dataplus._M_p[full_name->_M_string_length],
          (std::forward_iterator_tag)type);
        std::string::resize(&name, name._M_string_length - enum_type->name_->_M_string_length, 0LL);
        std::string::_M_append(&name, key->_M_dataplus._M_p, key->_M_string_length);
        SymbolNotEnforcingDeps = google::protobuf::DescriptorBuilder::FindSymbolNotEnforcingDeps(
                                   this->builder_,
                                   &name,
                                   1);
        v39 = SymbolNotEnforcingDeps.type;
        *(_QWORD *)&SymbolNotEnforcingDeps.type = 0LL;
        if ( v39 == ENUM_VALUE )
        {
          *(_QWORD *)&SymbolNotEnforcingDeps.type = SymbolNotEnforcingDeps._anon_0.descriptor;
          if ( (const google::protobuf::EnumDescriptor *)SymbolNotEnforcingDeps._anon_0.descriptor->containing_type_ != enum_type )
          {
            v67 = a2->full_name_;
            std::operator+<char>(&v80, "Enum type \"", enum_type->full_name_);
            if ( 0x3FFFFFFFFFFFFFFFLL - v80._M_string_length <= 0x15 )
              std::__throw_length_error("basic_string::append");
            v68 = std::string::_M_append(&v80, "\" has no value named \"", 22LL);
            v81 = &v83;
            if ( *(_QWORD *)v68 == v68 + 16 )
            {
              v83 = _mm_loadu_si128((const __m128i *)(v68 + 16));
            }
            else
            {
              v81 = *(void **)v68;
              v83.m128i_i64[0] = *(_QWORD *)(v68 + 16);
            }
            v82 = *(_QWORD *)(v68 + 8);
            *(_QWORD *)v68 = v68 + 16;
            *(_QWORD *)(v68 + 8) = 0LL;
            *(_BYTE *)(v68 + 16) = 0;
            v69 = std::string::_M_append(&v81, key->_M_dataplus._M_p, key->_M_string_length);
            v84 = &v86;
            if ( *(_QWORD *)v69 == v69 + 16 )
            {
              v86 = _mm_loadu_si128((const __m128i *)(v69 + 16));
            }
            else
            {
              v84 = *(void **)v69;
              v86.m128i_i64[0] = *(_QWORD *)(v69 + 16);
            }
            v85 = *(_QWORD *)(v69 + 8);
            *(_QWORD *)(v69 + 8) = 0LL;
            *(_BYTE *)(v69 + 16) = 0;
            *(_QWORD *)v69 = v69 + 16;
            if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v85) <= 0xD )
              std::__throw_length_error("basic_string::append");
            v70 = std::string::_M_append(&v84, "\" for option \"", 14LL);
            v87 = &v89;
            if ( *(_QWORD *)v70 == v70 + 16 )
            {
              v89 = _mm_loadu_si128((const __m128i *)(v70 + 16));
            }
            else
            {
              v87 = *(void **)v70;
              v89.m128i_i64[0] = *(_QWORD *)(v70 + 16);
            }
            v88 = *(_QWORD *)(v70 + 8);
            *(_QWORD *)v70 = v70 + 16;
            *(_BYTE *)(v70 + 16) = 0;
            v71 = v67->_M_dataplus._M_p;
            *(_QWORD *)(v70 + 8) = 0LL;
            v72 = std::string::_M_append(&v87, v71, v67->_M_string_length);
            v90._M_dataplus._M_p = v90._anon_0._M_local_buf;
            if ( *(_QWORD *)v72 == v72 + 16 )
            {
              v90._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v72 + 16));
            }
            else
            {
              v90._M_dataplus._M_p = *(std::string::pointer *)v72;
              v90._anon_0._M_allocated_capacity = *(_QWORD *)(v72 + 16);
            }
            v90._M_string_length = *(_QWORD *)(v72 + 8);
            *(_QWORD *)(v72 + 8) = 0LL;
            *(_BYTE *)(v72 + 16) = 0;
            *(_QWORD *)v72 = v72 + 16;
            if ( 0x3FFFFFFFFFFFFFFFLL - v90._M_string_length <= 0x31 )
              std::__throw_length_error("basic_string::append");
            v73 = std::string::_M_append(&v90, "\". This appears to be a value from a sibling type.", 50LL);
            closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
            if ( *(_QWORD *)v73 == v73 + 16 )
            {
              closure[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v73 + 16));
            }
            else
            {
              closure[0]._M_dataplus._M_p = *(std::string::pointer *)v73;
              closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v73 + 16);
            }
            closure[0]._M_string_length = *(_QWORD *)(v73 + 8);
            *(_BYTE *)(v73 + 16) = 0;
            v74 = this->builder_;
            *(_QWORD *)v73 = v73 + 16;
            v75 = this->uninterpreted_option_;
            *(_QWORD *)(v73 + 8) = 0LL;
            google::protobuf::DescriptorBuilder::AddError(
              (__int64)v74,
              &this->options_to_interpret_->element_name,
              (__int64)v75,
              8u,
              closure);
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p != &closure[0]._anon_0 )
              operator delete(closure[0]._M_dataplus._M_p);
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v90._M_dataplus._M_p != &v90._anon_0 )
              operator delete(v90._M_dataplus._M_p);
            if ( v87 != &v89 )
              operator delete(v87);
            if ( v84 != &v86 )
              operator delete(v84);
            if ( v81 != &v83 )
              operator delete(v81);
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v80._M_dataplus._M_p != &v80._anon_0 )
              operator delete(v80._M_dataplus._M_p);
            M_p = name._M_dataplus._M_p;
            if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)name._M_dataplus._M_p != &name._anon_0 )
              goto LABEL_75;
            return 0;
          }
        }
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)name._M_dataplus._M_p != &name._anon_0 )
        {
          v78 = *(_QWORD *)&SymbolNotEnforcingDeps.type;
          operator delete(name._M_dataplus._M_p);
          *(_QWORD *)&SymbolNotEnforcingDeps.type = v78;
        }
      }
      if ( *(_QWORD *)&SymbolNotEnforcingDeps.type )
      {
        v41 = *(int *)(*(_QWORD *)&SymbolNotEnforcingDeps.type + 16LL);
LABEL_80:
        google::protobuf::UnknownFieldSet::AddVarint(a3, a2->number_, v41);
        return v7;
      }
      v53 = a2->type_once_;
      v54 = a2->full_name_;
      if ( v53 && v53->state_ != 2 )
      {
        closure[0]._anon_0._M_local_buf[0] = 0;
        *(&closure[0]._anon_0._M_allocated_capacity + 1) = (std::string::size_type)a2;
        closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        closure[0]._M_string_length = (std::string::size_type)google::protobuf::FieldDescriptor::TypeOnceInit;
        google::protobuf::GoogleOnceInitImpl(&v53->state_, (google::protobuf::Closure *)closure);
        closure[0]._M_dataplus._M_p = (std::string::pointer)&off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)closure);
      }
      std::operator+<char>(&v80, "Enum type \"", a2->enum_type_->full_name_);
      if ( 0x3FFFFFFFFFFFFFFFLL - v80._M_string_length <= 0x15 )
        std::__throw_length_error("basic_string::append");
      v55 = std::string::_M_append(&v80, "\" has no value named \"", 22LL);
      v81 = &v83;
      if ( *(_QWORD *)v55 == v55 + 16 )
      {
        v83 = _mm_loadu_si128((const __m128i *)(v55 + 16));
      }
      else
      {
        v81 = *(void **)v55;
        v83.m128i_i64[0] = *(_QWORD *)(v55 + 16);
      }
      v82 = *(_QWORD *)(v55 + 8);
      *(_QWORD *)v55 = v55 + 16;
      *(_QWORD *)(v55 + 8) = 0LL;
      *(_BYTE *)(v55 + 16) = 0;
      v56 = std::string::_M_append(&v81, key->_M_dataplus._M_p, key->_M_string_length);
      v84 = &v86;
      if ( *(_QWORD *)v56 == v56 + 16 )
      {
        v86 = _mm_loadu_si128((const __m128i *)(v56 + 16));
      }
      else
      {
        v84 = *(void **)v56;
        v86.m128i_i64[0] = *(_QWORD *)(v56 + 16);
      }
      v85 = *(_QWORD *)(v56 + 8);
      *(_QWORD *)(v56 + 8) = 0LL;
      *(_BYTE *)(v56 + 16) = 0;
      *(_QWORD *)v56 = v56 + 16;
      if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v85) <= 0xD )
        std::__throw_length_error("basic_string::append");
      v57 = std::string::_M_append(&v84, "\" for option \"", 14LL);
      v87 = &v89;
      if ( *(_QWORD *)v57 == v57 + 16 )
      {
        v89 = _mm_loadu_si128((const __m128i *)(v57 + 16));
      }
      else
      {
        v87 = *(void **)v57;
        v89.m128i_i64[0] = *(_QWORD *)(v57 + 16);
      }
      v88 = *(_QWORD *)(v57 + 8);
      *(_QWORD *)v57 = v57 + 16;
      *(_BYTE *)(v57 + 16) = 0;
      v58 = v54->_M_dataplus._M_p;
      *(_QWORD *)(v57 + 8) = 0LL;
      v59 = std::string::_M_append(&v87, v58, v54->_M_string_length);
      v90._M_dataplus._M_p = v90._anon_0._M_local_buf;
      if ( *(_QWORD *)v59 == v59 + 16 )
      {
        v90._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v59 + 16));
      }
      else
      {
        v90._M_dataplus._M_p = *(std::string::pointer *)v59;
        v90._anon_0._M_allocated_capacity = *(_QWORD *)(v59 + 16);
      }
      v90._M_string_length = *(_QWORD *)(v59 + 8);
      *(_QWORD *)(v59 + 8) = 0LL;
      *(_BYTE *)(v59 + 16) = 0;
      *(_QWORD *)v59 = v59 + 16;
      if ( v90._M_string_length == 0x3FFFFFFFFFFFFFFFLL || v90._M_string_length == 4611686018427387902LL )
        std::__throw_length_error("basic_string::append");
      v60 = std::string::_M_append(&v90, "\".", 2LL);
      closure[0]._M_dataplus._M_p = closure[0]._anon_0._M_local_buf;
      if ( *(_QWORD *)v60 == v60 + 16 )
      {
        closure[0]._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v60 + 16));
      }
      else
      {
        closure[0]._M_dataplus._M_p = *(std::string::pointer *)v60;
        closure[0]._anon_0._M_allocated_capacity = *(_QWORD *)(v60 + 16);
      }
      closure[0]._M_string_length = *(_QWORD *)(v60 + 8);
      *(_BYTE *)(v60 + 16) = 0;
      v61 = this->builder_;
      *(_QWORD *)v60 = v60 + 16;
      v62 = this->uninterpreted_option_;
      *(_QWORD *)(v60 + 8) = 0LL;
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)v61,
        &this->options_to_interpret_->element_name,
        (__int64)v62,
        8u,
        closure);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)closure[0]._M_dataplus._M_p != &closure[0]._anon_0 )
        operator delete(closure[0]._M_dataplus._M_p);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v90._M_dataplus._M_p != &v90._anon_0 )
        operator delete(v90._M_dataplus._M_p);
      if ( v87 != &v89 )
        operator delete(v87);
      if ( v84 != &v86 )
        operator delete(v84);
      if ( v81 != &v83 )
        operator delete(v81);
      M_p = v80._M_dataplus._M_p;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v80._M_dataplus._M_p != &v80._anon_0 )
        goto LABEL_75;
      return 0;
    default:
      return 1;
  }
};

// Line 6538: range 000000000C919780-000000000C919799
void __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::AggregateOptionFinder::~AggregateOptionFinder(
        google::protobuf::DescriptorBuilder::OptionInterpreter::AggregateOptionFinder *const this)
{
  this->_vptr_Finder = (int (**)(...))off_1A17BF40;
  google::protobuf::TextFormat::Finder::~Finder(this);
  operator delete(this, 0x10uLL);
};

// Line 6538: range 000000000C919770-000000000C919777
void __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::AggregateOptionFinder::~AggregateOptionFinder(
        google::protobuf::DescriptorBuilder::OptionInterpreter::AggregateOptionFinder *const this)
{
  this->_vptr_Finder = (int (**)(...))off_1A17BF40;
  google::protobuf::TextFormat::Finder::~Finder(this);
};

// Line 6543: range 000000000C91F060-000000000C91F1EF
const google::protobuf::FieldDescriptor *__fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::AggregateOptionFinder::FindExtension(
        const google::protobuf::DescriptorBuilder::OptionInterpreter::AggregateOptionFinder *const this,
        google::protobuf::Message *message,
        const std::string *name)
{
  google::protobuf::internal::Mutex *mutex; // rdi
  __int64 v6; // r13
  __int64 v7; // rdx
  int v8; // ecx
  __int64 v9; // r14
  const google::protobuf::FieldDescriptor *result; // rax
  __int64 v11; // rbp
  int v12; // r12d
  __int64 v13; // rbx
  google::protobuf::ProtobufOnceType *v14; // rdi
  google::protobuf::ProtobufOnceType *v15; // rdi
  google::protobuf::Closure v16; // [rsp+0h] [rbp-48h] BYREF
  void (__fastcall *v17)(const google::protobuf::FieldDescriptor *); // [rsp+8h] [rbp-40h]
  char v18; // [rsp+10h] [rbp-38h]
  __int64 v19; // [rsp+18h] [rbp-30h]

  mutex = this->builder_->pool_->mutex_;
  if ( mutex )
    google::protobuf::internal::Mutex::AssertHeld(mutex);
  v6 = (*((__int64 (__fastcall **)(google::protobuf::Message *))message->_vptr_MessageLite + 24))(message);
  v8 = google::protobuf::DescriptorBuilder::LookupSymbolNoPlaceholder(
         this->builder_,
         (std::string *)name,
         *(_QWORD *)(v6 + 8),
         0,
         1);
  v9 = v7;
  result = (const google::protobuf::FieldDescriptor *)v7;
  if ( v8 == 2 )
  {
    if ( *(_BYTE *)(v7 + 66) )
      return result;
    return 0LL;
  }
  if ( v8 != 1 || !*(_BYTE *)(*(_QWORD *)(v6 + 32) + 104LL) || *(int *)(v7 + 124) <= 0 )
    return 0LL;
  v11 = 0LL;
  v12 = 0;
  while ( 1 )
  {
    v13 = v11 + *(_QWORD *)(v9 + 80);
    if ( v6 == *(_QWORD *)(v13 + 80) )
    {
      v14 = *(google::protobuf::ProtobufOnceType **)(v13 + 48);
      if ( v14 && *v14 != 2 )
      {
        v16._vptr_Closure = (int (**)(...))&off_1A17BF90;
        v17 = google::protobuf::FieldDescriptor::TypeOnceInit;
        v18 = 0;
        v19 = v13;
        google::protobuf::GoogleOnceInitImpl(v14, &v16);
        v16._vptr_Closure = (int (**)(...))&off_1A17BF90;
        google::protobuf::Closure::~Closure(&v16);
      }
      if ( *(_DWORD *)(v13 + 56) == 11 && *(_DWORD *)(v13 + 60) == 1 )
      {
        v15 = *(google::protobuf::ProtobufOnceType **)(v13 + 48);
        if ( v15 )
        {
          if ( *v15 != 2 )
          {
            v16._vptr_Closure = (int (**)(...))&off_1A17BF90;
            v17 = google::protobuf::FieldDescriptor::TypeOnceInit;
            v18 = 0;
            v19 = v13;
            google::protobuf::GoogleOnceInitImpl(v15, &v16);
            v16._vptr_Closure = (int (**)(...))&off_1A17BF90;
            google::protobuf::Closure::~Closure(&v16);
          }
        }
        if ( v9 == *(_QWORD *)(v13 + 104) )
          break;
      }
    }
    ++v12;
    v11 += 152LL;
    if ( v12 >= *(_DWORD *)(v9 + 124) )
      return 0LL;
  }
  return (const google::protobuf::FieldDescriptor *)v13;
};

// Line 6577: range 000000000C8F4240-000000000C8F426E
void __fastcall google::protobuf::`anonymous namespace'::AggregateErrorCollector::~AggregateErrorCollector(
        google::protobuf::`anonymous namespace'::AggregateErrorCollector *const this)
{
  google::protobuf::`anonymous namespace'::AggregateErrorCollector *M_p; // rdi

  this->_vptr_ErrorCollector = (int (**)(...))off_1A17BAB0;
  M_p = (google::protobuf::`anonymous namespace'::AggregateErrorCollector *)this->error_._M_dataplus._M_p;
  if ( M_p != (google::protobuf::`anonymous namespace'::AggregateErrorCollector *)&this->error_._anon_0 )
    operator delete(M_p);
  google::protobuf::io::ErrorCollector::~ErrorCollector(this);
  operator delete(this, 0x28uLL);
};

// Line 6577: range 000000000C8F35B0-000000000C8F35D1
void __fastcall google::protobuf::`anonymous namespace'::AggregateErrorCollector::~AggregateErrorCollector(
        google::protobuf::`anonymous namespace'::AggregateErrorCollector *const this)
{
  google::protobuf::`anonymous namespace'::AggregateErrorCollector *M_p; // rdi

  this->_vptr_ErrorCollector = (int (**)(...))off_1A17BAB0;
  M_p = (google::protobuf::`anonymous namespace'::AggregateErrorCollector *)this->error_._M_dataplus._M_p;
  if ( M_p != (google::protobuf::`anonymous namespace'::AggregateErrorCollector *)&this->error_._anon_0 )
    operator delete(M_p);
  google::protobuf::io::ErrorCollector::~ErrorCollector(this);
};

// Line 6581: range 000000000C8F47B0-000000000C8F480C
void __fastcall google::protobuf::`anonymous namespace'::AggregateErrorCollector::AddError(
        google::protobuf::`anonymous namespace'::AggregateErrorCollector *const this,
        int a2,
        int a3,
        const std::string *message)
{
  std::string::size_type M_string_length; // rax

  M_string_length = this->error_._M_string_length;
  if ( M_string_length )
  {
    if ( M_string_length == 0x3FFFFFFFFFFFFFFFLL || M_string_length == 4611686018427387902LL )
      std::__throw_length_error("basic_string::append");
    std::string::_M_append(&this->error_, "; ", 2LL);
  }
  std::string::_M_append(&this->error_, message->_M_dataplus._M_p, message->_M_string_length);
};

// Line 6592: range 000000000C8F31D0-000000000C8F3246
void __fastcall google::protobuf::`anonymous namespace'::AggregateErrorCollector::AddWarning(
        google::protobuf::`anonymous namespace'::AggregateErrorCollector *const this,
        int a2,
        int a3,
        const std::string *a4)
{
  ;
};

// Line 6601: range 000000000C90D6D0-000000000C90E0CB
__int64 __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::SetAggregateOption(
        google::protobuf::DescriptorBuilder::OptionInterpreter *this,
        google::protobuf::FieldDescriptor *a2,
        google::protobuf::UnknownFieldSet *a3)
{
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  __int64 Prototype; // rax
  google::protobuf::Message *v6; // r12
  google::protobuf::DescriptorBuilder *builder; // rax
  unsigned int v8; // eax
  unsigned int v9; // r13d
  google::protobuf::GoogleOnceDynamic *v10; // rdi
  google::protobuf::FieldDescriptor::Type type; // eax
  google::protobuf::GoogleOnceDynamic *v12; // rdi
  google::protobuf::UnknownFieldSet *v13; // rax
  std::string::pointer M_p; // rdi
  __int64 v16; // rax
  const char *M_string_length; // rsi
  __int64 v18; // rax
  google::protobuf::DescriptorBuilder *v19; // rdi
  const google::protobuf::UninterpretedOption *uninterpreted_option; // rdx
  const std::string *name; // r12
  __int64 v22; // rax
  const char *v23; // rsi
  __int64 v24; // rax
  __int64 v25; // rax
  const char *v26; // rsi
  __int64 v27; // rax
  __int64 v28; // rax
  google::protobuf::DescriptorBuilder *v29; // rdi
  const google::protobuf::UninterpretedOption *v30; // rdx
  std::string *v31; // rax
  google::protobuf::internal::LogMessage_0 *v32; // rax
  google::protobuf::internal::LogMessage_0 *v33; // rax
  google::protobuf::internal::LogMessage_0 *v34; // r13
  google::protobuf::internal::LogMessage_0 *v35; // rax
  std::string v37; // [rsp+20h] [rbp-128h] BYREF
  google::protobuf::TextFormat::Parser v38; // [rsp+40h] [rbp-108h] BYREF
  std::string v39; // [rsp+60h] [rbp-E8h] BYREF
  std::string output; // [rsp+80h] [rbp-C8h] BYREF
  std::string v41; // [rsp+A0h] [rbp-A8h] BYREF
  google::protobuf::internal::LogMessage_0 v42; // [rsp+D0h] [rbp-78h] BYREF

  if ( (this->uninterpreted_option_->_has_bits_.has_bits_[0] & 4) != 0 )
  {
    type_once = a2->type_once_;
    if ( type_once && type_once->state_ != 2 )
    {
      v42.message_._M_dataplus._M_p = (std::string::pointer)a2;
      LOBYTE(v42.line_) = 0;
      *(_QWORD *)&v42.level_ = &off_1A17BF90;
      v42.filename_ = (const char *)google::protobuf::FieldDescriptor::TypeOnceInit;
      google::protobuf::GoogleOnceInitImpl(&type_once->state_, (google::protobuf::Closure *)&v42);
      *(_QWORD *)&v42.level_ = &off_1A17BF90;
      google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&v42);
    }
    Prototype = google::protobuf::DynamicMessageFactory::GetPrototype(&this->dynamic_factory_, a2->message_type_);
    v6 = (google::protobuf::Message *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)Prototype + 24LL))(Prototype);
    if ( !v6 )
    {
      google::protobuf::internal::LogMessage::LogMessage(&v42, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6614);
      v33 = google::protobuf::internal::LogMessage::operator<<(&v42, "CHECK failed: dynamic.get() != NULL: ");
      v34 = google::protobuf::internal::LogMessage::operator<<(v33, "Could not create an instance of ");
      LOWORD(output._M_dataplus._M_p) = 0;
      BYTE2(output._M_dataplus._M_p) = 0;
      google::protobuf::FieldDescriptor::DebugStringWithOptions[abi:cxx11]((__int64)&v41, a2);
      v35 = google::protobuf::internal::LogMessage::operator<<(v34, &v41);
      google::protobuf::internal::LogFinisher::operator=((google::protobuf::internal::LogFinisher *const)&output, v35);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v41._M_dataplus._M_p != &v41._anon_0 )
        operator delete(v41._M_dataplus._M_p);
      google::protobuf::internal::LogMessage::~LogMessage(&v42);
    }
    v41._M_dataplus._M_p = (std::string::pointer)off_1A17BAB0;
    v41._M_string_length = (std::string::size_type)(&v41._anon_0._M_allocated_capacity + 1);
    builder = this->builder_;
    v41._anon_0._M_allocated_capacity = 0LL;
    v41._anon_0._M_local_buf[8] = 0;
    v37._M_dataplus._M_p = (std::string::pointer)off_1A17BF40;
    v37._M_string_length = (std::string::size_type)builder;
    google::protobuf::TextFormat::Parser::Parser(&v38);
    v38.error_collector_ = (google::protobuf::io::ErrorCollector *)&v41;
    v38.finder_ = (google::protobuf::TextFormat::Finder *)&v37;
    LOBYTE(v8) = google::protobuf::TextFormat::Parser::ParseFromString(
                   &v38,
                   this->uninterpreted_option_->aggregate_value_.ptr_,
                   v6);
    v9 = v8;
    if ( !(_BYTE)v8 )
    {
      std::operator+<char>(&v39, "Error while parsing option value for \"", a2->name_);
      if ( 0x3FFFFFFFFFFFFFFFLL - v39._M_string_length <= 2 )
        std::__throw_length_error("basic_string::append");
      v16 = std::string::_M_append(&v39, "\": ", 3LL);
      output._M_dataplus._M_p = output._anon_0._M_local_buf;
      if ( *(_QWORD *)v16 == v16 + 16 )
      {
        output._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v16 + 16));
      }
      else
      {
        output._M_dataplus._M_p = *(std::string::pointer *)v16;
        output._anon_0._M_allocated_capacity = *(_QWORD *)(v16 + 16);
      }
      output._M_string_length = *(_QWORD *)(v16 + 8);
      *(_QWORD *)v16 = v16 + 16;
      *(_BYTE *)(v16 + 16) = 0;
      M_string_length = (const char *)v41._M_string_length;
      *(_QWORD *)(v16 + 8) = 0LL;
      v18 = std::string::_M_append(&output, M_string_length, v41._anon_0._M_allocated_capacity);
      *(_QWORD *)&v42.level_ = &v42.line_;
      if ( *(_QWORD *)v18 == v18 + 16 )
      {
        *(__m128i *)&v42.line_ = _mm_loadu_si128((const __m128i *)(v18 + 16));
      }
      else
      {
        *(_QWORD *)&v42.level_ = *(_QWORD *)v18;
        *(_QWORD *)&v42.line_ = *(_QWORD *)(v18 + 16);
      }
      v42.filename_ = *(const char **)(v18 + 8);
      *(_BYTE *)(v18 + 16) = 0;
      v19 = this->builder_;
      *(_QWORD *)v18 = v18 + 16;
      uninterpreted_option = this->uninterpreted_option_;
      *(_QWORD *)(v18 + 8) = 0LL;
      google::protobuf::DescriptorBuilder::AddError(
        (__int64)v19,
        &this->options_to_interpret_->element_name,
        (__int64)uninterpreted_option,
        8u,
        (const std::string *)&v42);
      if ( *(google::protobuf::internal::LogMessage_0 **)&v42.level_ != (google::protobuf::internal::LogMessage_0 *)&v42.line_ )
        operator delete(*(void **)&v42.level_);
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)output._M_dataplus._M_p != &output._anon_0 )
        operator delete(output._M_dataplus._M_p);
      M_p = v39._M_dataplus._M_p;
      if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v39._M_dataplus._M_p == &v39._anon_0 )
        goto LABEL_20;
      goto LABEL_19;
    }
    output._M_string_length = 0LL;
    output._M_dataplus._M_p = output._anon_0._M_local_buf;
    output._anon_0._M_local_buf[0] = 0;
    google::protobuf::MessageLite::SerializeToString(v6, &output);
    v10 = a2->type_once_;
    if ( v10 )
    {
      if ( v10->state_ != 2 )
      {
        LOBYTE(v42.line_) = 0;
        v42.message_._M_dataplus._M_p = (std::string::pointer)a2;
        *(_QWORD *)&v42.level_ = &off_1A17BF90;
        v42.filename_ = (const char *)google::protobuf::FieldDescriptor::TypeOnceInit;
        google::protobuf::GoogleOnceInitImpl(&v10->state_, (google::protobuf::Closure *)&v42);
        *(_QWORD *)&v42.level_ = &off_1A17BF90;
        google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&v42);
      }
      type = a2->type_;
      if ( type != TYPE_MESSAGE_0 )
      {
        v12 = a2->type_once_;
        if ( v12 )
        {
          if ( v12->state_ != 2 )
          {
            LOBYTE(v42.line_) = 0;
            v42.message_._M_dataplus._M_p = (std::string::pointer)a2;
            *(_QWORD *)&v42.level_ = &off_1A17BF90;
            v42.filename_ = (const char *)google::protobuf::FieldDescriptor::TypeOnceInit;
            google::protobuf::GoogleOnceInitImpl(&v12->state_, (google::protobuf::Closure *)&v42);
            *(_QWORD *)&v42.level_ = &off_1A17BF90;
            google::protobuf::Closure::~Closure((google::protobuf::Closure *const)&v42);
          }
          type = a2->type_;
        }
        goto LABEL_15;
      }
    }
    else
    {
      type = a2->type_;
      if ( type != TYPE_MESSAGE_0 )
      {
LABEL_15:
        if ( type != TYPE_GROUP_0 )
        {
          google::protobuf::internal::LogMessage::LogMessage(
            &v42,
            LOGLEVEL_FATAL_0,
            "google/protobuf/descriptor.cc",
            6634);
          v32 = google::protobuf::internal::LogMessage::operator<<(
                  &v42,
                  "CHECK failed: (option_field->type()) == (FieldDescriptor::TYPE_GROUP): ");
          google::protobuf::internal::LogFinisher::operator=((google::protobuf::internal::LogFinisher *const)&v39, v32);
          google::protobuf::internal::LogMessage::~LogMessage(&v42);
        }
        v13 = google::protobuf::UnknownFieldSet::AddGroup(a3, a2->number_);
        google::protobuf::UnknownFieldSet::ParseFromArray(v13, output._M_dataplus._M_p, output._M_string_length);
LABEL_18:
        M_p = output._M_dataplus._M_p;
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)output._M_dataplus._M_p == &output._anon_0 )
        {
LABEL_20:
          google::protobuf::TextFormat::Parser::~Parser(&v38);
          v37._M_dataplus._M_p = (std::string::pointer)off_1A17BF40;
          google::protobuf::TextFormat::Finder::~Finder((google::protobuf::TextFormat::Finder *const)&v37);
          v41._M_dataplus._M_p = (std::string::pointer)off_1A17BAB0;
          if ( (std::string::size_type *)v41._M_string_length != &v41._anon_0._M_allocated_capacity + 1 )
            operator delete((void *)v41._M_string_length);
          google::protobuf::io::ErrorCollector::~ErrorCollector((google::protobuf::io::ErrorCollector *const)&v41);
          if ( v6 )
            (*((void (__fastcall **)(google::protobuf::Message *))v6->_vptr_MessageLite + 1))(v6);
          return v9;
        }
LABEL_19:
        operator delete(M_p);
        goto LABEL_20;
      }
    }
    v31 = google::protobuf::UnknownFieldSet::AddLengthDelimited[abi:cxx11](a3, a2->number_);
    std::string::_M_assign(v31, &output);
    goto LABEL_18;
  }
  name = a2->name_;
  std::operator+<char>(&v37, "Option \"", a2->full_name_);
  if ( 0x3FFFFFFFFFFFFFFFLL - v37._M_string_length <= 0x3B )
    std::__throw_length_error("basic_string::append");
  v22 = std::string::_M_append(&v37, "\" is a message. To set the entire message, use syntax like \"", 60LL);
  v38.error_collector_ = (google::protobuf::io::ErrorCollector *)&v38.parse_info_tree_;
  if ( *(_QWORD *)v22 == v22 + 16 )
  {
    *(__m128i *)&v38.parse_info_tree_ = _mm_loadu_si128((const __m128i *)(v22 + 16));
  }
  else
  {
    v38.error_collector_ = *(google::protobuf::io::ErrorCollector **)v22;
    v38.parse_info_tree_ = *(google::protobuf::TextFormat::ParseInfoTree **)(v22 + 16);
  }
  v38.finder_ = *(google::protobuf::TextFormat::Finder **)(v22 + 8);
  *(_QWORD *)v22 = v22 + 16;
  *(_BYTE *)(v22 + 16) = 0;
  v23 = name->_M_dataplus._M_p;
  *(_QWORD *)(v22 + 8) = 0LL;
  v24 = std::string::_M_append(&v38, v23, name->_M_string_length);
  v39._M_dataplus._M_p = v39._anon_0._M_local_buf;
  if ( *(_QWORD *)v24 == v24 + 16 )
  {
    v39._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v24 + 16));
  }
  else
  {
    v39._M_dataplus._M_p = *(std::string::pointer *)v24;
    v39._anon_0._M_allocated_capacity = *(_QWORD *)(v24 + 16);
  }
  v39._M_string_length = *(_QWORD *)(v24 + 8);
  *(_QWORD *)(v24 + 8) = 0LL;
  *(_BYTE *)(v24 + 16) = 0;
  *(_QWORD *)v24 = v24 + 16;
  if ( 0x3FFFFFFFFFFFFFFFLL - v39._M_string_length <= 0x46 )
    std::__throw_length_error("basic_string::append");
  v25 = std::string::_M_append(&v39, " = { <proto text format> }\". To set fields within it, use syntax like \"", 71LL);
  output._M_dataplus._M_p = output._anon_0._M_local_buf;
  if ( *(_QWORD *)v25 == v25 + 16 )
  {
    output._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v25 + 16));
  }
  else
  {
    output._M_dataplus._M_p = *(std::string::pointer *)v25;
    output._anon_0._M_allocated_capacity = *(_QWORD *)(v25 + 16);
  }
  output._M_string_length = *(_QWORD *)(v25 + 8);
  *(_QWORD *)v25 = v25 + 16;
  *(_BYTE *)(v25 + 16) = 0;
  v26 = name->_M_dataplus._M_p;
  *(_QWORD *)(v25 + 8) = 0LL;
  v27 = std::string::_M_append(&output, v26, name->_M_string_length);
  v41._M_dataplus._M_p = v41._anon_0._M_local_buf;
  if ( *(_QWORD *)v27 == v27 + 16 )
  {
    v41._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v27 + 16));
  }
  else
  {
    v41._M_dataplus._M_p = *(std::string::pointer *)v27;
    v41._anon_0._M_allocated_capacity = *(_QWORD *)(v27 + 16);
  }
  v41._M_string_length = *(_QWORD *)(v27 + 8);
  *(_QWORD *)(v27 + 8) = 0LL;
  *(_BYTE *)(v27 + 16) = 0;
  *(_QWORD *)v27 = v27 + 16;
  if ( 0x3FFFFFFFFFFFFFFFLL - v41._M_string_length <= 0xD )
    std::__throw_length_error("basic_string::append");
  v28 = std::string::_M_append(&v41, ".foo = value\".", 14LL);
  *(_QWORD *)&v42.level_ = &v42.line_;
  if ( *(_QWORD *)v28 == v28 + 16 )
  {
    *(__m128i *)&v42.line_ = _mm_loadu_si128((const __m128i *)(v28 + 16));
  }
  else
  {
    *(_QWORD *)&v42.level_ = *(_QWORD *)v28;
    *(_QWORD *)&v42.line_ = *(_QWORD *)(v28 + 16);
  }
  v42.filename_ = *(const char **)(v28 + 8);
  *(_BYTE *)(v28 + 16) = 0;
  v29 = this->builder_;
  *(_QWORD *)v28 = v28 + 16;
  v30 = this->uninterpreted_option_;
  *(_QWORD *)(v28 + 8) = 0LL;
  google::protobuf::DescriptorBuilder::AddError(
    (__int64)v29,
    &this->options_to_interpret_->element_name,
    (__int64)v30,
    8u,
    (const std::string *)&v42);
  if ( *(google::protobuf::internal::LogMessage_0 **)&v42.level_ != (google::protobuf::internal::LogMessage_0 *)&v42.line_ )
    operator delete(*(void **)&v42.level_);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v41._M_dataplus._M_p != &v41._anon_0 )
    operator delete(v41._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)output._M_dataplus._M_p != &output._anon_0 )
    operator delete(output._M_dataplus._M_p);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v39._M_dataplus._M_p != &v39._anon_0 )
    operator delete(v39._M_dataplus._M_p);
  if ( (google::protobuf::TextFormat::ParseInfoTree **)v38.error_collector_ != &v38.parse_info_tree_ )
    operator delete(v38.error_collector_);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v37._M_dataplus._M_p != &v37._anon_0 )
    operator delete(v37._M_dataplus._M_p);
  return 0;
};

// Line 6643: range 000000000C8F5E10-000000000C8F5EB6
void __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::SetInt32(
        google::protobuf::DescriptorBuilder::OptionInterpreter *this,
        int a2,
        signed int a3,
        int a4,
        google::protobuf::UnknownFieldSet *a5)
{
  google::protobuf::internal::LogMessage_0 *v6; // rax
  google::protobuf::internal::LogMessage_0 *v7; // rax
  google::protobuf::internal::LogFinisher v8; // [rsp+Fh] [rbp-49h] BYREF
  google::protobuf::internal::LogMessage_0 v9; // [rsp+10h] [rbp-48h] BYREF

  switch ( a4 )
  {
    case 15:
      google::protobuf::UnknownFieldSet::AddFixed32(a5, a2, a3);
      break;
    case 17:
      google::protobuf::UnknownFieldSet::AddVarint(a5, a2, (2 * a3) ^ (unsigned int)(a3 >> 31));
      break;
    case 5:
      google::protobuf::UnknownFieldSet::AddVarint(a5, a2, a3);
      break;
    default:
      google::protobuf::internal::LogMessage::LogMessage(&v9, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6660);
      v6 = google::protobuf::internal::LogMessage::operator<<(&v9, "Invalid wire type for CPPTYPE_INT32: ");
      v7 = google::protobuf::internal::LogMessage::operator<<(v6, a4);
      google::protobuf::internal::LogFinisher::operator=(&v8, v7);
      google::protobuf::internal::LogMessage::~LogMessage(&v9);
      break;
  }
};

// Line 6660: range 000000000C72D542-000000000C72D54F
void __fastcall __noreturn google::protobuf::DescriptorBuilder::OptionInterpreter::SetInt32(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 6666: range 000000000C8F5EC0-000000000C8F5F5E
void __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::SetInt64(
        google::protobuf::DescriptorBuilder::OptionInterpreter *this,
        int a2,
        __int64 a3,
        int a4,
        google::protobuf::UnknownFieldSet *a5)
{
  google::protobuf::internal::LogMessage_0 *v6; // rax
  google::protobuf::internal::LogMessage_0 *v7; // rax
  google::protobuf::internal::LogFinisher v8; // [rsp+Fh] [rbp-49h] BYREF
  google::protobuf::internal::LogMessage_0 v9; // [rsp+10h] [rbp-48h] BYREF

  if ( a4 == 16 )
  {
    google::protobuf::UnknownFieldSet::AddFixed64(a5, a2, a3);
  }
  else
  {
    if ( a4 == 18 )
    {
      a3 = (2 * a3) ^ (a3 >> 63);
    }
    else if ( a4 != 3 )
    {
      google::protobuf::internal::LogMessage::LogMessage(&v9, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6682);
      v6 = google::protobuf::internal::LogMessage::operator<<(&v9, "Invalid wire type for CPPTYPE_INT64: ");
      v7 = google::protobuf::internal::LogMessage::operator<<(v6, a4);
      google::protobuf::internal::LogFinisher::operator=(&v8, v7);
      google::protobuf::internal::LogMessage::~LogMessage(&v9);
      return;
    }
    google::protobuf::UnknownFieldSet::AddVarint(a5, a2, a3);
  }
};

// Line 6682: range 000000000C72D554-000000000C72D561
void __fastcall __noreturn google::protobuf::DescriptorBuilder::OptionInterpreter::SetInt64(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 6688: range 000000000C8F5F70-000000000C8F6002
void __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::SetUInt32(
        google::protobuf::DescriptorBuilder::OptionInterpreter *this,
        int a2,
        google::protobuf::uint32 a3,
        int a4,
        google::protobuf::UnknownFieldSet *a5)
{
  google::protobuf::internal::LogMessage_0 *v6; // rax
  google::protobuf::internal::LogMessage_0 *v7; // rax
  google::protobuf::internal::LogFinisher v8; // [rsp+Fh] [rbp-49h] BYREF
  google::protobuf::internal::LogMessage_0 v9; // [rsp+10h] [rbp-48h] BYREF

  if ( a4 == 7 )
  {
    google::protobuf::UnknownFieldSet::AddFixed32(a5, a2, a3);
  }
  else if ( a4 == 13 )
  {
    google::protobuf::UnknownFieldSet::AddVarint(a5, a2, a3);
  }
  else
  {
    google::protobuf::internal::LogMessage::LogMessage(&v9, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6699);
    v6 = google::protobuf::internal::LogMessage::operator<<(&v9, "Invalid wire type for CPPTYPE_UINT32: ");
    v7 = google::protobuf::internal::LogMessage::operator<<(v6, a4);
    google::protobuf::internal::LogFinisher::operator=(&v8, v7);
    google::protobuf::internal::LogMessage::~LogMessage(&v9);
  }
};

// Line 6699: range 000000000C72D566-000000000C72D573
void __fastcall __noreturn google::protobuf::DescriptorBuilder::OptionInterpreter::SetUInt32(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 6705: range 000000000C8F6010-000000000C8F6091
void __fastcall google::protobuf::DescriptorBuilder::OptionInterpreter::SetUInt64(
        google::protobuf::DescriptorBuilder::OptionInterpreter *this,
        int a2,
        google::protobuf::uint64 a3,
        int a4,
        google::protobuf::UnknownFieldSet *a5)
{
  google::protobuf::internal::LogMessage_0 *v6; // rax
  google::protobuf::internal::LogMessage_0 *v7; // rax
  google::protobuf::internal::LogFinisher v8; // [rsp+Fh] [rbp-49h] BYREF
  google::protobuf::internal::LogMessage_0 v9; // [rsp+10h] [rbp-48h] BYREF

  if ( a4 == 4 )
  {
    google::protobuf::UnknownFieldSet::AddVarint(a5, a2, a3);
  }
  else if ( a4 == 6 )
  {
    google::protobuf::UnknownFieldSet::AddFixed64(a5, a2, a3);
  }
  else
  {
    google::protobuf::internal::LogMessage::LogMessage(&v9, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6716);
    v6 = google::protobuf::internal::LogMessage::operator<<(&v9, "Invalid wire type for CPPTYPE_UINT64: ");
    v7 = google::protobuf::internal::LogMessage::operator<<(v6, a4);
    google::protobuf::internal::LogFinisher::operator=(&v8, v7);
    google::protobuf::internal::LogMessage::~LogMessage(&v9);
  }
};

// Line 6716: range 000000000C72D578-000000000C72D585
void __fastcall __noreturn google::protobuf::DescriptorBuilder::OptionInterpreter::SetUInt64(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 6722: range 000000000C8FA6B0-000000000C8FAAF8
void __fastcall google::protobuf::DescriptorBuilder::LogUnusedDependency(
        google::protobuf::DescriptorBuilder *this,
        const google::protobuf::FileDescriptorProto *a2,
        const google::protobuf::FileDescriptor *a3,
        std::forward_iterator_tag a4)
{
  std::forward_iterator_tag v4; // cl
  std::forward_iterator_tag v5; // cl
  std::forward_iterator_tag v6; // cl
  std::forward_iterator_tag v7; // cl
  std::forward_iterator_tag v8; // cl
  std::forward_iterator_tag v9; // cl
  std::forward_iterator_tag v10; // cl
  std::forward_iterator_tag v11; // cl
  std::_Rb_tree_node_base::_Base_ptr i; // rbp
  __int64 v13; // rax
  int v14; // esi
  __int64 v15; // r14
  int v16; // r15d
  __int64 v17; // rax
  std::string::size_type v18; // rcx
  std::string *M_p; // rdi
  std::string v22; // [rsp+20h] [rbp-A8h] BYREF
  std::string __v; // [rsp+40h] [rbp-88h] BYREF
  std::_Rb_tree<std::string,std::string,std::_Identity<std::string >,std::less<std::string >,std::allocator<std::string > > v24; // [rsp+60h] [rbp-68h] BYREF

  if ( this->unused_dependency_._M_t._M_impl._M_node_count )
  {
    v24._M_impl._M_header._M_left = &v24._M_impl._M_header;
    v24._M_impl._M_header._M_color = _S_red;
    v24._M_impl._M_header._M_parent = 0LL;
    v24._M_impl._M_header._M_right = &v24._M_impl._M_header;
    v24._M_impl._M_node_count = 0LL;
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&__v, "google.protobuf.MessageOptions", "", a4);
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v24,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&__v, "google.protobuf.FileOptions", "", v4);
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v24,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&__v, "google.protobuf.FieldOptions", "", v5);
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v24,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&__v, "google.protobuf.EnumOptions", "", v6);
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v24,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&__v, "google.protobuf.EnumValueOptions", "", v7);
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v24,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&__v, "google.protobuf.EnumValueOptions", "", v8);
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v24,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&__v, "google.protobuf.ServiceOptions", "", v9);
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v24,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&__v, "google.protobuf.MethodOptions", "", v10);
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v24,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    __v._M_dataplus._M_p = __v._anon_0._M_local_buf;
    std::string::_M_construct<char const*>(&__v, "google.protobuf.StreamOptions", "", v11);
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_insert_unique<std::string>(
      &v24,
      &__v);
    if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__v._M_dataplus._M_p != &__v._anon_0 )
      operator delete(__v._M_dataplus._M_p);
    for ( i = this->unused_dependency_._M_t._M_impl._M_header._M_left;
          i != (std::_Rb_tree_node_base::_Base_ptr)&this->unused_dependency_._M_t._M_impl.std::_Rb_tree_header;
          i = (std::_Rb_tree_node_base::_Base_ptr)std::_Rb_tree_increment(i) )
    {
      v13 = *(_QWORD *)&i[1]._M_color;
      v14 = *(_DWORD *)(v13 + 56);
      if ( v14 <= 0 )
      {
        v16 = 0;
      }
      else
      {
        v15 = 0LL;
        v16 = 0;
        while ( &v24._M_impl.std::_Rb_tree_header == (std::_Rb_tree_header *)std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::find(
                                                                               &v24,
                                                                               *(const std::string **)(*(_QWORD *)(*(_QWORD *)(v13 + 128) + v15 + 80) + 8LL))._M_node )
        {
          v13 = *(_QWORD *)&i[1]._M_color;
          ++v16;
          v15 += 152LL;
          v14 = *(_DWORD *)(v13 + 56);
          if ( v16 >= v14 )
            goto LABEL_26;
        }
        v13 = *(_QWORD *)&i[1]._M_color;
        v14 = *(_DWORD *)(v13 + 56);
      }
LABEL_26:
      if ( v14 == v16 )
      {
        std::operator+<char>(&__v, "Import ", *(const std::string **)v13);
        if ( 0x3FFFFFFFFFFFFFFFLL - __v._M_string_length <= 0xD )
          std::__throw_length_error("basic_string::append");
        v17 = std::string::_M_append(&__v, " but not used.", 14LL);
        v22._M_dataplus._M_p = v22._anon_0._M_local_buf;
        if ( *(_QWORD *)v17 == v17 + 16 )
        {
          v22._anon_0 = (std::string::$CFBEC286C7F52157F7E59FC354047095)_mm_loadu_si128((const __m128i *)(v17 + 16));
        }
        else
        {
          v22._M_dataplus._M_p = *(std::string::pointer *)v17;
          v22._anon_0._M_allocated_capacity = *(_QWORD *)(v17 + 16);
        }
        v18 = *(_QWORD *)(v17 + 8);
        *(_BYTE *)(v17 + 16) = 0;
        v22._M_string_length = v18;
        *(_QWORD *)v17 = v17 + 16;
        M_p = (std::string *)__v._M_dataplus._M_p;
        *(_QWORD *)(v17 + 8) = 0LL;
        if ( M_p != (std::string *)&__v._anon_0 )
          operator delete(M_p);
        google::protobuf::DescriptorBuilder::AddWarning(
          (__int64)this,
          **(const std::string ***)&i[1]._M_color,
          a2,
          OTHER,
          &v22);
        if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v22._M_dataplus._M_p != &v22._anon_0 )
          operator delete(v22._M_dataplus._M_p);
      }
    }
    std::_Rb_tree<std::string,std::string,std::_Identity<std::string>,std::less<std::string>,std::allocator<std::string>>::_M_erase(
      &v24,
      (std::_Rb_tree<std::string,std::string,std::_Identity<std::string >,std::less<std::string >,std::allocator<std::string > >::_Link_type)v24._M_impl._M_header._M_parent);
  }
};

// Line 6758: range 000000000C9135A0-000000000C913702
__int64 __fastcall google::protobuf::DescriptorPool::CrossLinkOnDemandHelper(
        __int64 a1,
        char **a2,
        __int64 a3,
        std::forward_iterator_tag a4)
{
  char *v5; // rdx
  char *v6; // rsi
  std::forward_iterator_tag v7; // cl
  unsigned int v8; // r13d
  std::string::$CFBEC286C7F52157F7E59FC354047095 *M_p; // rdi
  std::string::size_type M_string_length; // rdx
  std::string::size_type M_allocated_capacity; // rsi
  std::string dest; // [rsp+0h] [rbp-68h] BYREF
  std::string src; // [rsp+20h] [rbp-48h] BYREF

  v5 = &a2[1][(_QWORD)*a2];
  v6 = *a2;
  dest._M_dataplus._M_p = dest._anon_0._M_local_buf;
  std::string::_M_construct<char *>(&dest, v6, v5, a4);
  if ( !dest._M_string_length || *dest._M_dataplus._M_p != 46 )
    goto LABEL_3;
  src._M_dataplus._M_p = src._anon_0._M_local_buf;
  std::string::_M_construct<char const*>(
    &src,
    (const char *)dest._M_dataplus._M_p + 1,
    &dest._M_dataplus._M_p[dest._M_string_length],
    v7);
  M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)dest._M_dataplus._M_p;
  M_string_length = src._M_string_length;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)src._M_dataplus._M_p == &src._anon_0 )
  {
    if ( src._M_string_length )
    {
      if ( src._M_string_length == 1 )
        *dest._M_dataplus._M_p = src._anon_0._M_local_buf[0];
      else
        memcpy(dest._M_dataplus._M_p, &src._anon_0, src._M_string_length);
      M_string_length = src._M_string_length;
      M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)dest._M_dataplus._M_p;
    }
    dest._M_string_length = M_string_length;
    M_p->_M_local_buf[M_string_length] = 0;
    M_p = (std::string::$CFBEC286C7F52157F7E59FC354047095 *)src._M_dataplus._M_p;
    goto LABEL_10;
  }
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)dest._M_dataplus._M_p == &dest._anon_0 )
  {
    dest._M_dataplus._M_p = src._M_dataplus._M_p;
    dest._M_string_length = src._M_string_length;
    dest._anon_0._M_allocated_capacity = src._anon_0._M_allocated_capacity;
  }
  else
  {
    M_allocated_capacity = dest._anon_0._M_allocated_capacity;
    dest._M_dataplus._M_p = src._M_dataplus._M_p;
    dest._M_string_length = src._M_string_length;
    dest._anon_0._M_allocated_capacity = src._anon_0._M_allocated_capacity;
    if ( M_p )
    {
      src._M_dataplus._M_p = (std::string::pointer)M_p;
      src._anon_0._M_allocated_capacity = M_allocated_capacity;
      goto LABEL_10;
    }
  }
  src._M_dataplus._M_p = src._anon_0._M_local_buf;
  M_p = &src._anon_0;
LABEL_10:
  src._M_string_length = 0LL;
  M_p->_M_local_buf[0] = 0;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)src._M_dataplus._M_p != &src._anon_0 )
    operator delete(src._M_dataplus._M_p);
LABEL_3:
  v8 = google::protobuf::DescriptorPool::Tables::FindByNameHelper(
         *(_QWORD *)(a1 + 32),
         (google::protobuf::DescriptorPool *)a1,
         &dest);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)dest._M_dataplus._M_p != &dest._anon_0 )
    operator delete(dest._M_dataplus._M_p);
  return v8;
};

// Line 6771: range 000000000C913710-000000000C913B63
void __fastcall google::protobuf::FieldDescriptor::InternalTypeOnceInit(
        google::protobuf::FieldDescriptor *this,
        __int64 a2,
        __int64 a3,
        std::forward_iterator_tag a4)
{
  std::string *type_name; // rsi
  int v6; // eax
  const google::protobuf::EnumDescriptor *enum_type; // rdx
  const std::string *full_name; // rax
  std::string::size_type M_string_length; // rax
  std::forward_iterator_tag v10; // cl
  const std::string *default_value_enum_name; // r13
  __m128i *v12; // rax
  const char *M_p; // rsi
  __m128i *v14; // rax
  const char *v15; // rcx
  std::string *p_line; // rdi
  std::string::size_type M_allocated_capacity; // rsi
  google::protobuf::int64 v18; // rdx
  google::protobuf::internal::LogMessage_0 *v19; // rax
  google::protobuf::internal::LogMessage_0 *v20; // rax
  const char *filename; // rdx
  std::string __beg; // [rsp+0h] [rbp-C8h] BYREF
  std::string v23; // [rsp+20h] [rbp-A8h] BYREF
  google::protobuf::internal::LogFinisher v24[8]; // [rsp+40h] [rbp-88h] BYREF
  __int64 v25; // [rsp+48h] [rbp-80h]
  __m128i v26; // [rsp+50h] [rbp-78h] BYREF
  google::protobuf::internal::LogMessage_0 src; // [rsp+60h] [rbp-68h] BYREF

  if ( !this->file_->finished_building_ )
  {
    google::protobuf::internal::LogMessage::LogMessage(&src, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6772);
    v19 = google::protobuf::internal::LogMessage::operator<<(&src, "CHECK failed: file()->finished_building_ == true: ");
    google::protobuf::internal::LogFinisher::operator=(v24, v19);
    google::protobuf::internal::LogMessage::~LogMessage(&src);
  }
  type_name = (std::string *)this->type_name_;
  if ( type_name )
  {
    v6 = google::protobuf::DescriptorPool::CrossLinkOnDemandHelper(
           (__int64)this->file_->pool_,
           &type_name->_M_dataplus._M_p,
           this->type_ == TYPE_ENUM_0,
           a4);
    if ( v6 == 1 )
    {
      this->type_ = TYPE_MESSAGE_0;
      this->message_type_ = (const google::protobuf::Descriptor *)enum_type;
    }
    else if ( v6 == 4 )
    {
      this->type_ = TYPE_ENUM_0;
      this->enum_type_ = enum_type;
      goto LABEL_7;
    }
  }
  enum_type = this->enum_type_;
LABEL_7:
  if ( !enum_type || this->_anon_0.default_value_int64_ )
    return;
  if ( !this->default_value_enum_name_ )
    goto LABEL_35;
  full_name = enum_type->full_name_;
  __beg._M_dataplus._M_p = __beg._anon_0._M_local_buf;
  std::string::_M_construct<char *>(
    &__beg,
    full_name->_M_dataplus._M_p,
    &full_name->_M_dataplus._M_p[full_name->_M_string_length],
    a4);
  M_string_length = std::string::rfind(&__beg, 46LL, -1LL);
  if ( M_string_length == -1LL )
  {
    std::string::_M_assign(&__beg, this->default_value_enum_name_);
    goto LABEL_29;
  }
  v23._M_dataplus._M_p = v23._anon_0._M_local_buf;
  default_value_enum_name = this->default_value_enum_name_;
  if ( M_string_length > __beg._M_string_length )
    M_string_length = __beg._M_string_length;
  std::string::_M_construct<char const*>(&v23, __beg._M_dataplus._M_p, &__beg._M_dataplus._M_p[M_string_length], v10);
  if ( v23._M_string_length == 0x3FFFFFFFFFFFFFFFLL )
    std::__throw_length_error("basic_string::append");
  v12 = (__m128i *)std::string::_M_append(&v23, ".", 1LL);
  *(_QWORD *)v24[0].gap0 = &v26;
  if ( (__m128i *)v12->m128i_i64[0] == &v12[1] )
  {
    v26 = _mm_loadu_si128(v12 + 1);
  }
  else
  {
    *(_QWORD *)v24[0].gap0 = v12->m128i_i64[0];
    v26.m128i_i64[0] = v12[1].m128i_i64[0];
  }
  v25 = v12->m128i_i64[1];
  v12->m128i_i64[0] = (__int64)v12[1].m128i_i64;
  v12[1].m128i_i8[0] = 0;
  M_p = default_value_enum_name->_M_dataplus._M_p;
  v12->m128i_i64[1] = 0LL;
  v14 = (__m128i *)std::string::_M_append(v24, M_p, default_value_enum_name->_M_string_length);
  *(_QWORD *)&src.level_ = &src.line_;
  if ( (__m128i *)v14->m128i_i64[0] == &v14[1] )
  {
    *(__m128i *)&src.line_ = _mm_loadu_si128(v14 + 1);
  }
  else
  {
    *(_QWORD *)&src.level_ = v14->m128i_i64[0];
    *(_QWORD *)&src.line_ = v14[1].m128i_i64[0];
  }
  v15 = (const char *)v14->m128i_i64[1];
  src.filename_ = v15;
  v14->m128i_i64[0] = (__int64)v14[1].m128i_i64;
  p_line = (std::string *)__beg._M_dataplus._M_p;
  v14->m128i_i64[1] = 0LL;
  v14[1].m128i_i8[0] = 0;
  if ( *(google::protobuf::internal::LogMessage_0 **)&src.level_ == (google::protobuf::internal::LogMessage_0 *)&src.line_ )
  {
    filename = src.filename_;
    if ( src.filename_ )
    {
      if ( src.filename_ == (const char *)1 )
        LOBYTE(p_line->_M_dataplus._M_p) = src.line_;
      else
        memcpy(p_line, &src.line_, (size_t)src.filename_);
      filename = src.filename_;
      p_line = (std::string *)__beg._M_dataplus._M_p;
    }
    __beg._M_string_length = (std::string::size_type)filename;
    filename[(_QWORD)p_line] = 0;
    p_line = *(std::string **)&src.level_;
    goto LABEL_23;
  }
  LOBYTE(v15) = src.filename_;
  if ( p_line == (std::string *)&__beg._anon_0 )
  {
    __beg._M_dataplus._M_p = *(std::string::pointer *)&src.level_;
    __beg._M_string_length = (std::string::size_type)src.filename_;
    __beg._anon_0._M_allocated_capacity = *(_QWORD *)&src.line_;
    goto LABEL_41;
  }
  M_allocated_capacity = __beg._anon_0._M_allocated_capacity;
  __beg._M_dataplus._M_p = *(std::string::pointer *)&src.level_;
  __beg._M_string_length = (std::string::size_type)src.filename_;
  __beg._anon_0._M_allocated_capacity = *(_QWORD *)&src.line_;
  if ( !p_line )
  {
LABEL_41:
    *(_QWORD *)&src.level_ = &src.line_;
    p_line = (std::string *)&src.line_;
    goto LABEL_23;
  }
  *(_QWORD *)&src.level_ = p_line;
  *(_QWORD *)&src.line_ = M_allocated_capacity;
LABEL_23:
  src.filename_ = 0LL;
  LOBYTE(p_line->_M_dataplus._M_p) = 0;
  if ( *(google::protobuf::internal::LogMessage_0 **)&src.level_ != (google::protobuf::internal::LogMessage_0 *)&src.line_ )
    operator delete(*(void **)&src.level_);
  if ( *(__m128i **)v24[0].gap0 != &v26 )
    operator delete(*(void **)v24[0].gap0);
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)v23._M_dataplus._M_p != &v23._anon_0 )
    operator delete(v23._M_dataplus._M_p);
LABEL_29:
  if ( (unsigned int)google::protobuf::DescriptorPool::CrossLinkOnDemandHelper(
                       (__int64)this->file_->pool_,
                       &__beg._M_dataplus._M_p,
                       1LL,
                       (std::forward_iterator_tag)v15) == 5 )
    this->_anon_0.default_value_int64_ = v18;
  if ( (std::string::$CFBEC286C7F52157F7E59FC354047095 *)__beg._M_dataplus._M_p != &__beg._anon_0 )
    operator delete(__beg._M_dataplus._M_p);
  if ( !this->_anon_0.default_value_int64_ )
  {
    enum_type = this->enum_type_;
LABEL_35:
    if ( !enum_type->value_count_ )
    {
      google::protobuf::internal::LogMessage::LogMessage(&src, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6804);
      v20 = google::protobuf::internal::LogMessage::operator<<(&src, "CHECK failed: enum_type_->value_count(): ");
      google::protobuf::internal::LogFinisher::operator=(v24, v20);
      google::protobuf::internal::LogMessage::~LogMessage(&src);
      enum_type = this->enum_type_;
    }
    this->_anon_0.default_value_int64_ = (google::protobuf::int64)enum_type->values_;
  }
};

// Line 6811: range 000000000C913B70-000000000C913C1A
// attributes: thunk
void __fastcall google::protobuf::FieldDescriptor::TypeOnceInit(const google::protobuf::FieldDescriptor *to_init)
{
  __int64 v1; // rdx
  std::forward_iterator_tag v2; // cl
  __int64 v3; // rsi

  google::protobuf::FieldDescriptor::InternalTypeOnceInit((google::protobuf::FieldDescriptor *)to_init, v3, v1, v2);
};

// Line 6817: range 000000000C8F60A0-000000000C8F6111
const google::protobuf::Descriptor *__fastcall google::protobuf::FieldDescriptor::message_type(
        google::protobuf::FieldDescriptor *this)
{
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  google::protobuf::Closure v4[2]; // [rsp+0h] [rbp-38h] BYREF
  char v5; // [rsp+10h] [rbp-28h]
  google::protobuf::FieldDescriptor *v6; // [rsp+18h] [rbp-20h]

  type_once = this->type_once_;
  if ( !type_once || type_once->state_ == 2 )
    return this->message_type_;
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BF90;
  v4[1]._vptr_Closure = (int (**)(...))google::protobuf::FieldDescriptor::TypeOnceInit;
  v5 = 0;
  v6 = this;
  google::protobuf::GoogleOnceInitImpl(&type_once->state_, v4);
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BF90;
  google::protobuf::Closure::~Closure(v4);
  return this->message_type_;
};

// Line 6824: range 000000000C8F6120-000000000C8F6191
const google::protobuf::EnumDescriptor *__fastcall google::protobuf::FieldDescriptor::enum_type(
        google::protobuf::FieldDescriptor *this)
{
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  google::protobuf::Closure v4[2]; // [rsp+0h] [rbp-38h] BYREF
  char v5; // [rsp+10h] [rbp-28h]
  google::protobuf::FieldDescriptor *v6; // [rsp+18h] [rbp-20h]

  type_once = this->type_once_;
  if ( !type_once || type_once->state_ == 2 )
    return this->enum_type_;
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BF90;
  v4[1]._vptr_Closure = (int (**)(...))google::protobuf::FieldDescriptor::TypeOnceInit;
  v5 = 0;
  v6 = this;
  google::protobuf::GoogleOnceInitImpl(&type_once->state_, v4);
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BF90;
  google::protobuf::Closure::~Closure(v4);
  return this->enum_type_;
};

// Line 6831: range 000000000C8F61A0-000000000C8F6214
google::protobuf::int64 __fastcall google::protobuf::FieldDescriptor::default_value_enum(
        google::protobuf::FieldDescriptor *this)
{
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  google::protobuf::Closure v4[2]; // [rsp+0h] [rbp-38h] BYREF
  char v5; // [rsp+10h] [rbp-28h]
  google::protobuf::FieldDescriptor *v6; // [rsp+18h] [rbp-20h]

  type_once = this->type_once_;
  if ( !type_once || type_once->state_ == 2 )
    return this->_anon_0.default_value_int64_;
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BF90;
  v4[1]._vptr_Closure = (int (**)(...))google::protobuf::FieldDescriptor::TypeOnceInit;
  v5 = 0;
  v6 = this;
  google::protobuf::GoogleOnceInitImpl(&type_once->state_, v4);
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BF90;
  google::protobuf::Closure::~Closure(v4);
  return this->_anon_0.default_value_int64_;
};

// Line 6838: range 000000000C8F6220-000000000C8F6288
__int64 __fastcall google::protobuf::FieldDescriptor::type(google::protobuf::FieldDescriptor *this)
{
  google::protobuf::GoogleOnceDynamic *type_once; // rdi
  google::protobuf::Closure v4[2]; // [rsp+0h] [rbp-38h] BYREF
  char v5; // [rsp+10h] [rbp-28h]
  google::protobuf::FieldDescriptor *v6; // [rsp+18h] [rbp-20h]

  type_once = this->type_once_;
  if ( !type_once || type_once->state_ == 2 )
    return (unsigned int)this->type_;
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BF90;
  v4[1]._vptr_Closure = (int (**)(...))google::protobuf::FieldDescriptor::TypeOnceInit;
  v5 = 0;
  v6 = this;
  google::protobuf::GoogleOnceInitImpl(&type_once->state_, v4);
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BF90;
  google::protobuf::Closure::~Closure(v4);
  return (unsigned int)this->type_;
};

// Line 6845: range 000000000C913040-000000000C9130F7
__int64 __fastcall google::protobuf::FileDescriptor::InternalDependenciesOnceInit(
        google::protobuf::FileDescriptor *this)
{
  __int64 result; // rax
  __int64 v2; // rbx
  std::string *v3; // rsi
  _QWORD *v4; // r12
  google::protobuf::internal::LogMessage_0 *v5; // rax
  google::protobuf::internal::LogFinisher v6; // [rsp+Fh] [rbp-59h] BYREF
  google::protobuf::internal::LogMessage_0 v7; // [rsp+10h] [rbp-58h] BYREF

  if ( !this->finished_building_ )
  {
    google::protobuf::internal::LogMessage::LogMessage(&v7, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6846);
    v5 = google::protobuf::internal::LogMessage::operator<<(&v7, "CHECK failed: finished_building_ == true: ");
    google::protobuf::internal::LogFinisher::operator=(&v6, v5);
    google::protobuf::internal::LogMessage::~LogMessage(&v7);
  }
  result = (unsigned int)this->dependency_count_;
  if ( (int)result > 0 )
  {
    v2 = 0LL;
    do
    {
      result = 8 * v2;
      v3 = (std::string *)this->dependencies_names_[v2];
      if ( v3 )
      {
        v4 = (const google::protobuf::FileDescriptor **)((char *)this->dependencies_ + result);
        result = (__int64)google::protobuf::DescriptorPool::FindFileByName(
                            (google::protobuf::DescriptorPool *)this->pool_,
                            v3);
        *v4 = result;
      }
      ++v2;
    }
    while ( this->dependency_count_ > (int)v2 );
  }
  return result;
};

// Line 6846: range 000000000C730104-000000000C730111
void __fastcall __noreturn google::protobuf::FileDescriptor::InternalDependenciesOnceInit(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 6855: range 000000000C913100-000000000C91322F
// attributes: thunk
void __fastcall google::protobuf::FileDescriptor::DependenciesOnceInit(const google::protobuf::FileDescriptor *to_init)
{
  google::protobuf::FileDescriptor::InternalDependenciesOnceInit((google::protobuf::FileDescriptor *)to_init);
};

// Line 6858: range 000000000C8F6290-000000000C8F6305
const google::protobuf::FileDescriptor *__fastcall google::protobuf::FileDescriptor::dependency(
        google::protobuf::FileDescriptor *this,
        int a2)
{
  google::protobuf::GoogleOnceDynamic *dependencies_once; // rdi
  google::protobuf::Closure v5[2]; // [rsp+0h] [rbp-38h] BYREF
  char v6; // [rsp+10h] [rbp-28h]
  google::protobuf::FileDescriptor *v7; // [rsp+18h] [rbp-20h]

  dependencies_once = this->dependencies_once_;
  if ( !dependencies_once || dependencies_once->state_ == 2 )
    return this->dependencies_[a2];
  v5[0]._vptr_Closure = (int (**)(...))&off_1A17BFB8;
  v5[1]._vptr_Closure = (int (**)(...))google::protobuf::FileDescriptor::DependenciesOnceInit;
  v6 = 0;
  v7 = this;
  google::protobuf::GoogleOnceInitImpl(&dependencies_once->state_, v5);
  v5[0]._vptr_Closure = (int (**)(...))&off_1A17BFB8;
  google::protobuf::Closure::~Closure(v5);
  return this->dependencies_[a2];
};

// Line 6867: range 000000000C8F6310-000000000C8F6385
const google::protobuf::Descriptor *__fastcall google::protobuf::MethodDescriptor::input_type(
        google::protobuf::MethodDescriptor *this)
{
  google::protobuf::GoogleOnceDynamic *once; // rdi
  google::protobuf::Closure v4[2]; // [rsp+0h] [rbp-38h] BYREF
  char v5; // [rsp+10h] [rbp-28h]
  google::protobuf::internal::LazyDescriptor *p_input_type; // [rsp+18h] [rbp-20h]

  once = this->input_type_.once_;
  if ( !once || once->state_ == 2 )
    return this->input_type_.descriptor_;
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BFE0;
  v4[1]._vptr_Closure = (int (**)(...))google::protobuf::internal::LazyDescriptor::OnceStatic;
  v5 = 0;
  p_input_type = &this->input_type_;
  google::protobuf::GoogleOnceInitImpl(&once->state_, v4);
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BFE0;
  google::protobuf::Closure::~Closure(v4);
  return this->input_type_.descriptor_;
};

// Line 6871: range 000000000C8F6390-000000000C8F6405
const google::protobuf::Descriptor *__fastcall google::protobuf::MethodDescriptor::output_type(
        google::protobuf::MethodDescriptor *this)
{
  google::protobuf::GoogleOnceDynamic *once; // rdi
  google::protobuf::Closure v4[2]; // [rsp+0h] [rbp-38h] BYREF
  char v5; // [rsp+10h] [rbp-28h]
  google::protobuf::internal::LazyDescriptor *p_output_type; // [rsp+18h] [rbp-20h]

  once = this->output_type_.once_;
  if ( !once || once->state_ == 2 )
    return this->output_type_.descriptor_;
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BFE0;
  v4[1]._vptr_Closure = (int (**)(...))google::protobuf::internal::LazyDescriptor::OnceStatic;
  v5 = 0;
  p_output_type = &this->output_type_;
  google::protobuf::GoogleOnceInitImpl(&once->state_, v4);
  v4[0]._vptr_Closure = (int (**)(...))&off_1A17BFE0;
  google::protobuf::Closure::~Closure(v4);
  return this->output_type_.descriptor_;
};

// Line 6877: range 000000000C8F6410-000000000C8F653C
void __fastcall google::protobuf::internal::LazyDescriptor::Set(
        google::protobuf::internal::LazyDescriptor *this,
        const google::protobuf::Descriptor *a2)
{
  google::protobuf::internal::LogMessage_0 *v2; // rax
  google::protobuf::internal::LogMessage_0 *v3; // rax
  google::protobuf::internal::LogMessage_0 *v4; // rax
  google::protobuf::internal::LogFinisher v5; // [rsp+Fh] [rbp-59h] BYREF
  google::protobuf::internal::LogMessage_0 v6; // [rsp+10h] [rbp-58h] BYREF

  if ( this->name_ )
  {
    google::protobuf::internal::LogMessage::LogMessage(&v6, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6878);
    v2 = google::protobuf::internal::LogMessage::operator<<(&v6, "CHECK failed: !name_: ");
    google::protobuf::internal::LogFinisher::operator=(&v5, v2);
    google::protobuf::internal::LogMessage::~LogMessage(&v6);
  }
  if ( this->once_ )
  {
    google::protobuf::internal::LogMessage::LogMessage(&v6, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6879);
    v3 = google::protobuf::internal::LogMessage::operator<<(&v6, "CHECK failed: !once_: ");
    google::protobuf::internal::LogFinisher::operator=(&v5, v3);
    google::protobuf::internal::LogMessage::~LogMessage(&v6);
  }
  if ( this->file_ )
  {
    google::protobuf::internal::LogMessage::LogMessage(&v6, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6880);
    v4 = google::protobuf::internal::LogMessage::operator<<(&v6, "CHECK failed: !file_: ");
    google::protobuf::internal::LogFinisher::operator=(&v5, v4);
    google::protobuf::internal::LogMessage::~LogMessage(&v6);
  }
  this->descriptor_ = a2;
};

// Line 6880: range 000000000C72D632-000000000C72D63D
void __fastcall __noreturn google::protobuf::internal::LazyDescriptor::Set()
{
  google::protobuf::internal::LogMessage_0 *v0; // rbp
  struct _Unwind_Exception *v1; // r12

  google::protobuf::internal::LogMessage::~LogMessage(v0);
  _Unwind_Resume(v1);
};

// Line 6884: range 000000000C8FDE90-000000000C8FE195
google::protobuf::GoogleOnceDynamic *__fastcall google::protobuf::internal::LazyDescriptor::SetLazy(
        _QWORD *a1,
        __int64 a2,
        __int64 a3)
{
  google::protobuf::internal::LogMessage_0 *v4; // rax
  google::protobuf::internal::LogMessage_0 *v5; // rax
  google::protobuf::internal::LogMessage_0 *v6; // rax
  google::protobuf::internal::LogMessage_0 *v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  google::protobuf::GoogleOnceDynamic *result; // rax
  google::protobuf::internal::LogMessage_0 *v11; // rax
  google::protobuf::internal::LogMessage_0 *v12; // rax
  google::protobuf::internal::LogMessage_0 *v13; // rax
  google::protobuf::internal::LogFinisher v14; // [rsp+Fh] [rbp-69h] BYREF
  google::protobuf::internal::LogMessage_0 v15; // [rsp+10h] [rbp-68h] BYREF

  if ( *a1 )
  {
    google::protobuf::internal::LogMessage::LogMessage(&v15, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6886);
    v4 = google::protobuf::internal::LogMessage::operator<<(&v15, "CHECK failed: !descriptor_: ");
    google::protobuf::internal::LogFinisher::operator=(&v14, v4);
    google::protobuf::internal::LogMessage::~LogMessage(&v15);
  }
  if ( a1[3] )
  {
    google::protobuf::internal::LogMessage::LogMessage(&v15, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6887);
    v5 = google::protobuf::internal::LogMessage::operator<<(&v15, "CHECK failed: !file_: ");
    google::protobuf::internal::LogFinisher::operator=(&v14, v5);
    google::protobuf::internal::LogMessage::~LogMessage(&v15);
  }
  if ( a1[1] )
  {
    google::protobuf::internal::LogMessage::LogMessage(&v15, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6888);
    v6 = google::protobuf::internal::LogMessage::operator<<(&v15, "CHECK failed: !name_: ");
    google::protobuf::internal::LogFinisher::operator=(&v14, v6);
    google::protobuf::internal::LogMessage::~LogMessage(&v15);
  }
  if ( a1[2] )
  {
    google::protobuf::internal::LogMessage::LogMessage(&v15, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6889);
    v7 = google::protobuf::internal::LogMessage::operator<<(&v15, "CHECK failed: !once_: ");
    google::protobuf::internal::LogFinisher::operator=(&v14, v7);
    google::protobuf::internal::LogMessage::~LogMessage(&v15);
  }
  if ( a3 )
  {
    v8 = *(_QWORD *)(a3 + 16);
    if ( v8 )
    {
      if ( *(_BYTE *)(v8 + 41) )
        goto LABEL_12;
LABEL_15:
      google::protobuf::internal::LogMessage::LogMessage(&v15, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6891);
      v12 = google::protobuf::internal::LogMessage::operator<<(
              &v15,
              "CHECK failed: file->pool_->lazily_build_dependencies_: ");
      google::protobuf::internal::LogFinisher::operator=(&v14, v12);
      google::protobuf::internal::LogMessage::~LogMessage(&v15);
      if ( !*(_BYTE *)(a3 + 65) )
        goto LABEL_13;
LABEL_16:
      google::protobuf::internal::LogMessage::LogMessage(&v15, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6892);
      v13 = google::protobuf::internal::LogMessage::operator<<(&v15, "CHECK failed: !file->finished_building_: ");
      google::protobuf::internal::LogFinisher::operator=(&v14, v13);
      google::protobuf::internal::LogMessage::~LogMessage(&v15);
      goto LABEL_13;
    }
  }
  google::protobuf::internal::LogMessage::LogMessage(&v15, LOGLEVEL_FATAL_0, "google/protobuf/descriptor.cc", 6890);
  v11 = google::protobuf::internal::LogMessage::operator<<(&v15, "CHECK failed: file && file->pool_: ");
  google::protobuf::internal::LogFinisher::operator=(&v14, v11);
  google::protobuf::internal::LogMessage::~LogMessage(&v15);
  if ( !*(_BYTE *)(*(_QWORD *)(a3 + 16) + 41LL) )
    goto LABEL_15;
LABEL_12:
  if ( *(_BYTE *)(a3 + 65) )
    goto LABEL_16;
LABEL_13:
  v9 = *(_QWORD *)(a3 + 16);
  a1[3] = a3;
  a1[1] = google::protobuf::DescriptorPool::Tables::AllocateString(*(std::vector<std::string*> **)(v9 + 32), a2);
  result = google::protobuf::DescriptorPool::Tables::AllocateOnceDynamic(*(google::protobuf::DescriptorPool::Tables *const *)(*(_QWORD *)(a3 + 16) + 32LL));
  a1[2] = result;
  return result;
};

// Line 6890: range 000000000C72E348-000000000C72E353
void __fastcall __noreturn google::protobuf::internal::LazyDescriptor::SetLazy()
{
  google::protobuf::internal::LogMessage_0 *v0; // rbp
  struct _Unwind_Exception *v1; // r12

  google::protobuf::internal::LogMessage::~LogMessage(v0);
  _Unwind_Resume(v1);
};

// Line 6899: range 000000000C8F6550-000000000C8F65AC
void __fastcall google::protobuf::internal::LazyDescriptor::Once(google::protobuf::internal::LazyDescriptor *this)
{
  google::protobuf::GoogleOnceDynamic *once; // r8
  google::protobuf::Closure v2[2]; // [rsp+0h] [rbp-28h] BYREF
  char v3; // [rsp+10h] [rbp-18h]
  google::protobuf::internal::LazyDescriptor *v4; // [rsp+18h] [rbp-10h]

  once = this->once_;
  if ( once )
  {
    if ( once->state_ != 2 )
    {
      v4 = this;
      v2[0]._vptr_Closure = (int (**)(...))&off_1A17BFE0;
      v2[1]._vptr_Closure = (int (**)(...))google::protobuf::internal::LazyDescriptor::OnceStatic;
      v3 = 0;
      google::protobuf::GoogleOnceInitImpl(&once->state_, v2);
      v2[0]._vptr_Closure = (int (**)(...))&off_1A17BFE0;
      google::protobuf::Closure::~Closure(v2);
    }
  }
};

// Line 6904: range 000000000C913C20-000000000C913E0B
// attributes: thunk
void __fastcall google::protobuf::internal::LazyDescriptor::OnceStatic(
        google::protobuf::internal::LazyDescriptor *lazy)
{
  google::protobuf::internal::LazyDescriptor::OnceInternal(lazy);
};

// Line 6907: range 000000000C7301AC-000000000C7301B9
void __fastcall __noreturn google::protobuf::internal::LazyDescriptor::OnceInternal(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        google::protobuf::internal::LogMessage_0 a8)
{
  struct _Unwind_Exception *v8; // rbp

  google::protobuf::internal::LogMessage::~LogMessage(&a8);
  _Unwind_Resume(v8);
};

// Line 6918: range 000000000C746EF0-000000000C746F2B
void __cdecl GLOBAL__sub_I__ZN6google8protobuf15FieldDescriptor17kTypeToCppTypeMapE()
{
  std::ios_base::Init::Init(&std::__ioinit);
  __cxa_atexit(std::ios_base::Init::~Init, &std::__ioinit, &_dso_handle);
  google::protobuf::`anonymous namespace'::kNullSymbol.type = NULL_SYMBOL;
  google::protobuf::`anonymous namespace'::kNullSymbol._anon_0.descriptor = 0LL;
};
